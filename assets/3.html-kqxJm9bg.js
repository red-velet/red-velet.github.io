import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,a as p}from"./app-KXX3jVXZ.js";const t={},o=p(`<h1 id="解决用arrays-sort-排序整数溢出问题、arrays-sort-排序中lambda表达式和integer-compare-的区别、最少的数量引爆气球有一组测试用例不通过的情况" tabindex="-1"><a class="header-anchor" href="#解决用arrays-sort-排序整数溢出问题、arrays-sort-排序中lambda表达式和integer-compare-的区别、最少的数量引爆气球有一组测试用例不通过的情况" aria-hidden="true">#</a> 解决用Arrays.sort()排序整数溢出问题、Arrays.sort()排序中Lambda表达式和Integer.compare()的区别、最少的数量引爆气球有一组测试用例不通过的情况</h1><blockquote><p>背景：</p></blockquote><ul><li>做题时碰到了如下情况，使用<code>Arrays.sort()</code>进行排序后，有一组测试不通过，切换另一种传入排序的策略就通过。</li></ul><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240119102019177.png" alt="问题描述1" tabindex="0" loading="lazy"><figcaption>问题描述1</figcaption></figure><figure><img src="https://cloud.greennut.icu/blog/bug/Snipaste_2024-01-19_10-17-16.png" alt="问题描述2" tabindex="0" loading="lazy"><figcaption>问题描述2</figcaption></figure><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240119102251785.png" alt="问题描述3" tabindex="0" loading="lazy"><figcaption>问题描述3</figcaption></figure><ul><li><mark>发现有点不对劲的地方：这组测试用例的数据非常极端：要不非常大，或者非常小</mark></li></ul><p><mark>发现问题：Integer.compare()和lambda表达式-匿名内部类排序的区别：</mark></p><blockquote><p>Integer.compare()的源码：</p></blockquote><ul><li>其注释很详细： <ul><li>如果 <code>x == y</code>，则返回值为 0；</li><li>如果 <code>x &lt; y</code>，则返回一个小于 0 的值，此处是-1；</li><li>如果 <code>x &gt; y</code>，则返回一个大于 0 的值，此处是1。</li></ul></li></ul><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240119102427421.png" alt="源码展示" tabindex="0" loading="lazy"><figcaption>源码展示</figcaption></figure><blockquote><p>lambda表达式 -匿名内部类写法：</p></blockquote><ul><li><strong>返回的是两个差值</strong></li><li>这里直接使用了 <code>o1[0] - o2[0]</code> 进行比较，如果 <code>o1[0]</code> 和 <code>o2[0]</code> 的值很大，有可能在计算差值的时候发生整数溢出，导致比较结果不准确，可能会有整数溢出的问题。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> o1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> o1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> o2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>例如：让我们来看一个可能导致整数溢出问题</p></blockquote><p>假设有以下两个数组：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个数组分别代表了两个区间，<code>a</code> 区间的左边界很大，<code>b</code> 区间的左边界很小。</p><p>在第一个实现中，使用 Lambda 表达式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这里，<code>Integer.compare(x[0], y[0])</code> 会返回 <code>-1</code>，因为 <code>a[0]</code> 比 <code>b[0]</code> 大。</p><p>而在第二个实现中，使用匿名内部类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在这里，<code>x[0] - y[0]</code> 的结果是一个非常大的正整数，因为 <code>a[0]</code> 是 <code>Integer.MAX_VALUE</code>，<code>b[0]</code> 是 <code>Integer.MIN_VALUE</code>，所以 <code>x[0] - y[0]</code> 会溢出，导致比较的结果不准确。</strong></p><p>为了解决这个问题，可以将第二个实现中的比较方式修改为使用 <code>Integer.compare</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就能够避免整数溢出问题，确保比较结果的准确性。</p><blockquote><p>Tip：什么是整数溢出：</p></blockquote><p>整数溢出是指在进行整数运算时，结果的值超过了该数据类型所能表示的范围，导致数据溢出到另一端。在 Java 中，整数溢出会导致结果不准确，因为超出表示范围的部分会被丢弃，而只保留有效的位。</p><p>在上面的例子中，我们来看一下整数溢出是如何发生的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，<code>a[0]</code> 是 <code>Integer.MAX_VALUE</code>，它表示的是 <code>2147483647</code>。而 <code>b[0]</code> 是 <code>Integer.MIN_VALUE</code>，它表示的是 <code>-2147483648</code>。</p><p>当我们使用 <code>x[0] - y[0]</code> 进行比较时，实际上是在计算 <code>2147483647 - (-2147483648)</code>。这个结果超出了 <code>int</code> 数据类型的表示范围，它只能表示 <code>-2147483648</code> 到 <code>2147483647</code> 之间的整数。</p><p>在计算过程中，超出范围的部分会导致整数溢出，最终的结果不是我们期望的 <code>2147483647 - (-2147483648)</code>，而是一个负数。这样的结果会影响到排序的正确性，因为实际上我们期望 <code>a[0]</code> 大于 <code>b[0]</code>。</p><p>使用 <code>Integer.compare(x[0], y[0])</code> 能够避免这个问题，因为它使用了安全的方式比较两个整数，不会发生整数溢出。</p>`,35),e=[o];function c(u,l){return a(),s("div",null,e)}const k=n(t,[["render",c],["__file","3.html.vue"]]);export{k as default};

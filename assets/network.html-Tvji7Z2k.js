import{_ as u}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as a,o as g,c,b as p,f as e,w as i,d as l,a as r,e as t}from"./app-lW-6uHYn.js";const h={},P=l("p",null,[l("strong",null,"网络层的就是是为了实现不同网络之间的互连，为不同主机提供通信服务，允许数据包在这些网络之间传输，就是把数据分组从源端传到目的端")],-1),I=r('<h1 id="计算机网络-网络层" tabindex="-1"><a class="header-anchor" href="#计算机网络-网络层" aria-hidden="true">#</a> 计算机网络-网络层</h1><h2 id="一、简介" tabindex="-1"><a class="header-anchor" href="#一、简介" aria-hidden="true">#</a> 一、简介</h2><h3 id="_1、主要任务" tabindex="-1"><a class="header-anchor" href="#_1、主要任务" aria-hidden="true">#</a> 1、主要任务</h3><blockquote><p>网络层的主要任务：</p></blockquote><p>网络层的主要任务是<mark>实现不同网络之间的互连，为不同主机提供通信服务，允许数据包在这些网络之间传输，就是把数据分组从源端传到目的端</mark>。</p><ul><li>网络层传输单位是<code>数据报</code>。</li><li>当数据报过大时，还是会进行分组之后再发送。</li></ul><h3 id="_2、为什么需要" tabindex="-1"><a class="header-anchor" href="#_2、为什么需要" aria-hidden="true">#</a> 2、为什么需要</h3><blockquote><p>为什么需要网络层：</p></blockquote><p>因为我们的网络比较大，不再是拘于物理层和数据链路层的局域网了，而是更大的广域网、互联网。而在这个更大的网络中，如果我们要是信息送达给对方，单靠数据链路层的<code>mac地址</code>寻址是不够的，因为：</p><ol><li>数据是在不同设备间进行传输的，一直经历帧的封装的解封，这个过程中，<strong>帧的<code>mac地址</code>是不断变化的</strong>，例如A –&gt; D，要经过B、C两个路由器，那么最后达到D的数据中的<code>mac地址</code>就是C的<code>mac地址</code>，所以说当源端和目的端<strong>位于不同网络</strong>的时候，<strong>直接通信是不可行的（找不到对方）</strong>，此时就需要由<strong>网络层</strong>解决。</li><li>所以<strong>我们需要一个不变的地址</strong>，那就是本层网络层的<code>IP地址</code>。</li></ol><figure><img src="https://cloud.greennut.icu/blog/network/whyneedwlc.png" alt="网络层-简单工作流程" tabindex="0" loading="lazy"><figcaption>网络层-简单工作流程</figcaption></figure><h3 id="_3、怎么理解" tabindex="-1"><a class="header-anchor" href="#_3、怎么理解" aria-hidden="true">#</a> 3、怎么理解</h3><blockquote><p>怎么理解网络层：</p></blockquote><p>如果我们把物理层和数据链路层比作市内交通，那么，网络层就像是连接不同城市之间的高速公路系统。</p><ul><li>它负责在不同的网络之间传输数据包，类似于高速公路连接不同城市之间的交通流。</li><li>网络层的主要任务是确定数据的最佳路径，并且确保数据能够从源地址传输到目标地址。</li><li>就像高速公路可以有多条路径连接不同城市一样，网络层也能根据不同的条件选择最佳的数据传输路径(<code>路由器</code>)，比如最短路径或者最快路径，以确保数据的有效传输。</li></ul><h3 id="_4、有什么作用" tabindex="-1"><a class="header-anchor" href="#_4、有什么作用" aria-hidden="true">#</a> 4、有什么作用</h3><h4 id="i-屏蔽网络差异-提供透明传输" tabindex="-1"><a class="header-anchor" href="#i-屏蔽网络差异-提供透明传输" aria-hidden="true">#</a> （Ⅰ）屏蔽网络差异，提供透明传输</h4><p>网络层能够<strong>为上层传输层解决不同网络的规范要求差异</strong>，寻找一个不同网络间能共同遵守的网络通信规范，以便不同网络间能相互识别，并接受对方的访问请求，这样传输层就可以在不同网络间进行<strong>透明</strong>（也就是不管不同网络间的差异，就像通信双方是直接互连一样）<strong>数据传输</strong>了。</p><blockquote><p>网络层向传输层提供的服务：</p></blockquote><p>①面向<strong>连接</strong>的网络服务：<strong>虚电路</strong>服务</p><p>②<strong>无连接</strong>的网络服务：<strong>数据报</strong>服务</p><ul><li><strong>面向连接的虚电路服务</strong>： <ol><li><p><strong>可靠通信由网络保证</strong>：在虚拟电路通信中，网络确保了通信的可靠性。这意味着网络会尽最大努力确保分组在传输过程中能够正确、按序到达，且不会丢失或重复。</p></li><li><p><strong>建立网络层连接</strong>：在虚拟电路通信中，通信双方需要在网络层建立一个连接，这个连接是虚拟的，也就是说，它是逻辑上的连接，而非实际的物理连接。</p></li><li><p><strong>虚拟电路（Virtual Circuit）</strong>：通信双方沿着已建立的虚拟电路发送分组。在连接建立阶段，目的主机的地址会被使用来建立连接，但之后在传输过程中，每个分组的首部只需携带一个虚拟电路的编号。</p></li><li><p><strong>可靠传输协议的使用</strong>：如果在这种通信方式下使用了可靠传输的网络协议，那么发送的分组将最终可以正确到达接收方，且保证无差错、按序到达、不丢失和不重复。</p></li><li><p><strong>释放虚拟电路</strong>：在通信结束后，需要释放之前所建立的虚拟电路，以便释放网络资源。</p></li><li><p><strong>实际应用</strong>：许多广域分组交换网络，如曾经的X.25、帧中继FR、异步传输模式ATM等，都使用了面向连接的虚拟电路服务，以提供可靠的通信服务。</p></li></ol></li></ul><hr><ul><li><strong>无连接的数据报服务</strong>： <ol><li><p><strong>可靠通信由用户主机保证</strong>：在这种通信方式下，可靠通信的责任落在了用户主机（端点）的头上，而不是网络本身。用户主机必须使用适当的协议来保证数据的可靠传输。</p></li><li><p><strong>无需建立网络层连接</strong>：不像虚拟电路通信，这种通信方式不需要在网络层建立连接。每个分组被独立发送，不需要提前建立连接。</p></li><li><p><strong>分组可以走不同的路径</strong>：每个分组可以根据网络的情况走不同的路径，这使得网络能够更加灵活地处理分组传输。</p></li><li><p><strong>分组头部必须携带目的主机的完整地址</strong>：每个分组的头部包含了目的主机的完整地址，这样网络可以根据这个地址来确定分组的传输路径。</p></li><li><p><strong>分组可能出现误码、丢失、重复和失序</strong>：由于网络本身不提供端到端的可靠传输服务，传输过程中分组可能会遭受误码、丢失、重复或失序的情况。</p></li><li><p><strong>简化的网络处理功能</strong>：因为网络本身不提供可靠传输服务，路由器可以相对简单，这也降低了网络设备的成本。</p></li><li><p><strong>将复杂功能置于网络边缘</strong>：因特网采用了这种设计思想，即将复杂的网络处理功能放在网络边缘（用户主机和其内部的运输层），而将相对简单的分组交付功能放在网络核心。</p></li></ol></li></ul><h4 id="ii-为网络间通信提供路由选择" tabindex="-1"><a class="header-anchor" href="#ii-为网络间通信提供路由选择" aria-hidden="true">#</a> （Ⅱ）为网络间通信提供路由选择</h4><p>能根据<strong>一定的原则和路由选择算法</strong>在多个结点的通信子网中选择一条<strong>到达目的节点的最佳路径</strong></p><h4 id="iii-数据包封装和解封装" tabindex="-1"><a class="header-anchor" href="#iii-数据包封装和解封装" aria-hidden="true">#</a> （Ⅲ）数据包封装和解封装</h4><ul><li><strong>对来自传输层的报文</strong>：为其<strong>报文头部</strong>添加一些网络层协议控制信息<strong>封装成数据包</strong>。数据包的头部包含<strong>源节点和目标节点的网络层地址</strong>（例如IP地址）。</li><li><strong>对从低层到达网络层的报文</strong>：<strong>去掉在数据链路层加上的数据链路层协议控制信息</strong>（也就是帧头和帧尾），<strong>还原出原来的数据包格式</strong>，这就是包的解封装过程</li></ul><h4 id="iv-拥塞控制" tabindex="-1"><a class="header-anchor" href="#iv-拥塞控制" aria-hidden="true">#</a> （Ⅳ）拥塞控制</h4><p>避免网络传输路径中数据的<strong>传输延迟</strong>或<strong>死锁</strong></p><p>在<strong>数据链路层</strong>提到了<strong>流量控制</strong>功能，那是针对数据链路中<strong>点对点传输速率</strong>的控制</p><p>而这里的<strong>拥塞控制</strong>是针对在<strong>网络传输路径中</strong>的<strong>端到端传输效率</strong>的控制（如避免路由器缓存空间爆满而造成丢包的情况）。</p><h2 id="二、网络层协议及报文格式" tabindex="-1"><a class="header-anchor" href="#二、网络层协议及报文格式" aria-hidden="true">#</a> 二、网络层协议及报文格式</h2><h3 id="_1、ipv4协议" tabindex="-1"><a class="header-anchor" href="#_1、ipv4协议" aria-hidden="true">#</a> 1、IPV4协议</h3><blockquote><p>IPV4协议：将多个分组交换网络（数据报交换方式）连接起来的最典型通信协议</p></blockquote><p>​ 该协议是<strong>无连接</strong>的服务，负责在<strong>源地址和目的地址</strong>之间<strong>传送数据报</strong>，然后为了适应不同网络<strong>对分组大小的要求</strong>，需要对上层传来的<strong>报文进行分割</strong>，最后调用<strong>本地网络协议</strong>将数据报<strong>传送</strong>给<strong>下一个网关或目的计算机</strong>。</p><hr><h4 id="_1-主要功能" tabindex="-1"><a class="header-anchor" href="#_1-主要功能" aria-hidden="true">#</a> （1）主要功能</h4><h5 id="_1寻址" tabindex="-1"><a class="header-anchor" href="#_1寻址" aria-hidden="true">#</a> ①寻址</h5><ul><li><strong>在同一以太局域网内部，结点间的寻址可以通过二层MAC地址进行，但在不同网络之间，是不能通过MAC地址的，因为用于MAC地址寻址的广播帧只能在同一个以太网段内部进行</strong></li><li><strong>在不同网络中只能通过三层地址(该协议中为IP地址)进行寻址.</strong></li></ul><h5 id="_2数据报的封装" tabindex="-1"><a class="header-anchor" href="#_2数据报的封装" aria-hidden="true">#</a> ②数据报的封装</h5><p><mark>目的</mark>：<strong>标识此IP数据报发送节点和接收节点的IP地址及控制信息</strong></p><ul><li>从传输层到达的数据段都需要经过<strong>IP协议进行重新封装</strong>的。</li><li>因为IP协议是<strong>无连接</strong>的服务，并且采用<strong>数据报交换</strong>方式，所以封装后形成的是<strong>IP数据报</strong>。</li></ul><h5 id="_3分段与重组" tabindex="-1"><a class="header-anchor" href="#_3分段与重组" aria-hidden="true">#</a> ③分段与重组</h5><p><mark>作用</mark>：<strong>把那些被拆分的分段重新组合起来，还原成原来的大的数据报的问题</strong></p><ul><li>因为<strong>不同网络上的链路可以传输的最大报文大小是不同的</strong>，这就是我们通常所说的<code>MTU（最大传输单元）</code>。</li><li>为了使我们要传输的数据报能在不同网络中传输，当一些<strong>尺寸较大的数据报要在某个MTU值比较小的网络链路上传输时</strong>就可能需要对原来的数据报<strong>进行拆分</strong>，形成一个个小的分段，然后再把这些分段依次传输出去。</li></ul><h4 id="_2-ipv4数据报首部" tabindex="-1"><a class="header-anchor" href="#_2-ipv4数据报首部" aria-hidden="true">#</a> （2）IPV4数据报首部</h4><p><mark>IP数据报 = IP首部 + 数据</mark></p><blockquote><p>格式：<mark>每行4个字节，32位Bit，固定部分20字节，可变部分40字节</mark></p></blockquote><figure><img src="https://cloud.greennut.icu/blog/network/ipv4sjb.png" alt="IPV4数据报首部格式" tabindex="0" loading="lazy"><figcaption>IPV4数据报首部格式</figcaption></figure>',50),b=l("ul",null,[l("li",null,[l("mark",null,"版本"),t("：占4比特，表示IP协议版本。通信双方使用的IP协议版本必须一致。目前广泛使用的IP协议版本为号为4(IPv4)")]),l("li",null,[l("mark",null,"首部长度"),t("：占4比特，表示IP数据报首部长度。该字段取值以4字节为单位 "),l("ul",null,[l("li",null,"最小十进制取值为5，表示IP数据报首部只有20字节【4字节单位，所以取值5对应20字节】固定部分"),l("li",null,"最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分")])]),l("li",null,[l("mark",null,"区分服务"),t("：占8比特，利用该字段的不同数值可提供不同等级的服务质量，只有在使用区分服务时，该字段才起作用。一般情况下"),l("strong",null,"不使用"),t("该字段")]),l("li",null,[l("mark",null,"总长度"),t("：占16比特，表示IP数据报的总长度【首部+数据载荷】，最大取值为十进制65535，以字节为单位")])],-1),k=l("ul",null,[l("li",null,[l("mark",null,"标识"),t("：占16比特，属于同一个数据报的各分片数据报应该具有相同的标识【可理解为ID】 "),l("ul",null,[l("li",null,"IP软件维持一个计数器，每产生一个数据报，计数器值+1，并将此值赋给标识字段")])]),l("li",null,[l("mark",null,"标志"),t("：占3比特，各比特含义如下 "),l("ul",null,[l("li",null,"DF位：1表示不允许分片，0表示允许"),l("li",null,'MF位：1表示"后面还有分片"，0表示"这是最后一个分片"'),l("li",null,"保留位：必须为0")])]),l("li",null,[l("mark",null,"片偏移"),t("必须是整数)：占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少单位，片偏移以8个字节为单位")])],-1),m=l("ul",null,[l("li",null,[l("p",null,[l("mark",null,"生存时间"),t("：占8比特，最初以秒为单位，最大生存周期为255秒；")]),l("ul",null,[l("li",null,'路由器转发IP数据报时，将IP数据报首部中的该字段值减去IP数据报在本路由器上耗费的时间，若不为0【说明路由器消耗时间后还活着】就转发，否则丢弃，现在以"跳数"为单位，路由器转发IP数据报时，将IP数据报首部中的该字段值减1，若不为0就转发，否则丢弃【防止兜圈】')])]),l("li",null,[l("p",null,[l("mark",null,"协议"),t("：占8比特，指明IPv4数据报的数据部分是何种协议数据单元")]),l("ul",null,[l("li",null,"ICMP：1、IGMP：2、TCP：6、UDP17、IPV6：41、OSPF：89")])]),l("li",null,[l("p",null,[l("mark",null,"首部检验和"),t("：占16比特，用来检测首部在传输过程中是否出现差错，比CRC检验码简单，称为因特网检验和")]),l("ul",null,[l("li",null,"IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段【生存时间、标志、片偏移等】的取值可能发生变化"),l("li",null,"由于IP层本身不提供可靠传输服务，并且计算首部校验和是一项耗时的操作，因此在IPv6中，路由器不再计算首部校验和，从而更快转发IP数据报")])])],-1),_=l("ul",null,[l("li",null,[l("mark",null,"源IP地址和目的IP地址"),t("：各占32比特，用来填写发送该IP数据报的源主机IP地址和接收该IP数据报的目的主机")])],-1),v=l("ul",null,[l("li",null,[l("mark",null,"选项"),t("：选项字段(可无)支持各种选项，提供"),l("strong",null,"扩展余地"),t("。根据选项的不同，该"),l("strong",null,"字段是可变长"),t("的，从1字节到40字节。用来支持排错、测量以及安全、"),l("strong",null,"控制报头长度"),t("等措施。")])],-1),A=r('<h3 id="_2、arp协议" tabindex="-1"><a class="header-anchor" href="#_2、arp协议" aria-hidden="true">#</a> 2、ARP协议</h3><h4 id="_1-主要功能-1" tabindex="-1"><a class="header-anchor" href="#_1-主要功能-1" aria-hidden="true">#</a> （1）主要功能</h4><p><mark>ARP（Address Resolution Protocol，地址解析协议）是将IP地址解析为以太网MAC地址（或称物理地址）的协议。</mark></p><p><mark>ARP协议 = ARP报文 + ARP映射表</mark></p><blockquote><p>功能：完成主机或路由器IP地址到MAC地址的映射</p></blockquote><p>在<strong>局域网</strong>中，当主机或其他网络设备有数据要发送给另一个主机或设备时，它必须知道对方的<strong>IP地址</strong>（即网络层地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须<strong>封装成帧</strong>才能通过<strong>物理网络</strong>发送，因此发送站还必须有接收站的<strong>MAC地址</strong>（即物理地址），所以<strong>需要一个从IP地址到物理地址的映射。</strong></p><h4 id="_2-arp报文格式" tabindex="-1"><a class="header-anchor" href="#_2-arp报文格式" aria-hidden="true">#</a> （2）ARP报文格式</h4><blockquote><p>tip：ARP是一个<strong>独立的三层协议</strong>，所以ARP报文在向数据链路层传输时<strong>不需要经过IP协议的封装</strong>，而是<strong>直接生成</strong>自己的报文，然后再到数据链路层<strong>封装成帧</strong></p></blockquote><figure><img src="https://cloud.greennut.icu/blog/network/arpbw.png" alt="ARP报文格式" tabindex="0" loading="lazy"><figcaption>ARP报文格式</figcaption></figure><h4 id="_3-arp映射表" tabindex="-1"><a class="header-anchor" href="#_3-arp映射表" aria-hidden="true">#</a> （3）ARP映射表</h4><p>无论是主机，还是交换机都会有一个用来<strong>缓存同一网段设备IP地址和MAC地址</strong>的<strong>ARP映射表</strong>，用于数据帧的转发。</p><ol><li><strong>动态ARP表项</strong>：由ARP协议通过ARP报文<strong>自动生成和维护</strong></li><li><strong>静态ARP表项</strong>：通过<strong>手工配置</strong>（通过对应设备的IP地址与MAC地址绑定命令进行）和<strong>维护</strong><ul><li>静态ARP表项又分为<strong>短静态ARP表项</strong>和<strong>长静态ARP表项，<strong>区别在于</strong>地址表项</strong>是否绑定了<strong>VLAN。</strong></li></ul></li></ol><blockquote><p>流程：</p></blockquote><ul><li><p>检查ARP高速缓存</p></li><li><p>有对应表项则写入MAC帧</p></li><li><p>没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组</p></li><li><p>目的主机收到请求后就向源主机单播一个ARP响应分组</p></li><li><p>源主机收到后将此映射写入ARP缓存（10-20min更新一次）</p></li></ul><figure><img src="https://cloud.greennut.icu/blog/network/arpcz.png" alt="ARP映射表工作流程" tabindex="0" loading="lazy"><figcaption>ARP映射表工作流程</figcaption></figure><p>若在不同网络上，主机A向主机B发送数据，则主机A要先使用ARP协议询问<strong>本网络网关地址</strong>，然后发数据给网关后，网关再在主机B所在网络询问主机B的地址，并发送数据。</p><h3 id="_3、icmp协议及报文格式" tabindex="-1"><a class="header-anchor" href="#_3、icmp协议及报文格式" aria-hidden="true">#</a> 3、ICMP协议及报文格式</h3><h4 id="_1-主要功能-2" tabindex="-1"><a class="header-anchor" href="#_1-主要功能-2" aria-hidden="true">#</a> （1）主要功能</h4><p><mark>ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是IPv4协议簇中的一个子协议，用于在IP主机、路由器之间传递控制消息。</mark></p><ul><li>控制消息：指<strong>网络通不通、主机是否可达、路由是否可用</strong>等网络本身的消息。</li><li>与ARP协议不同，ICMP<strong>依靠IP协议</strong>来完成其任务，所以ICMP报文中要<strong>封装IP头部</strong>。</li></ul><blockquote><p>主要功能：</p></blockquote><ol><li>在<strong>网际层使用</strong>，为了更有效地转发<code>IP</code>数据报和提高交付成功的机会，主要用于网络层的<strong>错误处理和状态通知</strong></li><li>主机或路由器使用<code>ICMP</code>来发送差错报告报文和询问报文（<code>ICMP</code>报文被封装在<code>IP</code>数据报中发送） <ul><li>用于分组网间探测PING <ul><li>用来测试主机或路由器间的连通性【eNSP的ping命令】</li><li>应用层直接使用网际层的ICMP(没有通过运输层的TCP或UDP)</li><li>使用ICMP回送请求和回答报文</li></ul></li><li>用于跟踪路由tracerouce：用来测试IP数据报从源主机到达目的主机要经过哪些路由器 <ul><li>Windows版本：tracert命令 <ul><li>应用层直接使用网际层ICMP，使用了ICMP回送请求和回答报文以及差错报告报文</li><li>实现方法：由主机发送出去的数据包中的生存时间字段TTL由1开始逐渐增加，每个路由器都会返回一个时间超过报文，由此达到跟踪路由器的目的</li></ul></li><li>Unix版本：traceroute命令 <ul><li>在运输层使用UDP协议，仅使用ICMP差错报告报文</li></ul></li></ul></li></ul></li></ol><hr><blockquote><p>不发送ICMP的情况：</p></blockquote><ol><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文</li></ol><h4 id="_2-icmp报文类型" tabindex="-1"><a class="header-anchor" href="#_2-icmp报文类型" aria-hidden="true">#</a> （2）ICMP报文类型</h4><ul><li><strong>回答报文、询问报文</strong></li></ul><blockquote><p>回答报文（差错报文）类型：</p></blockquote><ol><li><p><strong>终点不可达</strong>：当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络位置、目的主机未知等13种错误</p></li><li><p><strong>源点抑制</strong>：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报发送速率放慢</p></li><li><p><strong>时间超过</strong>：当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段值减1。若结果不为0，则将该IP数据报转发出去；若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文</p></li><li><p><strong>参数问题</strong>：当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文</p></li><li><p><strong>改变路由(重定向)</strong>：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)如主机1的默认路由是R1，信息经过R1时，R1发现最佳路由不是自己，而是R2，所以通过ICMP告知主机1</p></li></ol><hr><blockquote><p>询问报文类型：</p></blockquote><ul><li><strong>回送请求和回答</strong>：ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文，这种询问报文用来测试目的站是否可达及了解其有关状态</li><li><strong>时间戳请求和回答</strong>：ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间，在ICMP时间戳回答报文中有一个32比特的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒，这种询问报文用来进行时钟同步和测量时间</li></ul><h4 id="_3-icmp报文格式" tabindex="-1"><a class="header-anchor" href="#_3-icmp报文格式" aria-hidden="true">#</a> （3）ICMP报文格式</h4><blockquote><p>组成格式/封装过程：</p></blockquote><figure><img src="https://cloud.greennut.icu/blog/network/icmpcc.png" alt="ICMP报文组成过程" tabindex="0" loading="lazy"><figcaption>ICMP报文组成过程</figcaption></figure><hr><blockquote><p>详细报文首部：</p></blockquote><figure><img src="https://cloud.greennut.icu/blog/network/icmpbt.png" alt="ICMP报文首部" tabindex="0" loading="lazy"><figcaption>ICMP报文首部</figcaption></figure><h2 id="三、路由算法和路由协议" tabindex="-1"><a class="header-anchor" href="#三、路由算法和路由协议" aria-hidden="true">#</a> 三、路由算法和路由协议</h2><p><mark>路由其实是一种网络层中进行数据报分组交换从而进行路径选择行为的功能。</mark></p><h3 id="_1、路由算法分类" tabindex="-1"><a class="header-anchor" href="#_1、路由算法分类" aria-hidden="true">#</a> 1、路由算法分类</h3><h4 id="_1-静态路由" tabindex="-1"><a class="header-anchor" href="#_1-静态路由" aria-hidden="true">#</a> （1）静态路由</h4><p><mark>静态路由 - 非自适应路由算法，需要手动配置路由信息</mark></p><ul><li>静态路由中包括<strong>目的节点或目的网络的IP地址</strong>，及数据包从当前路由器开始路由的第一个<strong>下一跳</strong>（通常就是网关）<strong>所对应的接口或IP地址</strong>。</li><li>如果某条静态路由<strong>中间经过的跳数大于1</strong>（也就是整条路由路径经历了三个或以上路由器结点），则必须在除最后一个路由器外的其他路由器上<strong>依次配置</strong>到达相同目的节点或目的网络的静态路由 <ul><li>优点：简单可靠，开销小，适用于负荷稳定、拓扑变化不大的网络</li><li>缺点：路由更新慢，不能及时适应网络状态的变化。一般只在小规模网络中采用，不适用于大网络,可能由于<code>①配置错误 ②聚合了不存在的网络 ③网络故障</code> 的问题而出现路由环路错误</li></ul></li></ul><figure><img src="https://cloud.greennut.icu/blog/network/lyhl.png" alt="路由环路问题展示" tabindex="0" loading="lazy"><figcaption>路由环路问题展示</figcaption></figure><hr><blockquote><p>具体实现：</p></blockquote><p>1、静态路由<br> 2、扩散法：当一个路由器接口收到一个报文分组后，即向它所有接口（包括接收该分组的源接口）进行复制扩散<br> 3、随机走动法：当结点收到分组后，向所有与之相邻的结点中随机选择出一个将分组转发出去<br> 4、最短路径法：将源节点到网络中所有结点的最短通路都找出来，作为这个结点的路由表。<br> 5、基于流量的路由算法：结合了网络拓扑结构和通信流量两方面的因素进行路由选择</p><hr><blockquote><p>路由环路解决：</p></blockquote><p><strong>路由环路-IP数据报永久兜圈</strong></p><ol><li><p><strong>在IP数据报首部设置TTL字段 - 过期时间</strong></p><ul><li>IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃</li></ul></li><li><p><strong>对于聚合后或由于网络故障而不存在的路由条目设置黑洞路由</strong></p><ul><li>所谓<strong>黑洞路由，即路由器应该丢弃的路由，下一跳位null0</strong></li></ul></li></ol><hr><blockquote><p>拓展：</p></blockquote><p><mark>默认路由</mark>：指定了当路由表中没有适配的路由信息时，数据包应该发送到哪个特定的下一跳路由器或接口。</p><p><code>0.0.0.0/0</code> 是一个特殊的IP地址段，也称为默认路由或默认路由表项。</p><ul><li>它表示匹配所有可能的IP地址，也就是说，如果没有找到更具体的路由匹配某个目标地址，系统就会使用默认路由来指示数据包的下一跳。</li><li>在IPv4网络中，<code>0.0.0.0/0</code> 通常用于指示数据包应该发送到默认的网关或者默认的下一跳路由器。这在大多数情况下意味着将数据包发送到连接网络的设备，让该设备决定如何处理这个数据包。</li><li>默认路由在网络配置中非常重要，因为它允许网络管理员定义一个通用的路径，以便将未知目的地的数据包发送到一个已知的位置，而不必为每个可能的目的地配置具体的路由。</li></ul><p>需要注意的是，<code>0.0.0.0/0</code> 可能会在不同的上下文中具有不同的含义，比如在防火墙配置中，它可能表示所有的IP地址或所有网络，取决于具体的设置和规则。</p><p><mark>特定主机路由</mark>：指定了数据包应该被发送到目标网络中的一个特定主机。这种配置在需要直接连接到特定主机的情况下非常有用。</p><ul><li>具体主机IP/32。网络号前缀长度<code>32</code>保证了这是第一个被匹配的静态条目</li></ul><h4 id="_2-动态路由" tabindex="-1"><a class="header-anchor" href="#_2-动态路由" aria-hidden="true">#</a> （2）动态路由</h4><p><mark>动态路由 - 自适应路由算法，路由器彼此交换信息，按照算法优化出路由表</mark></p><ul><li>在网络中某条路由所包括的路由器同时启动了<strong>某种动态路由协议</strong>，<strong>通告</strong>了各自所<strong>直接连接的网络</strong>后，则这些路由器间就会<strong>自动生成</strong>这些路由器<strong>直接连接</strong>的网络间的<strong>路由表项</strong>，管理员无须一一手动创建，且这些路由表项会自动更新维护。</li><li>优点：路由更新快、适用于大型网络，能及时响应链路变化和网络拓扑变化</li><li>缺点：算法复杂，增加网络负担</li></ul>',63),f=r('<hr><blockquote><p>自适应路由算法分为两类：</p></blockquote><ol><li><p><strong>总体式路由算法</strong>：</p><ul><li>每个路由器都拥有网络中<strong>某个区域或者整个网络中所有其他路由器的全部信息</strong>以及<strong>网络的流量状态</strong></li><li>应用：链路状态路由算法（OSPF）、分级路由算法（ISIS协议）</li></ul></li><li><p><strong>分散性</strong>：</p><ul><li><p>每个路由器<strong>只与直接相连的路由器交换路由信息</strong>，每个路由器只有相邻路由器的路由信息，而没有网络中的其他路由器的路由信息</p></li><li><p>应用：距离向量算法（RIP）</p></li></ul></li></ol><h3 id="_2、rip协议" tabindex="-1"><a class="header-anchor" href="#_2、rip协议" aria-hidden="true">#</a> 2、RIP协议</h3><p><mark>RIP协议 - Bellman-Ford路由算法和Ford-Fulkerson算法。<strong>主要在RIP（Route Information Protocol）协议中使用</strong></mark></p><h4 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> （1）概述</h4><blockquote><p>RIP概述：使用跳数作为度量来衡量到达目的网络的距离</p></blockquote><ul><li>路由器到直连网络的距离定义为1</li><li>路由器到非直连网络的距离定义为所经过的路由器数+1</li><li>允许一条路径最多只能包含15个路由器。&quot;距离&quot;等于16时相当于不可达。因此，RIP只适用于小型互联网，端口为520</li></ul><hr><blockquote><p>RIP的基本思想如下：</p></blockquote><ul><li>每个路由器维护一个<strong>距离矢量（通常是延时或跳数）表</strong>，然后通过相邻路由器之间的<strong>距离矢量通告</strong>进行距离矢量表的<strong>更新</strong>。</li><li>每个距离矢量表项包括两部分（通信子网中的其他每个路由器在表中占据一个表项）： <ol><li>到达目的节点的<strong>最佳输出线路</strong></li><li>到达目的节点<strong>所需时间或距离</strong></li></ol></li><li>每隔一段时间，路由器会<strong>向所有邻居结点发送它到每个目的节点的距离表</strong>，同时它<strong>也接收每个邻居结点发来的距离矢量表</strong>。这样以此类推，经过一段时间后便可将<strong>网络中各路由器所获得的距离矢量信息在各路由器上统一起来</strong><ul><li>从本结点起，每经过一个路由器（也可以是提供路由功能的三层交换机，下同），就<strong>加一跳</strong>。也就是对应路由条目中<strong>除源站点所在网络直接连接的路由器外，到达目的站点所经过的路由器数</strong>.</li><li>所有的路由会<strong>周期性交换信息</strong>，学习完全<strong>依靠邻居路由器</strong>，交换的是<strong>完整的路由表项。</strong></li></ul></li></ul><hr><blockquote><p>RIP的基本工作过程：</p></blockquote><ol><li>路由器刚开始工作时，只知道自己到直连网络的距离为1。</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息。</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛。</li></ol><hr><blockquote><p>RIP的路由条目的更新规则：</p></blockquote><ul><li>发现了新的网络，添加</li><li>到达目的网络，相同下一跳，最新消息，更新</li><li>到达目的网络，不同下一跳，新路由优势，更新</li><li>到达目的网络，不同下一跳，新路由劣势，不更新</li><li>到达目的网络，不同下一跳，等价负载均衡</li></ul><h4 id="_2-存在问题" tabindex="-1"><a class="header-anchor" href="#_2-存在问题" aria-hidden="true">#</a> （2）存在问题</h4><p><mark>存在“坏消息传播得慢”的问题</mark>，又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。</p><ul><li>可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。 <ol><li>限制最大路径距离为15(16表示不可达)</li><li>当路由表发生变化时就立即发送更新报文（即“触发更新”），而不仅是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“水平分割”）</li></ol></li></ul><h3 id="_3、ospf协议" tabindex="-1"><a class="header-anchor" href="#_3、ospf协议" aria-hidden="true">#</a> 3、OSPF协议</h3><p><mark>OSPF协议 - 链路状态路由算法，它不仅是要根据所经过的路由器多少，还要根据路径中各段链路的状态来计算最佳路由路径。而这个链路状态包括：接口的IP地址、子网掩码、网络类型（如以太网链路或串行点对点链路）、该链路的端口开销（Cost）、该链路上的所有的相邻路由器。</mark></p><ul><li>网络中的路由器并不向<strong>邻居路由器</strong>传递路由表项，只是向邻居路由器<strong>通告它的一些链路状态</strong></li></ul><blockquote><p>链路状态路由算法的基本思想是：</p></blockquote><p>网络中各个结点<strong>不必交换通往目的站点的距离</strong>，而是<strong>维护一张网络拓扑图</strong>，在网络拓扑结构发生变化时及时更新拓扑图即可。</p><p>具体步骤如下：</p><ol><li><p>使用洪泛法向自治系统内<strong>所有路由器</strong>发送信息</p><ul><li><p>路由器通过输出端口向所有相邻的路由器发送信息</p></li><li><p>每一个相邻路由器又再次将此信息发往其所有的相邻路由器</p></li></ul></li><li><p>发送的信息就是与本路由器相邻的所有路由器的链路状态</p><ul><li><p>本路由器和哪些路由器相邻</p></li><li><p>该链路的<code>度量/代价</code>：<mark>费用、距离、延时、带宽</mark>等</p></li></ul></li><li><p>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息</p></li></ol><hr><blockquote><p>OSPF分组分类：</p></blockquote><ul><li>问候(Hello)分组：用来发现和维护邻居路由器的可达性</li><li>数据库描述(Database Description)分组：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>链路状态请求信息(Link State Request)分组：向邻居路由器请求发送某些链路状态项目的详细信息</li><li>链路状态更新(Link State Update)分组：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态</li><li>链路状态确认(Link State Acknowledgement)分组：这是对链路状态更新分组的确认分组</li></ul><hr><blockquote><p>OSPF工作原理和工作流程：OSPF相邻路由器之间通过交互问候(Hello)分组，建立和维护邻居关系</p></blockquote><details class="hint-container details"><summary>工作原理：</summary><ol><li>Hello分组封装在IP数据报中，发往组播地址224.0.0.5</li><li>发送周期为10秒</li><li><code>40秒未收到来自邻居路由器的</code>Hello`分组，则认为该邻居路由器不可达</li></ol></details><hr><details class="hint-container details"><summary>工作流程</summary><ol><li>相邻路由器之间周期性发送问候分组(Hello)，以便建立和维护邻居关系</li><li>建立邻居关系后，给邻居路由器发送数据库描述分组(DD)，也就是将自己链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器</li><li>收到数据库描述分组后，若发现自己缺少其中某些链路状态项目，则会发送链路状态请求分组(LSR)。</li><li>对方收到链路状态请求分组后，则会将其所缺少的链路状态项目的详细信息封装在链路状态更新分组(LSU)中发送回去</li><li>收到链路状态更新分组后，将这些信息添加到自己的链路状态数据库中</li></ol></details><blockquote><p>OSPF的链路状态通告LSA：</p></blockquote><ul><li>使用<code>OSPF</code>的每个路由器都会产生<strong>链路状态通告LSA</strong>，包含以下内容 <ul><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ul></li><li>LSA被封装在链路状态更新分组LSU中，采用洪泛法发送</li><li>使用OSPF的每个路由器都有一个链路状态数据库LSDB，用于存储LSA <ol><li>通过各路由器洪泛法发送封装有自己LSA的LSU分组，各路由器的LSDB最终达到一致</li><li>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各种到达其他各路由器的最短路径带权有向图，即构建各自的路由表。</li></ol></li></ul><h3 id="_4、isis协议" tabindex="-1"><a class="header-anchor" href="#_4、isis协议" aria-hidden="true">#</a> 4、ISIS协议</h3><p><mark>ISIS协议 - 分级路由算法，在分级路由算法中，路由器被分成很多组，称为区域。每个路由器都只有自己所在区域路由器的信息，而没有其他区域路由器的信息。</mark></p><ul><li>在其路由表中，路由器只需要<strong>存储其他每个区域</strong>的<strong>一条记录</strong>。</li><li>在分级路由算法的思想下，出现了<strong>自治系统、内部网关协议、外部网关协议</strong>等概念</li></ul><figure><img src="https://cloud.greennut.icu/blog/network/outin.png" alt="ISIS协议分层展示" tabindex="0" loading="lazy"><figcaption>ISIS协议分层展示</figcaption></figure><blockquote><p>自治系统AS：</p></blockquote><ul><li>一个自治系统(AS)是一个<strong>有权自主地决定</strong>在本系统中应采用各种路由协议的小型单位。 <ul><li>这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个<strong>单独的可管理的网络单元</strong>（例如一所大学，一个企业或者一个公司个体）。</li><li>一个自治系统有时也被称为是一个路由选择域（routing domain）</li></ul></li></ul><blockquote><p>内部网关协议IGP：</p></blockquote><ul><li><strong>IGP间交换路由信息的协议</strong>。</li><li><strong>IGP协议包括RIP、OSPF、IS-IS、IGRP、EIGRP。</strong></li></ul><blockquote><p>外部网关协议：</p></blockquote><ul><li><strong>AS之间</strong>使用的路由协议，如<strong>BGP-4协议</strong></li></ul><h3 id="_5、bgp协议" tabindex="-1"><a class="header-anchor" href="#_5、bgp协议" aria-hidden="true">#</a> 5、BGP协议</h3><blockquote><p>BGP协议 - 边界网关协议：</p></blockquote><ul><li>在不同自治系统内，度量路由的<code>代价</code>可能不同。</li><li>因此，对于自治系统之间的路由选择，使用&quot;代价&quot;作为度量来寻找最佳路由是不行的 <ul><li>比如A系统路由选择度量是距离，B系统是带宽……那么A到系统E的路由怎样走最好呢？由于没有统一度量，所以不能直接得到最佳路由</li><li>自治系统之间的路由选择必须考虑相关策略(政治、经济、安全等)，如中国的数据报尽量要绕开美国的自治系统</li></ul></li></ul><blockquote><p>BGP工作原理：</p></blockquote><ul><li>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”</li><li>不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接，端口号为179 <ul><li>在此TCP连接上交换BGP报文以建立BGP会话</li><li>利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</li><li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站(neighbor)或对等站(peer)</li></ul></li><li>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP,例如OSPF或RIP。</li><li><code>BGP</code>发言人<strong>交换网络可达性的信息</strong>(要到达某个网络所要经过的一系列自治系统)</li><li>当<code>BGP</code>发言人互相交换了网络可达性的信息后，各<code>BGP</code>发言人就根据所采用的策略从收到的路由信息中<strong>找出到达各自治系统的较好路由</strong>。也就是构造出树形结构(防环路)的自治系统连通图</li></ul><blockquote><p>BGP-4的4中报文：</p></blockquote><ul><li>OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化</li><li>UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由</li><li>KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性</li><li>NOTIFICATION(通知)报文：用来发送检测到的差错</li></ul><h2 id="四、ipv4地址" tabindex="-1"><a class="header-anchor" href="#四、ipv4地址" aria-hidden="true">#</a> 四、IPV4地址</h2><h3 id="_1、概述" tabindex="-1"><a class="header-anchor" href="#_1、概述" aria-hidden="true">#</a> 1、概述</h3><h4 id="_1-ipv4地址介绍" tabindex="-1"><a class="header-anchor" href="#_1-ipv4地址介绍" aria-hidden="true">#</a> （1）IPV4地址介绍</h4><blockquote><p>IPv4地址是是什么：</p></blockquote><ul><li><mark>IPv4地址是一个32比特的标识符，用于给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的标识符</mark><ul><li><p>32比特的IPV4地址不方便阅读、记录以及输入等，因此IPV4地址采用<strong>点分十进制表示</strong>方法以方便用户使用。</p><ul><li>IPv4 32位地址：<code>11000000.10101000.00000000.00000001</code> ，点分十进制表示<code>192.168.0.1</code></li><li>每一组由点分隔的十进制数对应了四组8位的二进制数。</li></ul></li><li><p>IP地址由因特网名字和数字分配机构ICANN（Internet Corporation for Assigned Names and Numbers）进行分配。</p></li><li><p><strong>IPv4地址编址方法</strong>：</p><ul><li>IPv4地址编址经历了三个主要历史阶段：<em>分类编址、划分子网、无分类编址</em>。</li></ul></li></ul></li></ul><h4 id="_2-子网掩码介绍" tabindex="-1"><a class="header-anchor" href="#_2-子网掩码介绍" aria-hidden="true">#</a> （2）子网掩码介绍</h4><p>我们在为设备配置IP地址时，通常是不能仅配置IPv4地址，而<strong>必须同时配置</strong>所谓的<strong>子网掩码</strong>。</p><blockquote><p>为什么要有子网掩码（它的作用是什么）：</p></blockquote><ul><li><p>IPv4地址在设计时就考虑到<strong>地址分配的层次特点</strong>，将<strong>每个IP地址都分割成<code>网络ID</code>和<code>主机ID</code>两部分</strong>，以便于IPv4地址的寻址操作。</p></li><li><p><mark>子网掩码</mark>：</p><ul><li>由<strong>1</strong>和<strong>0</strong>组成，且长度也是<strong>32位</strong>，我们也可以把它分成<strong>网络ID</strong>和<strong>主机ID</strong>两部分，且各自的长度与IPv4地址的网络ID和主机ID部分<strong>对应相等</strong>。</li><li>子网掩码中的 <ul><li><code>网络ID</code>部分全是<strong>1</strong>表示，1的数目等于<strong>网络ID的长度</strong>；</li><li><code>主机ID</code>部分全是<strong>0</strong>表示，0的数目等于<strong>主机ID的长度</strong>。</li></ul></li></ul></li><li><p>这样做的目的是为了在寻址过程中<mark>使子网掩码与对应的IPv4地址做逻辑与运算时用0遮住IPv4地址中原主机ID部分，而不改变原网络ID部分</mark>，这样就一来就<strong>得到了目的IPv4地址的网络ID，从而确定目的主机所在的网络.</strong></p></li></ul><h3 id="_2、分类编址的ipv4" tabindex="-1"><a class="header-anchor" href="#_2、分类编址的ipv4" aria-hidden="true">#</a> 2、分类编址的IPV4</h3><blockquote><p>IPv4的分类编址主要分为五类：A、B、C、D、E。每个类别都有不同的地址范围和可用主机数量。</p></blockquote><figure><img src="https://cloud.greennut.icu/blog/network/fenleiaddress.png" alt="分类编址的IPV4" tabindex="0" loading="lazy"><figcaption>分类编址的IPV4</figcaption></figure>',66),q=l("p",null,[l("strong",null,"A类地址：网络号8位，主机号24位，0开头")],-1),x=l("ol",null,[l("li",null,[l("p",null,"最小网络号0，保留不指派"),l("ul",null,[l("li",null,"第一个可指派的网络号为1，网络地址为1.0.0.0")])]),l("li",null,[l("p",null,"最大网络号127，作为本地环回测试地址，不指派"),l("ul",null,[l("li",null,[l("p",null,"最小的本地环回测试地址为127.0.0.1")]),l("li",null,[l("p",null,"最大的本地环回测试地址为127.255.255.254")])])]),l("li",null,[l("p",null,"可指派的网络数量为：2^(8-1) - 2=126")]),l("li",null,[l("p",null,"最后一个可指派的网络号为126，网络地址为126.0.0.0")]),l("li",null,[l("p",null,"A类网络可分配IP地址数量：2^24 - 2（除去主机号全0网络地址、主机号全1的广播地址）")])],-1),C=l("hr",null,null,-1),R=l("p",null,[l("strong",null,"B类地址：网络号16位，主机号16位，10开头")],-1),M=l("ol",null,[l("li",null,[t("最小网络号128.0 "),l("ul",null,[l("li",null,"第一个可指派的网络号为128，网络地址为128.0.0.0")])]),l("li",null,[t("最大网络号191.255 "),l("ul",null,[l("li",null,"最后一个可指派的网络号为191，网络地址为191.255.0.0")])]),l("li",null,"可指派的网络数量为：2^(16-2) - 2"),l("li",null,"B类网络可分配IP地址数量：2^16 - 2 = 65534（除去主机号全0网络地址、主机号全1的广播地址）")],-1),S=l("hr",null,null,-1),D=l("p",null,[l("strong",null,"C类地址：网络号24位，主机号8位，110开头")],-1),B=l("ol",null,[l("li",null,[t("最小网络号192.0.0 "),l("ul",null,[l("li",null,"第一个可指派的网络号为192.0.0，网络地址为192.0.0.0")])]),l("li",null,[t("最大网络号223.255.255 "),l("ul",null,[l("li",null,"最后一个可指派的网络号为223.255.255，网络地址为223.255.255.0")])]),l("li",null,"可指派的网络数量为：2^(24-3) - 2"),l("li",null,"C类网络可分配IP地址数量：2^8 - 2 = 126（除去主机号全0网络地址、主机号全1的广播地址）")],-1),y=l("hr",null,null,-1),V=l("p",null,[l("strong",null,"D类地址：1110开头，多播地址")],-1),F=l("hr",null,null,-1),L=l("p",null,[l("strong",null,"E类地址：1111开头，保留未使用")],-1),N=r(`<blockquote><p>详细表格：</p></blockquote><table><thead><tr><th style="text-align:center;">网络类别</th><th style="text-align:center;">最大网络数</th><th style="text-align:center;">第一个可用的网络</th><th>最后一个可用网络</th><th>每个网络中最大主机数</th></tr></thead><tbody><tr><td style="text-align:center;">A</td><td style="text-align:center;">126（2^7 - 2）</td><td style="text-align:center;">1</td><td>126</td><td>16,777,214</td></tr><tr><td style="text-align:center;">B</td><td style="text-align:center;">16,383（2^14 - 1）</td><td style="text-align:center;">128.1</td><td>191.255</td><td>65,534</td></tr><tr><td style="text-align:center;">C</td><td style="text-align:center;">2,097,151（2^21 - 1）</td><td style="text-align:center;">192.0.1</td><td>233.255.255</td><td>254</td></tr><tr><td style="text-align:center;">D</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td></td><td></td></tr><tr><td style="text-align:center;">E</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td></td><td></td></tr></tbody></table><hr><blockquote><p>私网IP地址：不能直接用私网ip地址访问</p></blockquote><p>在设计IPv4地址时就专门在前面介绍的A、B、C这类IPv4地址中<strong>各自划分了一段专用于各组织局域网内部的地址段</strong>，这就是我们前面所说的<strong>私网IP地址</strong>（又称局域网专用IP地址或者专用网络地址）。</p><p>私网IPv4地址在不同公司内部的局域网中<strong>是可以重复使用</strong>的，且无须向IP地址管理机构申请、注册和购买的。在A、B、C类地址中各自划分的局域网专用地址段如下:</p><div class="language-tex line-numbers-mode" data-ext="tex"><pre class="language-tex"><code>（1）10.0.0.0/8（10.0.0.0，255.0.0.0）
（2）172.16.0.0/12（172.16.0.0，255.240.0.0）
（3）192.168.0.0/16（192.168.0.0，255.255.0.0）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、划分子网ipv4" tabindex="-1"><a class="header-anchor" href="#_3、划分子网ipv4" aria-hidden="true">#</a> 3、划分子网IPV4</h3><blockquote><p>引出：当你为新增网络申请新的网络号时，会带来以下弊端：</p></blockquote><ul><li>需要等待时间和花费更多的费用。</li><li>会增加其他路由器中路由表记录的数量。</li><li>浪费原有网络号中剩余的大量IPv4地址。</li></ul><blockquote><p>解决办法：</p></blockquote><ul><li>可以从主机号部分借用一部分比特作为子网号。</li><li>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号。</li></ul><blockquote><p>正确的选项是：</p></blockquote><ul><li>子网掩码使用连续的比特1来对应网络号和子网号。</li><li>将划分子网的IPv4地址与其相应的子网掩码，进行逻辑与运算就可得到IPv4地址所在子网的网络地址。</li></ul><p>默认的子网掩码是：</p><ul><li>A类：255.0.0.0、 B类：255.255.0.0、C类：255.255.255.0</li></ul><hr><details class="hint-container details"><summary>例题</summary><blockquote><p>某主机的1P地址为180.80.77.55，子网掩码为255.255.252.0，如该主机向其所在子网发送广播分组，则目的地址可以是</p><ul><li>A.180.80.76.0</li><li>B.180.80.76.255</li><li>C.180.80.77.255</li><li>D.180.80.79.255</li></ul></blockquote><p>由IP地址网络号可知，这是B类网络，子网掩码<code>255.255.252.0</code>，为<code>11111111.11111111.11111100.00000000</code>，子网掩码后两位表示借用的比特位-6位：</p><ul><li>划分出的子网数量有：2^6个，</li><li>每个子网可分配的地址数量：2^(16-6)个</li><li>主机所在子网的网络地址为：<code>180.80.01001100.00000000 - 180.80.01001111.11111111</code>，点分十进制标识<code>180.80.76.0 ~ 180.79.255</code></li></ul></details><h3 id="_4、无分类编址ipv4" tabindex="-1"><a class="header-anchor" href="#_4、无分类编址ipv4" aria-hidden="true">#</a> 4、无分类编址IPV4</h3><h4 id="_4-1-概述" tabindex="-1"><a class="header-anchor" href="#_4-1-概述" aria-hidden="true">#</a> 4.1 概述</h4><ul><li><code>CIDR</code>消除了传统的<code>A</code>类、<code>B</code>类和<code>C</code>类地址，以及划分子网的概念</li><li><code>CIDR</code>可以更加有效地分配<code>IPv4</code>地址空间</li><li><code>CIDR</code>使用&quot;<strong>斜线记法</strong>&quot;，或称<code>CIDR</code>记法。即在<code>IPv4</code>地址后面加上斜线&quot;<code>/</code>&quot;，<strong>在斜线后面写上网络前缀所占比特数量，网络主机号位32 - 斜线后面的数字</strong></li></ul><details class="hint-container details"><summary>例题</summary><blockquote><p>请给出C1DR地址块128.14.35.7/20的全部细节（最小地址，最大地址，地址数量，聚合C类网数量，地址掩码)。</p></blockquote><p>斜线后面为20：网络号20位，主机号12位：</p><ul><li>128.14.35.7/20 —&gt; 128.14.00100011.00000111</li></ul><ol><li>最小地址-主机号全为0：128.14.00100000.00000000 = 点分十进制表示：128.14.32.0</li><li>最大地址-主机号全为1：128.14.00101111.11111111 = 点分十进制表示：128.14.47.255</li><li>地址数量：2^(32-20)</li><li>聚合c类网的数量：2^(32-20) / 2 ^8</li><li>地址掩码 - 网络位全1，主机全0：11111111.11110000.00000000 = 点分十进制表示：255.255.240.0</li></ol></details><h4 id="_4-3-路由聚合" tabindex="-1"><a class="header-anchor" href="#_4-3-路由聚合" aria-hidden="true">#</a> 4.3 路由聚合</h4><p>路由聚合（构造超网）是网络设计中的一个重要概念，它有助于减少路由表的大小，提高路由器的性能。以下是一个例子：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>目的网络        下一跳   共同前缀
172.1.4.0/25    R1      172.1.00000100.0
172.1.4.128/25  R1      172.1.00000100.128
172.1.5.0/24    R1      172.1.00000101.0
172.1.6.0/24    R1      172.1.00000110.0
172.1.7.0/24    R1      172.1.00000111.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们有五个目的网络，每个网络都有一个下一跳和共同前缀。</p><p>为了减少路由表的大小，可以将具有相同共同前缀的路由进行聚合。</p><p>例如，他们的前缀前两个字节和第三个字节的前6位相同，共22位。</p><ul><li>如：<code>172.1.4.0/25</code>和<code>172.1.4.128/25</code>共享相同的前缀<code>172.1.00000100</code>，不同的补0</li><li>因此可以聚合成的聚合地址块<code>172.1.4.0/22</code>。</li></ul><hr><ol><li>网络前缀越长，地址块越小，路由越具体。</li><li><strong>最长前缀匹配</strong>：若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条， 因为这样的路由更具体。</li></ol><h3 id="_5、ipv4应用规划" tabindex="-1"><a class="header-anchor" href="#_5、ipv4应用规划" aria-hidden="true">#</a> 5、IPV4应用规划</h3><p>IP地址的应用规划是指在一个网络环境中，如何合理地分配和管理IP地址以满足网络通信的需求。以下是IP地址的应用规划涉及的一些重要方面：</p><ol><li><strong>子网划分</strong>：将一个大的IP地址范围分割成多个小的子网，以适应不同部门或网络区域的需求。每个子网都有自己的网络地址和广播地址。 <ul><li>定长子网掩码-FLSM： <ul><li>在FLSM中，每个子网使用相同长度的子网掩码。这意味着所有子网中可以容纳的主机数量是相同的，FLSM常用于早期的网络设计，它简单直观，但可能会造成IP地址的浪费。。</li><li>例如，如果使用/24的子网掩码，每个子网将包含2^8 (256) 个IP地址，其中包括一个网络地址和一个广播地址，因此可用的主机IP数量是254个。</li></ul></li><li>变长子网掩码-VLSM： <ul><li>VLSM允许在同一个网络中使用不同长度的子网掩码。这样可以根据各个子网的实际需求，分配不同大小的IP地址块，VLSM是现代网络设计的常用方法，特别是在复杂网络环境中，可以根据具体需求分配不同大小的子网。。</li><li>举例来说，如果某个子网需要容纳更多主机，可以分配一个较小的子网掩码（例如，/26）。而对于另一个只需要较少主机的子网，可以分配一个较大的子网掩码（例如，/28）。</li><li>VLSM可以高效地利用IP地址空间，减少了浪费。</li></ul></li></ul></li><li><strong>IP地址分配</strong>：确定每个子网中可用的IP地址范围，并将这些地址分配给主机、设备或服务器。这确保了每个设备都有一个唯一的IP地址。</li><li><strong>保留地址</strong>：确定哪些地址用于特定目的，比如网络地址、广播地址和保留地址（如回环地址等）。</li></ol><h2 id="五、vpn和nat" tabindex="-1"><a class="header-anchor" href="#五、vpn和nat" aria-hidden="true">#</a> 五、VPN和NAT</h2><blockquote><p>VPN虚拟专用网：是一种通过公共因特网创建安全连接的技术。在这种网络中，<strong>各个主机使用本机构内部可自由分配的专用地址进行通信，而这些地址在公共因特网上是不可见的</strong>。</p></blockquote><ol><li><strong>内联网VPN（Intranet VPN）：</strong> 用于连接企业内部的分支机构、办公室或远程员工。内联网VPN通常用于建立企业内部的安全通信网络。</li><li><strong>外联网VPN（Extranet VPN）：</strong> 用于连接不同组织之间的网络，比如合作伙伴、供应商或客户。外联网VPN允许不同组织之间安全地共享资源和信息。</li><li><strong>远程接入VPN（Remote Access VPN）：</strong> 允许个人用户或远程办公者通过公共网络（如互联网）连接到企业网络，以便访问内部资源。</li></ol><blockquote><p>NAT网络地址转换：用于在私有网络和公共网络之间进行通信。它的主要目的是将内部私有网络中的多个主机共享一个公共IP地址，以节约公共IP地址的使用。</p></blockquote><ol><li><strong>私有IP地址和公共IP地址：</strong> NAT允许内部网络使用私有IP地址（如在RFC1918标准中定义的10.0.0.0/8、172.16.0.0/12和192.168.0.0/16）进行通信，而将公共IP地址留给NAT设备用于与公共网络通信。</li><li><strong>地址转换：</strong> 当内部主机发送数据包到公共网络时，NAT设备将内部主机的私有IP地址和端口号转换为NAT设备的公共IP地址和一个唯一的端口号，以便在公共网络中唯一标识这个连接。</li><li><strong>解决IPv4地址枯竭问题：</strong> NAT允许在IPv4地址有限的情况下，通过在内部网络中使用私有IP地址来连接到公共网络，从而节约公共IP地址的使用。</li></ol><p>由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。</p><p>这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫作网络地址与端口号转换NAPT。</p><p>但是NAT构建的局域网不能充当服务器。</p>`,42);function T(G,w){const s=a("Tabs"),d=a("Mermaid");return g(),c("div",null,[P,p(" more "),I,e(s,{id:"307",data:[{id:"第一层详解"},{id:"第二层详解"},{id:"第三层详解"},{id:"第四层详解"},{id:"第五层详解"}]},{title0:i(({value:o,isActive:n})=>[t("第一层详解")]),title1:i(({value:o,isActive:n})=>[t("第二层详解")]),title2:i(({value:o,isActive:n})=>[t("第三层详解")]),title3:i(({value:o,isActive:n})=>[t("第四层详解")]),title4:i(({value:o,isActive:n})=>[t("第五层详解")]),tab0:i(({value:o,isActive:n})=>[b]),tab1:i(({value:o,isActive:n})=>[k]),tab2:i(({value:o,isActive:n})=>[m]),tab3:i(({value:o,isActive:n})=>[_]),tab4:i(({value:o,isActive:n})=>[v]),_:1}),A,e(d,{id:"mermaid-902",code:"eJxLL0osyFDwCbLmUgCCF9vXP5+y8WVD57PulU97+1+sW6egq2un8LSt9WXziud7Jz5t3QxRApH0dA9QwKtvyTS4PoiwK0wHPiPBeiGCT/YvfNa4HiIV5EmsXtwKglAcjG46WO/8XU929b3YPvf5st1PJ0x82d5PwE6gkeRphOlbNO/pnl1P53XjUumKcDaRasHmPmuY+3z5xOfLG5/N6Xw+q4VIx+xpeDZl39M9/c/mNDyfvxao5um+lid7Zjxt7fAPDnAjMvyf7Fj7cvqW55t3P989/2nHBmSuZ7CuZzDUGAJ2IQL15eR9IHu6tj1raIR5haAd+LVjT5rQpLdv5/OpPchyTu4BXAAYVs8L"}),f,e(s,{id:"1610",data:[{id:"A类地址"},{id:"B类地址"},{id:"C类地址"},{id:"D类地址"},{id:"E类地址"}]},{title0:i(({value:o,isActive:n})=>[t("A类地址")]),title1:i(({value:o,isActive:n})=>[t("B类地址")]),title2:i(({value:o,isActive:n})=>[t("C类地址")]),title3:i(({value:o,isActive:n})=>[t("D类地址")]),title4:i(({value:o,isActive:n})=>[t("E类地址")]),tab0:i(({value:o,isActive:n})=>[q,x,C]),tab1:i(({value:o,isActive:n})=>[R,M,S]),tab2:i(({value:o,isActive:n})=>[D,B,y]),tab3:i(({value:o,isActive:n})=>[V,F]),tab4:i(({value:o,isActive:n})=>[L]),_:1}),N])}const E=u(h,[["render",T],["__file","network.html.vue"]]);export{E as default};

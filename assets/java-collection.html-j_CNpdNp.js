import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as n,a as e}from"./app-yOESM-4p.js";const t={},o=e(`<h1 id="java集合框架" tabindex="-1"><a class="header-anchor" href="#java集合框架" aria-hidden="true">#</a> Java集合框架</h1><h2 id="一、基础" tabindex="-1"><a class="header-anchor" href="#一、基础" aria-hidden="true">#</a> 一、基础</h2><h3 id="_1、java集合框架体系" tabindex="-1"><a class="header-anchor" href="#_1、java集合框架体系" aria-hidden="true">#</a> 1、Java集合框架体系</h3><details class="hint-container details"><summary>说说Java集合的框架体系？</summary><p>集合相关类和接口都在java.util中，主要和两家接口相关：Collection、Map，而集合可以分为4种：Collection接口下面的基于单值集合的List（列表）接口、Set(集)接口、Queue（队列），另一种就是Map（映射）接口、。</p></details><h3 id="_2、那这几个父类接口有什么区别" tabindex="-1"><a class="header-anchor" href="#_2、那这几个父类接口有什么区别" aria-hidden="true">#</a> 2、那这几个父类接口有什么区别</h3><details class="hint-container details"><summary>那这几个父类接口有什么区别？</summary><blockquote><p>说说 List, Set, Queue, Map 四者的区别？</p></blockquote><ul><li><code>List</code>列表（对付顺序的好帮手）：存储的元素是有序的、可重复的。</li><li><code>Set</code>集（注重独一无二的性质）：存储的元素不可重复的。</li><li><code>Queue</code>队列（实现排队功能的叫号机）： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>映射（用 key 来搜索的专家）：使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul></details><h3 id="_3、无序性和不可重复性" tabindex="-1"><a class="header-anchor" href="#_3、无序性和不可重复性" aria-hidden="true">#</a> 3、无序性和不可重复性</h3><details class="hint-container details"><summary>无序性和不可重复性的含义是什么？</summary><ul><li>无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的，无序性不等于随机性 。</li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul></details><h3 id="_4、为什么要使用集合-如何挑选合适的集合" tabindex="-1"><a class="header-anchor" href="#_4、为什么要使用集合-如何挑选合适的集合" aria-hidden="true">#</a> 4、为什么要使用集合，如何挑选合适的集合</h3><details class="hint-container details"><summary>为什么要使用集合，如何挑选合适的集合？</summary><ol><li>数组存储对象存在一些不足之处不能动态扩容，Java 集合底层是基于Obejct动态数组实现，还是使用了反向，Java 集合更灵活、更有效的方法来存储多个数据对象</li><li>Java 集合封装了一些了对数据操作的常用方法，减少了工作量，其次关于操作过程中的一些问题，如线程安全，也提供对应符合要求的集合</li><li>集合种类多样，可以根据业务情况进行挑选</li></ol></details><h3 id="_5、comparable-和-comparator" tabindex="-1"><a class="header-anchor" href="#_5、comparable-和-comparator" aria-hidden="true">#</a> 5、Comparable 和 Comparator</h3><details class="hint-container details"><summary>Comparable 和 Comparator 的区别？</summary><p>两个接口都是 Java 中用于排序的接口，用于实例对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序 <ul><li><code>Comparable</code> 接口定义了对象自身的排序方式，是对象固有的排序方法</li><li>比如一个 <code>song</code> 对象中的歌名和歌手名分别采用一种排序方法的话</li></ul></li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序 <ul><li><code>Comparator</code> 接口则是在外部独立定义的排序方式，可以创建多个不同的比较器，并在需要时选择使用。</li><li>可以为两个 <code>Comparator</code> 来实现歌名排序和歌星名排序</li></ul></li></ul></details><h3 id="_6、java里线程安全的集合" tabindex="-1"><a class="header-anchor" href="#_6、java里线程安全的集合" aria-hidden="true">#</a> 6、Java里线程安全的集合</h3><details class="hint-container details"><summary>那有Java集合里面有哪些是线程安全的集合？</summary></details><h2 id="二、单值集合" tabindex="-1"><a class="header-anchor" href="#二、单值集合" aria-hidden="true">#</a> 二、单值集合</h2><h3 id="_1、说说你对arraylist的理解" tabindex="-1"><a class="header-anchor" href="#_1、说说你对arraylist的理解" aria-hidden="true">#</a> 1、说说你对ArrayList的理解</h3><details class="hint-container details"><summary>说说你对ArrayList的理解？</summary><p>ArrayList是Java基于数组实现的一种动态数组的数据结构。</p><ul><li>底层实现是基于一个Object数组，会根据实际存储的元素动态地扩容或缩容</li><li>创建时的大小可以传入创建大小，如何是无参构造则默认大小为10，扩容是满了才会扩容，按原大小的<strong>1.5倍</strong>扩容，扩容方式是创建一个新数组，然后copy赋值，改变引用指向</li><li>由于是一种动态数组的数据结构，且被<code>RandomAccess</code> 接口标记了，表明实现该接口的类支持随机访问，可以通过索引进行访问，查询的时间复杂度是O(1)</li><li>插入可以头部插入、尾部插入、指定位置插入：时间复杂度是 O(n)、时间复杂度是 O(1)、时间复杂度是 O(n)</li><li>删除可以头部删除、尾部删除、指定位置删除：时间复杂度是 O(n)、时间复杂度是 O(1)、时间复杂度是 O(n)</li></ul></details><h3 id="_2、说说你对linkedlist的理解" tabindex="-1"><a class="header-anchor" href="#_2、说说你对linkedlist的理解" aria-hidden="true">#</a> 2、说说你对LinkedList的理解</h3><details class="hint-container details"><summary>说说ArrayList的添加元素的过程和扩容过程?</summary><p>LinkedList是Java基于数组实现的一种动态数组的数据结构。</p><ul><li>底层实现是基于链表实现，是一个个的Node节点，节点包括pre、next指针和data数据</li><li>由于是一种链表的数据结构，不可以通过索引进行访问，访问指定节点只能遍历链表，查询的时间复杂度是O(n)</li><li>插入可以头部插入、尾部插入、指定位置插入：时间复杂度是 O(1)、时间复杂度是 O(1)、时间复杂度是 O(1)</li><li>删除可以头部删除、尾部删除、指定位置删除：时间复杂度是 O(1)、时间复杂度是 O(1)、时间复杂度是 O(1)</li></ul></details><h3 id="_3、arraylist和linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#_3、arraylist和linkedlist的区别" aria-hidden="true">#</a> 3、ArrayList和LinkedList的区别</h3><details class="hint-container details"><summary>说说ArrayList和LinkedList的区别？</summary><p>底层实现、查询效率、增加/删除效率、扩容方式、遍历方式</p></details><h3 id="_4、arraylist序列化" tabindex="-1"><a class="header-anchor" href="#_4、arraylist序列化" aria-hidden="true">#</a> 4、ArrayList序列化</h3><details class="hint-container details"><summary>ArrayList怎么序列化的知道吗？</summary><p>ArrayList的序列化不太一样，它使用<code>transient</code>修饰存储元素的<code>elementData</code>的数组，<code>transient</code>关键字的作用是让被修饰的成员属性不被序列化。</p><blockquote><p>为什么最ArrayList不直接序列化元素数组呢？</p></blockquote><p>出于效率的考虑，数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。</p><blockquote><p>那ArrayList怎么序列化呢？</p></blockquote><p>ArrayList通过两个方法<strong>readObject、writeObject</strong>自定义序列化和反序列化策略，实际直接使用两个流<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>来进行序列化和反序列化。</p></details><h3 id="_5、arraylist是不是线程安全的" tabindex="-1"><a class="header-anchor" href="#_5、arraylist是不是线程安全的" aria-hidden="true">#</a> 5、ArrayList是不是线程安全的</h3><details class="hint-container details"><summary>ArrayList是线程安全的吗？有哪几种实现ArrayList线程安全的方法？</summary><p>ArrayList是线程不安全的，保证ArrayList的线程安全可以通过这些方案：</p><ul><li>使用 Vector 代替 ArrayList。（不推荐，Vector是一个历史遗留类）</li><li>使用 Collections.synchronizedList 包装 ArrayList，然后操作包装后的 list。</li><li>使用 CopyOnWriteArrayList 代替 ArrayList。</li><li>在使用 ArrayList 时，应用程序通过同步机制去控制 ArrayList 的读写。</li></ul></details><h3 id="_6、你是否了解copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#_6、你是否了解copyonwritearraylist" aria-hidden="true">#</a> 6、你是否了解CopyOnWriteArrayList</h3><details class="hint-container details"><summary>CopyOnWriteArrayList了解多少？</summary><p>CopyOnWriteArrayList就是线程安全版本的ArrayList。</p><p>它的名字叫<code>CopyOnWrite</code>——写时复制，采用了一种读写分离的并发策略。</p><ul><li>允许并发读，读操作是无锁的，性能较高。</li><li>至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。 <ol><li>将原数组拷贝一份</li><li>写操作在副本上，加锁；此时读操作在原数组上</li><li>写完将元素数组指向副本</li></ol></li></ul></details><h3 id="_7、hashset实现原理" tabindex="-1"><a class="header-anchor" href="#_7、hashset实现原理" aria-hidden="true">#</a> 7、HashSet实现原理</h3><details class="hint-container details"><summary>HashSet实现原理？</summary><p>HashSet实现就是基于 <code>HashMap</code> 实现的，当你向 <code>HashSet</code> 中添加元素时，实际上是将这些元素作为 <code>HashMap</code> 中的 <code>key</code>，而对应的 <code>value</code> 则是一个固定的 <code>Object</code> 对象， <code>private static final Object PRESENT = new Object()</code>。</p><p>因此，<code>HashSet</code> 的实现本质上就是通过 <code>HashMap</code> 来模拟一个<mark>只有 <code>key</code> 没有 <code>value</code> 的集合</mark>。这也解释了为什么 <code>HashSet</code> 中不能存储重复元素，因为 <code>HashMap</code> 中的 <code>key</code> 是唯一的。</p></details><h2 id="二、双值集合" tabindex="-1"><a class="header-anchor" href="#二、双值集合" aria-hidden="true">#</a> 二、双值集合</h2><h3 id="_1、说说你对hashmap的理解" tabindex="-1"><a class="header-anchor" href="#_1、说说你对hashmap的理解" aria-hidden="true">#</a> 1、说说你对HashMap的理解</h3><details class="hint-container details"><summary>说说你对HashMap的理解？</summary><p>HashMap是Map接口下的一个实现类，存储方式是键值对存储，是Java对Hash表的一种实现，具体是使用数组做Hash容器。</p><ul><li><p>底层实现是在jdk1.7是基于一个数组+链表形式，数组做Hash容器，数组存储每个元素对应一个链表，用于解决哈希冲突。</p></li><li><p>底层实现是在jdk1.8是基于一个数组+链表+红黑树形式，引入了红黑树，数组做Hash容器，数组存储每个元素对应一个链表，用于解决哈希冲突，红黑树用于以提高查询效率，优化 HashMap 的性能。</p><ul><li>引入红黑树主要是为hashmap集合分布的元素更均匀，如果没有红黑树，可能会出现元素集中分布，某一个部位的链表特别长，其他部位特别短，</li></ul></li><li><p>初始化HashMap，默认大小是16，也可以传参，如果传一个值不是2的倍数，则会HashMap会向上寻找离得最近的2的倍数</p></li><li><p>HashMap 在元素数量超过负载因子（默认为 0.75）与容量的乘积时，HashMap 将自动进行扩容操作，扩容长度为原来的两倍</p><p>这个过程可能会比较耗时，尤其是当元素数量巨大时，因为需要重新计算所有元素的哈希值并重新分配到新的位置。为了避免频繁扩容带来的性能开销，通常在创建 HashMap 时指定一个合适的初始容量，以及根据实际情况调整负载因子。</p></li><li><p>数据元素通过hash算法也就是散列函数进行定位，映射到Hash表（桶数组）对应索引的位置，在大多数情况下，已知键，对应查询、删除、修改的效率是O(1)，如果链表非常长，最差情况是O(n)</p></li></ul></details><h3 id="_2、hashmap的实现原理" tabindex="-1"><a class="header-anchor" href="#_2、hashmap的实现原理" aria-hidden="true">#</a> 2、HashMap的实现原理</h3><details class="hint-container details"><summary>HashMap的实现原理？</summary><ul><li>底层实现是在jdk1.7是基于一个<strong>数组+链表</strong>形式，数组做Hash容器，数组存储每个元素对应一个链表，用于解决哈希冲突。 <ul><li>HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度）</li><li>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话-是同一个元素，直接覆盖，不相同就通过拉链法解决冲突。</li></ul></li><li>底层实现是在jdk1.8是基于一个<strong>数组+链表+红黑树</strong>形式，引入了红黑树，数组做Hash容器，数组存储每个元素对应一个链表，用于解决哈希冲突，红黑树用于以提高查询效率，优化 HashMap 的性能。 <ul><li>引入红黑树主要是为hashmap集合分布的元素更均匀，如果没有红黑树，可能会出现元素集中分布，某一个部位的链表特别长，其他部位特别短</li><li>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li></ul></li></ul></details><h3 id="_3、hashmap可以添加null-元素可以重复吗" tabindex="-1"><a class="header-anchor" href="#_3、hashmap可以添加null-元素可以重复吗" aria-hidden="true">#</a> 3、HashMap可以添加null，元素可以重复吗</h3><details class="hint-container details"><summary>HashMap可以添加null，元素可以重复吗？</summary><p>在 <code>HashMap</code> 中：</p><ol><li><p><strong>允许添加 <code>null</code>：</strong> 是的，<code>HashMap</code> 中的键和值都可以为 <code>null</code>。在键值对中，键和值都可以是 <code>null</code>。</p></li><li><p><strong>元素不允许重复：</strong> 在 <code>HashMap</code> 中，键是唯一的，不允许重复。如果添加相同的键（即相同的 <code>hashCode</code> 和 <code>equals</code> 结果），后添加的值会覆盖先前的值。但是值可以重复，即多个键可以对应相同的值，不会影响 <code>HashMap</code> 的数据结构。</p></li></ol></details><h3 id="_4、为什么hashmap-的长度是-2-的幂次方-倍数" tabindex="-1"><a class="header-anchor" href="#_4、为什么hashmap-的长度是-2-的幂次方-倍数" aria-hidden="true">#</a> 4、为什么HashMap 的长度是 2 的幂次方/倍数</h3><details class="hint-container details"><summary>为什么HashMap 的长度是 2 的幂次方/倍数？</summary><ol><li><p><strong>为了方便哈希取余</strong>：</p><ul><li><p>HashMap是用<code>hash值&amp;(数组大小-1)</code>代替了<code>hash值%数组</code>定位位置，这就得益于HashMap的大小是2的倍数.</p><ul><li>2的倍数意味着该数的二进制位只有一位为1，而该数-1就可以得到二进制位上1变成0，后面的0变成1，再通过&amp;运算，就可以得到和%一样的效果，并且位运算比%的效率高得多</li></ul></li><li><p>HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。</p></li></ul></li><li><p><strong>在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去</strong></p><ul><li>进行与运算时，只是多了一个1参与运算（例如从 16 扩容到 32，n-1二进制分别为 01111 和 011111），保持与运算 <code>(hash &amp; (newCapacity - 1))</code> 在扩容后的效果，仍然能够有效且均匀地分布元素到新的数组中。</li><li>低位在进行位运算时能够更均匀地分布元素到新的数组中，虽然只有低位参与了运算，但这足以保持元素的均匀性，有助于减少哈希冲突，提高 HashMap 的性能。</li></ul></li></ol></details><h3 id="_5、如果初始化hashmap-传入的值不是2的倍数-它会怎么处理" tabindex="-1"><a class="header-anchor" href="#_5、如果初始化hashmap-传入的值不是2的倍数-它会怎么处理" aria-hidden="true">#</a> 5、如果初始化HashMap，传入的值不是2的倍数，它会怎么处理</h3><details class="hint-container details"><summary>如果初始化HashMap，传入的值不是2的倍数，它会怎么处理？</summary><p>简单来说，就是初始化时，传的不是2的倍数时，HashMap会向上寻找<code>离得最近的2的倍数</code>，所以传入17，但HashMap的实际容量是32。</p><p>我们来看看详情，在HashMap的初始化中，有这样⼀段⽅法；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>阀值 threshold ，通过⽅法<code> tableSizeFor</code> 进⾏计算，是根据初始化传的参数来计算的。</li><li>同时，这个⽅法也要要寻找⽐初始值⼤的，最⼩的那个2进制数值。⽐如传了17，我应该找到的是32。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
 n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
 n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
 n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
 n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>
 n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30，这个是临界范围，也就是最⼤的Map集合。</li><li>计算过程是向右移位1、2、4、8、16，和原来的数做<code>|</code>运算，这主要是为了把⼆进制的各个位置都填上1，当⼆进制的各个位置都是1以后，就是⼀个标准的2的倍数减1了，最后把结果加1再返回即可。</li></ul></details><h3 id="_6、你和我简单的说一说hash算法" tabindex="-1"><a class="header-anchor" href="#_6、你和我简单的说一说hash算法" aria-hidden="true">#</a> 6、你和我简单的说一说hash算法</h3><details class="hint-container details"><summary>你和我简单的说一说hash算法？</summary><p>hash算法是一种散列算法，可以将几个任意长度的二进制数据散列计算成一个定长的二进制数据，常见的hash算法有md5，sha256等，当然我们也可以自定义实现一些简单的hash算法，比如java中有取余、内存地址等。</p><p>hash算法通常是要结合数组来实现hash表。</p><p>1、hash表是一种数据结构，通常要结合数组和hash算法来实现，我们利用hash算法可以定位一个元素的位置，并利用数据的随机访问特性快速的元素进行增删查改，他的<strong>最优时间复杂度可以达到O(1)。</strong></p><p>2、但是，他也存在一些问题，比如hash碰撞，如果<strong>数组的元素过少，或者hash算法不太优秀或者存入的元素太多</strong>，可能会经常发生hash碰撞，导致时间复杂度进行退化，最差可能是O(n)。</p><p>3、通常情况下，我们可以使用线性探测法、链表法等来解决hash碰撞的问题，同时提供一个负载因子，在必要的时候进行扩容，来保持一个相对较稳定的时间复杂度，比如java中的hashmap的实现。</p><p>那你继续说说hashmap（O(1) —》 数据总量和查询次数的关系）</p><p>1、基础数据结构，负载因子0.75（泊松分布）</p><p>2、hash算法，只要我们的hash算法不垃圾，一般情况都不会树化</p><p>3、扩缩容的条件: &gt;0.75 链表节点 &gt; 8 （优先扩容）</p><p>4、treeify的条件: 链表的节点 &gt; 8 &amp;&amp; 数组长度 &gt; 64</p><p>5、线程安全的问题.</p></details><h3 id="_7、你还知道哪些哈希函数的构造方法呢" tabindex="-1"><a class="header-anchor" href="#_7、你还知道哪些哈希函数的构造方法呢" aria-hidden="true">#</a> 7、你还知道哪些哈希函数的构造方法呢？</h3><details class="hint-container details"><summary>你还知道哪些哈希函数的构造方法呢？</summary><p>HashMap里哈希构造函数的方法叫：</p><ul><li><p><strong>除留取余法</strong>：H（key)=key%p（p&lt;=N）,关键字除以一个不大于哈希表长度的正整数p，所得余数为地址，当然HashMap里进行了优化改造，效率更高，散列也更均衡。</p></li><li><p><strong>直接定址法</strong>：直接根据<code>key</code>来映射到对应的数组位置，例如1232放到下标1232的位置。</p></li><li><p><strong>数字分析法</strong>：取<code>key</code>的某些数字（例如十位和百位）作为映射的位置</p></li><li><p><strong>平方取中法</strong>：取<code>key</code>平方的中间几位作为映射的位置</p></li><li><p><strong>折叠法</strong>：将<code>key</code>分割成位数相同的几段，然后把它们的叠加和作为映射的位置</p></li></ul></details><h3 id="_8、解决哈希冲突有哪些方法呢" tabindex="-1"><a class="header-anchor" href="#_8、解决哈希冲突有哪些方法呢" aria-hidden="true">#</a> 8、解决哈希冲突有哪些方法呢</h3><details class="hint-container details"><summary>解决哈希冲突有哪些方法呢？</summary><p>我们到现在已经知道，HashMap使用链表的原因为了处理哈希冲突，这种方法就是所谓的：</p><ul><li><p><strong>链地址法</strong>：在冲突的位置拉一个链表，把冲突的元素放进去。</p></li><li><p><strong>开放定址法</strong>：开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位。</p><p>找到空闲位置的方法也有很多种：</p><ul><li>线行探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置</li><li>平方探查法: 从冲突的位置x开始，第一次增加<code>1^2</code>个位置，第二次增加<code>2^2</code>…，直至找到空闲的位置</li></ul></li><li><p><strong>再哈希法</strong>：换种哈希函数，重新计算冲突元素的地址。</p></li><li><p><strong>建立公共溢出区</strong>：再建一个数组，把冲突的元素放进去。</p></li></ul></details><h3 id="_9、hashmap的哈希-扰动函数是怎么设计的" tabindex="-1"><a class="header-anchor" href="#_9、hashmap的哈希-扰动函数是怎么设计的" aria-hidden="true">#</a> 9、HashMap的哈希/扰动函数是怎么设计的?</h3><details class="hint-container details"><summary>详情</summary><p>HashMap的哈希函数是先拿到 key 的hashcode，是一个32位的int类型的数值，然后让hashcode的高16位和低16位进行异或操作。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token comment">// key的hashCode和key的hashCode右移16位做异或运算</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="_10、为什么哈希-扰动函数能降hash碰撞" tabindex="-1"><a class="header-anchor" href="#_10、为什么哈希-扰动函数能降hash碰撞" aria-hidden="true">#</a> 10、为什么哈希/扰动函数能降hash碰撞？</h3><details class="hint-container details"><summary>为什么哈希/扰动函数能降hash碰撞？</summary><p>因为 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。int 值范围为 <strong>-2147483648~2147483647</strong>，加起来大概 40 亿的映射空间。</p><p>只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。</p><p>假如 HashMap 数组的初始大小才 16，就需要用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。</p><p>源码中模运算就是把散列值和数组长度 - 1 做一个 &quot;<code>与&amp;</code>&quot; 操作，位运算比取余 % 运算要快。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顺便说一下，这也正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。因为这样（数组长度 - 1）正好相当于一个 “低位掩码”。<code>与</code> 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是<code> 0000 0000 0000 0000 0000 0000 0000 1111</code>。和某个散列值做 <code>与</code> 操作如下，结果就是截取了最低的四位值。</p><p>这样是要快捷一些，但是新的问题来了，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，那就更难搞了。</p><p>这时候 <code>扰动函数</code> 的价值就体现出来了：</p><p>key的hashCode右移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p></details><h3 id="_11、hashmap的put-流程" tabindex="-1"><a class="header-anchor" href="#_11、hashmap的put-流程" aria-hidden="true">#</a> 11、HashMap的put()流程</h3><details class="hint-container details"><summary>HashMap的put()流程知道吗？</summary><ol><li><p>首先进行哈希值的扰动，获取一个新的哈希值。<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></p></li><li><p>判断tab是否位空或者长度为0，如果是则进行扩容操作。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆盖。<code>tab[i = (n - 1) &amp; hash])</code></p></li><li><p>判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。</p></li><li><p>如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。<code>treeifyBin(tab, hash);</code></p></li><li><p>最后所有元素处理完成后，判断是否超过阈值；<code>threshold</code>，超过则扩容。</p></li></ol></details><h3 id="_12、扩容在什么时候呢-为什么扩容因子是0-75" tabindex="-1"><a class="header-anchor" href="#_12、扩容在什么时候呢-为什么扩容因子是0-75" aria-hidden="true">#</a> 12、扩容在什么时候呢？为什么扩容因子是0.75</h3><details class="hint-container details"><summary>扩容在什么时候呢？为什么扩容因子是0.75？</summary><p>那就是大于容量 * 负载因子(0.75)如：<code>16x0.75=12</code>时，就会触发扩容操作。</p><blockquote><p>那么为什么选择了0.75作为HashMap的默认加载因子呢？</p></blockquote><p>简单来说，这是对<code>空间</code>成本和<code>时间</code>成本平衡的考虑</p><p>HashMap 中的加载因子（即扩容因子）通常设置为 0.75。这个值的选择考虑了几个方面：</p><p>太大了分布不均匀，太小了容易hash冲突，基于他们一次次的尝试，参考下列的因素试出来的。</p><ol><li><p><strong>减少哈希冲突和提高性能：</strong> 较低的加载因子可以减少哈希碰撞，也就是减少了链表或红黑树的长度，使得哈希表的性能更高效。过高的加载因子会导致哈希碰撞增多，链表长度变长，使得哈希表的性能下降。</p></li><li><p><strong>空间利用和内存效率：</strong> 较高的加载因子意味着哈希表需要更少的空间来存储相同数量的元素。但过高的加载因子可能导致哈希表过度填充，增加了哈希冲突的概率，影响了性能。</p></li><li><p><strong>泊松分布：</strong> 在一些情况下，0.75 这个值选择可能考虑到了键的插入和查询操作符合泊松分布的假设。泊松分布是一种描述在一定时间或空间区域内随机事件发生次数的概率分布，HashMap 中键的插入和查询操作可能在一定程度上符合这种分布。选择加载因子为 0.75 可能是在尽可能平衡哈希表的空间利用率和性能之间做出的折中。</p></li></ol><p>总的来说，0.75 这个值的选择是为了在空间利用和哈希表性能之间取得一个较好的平衡，并不仅仅是基于泊松分布考虑的。这个值可能会因不同的情况和需求而有所调整。</p></details><h3 id="_13、为什么hashmap链表转红黑树的阈值为8呢" tabindex="-1"><a class="header-anchor" href="#_13、为什么hashmap链表转红黑树的阈值为8呢" aria-hidden="true">#</a> 13、为什么HashMap链表转红黑树的阈值为8呢</h3><details class="hint-container details"><summary>为什么HashMap链表转红黑树的阈值为8呢？</summary><p>树化发生在table数组的长度大于64，且链表的长度大于8的时候。</p><blockquote><p>我记得源码的注释给了解答：</p></blockquote><ul><li>红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。</li><li>阈值为什么要选8呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为<code>0.00000006</code>。</li></ul><p>至于红黑树转回链表的阈值为什么是6，而不是8？是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费。</p></details><h3 id="_14、你对红黑树了解多少-为什么不用二叉树-平衡树呢" tabindex="-1"><a class="header-anchor" href="#_14、你对红黑树了解多少-为什么不用二叉树-平衡树呢" aria-hidden="true">#</a> 14、你对红黑树了解多少？为什么不用二叉树/平衡树呢？</h3><details class="hint-container details"><summary>你对红黑树了解多少？为什么不用二叉树/平衡树呢？</summary><p>红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点永远是黑色的；</li><li>所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；</li><li>每个红色节点的两个子节点一定都是黑色；</li><li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li></ol><blockquote><p>之所以不用二叉树：</p></blockquote><ul><li>二叉树不平衡，可能出现树枝不均匀情况，一边长一边短。</li><li>红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。</li></ul><blockquote><p>之所以不用平衡二叉树：</p></blockquote><ul><li>平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。</li></ul></details><h3 id="_15、红黑树怎么保持平衡的知道吗" tabindex="-1"><a class="header-anchor" href="#_15、红黑树怎么保持平衡的知道吗" aria-hidden="true">#</a> 15、红黑树怎么保持平衡的知道吗？</h3><details class="hint-container details"><summary>红黑树怎么保持平衡的知道吗？</summary><p>红黑树有两种方式保持平衡：<code>旋转</code>和<code>染色</code>。</p><ul><li>旋转：旋转分为两种，左旋和右旋</li></ul></details><h3 id="_16、hashmap怎么查找元素的呢" tabindex="-1"><a class="header-anchor" href="#_16、hashmap怎么查找元素的呢" aria-hidden="true">#</a> 16、HashMap怎么查找元素的呢？</h3><details class="hint-container details"><summary>HashMap怎么查找元素的呢？</summary><p>HashMap的查找就简单很多：</p><ol><li>使用扰动函数，获取新的哈希值</li><li>计算数组下标，获取节点</li><li>当前节点和key匹配，直接返回</li><li>否则，当前节点是否为树节点，查找红黑树</li><li>否则，遍历链表查找</li></ol></details><h3 id="_17、jdk1-8对hashmap主要做了哪些优化呢" tabindex="-1"><a class="header-anchor" href="#_17、jdk1-8对hashmap主要做了哪些优化呢" aria-hidden="true">#</a> 17、jdk1.8对HashMap主要做了哪些优化呢</h3><details class="hint-container details"><summary>jdk1.8对HashMap主要做了哪些优化呢？</summary><blockquote><p>jdk1.8 的HashMap主要有五点优化：</p></blockquote><ol><li><p><strong>数据结构</strong>：数组 + 链表改成了数组 + 链表或红黑树</p><ul><li><code>原因</code>：发生 hash 冲突，元素会存入链表，链表过长转为红黑树，将时间复杂度由<code>O(n)</code>降为<code>O(logn)</code></li></ul></li><li><p><strong>链表插入方式</strong>：链表的插入方式从头插法改成了尾插法</p><p>简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后。</p><ul><li><code>原因</code>：因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环。</li></ul></li><li><p><strong>扩容rehash</strong>：扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，不需要重新通过哈希函数计算位置，新的位置不变或索引 + 新增容量大小。</p><ul><li><code>原因：</code>提高扩容的效率，更快地扩容。</li></ul></li><li><p><strong>扩容时机</strong>：在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；</p></li><li><p><strong>散列函数</strong>：1.7 做了四次移位和四次异或，jdk1.8只做一次。</p><ul><li><code>原因</code>：做 4 次的话，边际效用也不大，改为一次，提升效率。</li></ul></li></ol></details><h3 id="_18、hashmap-常见的遍历方式" tabindex="-1"><a class="header-anchor" href="#_18、hashmap-常见的遍历方式" aria-hidden="true">#</a> 18、HashMap 常见的遍历方式</h3><details class="hint-container details"><summary>HashMap 常见的遍历方式？</summary><p>核心就是拿到entrySet / keySet，所有遍历都是基于这个，如lambda、stream流</p><ol><li><p><strong>使用 <code>entrySet()</code> 遍历：</strong></p><ul><li>通过 <code>entrySet()</code> 方法获取键值对的集合 <code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code>。</li><li>遍历每个键值对，使用 <code>getKey()</code> 和 <code>getValue()</code> 获取键和值。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 假设 map 已经有键值对数据</span>

<span class="token comment">// 遍历 entrySet</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">K</span> key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">V</span> value <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理 key 和 value</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用 <code>keySet()</code> 遍历键集合：</strong></p><ul><li>通过 <code>keySet()</code> 方法获取键的集合 <code>Set&lt;K&gt;</code>。</li><li>遍历每个键，通过键获取对应的值。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 假设 map 已经有键值对数据</span>

<span class="token comment">// 遍历 keySet</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">K</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">V</span> value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理 key 和 value</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用迭代器遍历：</strong></p><ul><li>通过 <code>entrySet()</code> 方法获取键值对的集合，再通过迭代器进行遍历。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 假设 map 已经有键值对数据</span>

<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">K</span> key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">V</span> value <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理 key 和 value</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></details><h3 id="_19、hashmap可以按照key来排序吗-如果不可以-有没有可以的实现" tabindex="-1"><a class="header-anchor" href="#_19、hashmap可以按照key来排序吗-如果不可以-有没有可以的实现" aria-hidden="true">#</a> 19、hashmap可以按照key来排序吗？如果不可以，有没有可以的实现？</h3><details class="hint-container details"><summary>hashmap可以按照key来排序吗？如果不可以，有没有可以的实现？</summary><p>HashMap是无序的，根据 hash 值随机插入。因此不能直接按照键来排序。如果想使用有序的Map，可以使用LinkedHashMap 或者 TreeMap。</p><ol><li><p><strong>TreeMap</strong>： <code>TreeMap</code> 是基于红黑树实现的，它会对键进行排序存储，因此可以按照键的自然顺序或者自定义的比较器来排序。示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 添加键值对</span>
<span class="token comment">//...</span>

<span class="token comment">// 遍历按键排序后的结果</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">K</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">V</span> value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理 key 和 value</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>LinkedHashMap</strong>：<code>LinkedHashMap</code> 保留了元素插入的顺序，因此按照插入的顺序可以遍历键值对。示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 添加键值对</span>
<span class="token comment">//...</span>

<span class="token comment">// 遍历按插入顺序的结果</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">K</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">V</span> value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 处理 key 和 value</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></details><h3 id="_20、hashmap-和-hashset-区别" tabindex="-1"><a class="header-anchor" href="#_20、hashmap-和-hashset-区别" aria-hidden="true">#</a> 20、HashMap 和 HashSet 区别</h3><details class="hint-container details"><summary>详情</summary><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的</p><p>相同点：它们都是基于哈希表的实现，并且具有快速查找、插入和删除元素的特性。</p><p>区别：</p><ol><li><p><strong>实现接口</strong>：<code>HashMap</code>实现了 <code>Map</code> 接口，<code>HashSet</code>是<code>Collection</code>接口下面的<code>Set</code>接口的子实现类</p></li><li><p><strong>内部数据结构：</strong></p><ul><li><code>HashMap</code> 是基于键值对的存储结构，使用键来唯一标识每个值，并通过哈希表实现，它允许键和值都可以为 <code>null</code>，但只能有一个 <code>null</code> 键。每个键值对都是由键和值组成的。</li><li><code>HashSet</code> 是基于哈希表的存储结构，它是基于 <code>HashMap</code> 实现的，只存储对象的唯一值，不允许重复，并且允许一个 <code>null</code> 元素。</li></ul></li><li><p><strong>存储方式和特性：</strong></p><ul><li><code>HashMap</code> 存储键值对，通过键来获取值，可以根据键来查询、删除、更新对应的值。</li><li><code>HashSet</code> 存储唯一的元素集合，不能包含重复元素。它可以用来检查某个元素是否存在，但不提供像 <code>HashMap</code> 那样的键值对映射关系。</li></ul></li><li><p><strong>使用场景：</strong></p><ul><li><code>HashMap</code> 通常用于需要存储键值对且需要根据键快速检索值的情况，比如存储缓存、数据库中的数据等。</li><li><code>HashSet</code> 适用于需要存储唯一元素集合且不需要键值对映射关系的情况，比如去重、集合运算等。</li></ul></li></ol></details><h3 id="_21、hashmap-和-treemap-区别" tabindex="-1"><a class="header-anchor" href="#_21、hashmap-和-treemap-区别" aria-hidden="true">#</a> 21、HashMap 和 TreeMap 区别</h3><details class="hint-container details"><summary>HashMap 和 TreeMap 区别？</summary><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，<code>HashMap</code> 和 <code>TreeMap</code> 是 Java 中的两种不同的 Map 实现，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p><code>HashMap</code> 和 <code>TreeMap</code> 是 Java 中的两种不同的 Map 实现，它们之间有以下区别：</p><ol><li><p><strong>内部数据结构：</strong></p><ul><li><code>HashMap</code> 是基于哈希表的实现，使用哈希表存储键值对，它通过键的哈希码来快速定位存储位置，具有 O(1) 的常数时间复杂度进行插入、删除和查找操作。</li><li><code>TreeMap</code> 是基于红黑树的实现，它是有序的键值对集合，根据键的自然顺序或者自定义的比较器进行排序。由于使用红黑树存储，它具有 O(log n) 的时间复杂度。</li></ul></li><li><p><strong>存储顺序：</strong></p><ul><li><code>HashMap</code> 不保证元素的顺序，它是无序的。</li><li><code>TreeMap</code> 会根据键的顺序进行排序存储，因此它是有序的。</li></ul></li><li><p><strong>性能和用途：</strong></p><ul><li><code>HashMap</code> 适用于需要快速查找、插入和删除键值对，并不需要保持顺序的情况。它在大多数情况下提供了更好的性能。</li><li><code>TreeMap</code> 适用于需要按键排序的情况，它提供了按键排序的有序映射。虽然它的性能相对较慢，但它提供了有序性和额外的方法来处理有序映射。</li></ul></li><li><p><strong>null 键和排序：</strong></p><ul><li><code>HashMap</code> 允许一个 <code>null</code> 键和多个 <code>null</code> 值。</li><li><code>TreeMap</code> 不允许 <code>null</code> 键，但允许 <code>null</code> 值。</li></ul></li></ol><p>综上所述，<code>HashMap</code> 和 <code>TreeMap</code> 在内部实现、存储顺序、性能和适用场景等方面存在明显差异，选择使用取决于具体的需求和情况。如果需要快速的插入、删除和查找，并且不需要顺序，则 <code>HashMap</code> 更合适；如果需要有序的键值对集合，就需要使用 <code>TreeMap</code>。</p></details><h3 id="_22、hashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_22、hashmap-和-hashtable-的区别" aria-hidden="true">#</a> 22、HashMap 和 Hashtable 的区别</h3><details class="hint-container details"><summary>HashMap 和 Hashtable 的区别？</summary><p><code>HashMap</code> 和 <code>Hashtable</code> 是 Java 中的两种不同的 Map 实现，都实现了Map接口，它们有一些区别：</p><ol><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</p><ol><li><code>HashMap</code> 的底层是基于数组和链表/红黑树的组合实现的。它使用哈希表存储数据，通过键的哈希码来确定存储位置，当发生哈希冲突时，使用链表或红黑树来解决冲突。</li><li><code>Hashtable</code> 也是基于数组和链表实现的。它使用哈希表存储数据，同样通过哈希码来确定存储位置，但是在解决哈希冲突时，使用的是链表，没有红黑树优化。</li></ol></li><li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong></p><ol><li>创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li><li>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</li></ol></li><li><p><strong>存储数据null 键值：</strong></p><ul><li><code>HashMap</code> 允许有一个 <code>null</code> 键和多个 <code>null</code> 值，即键和值都可以为 <code>null</code>。</li><li><code>Hashtable</code> 不允许键或值为 <code>null</code>，如果尝试将 <code>null</code> 作为键或值放入 <code>Hashtable</code>，会抛出 <code>NullPointerException</code>。</li></ul></li><li><p><strong>线程安全性：</strong></p><ul><li><code>HashMap</code> 是非线程安全的类，不提供线程同步，多个线程同时访问 <code>HashMap</code> 可能导致不确定的结果。在多线程环境下使用时，需要额外的同步措施来确保线程安全。</li><li><code>Hashtable</code> 是线程安全的类，所有的方法都是同步的。在多线程环境下，<code>Hashtable</code> 的线程安全性能会带来额外的开销，可能影响性能。</li></ul></li><li><p><strong>继承关系：</strong></p><ul><li><code>HashMap</code> 继承自 <code>AbstractMap</code> 类，实现了 <code>Map</code> 接口。</li><li><code>Hashtable</code> 继承自 <code>Dictionary</code> 类（已经被淘汰，不推荐使用），实现了 <code>Map</code> 接口和 <code>Hashtable</code> 接口。</li></ul></li><li><p><strong>迭代顺序：</strong></p><ul><li><code>HashMap</code> 不保证元素的顺序，它是无序的，遍历时不能保证顺序与插入顺序相同。</li><li><code>Hashtable</code> 也不保证元素的顺序，同样是无序的。</li></ul></li><li><p><strong>性能：</strong></p><ul><li>由于 <code>Hashtable</code> 的方法都是同步的，因此在多线程环境下提供了线程安全性，但性能相对较低。</li><li><code>HashMap</code> 不提供线程安全性，但在单线程环境下具有较好的性能。</li></ul></li></ol><p>综上所述，主要区别在于线程安全性、对 <code>null</code> 键值的支持、迭代顺序和性能。通常情况下，在单线程环境下，使用 <code>HashMap</code> 更常见，而在多线程环境下，如果需要线程安全的操作，可以考虑使用 <code>Hashtable</code> 或者 <code>ConcurrentHashMap</code>。</p></details><h3 id="_23、hashmap为什么线程不安全" tabindex="-1"><a class="header-anchor" href="#_23、hashmap为什么线程不安全" aria-hidden="true">#</a> 23、HashMap为什么线程不安全？</h3><details class="hint-container details"><summary>HashMap为什么线程不安全？</summary><p>JDK1.7 及之前版本，在多线程环境下，<code>HashMap</code> 扩容时会造成死循环和数据丢失的问题。</p><p>数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。</p><p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p><p>举个例子：</p><ul><li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li><li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li><li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li></ul><p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p><ol><li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li><li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li><li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li><li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li></ol></details><h3 id="_24、有什么办法能解决hashmap线程不安全的问题呢" tabindex="-1"><a class="header-anchor" href="#_24、有什么办法能解决hashmap线程不安全的问题呢" aria-hidden="true">#</a> 24、有什么办法能解决HashMap线程不安全的问题呢</h3><details class="hint-container details"><summary>有什么办法能解决HashMap线程不安全的问题呢？</summary><p>Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map。</p><ul><li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大；</li><li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li><li>ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。</li></ul></details><h3 id="_25、快速失败-fail-fast-和安全失败-fail-safe" tabindex="-1"><a class="header-anchor" href="#_25、快速失败-fail-fast-和安全失败-fail-safe" aria-hidden="true">#</a> 25、快速失败(fail-fast)和安全失败(fail-safe)</h3><details class="hint-container details"><summary>快速失败(fail-fast)和安全失败(fail-safe)了解吗？</summary><blockquote><p>快速失败（fail—fast）：快速失败是Java集合的一种错误检测机制</p></blockquote><ul><li>在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li><li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <code>modCount</code> 变量。集合在被遍历期间如果内容发生变化，就会改变<code>modCount</code>的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li><li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。</li></ul><blockquote><p>安全失败（fail—safe）:</p></blockquote><ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li><li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li><li>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类。</li></ul></details><h3 id="_26、并发修改异常是什么-什么情况下会发生" tabindex="-1"><a class="header-anchor" href="#_26、并发修改异常是什么-什么情况下会发生" aria-hidden="true">#</a> 26、并发修改异常是什么？什么情况下会发生</h3><details class="hint-container details"><summary>并发修改异常是什么？什么情况下会发生？</summary><p>并发修改异常（<code>ConcurrentModificationException</code>）是 Java 集合框架中的一种异常，通常在使用迭代器遍历集合时，发生了对集合结构的并发修改操作时抛出。</p><blockquote><p>情况如下：</p></blockquote><ol><li><p><strong>并发修改：</strong> 当使用迭代器遍历集合的过程中，通过集合的方法（如 <code>add()</code>、<code>remove()</code>）或者迭代器的 <code>remove()</code> 方法修改了集合的结构时，即在迭代器遍历过程中进行了集合的结构性修改。</p></li><li><p><strong>遍历冲突：</strong> 在迭代器遍历过程中，如果有其他线程对集合进行了修改（结构性修改），导致迭代器的“修改次数”与集合实际的“修改次数”不一致。</p></li></ol><p>这种情况下，迭代器会检测到集合结构的修改，与自己遍历过程中所记录的修改次数不一致，就会抛出 <code>ConcurrentModificationException</code> 异常，以保证遍历过程中的一致性和防止数据不一致性。</p><blockquote><p>为什么要维护：</p></blockquote><p>维护“修改次数”（modification count）的计数器主要是为了在迭代器遍历集合时进行快速失败（fail-fast）机制的实现。</p><ul><li>这个计数器实际上是在 Java 集合中的一种内部结构，用于记录集合被修改的次数。在创建迭代器时，会记录当前集合的修改次数值。在迭代器进行遍历时，如果发现迭代器所记录的修改次数与集合实际的修改次数不一致，就会抛出 <code>ConcurrentModificationException</code> 异常，即迭代器快速失败，以保证遍历过程中的一致性和避免潜在的并发修改引起的数据不一致性。</li><li>这样做的目的是确保迭代器在遍历时，能够及时发现集合结构的修改，避免继续遍历导致数据不一致或不可预测的结果。这种快速失败机制提供了一种机制来尽早检测并发修改，以确保程序的健壮性和可靠性。</li></ul><blockquote><p>解决方法包括：</p></blockquote><ul><li>避免在迭代器遍历期间对集合进行结构性修改。</li><li>使用迭代器自身的 <code>remove()</code> 方法进行删除操作。</li><li>在多线程环境下，使用线程安全的集合（如 <code>ConcurrentHashMap</code>）或者使用同步机制来避免并发修改异常的发生。</li></ul></details><h3 id="_27、concurrenthashmap的底层实现原理是什么" tabindex="-1"><a class="header-anchor" href="#_27、concurrenthashmap的底层实现原理是什么" aria-hidden="true">#</a> 27、ConcurrentHashMap的底层实现原理是什么</h3><details class="hint-container details"><summary>ConcurrentHashMap的底层实现原理是什么？</summary><blockquote><p>ConcurrentHashmap线程安全在jdk1.7版本是基于<code>分段锁</code>实现，在jdk1.8是基于<code>CAS+synchronized</code>实现。</p></blockquote><ul><li>1.7分段锁： <ul><li>从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。</li><li>实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。</li><li><strong>put流程</strong>：整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已，后面的流程，就和HashMap基本上是一样的。 <ol><li>计算hash，定位到segment，segment如果是空就先初始化</li><li>使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功</li><li>遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作</li></ol></li><li><strong>get流程</strong>：get也很简单，key通过hash定位到segment，再遍历链表定位到具体的元素上，需要注意的是value是volatile的，所以get是不需要加锁的。</li></ul></li><li>1.8cas+synchronized： <ul><li>jdk1.8实现线程安全不是在数据结构上下功夫，它的数据结构和HashMap是一样的，数组+链表+红黑树。它实现线程安全的关键点在于put流程。</li><li><strong>put流程</strong>： <ol><li>首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化</li><li>如果当前数组位置是空则直接通过CAS自旋写入数据</li><li>如果hash==MOVED，说明需要扩容，执行扩容</li><li>如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树</li></ol></li><li><strong>get查询</strong>：get很简单，和HashMap基本相同，通过key计算位置，table该位置key相同就返回，如果是红黑树按照红黑树获取，否则就遍历链表获取。</li></ul></li></ul><blockquote><p>区别：</p></blockquote><ul><li><strong>底层实现/Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li><li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li><li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul></details><h3 id="_28、concurrenthashmap-为什么-key-和-value可以为null吗" tabindex="-1"><a class="header-anchor" href="#_28、concurrenthashmap-为什么-key-和-value可以为null吗" aria-hidden="true">#</a> 28、ConcurrentHashMap 为什么 key 和 value可以为null吗</h3><details class="hint-container details"><summary>ConcurrentHashMap 为什么 key 和 value可以为null吗？</summary><p>完善hashmap的key value为空，避免二义性</p><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p></details><h3 id="_29、concurrenthashmap能保证复合性操作吗" tabindex="-1"><a class="header-anchor" href="#_29、concurrenthashmap能保证复合性操作吗" aria-hidden="true">#</a> 29、ConcurrentHashMap能保证复合性操作吗</h3><details class="hint-container details"><summary>ConcurrentHashMap能保证复合性操作吗？</summary><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p><p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p><blockquote><p>那如何保证 <code>ConcurrentHashMap</code> 复合操作的原子性呢？</p></blockquote><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p></details><h3 id="_30、linkedhashmap-底层实现" tabindex="-1"><a class="header-anchor" href="#_30、linkedhashmap-底层实现" aria-hidden="true">#</a> 30、LinkedHashMap 底层实现</h3><details class="hint-container details"><summary>LinkedHashMap 底层实现？</summary><p><code>LinkedHashMap</code> 是继承自 <code>HashMap</code> 的一个类，在 <code>HashMap</code> 的基础上增加了按照插入顺序或者访问顺序（LRU）来维护键值对的顺序。</p><ul><li>底层实现结构上，<code>LinkedHashMap</code> 与 <code>HashMap</code> 类似，仍然使用哈希表（数组 + 链表 / 红黑树）来存储键值对，只是在 <code>LinkedHashMap</code> 中增加了一个双向链表来维护顺序。 <ul><li>它通过一个双向链表来维护键值对的插入顺序或者访问顺序（根据构造函数的不同而定）。这个链表使得 <code>LinkedHashMap</code> 能够保持键值对的迭代顺序与插入顺序或访问顺序一致。</li><li>每个 <code>LinkedHashMap</code> 的 Entry（即键值对）不仅保存了键值对信息，还包含了两个指针用于维护双向链表的结构。一个指针指向链表的前一个元素，另一个指针指向链表的后一个元素，这样就构成了一个双向链表的结构。</li><li>基于这种结构，在 <code>LinkedHashMap</code> 中，插入顺序或者访问顺序的维护是比较高效的，因为它只需要对双向链表进行简单的指针调整，而不需要对哈希表进行重新的散列或重排。</li></ul></li></ul><p>总体来说，<code>LinkedHashMap</code> 在保留 <code>HashMap</code> 的查询性能的同时，通过双向链表的结构保持了键值对的顺序，是一个可以按照插入顺序或者访问顺序遍历的有序 Map。</p></details><h3 id="_31、linkedhashmap和-hashmap-有什么区别" tabindex="-1"><a class="header-anchor" href="#_31、linkedhashmap和-hashmap-有什么区别" aria-hidden="true">#</a> 31、LinkedHashMap和 HashMap 有什么区别</h3><details class="hint-container details"><summary>LinkedHashMap和 HashMap 有什么区别?</summary><p>都是Map接口的子实现类</p><ol><li><strong>底层实现结构：</strong><ul><li><strong>HashMap：</strong> 使用哈希表（数组 + 链表 / 红黑树）来存储键值对。它通过哈希码计算来确定元素的存储位置，具有较快的添加、查询和删除性能。</li><li><strong>LinkedHashMap：</strong> 在 <code>HashMap</code> 的基础上，增加了一个双向链表来维护元素的顺序。这个链表使得 <code>LinkedHashMap</code> 能够保持插入顺序或者访问顺序，但在维护顺序方面会带来额外的开销。</li></ul></li><li><strong>元素顺序的处理/可以记录插入顺序：</strong><ul><li><strong>HashMap：</strong> 在 <code>HashMap</code> 中，元素的存储顺序是不确定的，不受添加顺序或者访问顺序影响。元素在哈希表中的存储位置是根据其哈希码计算得到的，因此在遍历时无法保证元素的顺序性。</li><li><strong>LinkedHashMap：</strong> 相比之下，<code>LinkedHashMap</code> 会按照插入顺序或访问顺序（可选择）来维护元素的顺序。插入顺序表示元素被插入的顺序，而访问顺序表示元素最近被访问的顺序。这意味着遍历 <code>LinkedHashMap</code> 可以按照插入顺序或者最近访问的顺序进行。</li></ul></li><li><strong>性能方面的考量：</strong><ul><li><strong>HashMap：</strong> 由于不需要额外维护顺序，因此在一般情况下，在添加、查询和删除方面可能会略微快于 <code>LinkedHashMap</code>。</li><li><strong>LinkedHashMap：</strong> 在维护顺序的情况下，可能在性能上略微慢于 <code>HashMap</code>，但提供了按照插入顺序或访问顺序访问键值对的能力。</li></ul></li><li><strong>初始容量大小和每次扩充容量大小的不同：</strong><ul><li>两者在初始容量大小和每次扩充容量大小上没有本质的不同，都有默认的初始容量和加载因子（即扩容时的阈值）。</li></ul></li><li><strong>线程安全性：</strong><ul><li><strong>HashMap 和 LinkedHashMap：</strong> 都不是线程安全的。在多线程环境中使用时，需要进行额外的同步措施。</li></ul></li></ol></details>`,92),l=[o];function p(c,i){return s(),n("div",null,l)}const u=a(t,[["render",p],["__file","java-collection.html.vue"]]);export{u as default};

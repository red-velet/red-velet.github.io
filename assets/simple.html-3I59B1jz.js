import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c as i,a as t}from"./app-qOaOTfkM.js";const r={},n=t('<h2 id="一、操作系统定义和作用" tabindex="-1"><a class="header-anchor" href="#一、操作系统定义和作用" aria-hidden="true">#</a> 一、操作系统定义和作用</h2><blockquote><p><strong>操作系统的定义</strong>：</p></blockquote><ol><li><strong>操作系统是系统资源的管理者</strong>：操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；</li><li><strong>为上层提供方便易用的服务</strong>：以提供给用户和其他软件方便的接口和环境；</li><li><strong>是最接近硬件的软件</strong>：它是计算机系统中最基本的系统软件。</li></ol><blockquote><p><strong>操作系统的作用-系统资源的管理者</strong>：</p></blockquote><p>在打开QQ并进行视频聊天的过程中，操作系统发挥了以下作用：</p><ol><li><p><strong>处理机管理</strong>：操作系统负责管理CPU资源，确保每个程序都有机会运行。在打开QQ时，操作系统会为其分配CPU时间片，使其可以在CPU上执行。</p></li><li><p><strong>存储器管理</strong>：当双击打开QQ.exe时，操作系统将负责将QQ程序及其相关数据加载到内存中，以便CPU可以访问和执行。这涉及到内存的分配和管理。</p></li><li><p><strong>文件管理</strong>：需要通过逐层打开文件夹来找到QQ.exe的位置。这是通过操作系统提供的文件管理功能来实现的。</p></li><li><p><strong>设备管理</strong>：在视频聊天过程中，操作系统需要协调摄像头设备的访问，以确保QQ程序可以获取摄像头的图像数据。</p></li></ol><blockquote><p><strong>操作系统的作用</strong>-为上层提供方便易用的服务：</p></blockquote><p>操作系统为上层用户屏蔽了底层硬件的直接交互，因为硬件只认识0和1，是提供二进制交流的，如果我们直接和硬件交换，那是十分繁琐的，就比如我们想和对方发一条微信，那还需要自己将文字转为二进制再发送，而操作系统解决了这个问题。</p><p>操作系统运用了封装思想：把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</p><p>操作系统提供了以下易用的接口：</p><ol><li><strong>图形化用户接口 (Graphical User Interface, GUI)</strong>：GUI是一种用户界面，它使用图形元素（如图标、按钮、窗口等）以及鼠标和键盘等输入设备，使用户可以通过直观的操作来控制计算机。例如，Windows、macOS和Linux等操作系统都提供了图形化界面，使用户可以通过点击图标、拖拽文件等来执行操作。</li><li><strong>命令行界面 (Command Line Interface, CLI)</strong>：CLI允许用户通过键入命令来与计算机进行交互。用户可以在命令提示符下输入指令，以执行各种任务。例如，在Windows系统中，用户可以使用命令行来执行一些操作，如复制、移动文件等。 <ul><li>联机（一个指令）、脱机（一堆指令）</li></ul></li><li><strong>应用程序接口 (Application Programming Interface, API)</strong>：API是一组定义了软件组件如何互相交互的规范。它为开发人员提供了一种方式来利用系统功能，进行系统调用来使用程序接口，以便于开发软件和应用程序。</li></ol><blockquote><p><strong>操作系统的作用</strong>-是最接近硬件的软件：</p></blockquote><p>操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。</p><h2 id="二、操作系统的特征" tabindex="-1"><a class="header-anchor" href="#二、操作系统的特征" aria-hidden="true">#</a> 二、操作系统的特征</h2><blockquote><p>四大特征：<strong>并发、共享</strong>、虚拟、异步</p></blockquote><h3 id="_1、并发" tabindex="-1"><a class="header-anchor" href="#_1、并发" aria-hidden="true">#</a> 1、并发</h3><blockquote><p>并发和并行：</p></blockquote><ul><li>并发：两个或多个事件在同一时间间隔内发生，这些事件在宏观上是同时发生的，在微观上是交替发生的， 操作系统的并发性指系统中同时存在着多个运行的程序</li><li>并行：两个或多个事件在同一时刻发生一个单核（CPU）同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</li></ul><p>操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的在如今的计算机中，一般都是多核cpu的，即在同一时刻可以并行执行多个程序，比如我的计算机是8核的，我的计算机可以在同一时刻并行执行8个程序，但是事实上我们计算机执行的程序并不止8个，因此并发技术是必须存在的，并发性必不可少</p><h3 id="_2、共享" tabindex="-1"><a class="header-anchor" href="#_2、共享" aria-hidden="true">#</a> 2、共享</h3><blockquote><p>概念：</p></blockquote><p>资源共享即共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用</p><blockquote><p>互斥共享和同时共享：</p></blockquote><ol><li>互斥共享：计算机中的某个资源在一段时间内只能允许一个进程访问，别的进程没有使用权 <ul><li>举个例子：比如QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程</li><li>临界资源（独占资源）：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享</li></ul></li><li>同时共享：计算机中的某个资源在一段时间内可以同时允许多个进程访问 <ul><li>举个例子：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行访问磁盘的，只是时间太短，cpu处理速度太快，我们感觉不到。</li><li>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”这里的同时指在宏观上是同时的，在微观上是交替进行访问的，只是cpu处理速度很快，我们感觉不到，在宏观上感觉是在同时进行</li><li>注意：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</li></ul></li></ol><h3 id="_3、虚拟" tabindex="-1"><a class="header-anchor" href="#_3、虚拟" aria-hidden="true">#</a> 3、虚拟</h3><blockquote><p>虚拟：是把一个物理上的实体变为若干逻辑上的对应物。</p></blockquote><ul><li><p>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</p></li><li><p>虚拟技术：用于实现虚拟的技术</p><ul><li>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</li><li>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</li><li>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的</li><li>操作系统的虚拟技术科归纳为： <ol><li>时分复用技术：如处理器的分时共享</li><li>空间复用技术：如虚拟存储器</li></ol></li></ul></li><li><p>多道程序设计：是指在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。</p><ul><li>多道程序技术运行的特征：多道、宏观上并行、微观上串行。</li></ul></li></ul><h3 id="_4、异步" tabindex="-1"><a class="header-anchor" href="#_4、异步" aria-hidden="true">#</a> 4、异步</h3><blockquote><p>异步的概念：</p></blockquote><ul><li>异步：多道程序环境允许多个程序并发执行，但由于资源有限，如cpu只有一个，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，它允许程序在执行过程中可以同时处理多个事件或请求，而不需要按照固定的顺序依次执行。 <ul><li>举个例子：假设你在使用一个网页浏览器，同时打开了多个标签页。每个标签页都可能在加载不同的网页内容，这些页面的加载可能需要不同的时间，因为网速可能会有差异或者网页内容复杂度不同。在这种情况下，操作系统可以利用异步性来处理这些请求。它可以同时发送多个请求给网络，而不是等待一个页面完全加载后才去加载下一个。当某个页面的内容准备好后，浏览器就可以将其显示在对应的标签页上，而无需等待其他页面。这种异步的方式使得用户可以在不阻塞其他操作的情况下浏览多个网页，并提高了浏览器的响应速度。</li></ul></li><li>在程序设计中，异步性也经常用于处理诸如用户输入、网络请求、文件读写等涉及到可能有较长延迟的操作。通过异步处理，程序可以在等待某些操作完成的同时继续执行其他任务，从而提高了程序的效率和响应性。</li></ul><h2 id="三、操作系统的发展和分类" tabindex="-1"><a class="header-anchor" href="#三、操作系统的发展和分类" aria-hidden="true">#</a> 三、操作系统的发展和分类</h2><h2 id="四、操作系统的运行机制" tabindex="-1"><a class="header-anchor" href="#四、操作系统的运行机制" aria-hidden="true">#</a> 四、操作系统的运行机制</h2><h3 id="_1、操作系统运行原理" tabindex="-1"><a class="header-anchor" href="#_1、操作系统运行原理" aria-hidden="true">#</a> 1、操作系统运行原理</h3><blockquote><p><strong>程序在操作系统运行的过程</strong>：</p></blockquote><ul><li>运行过程：Java代码 —-javac—-–&gt; 编译字节码 —-jvm—-–&gt; 转换为机器码（机器指令-二进制） —cpu—-–&gt; 执行指令</li></ul><blockquote><p><strong>程序分类</strong>：</p></blockquote><ul><li><strong>内核程序</strong>：内核程序是操作系统的核心组件，负责管理系统资源、提供各种服务以及控制硬件。它通常运行在特权模式下，可以直接访问系统的底层硬件。 <ul><li>微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”由很多内核程序组成了**“操作系统内核”<strong>，或简称</strong>“内核(Kernel)**</li></ul></li><li><strong>用户程序</strong>：用户程序是由用户编写或安装的应用程序，它们运行在操作系统的用户模式下。用户程序不能直接访问底层硬件资源，而是通过操作系统提供的接口来实现各种功能 <ul><li>我们普通程序员写的程序就是“应用程序”</li></ul></li></ul><blockquote><p><strong>特权指令和非特权指令</strong>：</p></blockquote><p>操作系统作为内核的管理者，有时会让CPU执行一些<code>特殊的指令 - “特权指令”</code>，如：内存清零指令。这些指令的运行可能会对其他程序造成很大的影响，可能影响其他程序的运行，所以这样的指令只允许管理者执行 - 内核执行。<br> 只允许“管理者”一一即操作系统内核来使用。</p><ul><li>特权指令：只允许操作系统内核执行的指令。这些指令通常涉及到对硬件资源的直接访问，或者对系统进行一些敏感的操作，如修改特定的寄存器、改变内存映射等。由于这些指令可能对系统的稳定性和安全性产生影响，因此只有操作系统内核拥有足够的权限来执行它们。</li><li>非特权指令：普通用户程序可以执行的指令。这些指令只能在用户模式下执行，不能直接访问底层硬件资源，而是通过系统调用等方式向操作系统发起请求，由操作系统代表用户程序执行需要的操作。大部分的应用程序代码都属于非特权指令。</li></ul><p>在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。</p><blockquote><p><strong>内核态和用户态</strong>：</p></blockquote><p>CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序o应用程序？</p><p>为了防止普通程序执行特权指令干扰操作系统，比如黑客给我们的程序发送一条特权指令（清除整个电脑文件），这样是非常危险了，所以为了解决这种问题，分为内核态和用户态，具体实现是：CPU中有一个寄存器叫<code>程序状态字寄存器(PSW)</code>,其中有个二进制位，<strong>1表示“内核态”</strong>，<strong>0表示“用户态”</strong></p><ul><li><p><strong>内核态/核心态/管态</strong>：处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</p></li><li><p><strong>用户态</strong>：处于用户态时，说明此时正在运行修是应用程序，此时只能执行非特权指令</p></li></ul><blockquote><p><strong>内核态和用户态切换</strong>：</p></blockquote><ul><li><mark>内核态 —&gt; 用户态</mark>：内核程序主动让出 CPU 控制权，并执行一条修改程序状态字寄存器(PSW)的特权指令来实现。</li><li><mark>用户态 —&gt; 内核态</mark>：由中断信号引起的，通过硬件自动完成。当发生需要内核处理的事件或者用户程序请求服务时，CPU 会产生一个中断信号，将控制权转交给操作系统内核。 <ul><li>中断信号：需要操作系统介入的时候会产生，如用户态执行特权指令。</li></ul></li></ul><h3 id="_2、中断和异常" tabindex="-1"><a class="header-anchor" href="#_2、中断和异常" aria-hidden="true">#</a> 2、中断和异常</h3><blockquote><p><strong>中断的作用</strong>：</p></blockquote><ul><li><p><strong>为什么要有中断</strong>：如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序</p></li><li><p><strong>作用</strong>：<code>“中断”</code>会使CPU由用户态变为内核态，使操作系统重新夺回对CPU</p></li><li><p><strong>“中断”是让操作系统内核夺回CPU使用权的唯一途径</strong></p></li></ul><blockquote><p><strong>中断的类型</strong>：</p></blockquote><ul><li><strong>内中断/异常</strong>：与当前执行的指令有关，中断信号来源于CPU的内部。 <ul><li>例子：黑客从应用程序中参入特权指令，CPU检测到<strong>用户态执行特权指令</strong> - 触发中断</li></ul></li><li><strong>外中断</strong>：与当前执行的指令无关，中断信号来源于CPU的外部。 <ul><li>例子：有时候应用程序想请求操作系统内核的服务，此时会执行一条<strong>特殊的指令一一陷入指令</strong>，该指<br> 令会引发一个内部中断信号。 <ul><li>执行<code>“陷入指令” - 非特权指令</code>，意味着应用程序主动地将CPU控制权还给操作系统内核。</li><li><mark>“系统调用”就是通过陷入指令完成的</mark></li></ul></li><li>例子：时钟中断一一由时钟部件发来的中断信号 <ul><li>时钟部件会以固定的时间间隔（例如50毫秒）发送一个时钟中断信号给CPU。这个信号会打断当前正在执行的程序，将控制权交给操作系统内核。操作系统可以利用时钟中断来更新系统时间、调度进程、以及进行其他与时间相关的操作。</li><li>这个机制是实现并发操作的重要手段之一，使得操作系统可以在多个任务之间快速切换，从而实现多任务并发执行。</li></ul></li></ul></li></ul><blockquote><p><strong>中断的实现原理</strong>：</p></blockquote><ol><li><strong>中断信号的检测</strong>：当CPU检测到中断信号时，它会停止当前正在执行的程序，并且保存当前程序的状态，包括寄存器值和指令指针等信息。</li><li><strong>中断向量表的查询</strong>：CPU根据中断信号的类型，去查询一个被称作“中断向量表”的数据结构。这个表中包含了不同类型中断对应的中断处理程序在内存中的存放位置。</li><li><strong>中断处理程序的执行</strong>：根据中断向量表的结果，CPU会跳转到相应的中断处理程序所在的内存地址开始执行。这个中断处理程序会负责处理特定类型的中断事件。</li></ol><h3 id="_3、系统调用" tabindex="-1"><a class="header-anchor" href="#_3、系统调用" aria-hidden="true">#</a> 3、系统调用</h3><blockquote><p><strong>什么是系统调用</strong>：</p></blockquote><p>系统调用：程序请求获取操作系统提供的内核服务，可以理解为一种接口的调用/函数的调用。</p><blockquote><p><strong>系统调用（按功能分类）</strong>：</p></blockquote><ul><li>设备管理：设备的 请求/释放/启动</li><li>文件管理：文件的 读/写/创建/删除</li><li>进程控制：进程的 创建/撤销/阻塞/唤醒</li><li>进程通信：进程之间的 消息传递/信号传递</li><li>内存管理：内存的 分片/回收</li></ul><p>Linux系统调用：</p><p>Linux 操作系统提供了许多系统调用，用于向内核发出请求以执行特定的操作。以下是一些常见的 Linux 系统调用：</p><ol><li><p><strong>open()</strong>: 用于打开文件或创建文件。</p></li><li><p><strong>close()</strong>: 用于关闭一个打开的文件描述符。</p></li><li><p><strong>read()</strong>: 从文件描述符中读取数据。</p></li><li><p><strong>write()</strong>: 向文件描述符中写入数据。</p></li><li><p><strong>lseek()</strong>: 在文件中移动读写位置。</p></li><li><p><strong>fork()</strong>: 创建一个新的进程。</p></li><li><p><strong>exec()</strong>: 在当前进程中执行一个新程序。</p></li><li><p><strong>wait()</strong>: 等待子进程的终止。</p></li><li><p><strong>exit()</strong>: 终止当前进程。</p></li><li><p><strong>kill()</strong>: 发送一个信号给指定的进程。</p></li><li><p><strong>getpid()</strong>: 获取当前进程的 PID。</p></li><li><p><strong>getppid()</strong>: 获取当前进程的父进程的 PID。</p></li><li><p><strong>chdir()</strong>: 改变当前工作目录。</p></li><li><p><strong>mkdir()</strong>: 创建一个新的目录。</p></li><li><p><strong>rmdir()</strong>: 删除一个目录。</p></li><li><p><strong>stat()</strong>: 获取文件的信息。</p></li><li><p><strong>link()</strong>: 创建一个硬链接。</p></li><li><p><strong>unlink()</strong>: 删除一个文件或硬链接。</p></li><li><p><strong>symlink()</strong>: 创建一个符号链接。</p></li><li><p><strong>readlink()</strong>: 读取符号链接的目标路径。</p></li><li><p><strong>chmod()</strong>: 改变文件的权限。</p></li><li><p><strong>chown()</strong>: 改变文件的所有者。</p></li><li><p><strong>umask()</strong>: 设置文件创建时的默认权限掩码。</p></li><li><p><strong>pipe()</strong>: 创建一个管道。</p></li><li><p><strong>dup() / dup2()</strong>: 复制文件描述符。</p></li><li><p><strong>select() / poll() / epoll()</strong>: 用于 I/O 多路复用。</p></li><li><p><strong>socket() / bind() / listen() / accept()</strong>: 用于网络编程。</p></li></ol><p>这只是一部分常见的系统调用列表，实际上 Linux 提供了许多其他的系统调用，用于执行各种不同的任务。每个系统调用都有其特定的参数和返回值，用于实现不同的功能。</p><blockquote><p>系统调用的过程：</p></blockquote><p>系统调用是用户空间程序与内核空间之间进行通信的方式，使用户程序可以请求操作系统内核提供的服务。以下是系统调用的一般过程：</p><ol><li><p><strong>用户程序发起系统调用请求</strong>：<br> 用户程序通过调用库函数或者直接调用底层指令触发系统调用，比如C语言中的<code>syscall</code>函数或汇编中的<code>int 0x80</code>指令。</p></li><li><p><strong>从用户空间切换到内核空间</strong>：<br> 当系统调用被触发时，CPU会从用户模式切换到内核模式，以便用户程序可以执行特权操作。</p></li><li><p><strong>系统调用号识别</strong>：<br> 内核通过查看特定的寄存器或内存位置来确定用户请求的具体系统调用，这个值通常被称为系统调用号。</p></li><li><p><strong>参数传递</strong>：<br> 用户程序提供的参数会被传递给相应的系统调用处理程序。这些参数通常是通过寄存器或者栈传递给内核。</p></li><li><p><strong>内核执行系统调用</strong>：<br> 根据系统调用号和传递的参数，内核执行相应的操作，可能会涉及文件操作、进程管理、内存管理等。</p></li><li><p><strong>处理结果</strong>：<br> 内核执行完系统调用后，将结果返回到用户程序。结果通常通过寄存器或者特定的返回值传递给用户程序。</p></li><li><p><strong>从内核空间切换回用户空间</strong>：<br> 一旦系统调用处理完成，CPU会从内核模式切换回用户模式，用户程序可以继续执行。</p></li></ol><p>系统调用的过程允许用户程序安全地请求和使用操作系统内核提供的功能，同时保护了核心系统资源免受用户程序的直接访问。</p><h2 id="五、操作系统的体系结构" tabindex="-1"><a class="header-anchor" href="#五、操作系统的体系结构" aria-hidden="true">#</a> 五、操作系统的体系结构</h2>',68),s=[n];function p(e,g){return o(),i("div",null,s)}const c=l(r,[["render",p],["__file","simple.html.vue"]]);export{c as default};

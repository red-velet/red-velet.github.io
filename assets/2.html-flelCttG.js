import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,a as e}from"./app-KXX3jVXZ.js";const t={},o=e(`<h1 id="springboot拦截器中跨域失效的问题" tabindex="-1"><a class="header-anchor" href="#springboot拦截器中跨域失效的问题" aria-hidden="true">#</a> Springboot拦截器中跨域失效的问题</h1><h2 id="一、概述" tabindex="-1"><a class="header-anchor" href="#一、概述" aria-hidden="true">#</a> 一、概述</h2><h3 id="_1、具体场景" tabindex="-1"><a class="header-anchor" href="#_1、具体场景" aria-hidden="true">#</a> 1、具体场景</h3><blockquote><p>起因：</p></blockquote><ul><li>同一个接口，传入不同参数进行值的修改时，一个成功，另一个竟然失败，而且是<strong>跨域问题</strong></li><li>拦截器内的request参数调用getHeader方法时，获取不到前端设置的请求头，且浏览器显示有，但是后端输出后只有对于的key，而且key变成了<code>access-control-request-headers</code>的value</li></ul><blockquote><p>同一个接口不同参数错误展示：</p></blockquote><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240208163220924.png" alt="问题所在" tabindex="0" loading="lazy"><figcaption>问题所在</figcaption></figure><hr><blockquote><p>前端代码展示：</p></blockquote><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240208163749025.png" alt="前端代码" tabindex="0" loading="lazy"><figcaption>前端代码</figcaption></figure><hr><blockquote><p>浏览器请求头显示：</p></blockquote><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240208163815405.png" alt="浏览器显示" tabindex="0" loading="lazy"><figcaption>浏览器显示</figcaption></figure><hr><blockquote><p>后端获取request的header参数显示：</p></blockquote><p>全是null</p><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240208163930314.png" alt="控制台输出" tabindex="0" loading="lazy"><figcaption>控制台输出</figcaption></figure><blockquote><p>输出headers：</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{sec-fetch-mode=cors, referer=http://localhost:8080/, sec-fetch-site=cross-site, accept-language=zh-CN,zh;q=0.9, origin=http://localhost:8080, access-control-request-method=POST, accept=*/*, host=127.0.0.1:8099, access-control-request-headers=content-type,headeruserid,headerusertoken, connection=keep-alive, accept-encoding=gzip, deflate, br, user-agent=Mozilla/5.0 (Linux; Android 8.0.0; SM-G955U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36, sec-fetch-dest=empty}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><mark>变成了这样：</mark><code>access-control-request-headers=content-type,headeruserid,headerusertoken,</code></p><h3 id="_2、背景" tabindex="-1"><a class="header-anchor" href="#_2、背景" aria-hidden="true">#</a> 2、背景</h3><blockquote><p>前端：</p></blockquote><ol><li>是个uniapp项目，只会调，不会写，未设置跨域</li></ol><blockquote><p>后端：</p></blockquote><ol><li>spring boot项目</li><li>后端使用了<code>@CrossOrigin(origins = &quot;*&quot;)</code>，进行了简单的跨域设置</li><li>后端使用了拦截器进行拦截认证</li></ol><h3 id="_3、尝试改bug" tabindex="-1"><a class="header-anchor" href="#_3、尝试改bug" aria-hidden="true">#</a> 3、尝试改bug</h3><blockquote><p>发现前端的参数key，浏览器的参数key和后端的参数key大小写不一致：</p></blockquote><ul><li>修改了多次，且尝试了多次，无效果</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> userId <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">&quot;headerUserId&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> userId2 <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">&quot;HeaderUserId&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> userId3 <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Headeruserid&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240208164444696.png" alt="请求头效果" tabindex="0" loading="lazy"><figcaption>请求头效果</figcaption></figure><blockquote><p>尝试前端添加跨域：</p></blockquote><ul><li>统一设置跨域请求头，不会，只会小改</li><li>前端添加：Access-Control-Allow-Origin: *，无效，后面认真看才发现这是响应头，不是请求头，sha呗了</li></ul><blockquote><p>尝试后端的拦截器内添加@CrossOrigin(origins = &quot;*&quot;)、具体拦截方法内给响应参数添加响应头：</p></blockquote><ul><li>无效</li></ul><blockquote><p>重启前端项目、清除浏览器缓存、清除idea缓存、rebuild项目、重新运行：</p></blockquote><ul><li>无效</li></ul><h2 id="二、解决办法" tabindex="-1"><a class="header-anchor" href="#二、解决办法" aria-hidden="true">#</a> 二、解决办法</h2><blockquote><p>试了很多方法，慢慢的就定位了问题：</p></blockquote><ul><li>前端设置的请求头，浏览器可以接收，而且具体显示，那就不是前端的问题</li><li>后端试了很多次，拦截器获取的request header 的key和value还是null</li><li>如果取消拦截器，正常可以获取</li><li>那么可能是拦截器的问题，我的<code>@CrossOrigin(origins = &quot;*&quot;)</code>加在我的接口上，但是拦截器先执行，如果没用通过那么直接返回，根本到不了我的接口，也就到不了我接口上的<code>@CrossOrigin(origins = &quot;*&quot;)</code>，那就没用跨域了</li><li>但是我尝试再拦截器内的方法中手动给response响应添加跨域的代码，如下，但是还是无效</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 支持跨域</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Methods&quot;</span><span class="token punctuation">,</span>
<span class="token string">&quot;GET,POST,PUT,DELETE,OPTIONS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Credentials&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Content-Type,X-Token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Credentials&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>后面查询跨域的请求流程：</p></blockquote><p>跨域请求的流程通常分为两个阶段：预检请求（Preflight Request）和实际请求。以下是跨域请求的一般流程：</p><ol><li><p><strong>预检请求阶段</strong>：</p><ul><li>当浏览器检测到跨域请求时（例如请求方法不是简单请求方法、请求包含自定义的请求头等），会首先发送一个预检请求（OPTIONS请求）给服务器。</li><li>预检请求的目的是询问服务器是否允许实际请求中包含特定的自定义请求头字段和请求方法。</li><li>预检请求会包含一些特定的请求头，如<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>，用来询问服务器的允许范围。</li><li>服务器收到预检请求后，根据预检请求中的信息判断是否允许实际请求，然后发送适当的CORS响应头给浏览器。</li></ul></li><li><p><strong>实际请求阶段</strong>：</p><ul><li>如果预检请求得到了服务器的允许（即服务器返回了合适的CORS响应头），浏览器将发送实际的请求给服务器。</li><li>实际请求中包含了正常的请求方法（例如GET、POST、PUT等）、请求头和请求体等信息。</li><li>服务器收到实际请求后，会处理请求并返回相应的响应给浏览器。</li></ul></li></ol><p>下图展示了跨域请求的流程：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>     +-------------+         +-------------+
     |    Browser  |         |    Server   |
     +-------------+         +-------------+
           |                        |
           | 1. 发送预检请求        |
           +-----------------------&gt;|
           |                        |
           | 2. 接收预检响应        |
           |&lt;-----------------------+
           |                        |
           | 3. 发送实际请求        |
           +-----------------------&gt;|
           |                        |
           | 4. 接收实际响应        |
           |&lt;-----------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总的来说，跨域请求的流程就是浏览器先发送预检请求询问服务器是否允许跨域请求，然后根据服务器的响应决定是否发送实际请求。如果预检请求得到了服务器的允许，浏览器才会发送实际的请求。</p><blockquote><p>跟着这个OPTIONS请求查找：</p></blockquote><p>发现，只需要我把这个请求过滤掉即可，让它可以实际请求，使得我的自定义请求头 - 特定的请求头（access-control-request-headers=content-type,headeruserid,headerusertoken）可以接收到我就可以进行判断了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;OPTIONS&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>有效果，解决了。</mark></p><figure><img src="https://cloud.greennut.icu/blog/bug/image-20240208165819476.png" alt="解决方式" tabindex="0" loading="lazy"><figcaption>解决方式</figcaption></figure><h2 id="三、拓展" tabindex="-1"><a class="header-anchor" href="#三、拓展" aria-hidden="true">#</a> 三、拓展</h2><p>此处是使用的<code>@CrossOrigin(origins = &quot;*&quot;)</code>注解同时过滤掉<code>OPTIONS</code>请求实现了跨域</p><p><mark>还可以通过只设置一个跨域过滤器解决跨域问题</mark>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>cors<span class="token punctuation">.</span></span><span class="token class-name">CorsConfiguration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>cors<span class="token punctuation">.</span></span><span class="token class-name">UrlBasedCorsConfigurationSource</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span></span><span class="token class-name">CorsFilter</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 全局跨域配置类
 * 跨域请求的配置，允许所有来源的跨域请求
 * 
 * 跨域请求流程：
 * 1. 浏览器发送预检请求（OPTIONS请求）给服务器，询问是否允许实际请求中包含特定的自定义请求头字段和请求方法。
 * 2. 服务器根据预检请求的信息判断是否允许实际请求，发送适当的CORS响应头给浏览器。
 * 3. 如果预检请求得到了服务器的允许，浏览器发送实际的请求给服务器。
 * 4. 服务器收到实际请求后，处理请求并返回相应的响应给浏览器。
 * 
 * 注：当设置allowCredentials为true时，Access-Control-Allow-Origin响应头不能使用通配符&quot;*&quot;，而是必须明确指定允许的来源。
 * 
 * <span class="token keyword">@author</span> red-velvet
 * <span class="token keyword">@since</span> 2024/2/8
 */</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalCorsConfig</span> <span class="token punctuation">{</span>

    <span class="token doc-comment comment">/**
     * 配置CorsFilter
     * <span class="token keyword">@return</span> CorsFilter
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">CorsFilter</span> <span class="token function">corsFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建CorsConfiguration对象，配置CORS跨域规则</span>
        <span class="token class-name">CorsConfiguration</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorsConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 允许所有来源的跨域请求</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedOrigin</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 允许携带凭据（例如Cookie）</span>
        config<span class="token punctuation">.</span><span class="token function">setAllowCredentials</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 允许所有请求方法的跨域请求</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 允许所有请求头的跨域请求</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedHeader</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建UrlBasedCorsConfigurationSource对象，注册CORS配置</span>
        <span class="token class-name">UrlBasedCorsConfigurationSource</span> configSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlBasedCorsConfigurationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        configSource<span class="token punctuation">.</span><span class="token function">registerCorsConfiguration</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建CorsFilter对象，传入配置源</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CorsFilter</span><span class="token punctuation">(</span>configSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,55),i=[o];function p(c,l){return s(),a("div",null,i)}const d=n(t,[["render",p],["__file","2.html.vue"]]);export{d as default};

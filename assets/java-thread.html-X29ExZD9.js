import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,a as e}from"./app-qOaOTfkM.js";const t={},o=e(`<h1 id="java多线程" tabindex="-1"><a class="header-anchor" href="#java多线程" aria-hidden="true">#</a> Java多线程</h1><h2 id="一、基础" tabindex="-1"><a class="header-anchor" href="#一、基础" aria-hidden="true">#</a> 一、基础</h2><h3 id="_1、程序、进程、线程" tabindex="-1"><a class="header-anchor" href="#_1、程序、进程、线程" aria-hidden="true">#</a> 1、程序、进程、线程</h3><details class="hint-container details"><summary>说说你对程序、进程、线程的理解？</summary><blockquote><p>程序：</p></blockquote><ol><li>程序是一组指令集合，用来指示计算机执行特定任务的。它们以某种特定的编程语言编写，可以是像Python、Java、C++等高级语言，也可以是机器语言（二进制代码）。</li><li>程序是静态的，它们只是存在于磁盘或内存中，直到被执行。</li></ol><blockquote><p>进程：</p></blockquote><ol><li>进程是程序的动态存在的状态，是在计算机中执行时的实例。而且一个程序同时启动多个，也就是可以同时运行多个进程，每个进程都有自己的内存空间、资源（如CPU时间、文件句柄等）和状态，就和我们的Java中类与对象实例的关系，每个进程都被独立地管理，彼此之间不会干扰。</li><li>进程通常有两个任务：资源的分配和调度执行任务</li></ol><blockquote><p>线程：</p></blockquote><ol><li>线程和进程是紧密相关的，线程是进程的一部分，是进程内的一个独立执行单元，线程之间共享进程的内存资源，且承担调度执行的任务。而引入线程主要就是用于执行调度任务的，用来提高并发度（上下文切换开销少-地址、资源、内核的切换）。</li><li>因为线程共享进程的资源，共享相同的地址空间。这种共享使得线程之间的通信更加直接和高效，可以通过共享内存等方式进行数据传递，而无需复杂的进程间通信机制。</li></ol><hr><p>总体来说，举个不是很恰当的例子，程序就类似与我们的Java的类文件，它只有一个，是静态的文件，而进程就类似于对应类的对象实例，我们可以根据我们的类创建多个对象实例，同理一个程序可以启动多个进程，而线程是具体干活的，好比对象里面调用的方法，干不同的事情，调用不同的方法，他们之间的关系就类比与宅子-管家-仆人。</p></details><h3 id="_2、并行跟并发" tabindex="-1"><a class="header-anchor" href="#_2、并行跟并发" aria-hidden="true">#</a> 2、并行跟并发</h3><details class="hint-container details"><summary>说说并行跟并发有什么区别？</summary><ul><li>从操作系统的角度来看，线程是CPU分配的最小单位。 <ul><li>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</li><li>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的（这些程序在宏观上是同时发生的，在微观上是交替进行的）。</li></ul></li></ul></details><h3 id="_3、线程有几种创建方式" tabindex="-1"><a class="header-anchor" href="#_3、线程有几种创建方式" aria-hidden="true">#</a> 3、线程有几种创建方式</h3><details class="hint-container details"><summary>说说线程有几种创建方式？</summary><blockquote><p>Java中创建线程主要有四种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口、线程池。</p></blockquote><ul><li>继承Thread类，重写run()方法，调用start()方法启动线程</li><li>实现 Runnable 接口，重写run()方法</li><li>实现Callable接口，重写call()方法，这种方式一般和FutureTask搭配使用用于获取任务执行的返回值</li><li>通过线程池创建 - 线程工厂</li></ul></details><h3 id="_4、线程有哪些常用的调度方法" tabindex="-1"><a class="header-anchor" href="#_4、线程有哪些常用的调度方法" aria-hidden="true">#</a> 4、线程有哪些常用的调度方法</h3><details class="hint-container details"><summary>线程有哪些常用的调度方法？</summary><blockquote><p>在Object类中有一些函数可以用于线程的等待与通知：</p></blockquote><ul><li><strong>wait()</strong>：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ： <ul><li>（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；</li><li>（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</li></ul></li><li><strong>wait(long timeout)</strong> ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</li><li><strong>wait(long timeout、 int nanos)</strong>，其内部调用的是 wait(long timout）函数。</li></ul><p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p><ul><li><strong>notify()</strong> : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li><li><strong>notifyAll()</strong> ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li></ul><blockquote><p>Thread类也提供了一个方法用于等待的方法：</p></blockquote><ul><li><p><strong>等待其他线程执行完 - join()</strong>：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</p></li><li><p><strong>线程休眠 - sleep(long millis)</strong> :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</p></li><li><p><strong>让出优先权 - yield()</strong> ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</p></li></ul><p><strong>线程中断</strong> - Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><ul><li>void interrupt() ：中断线程，例如，当线程A运行时，线程B可以调用线程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志、 线程A实际并没有被中断， 会继续往下执行。</li><li>boolean isInterrupted() 方法： 检测当前线程是否被中断。</li><li>boolean interrupted() 方法： 检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li></ul></details><h3 id="_5、线程有几种状态-生命周期" tabindex="-1"><a class="header-anchor" href="#_5、线程有几种状态-生命周期" aria-hidden="true">#</a> 5、线程有几种状态/生命周期</h3><details class="hint-container details"><summary>线程有几种状态/生命周期？</summary><blockquote><p>在Java中，线程共有六种状态：</p></blockquote><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态：线程被创建，但还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”</td></tr><tr><td>BLOCKED</td><td>阻塞状态：表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td>超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的</td></tr><tr><td>TERMINATED</td><td>终止状态：表示当前线程已经执行完毕</td></tr></tbody></table><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换。</p></details><h3 id="_6、线程上下文切换" tabindex="-1"><a class="header-anchor" href="#_6、线程上下文切换" aria-hidden="true">#</a> 6、线程上下文切换</h3><details class="hint-container details"><summary>什么是线程上下文切换？</summary><p>线程上下文切换和线程并发工作的原理有关，并发其实是一个CPU来应付多个线程，为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p><ul><li>切换实际上设计到了操作系统的原子性指令 - 原语：<code>“关中断指令”</code>和<code>“开中断指令”</code>这两个特权指令实现原子性 <ul><li>当时间片用完cpu就会执行外部中断指令，<code>“中断”</code>会使CPU由用户态变为内核态，使操作系统重新夺回对CPU</li><li>例子：时钟中断一一由时钟部件发来的中断信号 <ul><li>时钟部件会以固定的时间间隔（例如50毫秒）发送一个时钟中断信号给CPU。这个信号会打断当前正在执行的程序，将控制权交给操作系统内核。操作系统可以利用时钟中断来更新系统时间、调度进程、以及进行其他与时间相关的操作。</li><li>这个机制是实现并发操作的重要手段之一，使得操作系统可以在多个任务之间快速切换，从而实现多任务并发执行。</li></ul></li></ul></li></ul></details><h3 id="_7、守护线程" tabindex="-1"><a class="header-anchor" href="#_7、守护线程" aria-hidden="true">#</a> 7、守护线程</h3><details class="hint-container details"><summary>什么是守护线程？</summary><blockquote><p>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）</p></blockquote><p>在JVM 启动时会调用 main 函数，main函数所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</p><p>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。</p></details><h3 id="_8、线程间通信方式" tabindex="-1"><a class="header-anchor" href="#_8、线程间通信方式" aria-hidden="true">#</a> 8、线程间通信方式</h3><details class="hint-container details"><summary>线程间有哪些通信方式？</summary><p>不同线程之间、当前线程和它之前的</p><blockquote><p>对于操作系统而言：</p></blockquote><ul><li><p><strong>共享内存</strong>：多个线程共享同一块内存区域，它们可以直接读写这块内存来进行通信。</p></li><li><p><strong>锁机制：</strong> 使用锁来保护共享资源，例如互斥锁和读写锁，确保同时只有一个线程能够访问共享资源，从而避免竞争条件。</p></li><li><p><strong>等待/通知机制</strong>：可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</p></li><li><p><strong>管道输入/输出流</strong>：管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p></li><li><p><strong>消息队列：</strong> 操作系统提供消息队列的机制，允许线程发送和接收消息。线程可以使用操作系统提供的 API 来操作消息队列，进行消息的发送和接收。</p></li></ul><blockquote><p>具体到Java的实现：</p></blockquote><ul><li><p><strong>java内存模型和volatile关键字</strong></p><ul><li>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</li></ul></li><li><p><strong>synchronized关键字</strong></p><ul><li>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</li></ul></li><li><p><strong>wait()和notify()</strong></p><ul><li>Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</li></ul></li><li><p><strong>管道输入/输出流</strong></p><ul><li>Java主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</li></ul></li><li><p><strong>使用Thread.join()</strong></p><ul><li>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis、int nanos)两个具备超时特性的方法。</li></ul></li><li><p><strong>使用ThreadLocal</strong></p><ul><li>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</li><li>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</li></ul></li></ul></details><h3 id="_9、sleep-方法和-wait-方法" tabindex="-1"><a class="header-anchor" href="#_9、sleep-方法和-wait-方法" aria-hidden="true">#</a> 9、sleep() 方法和 wait() 方法</h3><details class="hint-container details"><summary>sleep() 方法和 wait() 方法的区别？</summary><p><strong>共同点</strong>：两者都是用于线程进行调度的方法，可以实现线程在不同状态之间转换，作用都是用于暂停线程的执行，而且他俩都是本地方法。</p><p><strong>区别</strong>：</p><ol><li><p><strong>所属者不同</strong>：<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。<strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</p></li><li><p><strong>资源释放不同</strong>：<code>wait()</code> 通常被侧重用于线程间交互/通信，调用的时候<strong>会释放锁</strong>，而<code>sleep()</code>通常被用于暂停执行，<strong>不会释放锁</strong>。</p></li><li><p><strong>其他</strong>：<code>wait()</code> 默认是一直等，但还有其他重载方法，里面可以传入等待时间，而<code>sleep()</code>方法执行完成后，线程会自动苏醒。</p></li></ol></details><h3 id="_10、为什么-wait-方法不定义在-thread-中" tabindex="-1"><a class="header-anchor" href="#_10、为什么-wait-方法不定义在-thread-中" aria-hidden="true">#</a> 10、为什么 wait() 方法不定义在 Thread 中</h3><details class="hint-container details"><summary>为什么 wait() 方法不定义在 Thread 中？</summary><blockquote><p>为什么 wait() 方法不定义在 Thread 中？</p></blockquote><p>因为我们都知道嘛，先是根据我们需要什么功能再设计出什么来：</p><p>主要在于理解其功能以及Java对象的锁机制。</p><ul><li>首先，锁机制的主要目的是保护共享资源。锁机制包括<strong>加锁和释放锁</strong></li><li><code>wait()</code>方法涉及锁的释放，因此它需要知道应该释放哪个锁。若将其定义在<code>Thread</code>类中，这会导致<code>Thread</code>类和其他类没有相关性，使得难以确定其他对象是否存在锁。</li><li>而如果定义在<strong>Object</strong>类中，考虑到Java中的继承关系，所有对象都隐式地继承自顶级父类<code>Object</code>。如果将<code>wait()</code>方法定义在<code>Object</code>内部，由于继承关系，每个子类对象都可以调用<code>wait()</code>方法，从而导致每个对象都有释放锁的能力，这不符合锁机制的意图。</li><li>其次Java对象由对象头、示例数据和填充对齐组成，对象头包含了锁的标志信息（锁是否被持有）以及该锁属于哪个线程。</li><li>因此，<code>wait()</code>方法被定义在<code>Object</code>类中，以确保锁的释放与对象的关联性，使其能够在正确的情况下释放相应的锁，维护了Java中锁机制的合理性和安全性。</li></ul><blockquote><p>为什么 sleep() 方法定义在Thread中？</p></blockquote><p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p><p>因为sleep的作用是：让线程在预期的时间内执行，其他时候不要来占用CPU资源。从此可以理解为sleep是属于线程级别的，它是为了让线程在限定的时间后去执行。而且sleep方法是不会去释放锁的。</p></details><h3 id="_11、线程安全" tabindex="-1"><a class="header-anchor" href="#_11、线程安全" aria-hidden="true">#</a> 11、线程安全</h3><details class="hint-container details"><summary>什么是线程安全？</summary><p>线程安全指的是在多线程环境下，当多个线程同时访问某个对象或资源时，该对象或资源仍然能够表现出正确的行为，不会产生不确定的结果或出现数据损坏等问题。</p><p>具体来说，线程安全可以表现为以下几个方面：</p><ol><li><p><strong>原子性（Atomicity）：</strong> 指的是对于涉及多步骤操作的方法或操作，要么全部执行成功，要么全部不执行，中间不会被其他线程打断。比如对共享变量的读写操作要么完整地执行，要么不执行。</p></li><li><p><strong>可见性（Visibility）：</strong> 表示当一个线程修改了共享变量的值时，其他线程能够立即看到这个修改后的值。如果缺乏可见性，一个线程对共享变量的修改可能对其他线程是不可见的，导致错误的结果。</p></li><li><p><strong>有序性（Ordering）：</strong> 多个线程按照一定的顺序执行时，程序的执行结果是符合预期的。在并发环境下，由于线程调度的不确定性，如果没有正确的同步机制，可能导致代码的执行顺序混乱，产生不正确的结果。</p></li></ol></details><h2 id="二、threadlocal" tabindex="-1"><a class="header-anchor" href="#二、threadlocal" aria-hidden="true">#</a> 二、ThreadLocal</h2><h3 id="_1、什么是threadlocal" tabindex="-1"><a class="header-anchor" href="#_1、什么是threadlocal" aria-hidden="true">#</a> 1、什么是ThreadLocal</h3><details class="hint-container details"><summary>什么是ThreadLocal？</summary><ol><li>ThreadLocal，也就是线程本地变量。</li><li>它是Java保证线程安全的一种无同步方案，也就是说无需同步， 因为ThreadLocal提供了线程内存储变量的能力，每一个线程读取的变量是对应的互相独立的，类似我们传参的形参，每个都是一个副本变量，其次我们可以通过其提供get和set方法设置/得到当前线程对应的值。</li><li>ThreadLocal的话，它本质就是一个特殊的数据结构，本质实现就是一个<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说<strong>每个线程实例对象</strong>有一个自己的<code>ThreadLocalMap</code>。</li><li>而ThreadLocalMap它类似与我们的HashMap，也是一个键值对的存储，只不过它的底层实现是基于一个entry数组，每个entry就是key-value，它的key就是弱引用类型ThreadLocal对象，value就是我们真正存储的值。</li><li>当每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</li><li>ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。</li><li>我们通常使用static关键字修饰threadlocal</li></ol><hr><blockquote><p>例子：</p></blockquote><p>实习的时候中午吃饭点外卖</p><ul><li>ThreadLocal - 外卖柜</li><li>ThreadLocalMap - 每个人自己的专用抽屉（线程在 <code>ThreadLocal</code> 中的存储空间 ）</li><li>数据 - 抽屉内的外码</li><li>钥匙/取件码 - 线程</li><li>当每个人需要存储或者取出自己的书（数据）时，他们使用自己独有的钥匙（线程）打开自己的抽屉，而不会影响其他人的抽屉。虽然柜子是大家共用的，但每个人只能打开和操作自己的抽屉，保证了他们各自书本的独立性和安全性。这样，无论多少人共用同一个书柜，每个人都能安心地将自己的书本放在自己的抽屉里，互不干扰，也不会出现书本混乱或丢失的问题。</li></ul><hr><blockquote><p>为什么要使用static修饰：</p></blockquote><p>使用 <code>static</code> 修饰 ThreadLocal 有几个优势和好处：</p><ol><li><p><strong>全局共享数据：</strong> 使用 <code>static</code> 修饰的 ThreadLocal 实例在整个类中都是共享的，不同对象实例间和不同线程间可以共享同一个 ThreadLocal 实例。这样可以方便地实现数据在多个对象实例（如请求层和数据层）之间的共享和访问。</p></li><li><p><strong>简化代码：</strong> 如果某个数据在类的多个方法中需要共享或者访问，使用 <code>static</code> 修饰的 ThreadLocal 可以减少参数传递的复杂性。不需要将 ThreadLocal 作为方法参数传递，而是可以直接在方法内部获取线程独立的数据。</p></li><li><p><strong>提高可访问性：</strong> 静态的 ThreadLocal 实例可以被类的所有实例和方法直接访问，不需要通过对象实例来获取。这样可以简化代码，更容易地管理线程特定的数据。</p></li></ol><p>与不使用 <code>static</code> 修饰的区别在于：</p><ul><li><p><strong>作用域不同：</strong> 使用 <code>static</code> 修饰的 ThreadLocal 实例是类级别的，它的作用范围是整个类，可以被类的所有实例和方法直接访问和共享。而没有使用 <code>static</code> 修饰的 ThreadLocal 是对象级别的，每个对象实例都有自己的 ThreadLocal 实例，不同对象之间的数据是隔离的。</p></li><li><p><strong>访问范围不同：</strong> 使用 <code>static</code> 修饰的 ThreadLocal 实例可以在整个类中直接访问，而不需要通过对象实例。而非静态的 ThreadLocal 需要通过对象实例来访问其实例。</p></li></ul><p>总的来说，使用 <code>static</code> 修饰的 ThreadLocal 可以更方便地实现全局共享的线程局部变量，提高数据的访问性和代码的简洁性。而不使用 <code>static</code> 则更适合在对象级别实现线程安全的数据共享。选择使用哪种方式取决于具体的场景和需求。</p></details><h3 id="_2、threadlocal使用场景" tabindex="-1"><a class="header-anchor" href="#_2、threadlocal使用场景" aria-hidden="true">#</a> 2、ThreadLocal使用场景</h3><details class="hint-container details"><summary>ThreadLocal使用场景？</summary><blockquote><p>ThreadLocal使用场景有哪些？</p></blockquote><p>我觉得吧，ThreadLocal的使用场景主要是和它本身有关，他本质也就是一个Java对象，是我们Java实现线程安全的一种无同步方案，这种的话，为了避免创建多个对象，我们会使用static关键字修饰。</p><ul><li><strong>第一种场景</strong>：每个线程内需要保存全局变量 <ul><li>例如-保存一些业务内存【用户权限信息，从用户系统获取到的用户名、userId等】可以让不同方法直接使用，例如我们常用MVC架构，可能Controller层不需要的参数，但是Dao层需要，这样就可以使用ThreadLocal保存参数，避免参数传递的麻烦</li><li>例如-用来做用户信息上下文的存储，我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。</li><li>其次我的RPC也使用了，因为RPC调用过程中可能会返回的RPC响应出现一些了调用失败的信息，比如可能当前的服务器关闭了，那我们的请求需要再次进行负载均衡，把请求往其他服务器发送，但是到这里我们并没有原来请求的RPC报文，所以使用了ThreadLocal在发送请求前，把封装的请求存入本地线程，如果是正常的响应没有问题，就调用remove方法移除即可。</li></ul></li><li><strong>第二种场景</strong>：每个线程需要一个独享的对象 <ul><li>例如：通常是工具类，典型需要使用的类有SimpleDateFormat和Random，用于对每个请求或线程需要格式化时间的情况。</li><li>如果不使用ThreadLocal，也可以，比如每次来都new新的，空间浪费比较大；又或者使用synchronized修饰，但是并发上不来</li></ul></li></ul></details><h3 id="_3、threadlocal-内存泄露" tabindex="-1"><a class="header-anchor" href="#_3、threadlocal-内存泄露" aria-hidden="true">#</a> 3、ThreadLocal 内存泄露</h3><details class="hint-container details"><summary>ThreadLocal 内存泄露是怎么回事？</summary><blockquote><p>ThreadLocal 内存泄露主要和ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用有关：</p></blockquote><ul><li>因为线程内存储的不是此threadlocal，而是弱引用容器装载的threadlocal，而对于弱引用，只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。</li><li>value基本都是我们创建的对象，是强引用回收不掉，ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会<strong>造成了内存泄漏问题</strong>。</li></ul><blockquote><p>那怎么解决内存泄漏问题呢？</p></blockquote><ul><li>很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。</li><li>remove()方法会删除key为null的value也会删除，这样就ThreadLocalMap释放了空间</li></ul><blockquote><p>那为什么key还要设计成弱引用？</p></blockquote><ul><li>key设计成弱引用同样是为了防止内存泄漏。</li><li>假如key被设计成强引用：强引用即使内存爆了也不会垃圾回收掉，也就说如果此时有很多用于访问，大量线程内存储了ThreadLocal对象，这样负载很高，如果我们内存足还没事，如果不足则可用内存就一直减少，最后可能引发内存溢出。</li><li>所有设计成弱引用，每次垃圾回收时就删除，再搭配我们小心使用，使用完调用remove()就可以了。</li></ul></details><h3 id="_4、threadlocalmap的结构" tabindex="-1"><a class="header-anchor" href="#_4、threadlocalmap的结构" aria-hidden="true">#</a> 4、ThreadLocalMap的结构</h3><details class="hint-container details"><summary>ThreadLocalMap的结构了解吗？</summary><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<code>元素数组</code>和<code>散列方法</code>。</p><ul><li><p>元素数组：一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p></li><li><p>散列方法：散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HASH_INCREMENT</span> <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token constant">HASH_INCREMENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="_5、threadlocalmap的hash冲突" tabindex="-1"><a class="header-anchor" href="#_5、threadlocalmap的hash冲突" aria-hidden="true">#</a> 5、ThreadLocalMap的Hash冲突</h3><details class="hint-container details"><summary>ThreadLocalMap怎么解决Hash冲突的？</summary><p>ThreadLocalMap没有使用链表，它用的是另外一种方式——<strong>开放定址法（简单来说，就是这个坑被人占了，那就接着去找空着的坑。）</strong>。</p><ul><li>如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</li><li>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</li></ul></details><h3 id="_6、threadlocalmap的扩容机制" tabindex="-1"><a class="header-anchor" href="#_6、threadlocalmap的扩容机制" aria-hidden="true">#</a> 6、ThreadLocalMap的扩容机制</h3><details class="hint-container details"><summary>ThreadLocalMap扩容机制了解吗？</summary><p>在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i、 sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">&gt;=</span> threshold<span class="token punctuation">)</span>
    <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code>来决定是否需要扩容。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//清理过期Entry</span>
    <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> threshold <span class="token operator">-</span> threshold <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//清理过期Entry</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着看看具体的<code>resize()</code>方法，扩容后的<code>newTab</code>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的<code>newTab</code>，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到<code>newTab</code>中了，然后table引用指向<code>newTab</code></p></details><h3 id="_7、父子线程怎么共享数据" tabindex="-1"><a class="header-anchor" href="#_7、父子线程怎么共享数据" aria-hidden="true">#</a> 7、父子线程怎么共享数据</h3><details class="hint-container details"><summary>父子线程怎么共享数据？</summary><p>父线程使用类——<code>InheritableThreadLocal </code>。</p><ul><li>使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InheritableThreadLocalTest</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InheritableThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 主线程</span>
        threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;不擅技术&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//子线程</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;鄙人三某 ，&quot;</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>那原理是什么呢？</p></blockquote><ul><li>原理就是子线程被创建的时候会将父线程的ThreadLocalMap复制给子线程，但是后续两者就没啥关系了。</li></ul><p>原理很简单，在Thread类里还有另外一个变量：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在Thread.init的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals </code>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>inheritThreadLocals <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">=</span>
        <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">createInheritedMap</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="三、java内存模型" tabindex="-1"><a class="header-anchor" href="#三、java内存模型" aria-hidden="true">#</a> 三、Java内存模型</h2><h3 id="_1、java内存模型-jmm" tabindex="-1"><a class="header-anchor" href="#_1、java内存模型-jmm" aria-hidden="true">#</a> 1、Java内存模型（JMM）</h3><details class="hint-container details"><summary>介绍一下Java内存模型？</summary><p>Java内存模型（Java Memory Model，JMM），是一种抽象的模型，是Java定义的出来的用来屏蔽各种硬件和操作系统的内存访问差异。</p><ul><li>JMM主要就是线程和主内存之间的抽象关系： <ul><li>线程之间的共享变量存储在<code>主内存</code>（Main Memory）中，每个线程都有一个私有的<code>本地内存</code>（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。</li><li>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</li></ul></li></ul></details><h3 id="_2、说说你对原子性、可见性、有序性的理解" tabindex="-1"><a class="header-anchor" href="#_2、说说你对原子性、可见性、有序性的理解" aria-hidden="true">#</a> 2、说说你对原子性、可见性、有序性的理解</h3><details class="hint-container details"><summary>说说你对原子性、可见性、有序性的理解？</summary><ul><li><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。 <ul><li>应用实现：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<code>synchronized </code>或者原子类的原子操作。</li></ul></li><li><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。 <ul><li>应用实现：Java是利用<code>volatile</code>关键字来保证可见性的，除此之外，<code>final</code>和<code>synchronized</code>也能保证可见性。</li></ul></li><li><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。 <ul><li>应用实现：<code>synchronized</code>或者<code>volatile</code>都可以保证多线程之间操作的有序性。</li></ul></li></ul></details><h3 id="_3、那说说什么是指令重排-指令重排有限制吗" tabindex="-1"><a class="header-anchor" href="#_3、那说说什么是指令重排-指令重排有限制吗" aria-hidden="true">#</a> 3、那说说什么是指令重排？指令重排有限制吗</h3><details class="hint-container details"><summary>那说说什么是指令重排？指令重排有限制吗？</summary><blockquote><p>什么是指令重排：</p></blockquote><p>指令重排就是在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子：</p><ul><li><p><code>Singleton instance=new Singleton()；</code></p></li><li><p>对应的JVM指令分为三步：<strong>分配内存空间--&gt;初始化对象---&gt;对象指向分配的内存空间</strong></p></li><li><p>但是经过了编译器的指令重排序，<strong>第二步和第三步就可能会重排序</strong>，在多线程的访问情况下，可能会有对象的半初始化的问题。</p></li></ul><blockquote><p>指令重排的限制：</p></blockquote><p>指令重排也是有一些限制的，有两个规则<code>as-if-serial</code>和<code>happens-before</code>来约束。</p><ul><li><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），<strong>单线程程序的执行结果不能被改变</strong>。编译器、runtime和处理器都必须遵守as-if-serial语义。</p></li><li><p>happens-before的定义：多线程程序的执行结果不能被改变</p><ul><li><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p></li><li><p>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法</p></li></ul></li></ul></details><h3 id="_4、volatile有什么作用" tabindex="-1"><a class="header-anchor" href="#_4、volatile有什么作用" aria-hidden="true">#</a> 4、volatile有什么作用</h3><details class="hint-container details"><summary>volatile有什么作用？</summary><blockquote><p>volatile有两个作用，保证<strong>可见性</strong>和<strong>有序性</strong>。</p></blockquote><ul><li><p><strong>可见性</strong>：一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存，当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p><ul><li>例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</li><li>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</li></ul></li><li><p><strong>有序性</strong>：重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p><ul><li><p>为了实现volatile的内存语义，编译器在生成字节码时，会<strong>在指令序列中插入内存屏障</strong>来禁止特定类型的处理器重排序。</p><ol><li><p><strong><code>StoreStore</code>屏障：</strong> 在每个 volatile 写操作的前面插入一个 <code>StoreStore</code> 屏障，确保在当前 volatile 写操作之前的所有普通写操作（非 volatile 写操作）完成后，再执行当前 volatile 写操作。这样可以防止当前 volatile 写操作的数据与之前的非 volatile 写操作的数据重排序。</p></li><li><p><strong><code>StoreLoad</code>屏障：</strong> 在每个 volatile 写操作的后面插入一个 <code>StoreLoad</code> 屏障，确保当前 volatile 写操作的结果对后续的 volatile 读操作是可见的。它保证在当前 volatile 写操作之后的所有读操作（无论是 volatile 读操作还是普通读操作）都能看到当前 volatile 写操作所写入的最新值。</p></li><li><p><strong><code>LoadLoad</code>屏障：</strong> 在每个 volatile 读操作的后面插入一个 <code>LoadLoad</code> 屏障，确保当前 volatile 读操作之前的所有读操作（无论是 volatile 读操作还是普通读操作）都在当前 volatile 读操作之前完成。这样可以防止当前 volatile 读操作与之前的读操作重排序。</p></li><li><p><strong><code>LoadStore</code>屏障：</strong> 在每个 volatile 读操作的后面插入一个 <code>LoadStore</code> 屏障，确保当前 volatile 读操作的结果被后续的写操作（无论是 volatile 写操作还是普通写操作）正确刷新到内存中。这样可以防止当前 volatile 读操作的结果与后续的写操作重排序。</p></li></ol></li><li><p>此外，在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>理论上来说，你通过这个三个方法也可以实现和<code>volatile</code>禁止重排序一样的效果，只是会麻烦一些。</p></li></ul></li></ul></details><h3 id="_5、volatile实现原理了解吗" tabindex="-1"><a class="header-anchor" href="#_5、volatile实现原理了解吗" aria-hidden="true">#</a> 5、volatile实现原理了解吗</h3><details class="hint-container details"><summary>volatile实现原理了解吗？</summary><blockquote><p>volatile保证可见性和有序性的原理涉及到底层的硬件和内存模型：</p></blockquote><ol><li><strong>缓存一致性协议（Cache Coherence Protocol）：</strong> 多核处理器系统中，不同的核心有自己的缓存。当一个核心对一个共享的 volatile 变量进行写操作时，会发出信号通知其他核心的缓存失效，确保其他核心读取时能够获取到最新的值。</li><li><strong>内存屏障（Memory Barrier）：</strong> 编译器和处理器在生成和执行指令时，会在适当的地方插入内存屏障指令。对于 volatile 变量的写操作，会插入写屏障（Store Barrier），确保写操作将数据立即刷新到主内存。对于 volatile 变量的读操作，会插入读屏障（Load Barrier），确保读取的是主内存中最新的值。</li></ol></details><h3 id="_6、为什么volatile不能保证原子性" tabindex="-1"><a class="header-anchor" href="#_6、为什么volatile不能保证原子性" aria-hidden="true">#</a> 6、为什么volatile不能保证原子性</h3><details class="hint-container details"><summary>为什么volatile不能保证原子性</summary><p>虽然 <code>volatile</code> 可以保证可见性和禁止指令重排序，但它并不能保证原子性。</p><ul><li>原子性是指一个操作是不可中断的，要么全部执行成功，要么完全不执行，不会被其他线程中断或交错执行。</li><li>而 <code>volatile</code> 只是保证了对变量的读写操作具有可见性，但并不能保证复合操作的原子性。</li></ul><blockquote><p>考虑一个具体的场景：</p></blockquote><p><code>volatile int count = 0;</code>，多个线程对 <code>count</code> 进行自增操作 <code>count++</code>。</p><ul><li>虽然 <code>count</code> 是 <code>volatile</code> 的，但是 <code>count++</code> 是一个复合操作，包括读取 <code>count</code> 的值、对其进行加一操作、再将结果写回 <code>count</code>，这些操作之间可能会被其他线程打断，导致不同线程的操作交错执行，最终产生错误的结果。</li><li>例如又A、B两个线程都对 <code>count</code> 进行自增操作 <code>count++</code>，A、B线程读取操作<code>count</code> 的值，进行操作，A先一步刷回主存，此时其他线程内的变量副本刷新，但是我B已经进行了自增，正要刷回主存，刷回后还是1，两次操作本来结果是2，但是因为多线程进行交错执行，导致丢失了更新操作，使得最终结果不是期望的，产生了错误结果1。</li></ul><p>要保证这种情况下的原子性操作，可以使用 <code>AtomicInteger</code> 等原子类来代替 <code>volatile int</code>。<code>AtomicInteger</code> 提供了诸如 <code>getAndIncrement()</code> 这样的原子性操作，确保了自增操作的原子性，不会被其他线程中断或交错执行。这些原子类内部使用了底层的 CAS（Compare and Swap）等机制来实现原子性操作。</p></details><h2 id="四、锁" tabindex="-1"><a class="header-anchor" href="#四、锁" aria-hidden="true">#</a> 四、锁</h2><h3 id="_1、保证线程安全有什么方案" tabindex="-1"><a class="header-anchor" href="#_1、保证线程安全有什么方案" aria-hidden="true">#</a> 1、保证线程安全有什么方案</h3><details class="hint-container details"><summary>有什么保证线程安全的方案？</summary><p>实现线程安全的方法通常包括：</p><blockquote><p>数据不可变：</p></blockquote><p>在Java当中，一切不可变的对象（immutable）一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障的措施。</p><ul><li>比如final关键字修饰的基础数据类型，再比如说咱们的Java字符串儿。</li><li>只要一个不可变的对象被正确的构建出来，那外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态，带来的安全性是最直接最纯粹的。</li><li>比如使用final修饰的基础数据类型（引用数据类型不可以）、比如java字符串，而一旦被创建就永远不能改变，其实谷歌的开发工具包（guava）中也给我们提供了一些不可变的一类（immutable），咱们以后的学习过程当中可能会接触到。</li></ul><blockquote><p>互斥/阻塞同步同步：</p></blockquote><p>互斥同步是常见的一种并发正确性的保障手段，同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用，互斥是实现同步的一种手段，互斥是因、同步是果，互斥是方法，同步是目的。</p><ul><li><code>synchronized</code> 关键字：使用 <code>synchronized</code> 对象锁或方法锁来保护临界区。</li><li><code>ReentrantLock</code>：使用 <code>ReentrantLock</code> 显式锁来实现同步，提供了更多灵活性和功能，如可中断锁、公平性等。</li><li><code>ReadWriteLock</code>：<code>ReentrantReadWriteLock</code> 支持读写锁，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。</li></ul><p>但是互斥同步是一种【悲观的并发策略】，其总是认为，只要不去做正确的同步措施，那就肯定会出现问题，无论共享的数据是否真的出现，都会进行加锁。</p><ul><li>这将会导致用户态到内核态的转化、维护锁计数器和检查是否被阻塞的线程需要被唤醒等等开销，因此这种同步也被称为阻塞同步。</li></ul><blockquote><p>非阻塞同步</p></blockquote><p>随着硬件指令级的发展，我们已经有了另外的选择，基于【冲突检测的乐观并发策略】。</p><ul><li>通俗的说，就是不管有没有风险，先进行操作，如果没有其他线程征用共享数据，那就直接成功，如果共享数据确实被征用产生了冲突，那就再进行补偿策略，常见的补偿策略就是不断的重试，直到出现没有竞争的共享数据为止，这种乐观并发策略的实现，不再需要把线程阻塞挂起，因此同步操作也被称为非阻塞同步，这种措施的代码也常常被称之为【无锁编程】，也就是咱们说的自旋。我们用cas来实现这种非阻塞同步。</li><li>在 Java 中，非阻塞同步的实现方式通常涉及 <code>java.util.concurrent.atomic</code> 包中的原子类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等。这些类使用了 CAS 操作来确保对变量的操作是原子性的。</li></ul><blockquote><p>无同步方案</p></blockquote><p>在我们这个工作当中，还经常遇到这样一种情况，多个线程需要共享数据，但是这些数据又可以在单独的线程当中计算，得出结果，而不被其他的线程所影响，如果能保证这一点，我们就可以把共享数据的可见范围限制在一个线程之内，这样就无需同步，也能够保证个个线程之间不出现数据征用的问题，说人话就是数据拿过来，我用我的，你用你的，从而保证线程安全，比如说咱们的ThreadLocal。</p><ul><li>ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。</li></ul></details><h3 id="_2、介绍一下java里面常见的锁" tabindex="-1"><a class="header-anchor" href="#_2、介绍一下java里面常见的锁" aria-hidden="true">#</a> 2、介绍一下Java里面常见的锁</h3><details class="hint-container details"><summary>介绍一下Java里面常见的锁？</summary><blockquote><p>从Java锁实现来看：</p></blockquote><ol><li><p><strong>synchronized 关键字：</strong> 是 Java 中最基本的锁机制之一。它可以用来修饰方法或代码块，确保同一时间只有一个线程可以访问被 <code>synchronized</code> 修饰的代码段，实现互斥同步。它是隐式锁，不需要手动加锁解锁，当线程进入 synchronized 块时获取锁，退出时释放锁，其次它的底层实现原理是…..。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">synchronizedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 同步方法代码块</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>ReentrantLock：</strong> 是juc（ <code>java.util.concurrent</code>） 包提供的显式锁实现，具有与 synchronized 相似的互斥同步能力，并且提供了更多的灵活性。它支持公平性设置、可中断锁、条件变量等特性，可以更精确地控制锁的获取和释放。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 临界区代码块</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>ReadWriteLock（读写锁）：</strong> 为了应对一些特殊场景，也引入了读写锁，也是 <code>java.util.concurrent</code> 包提供的，它包含了一个读锁和一个写锁，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。读写锁适用于读多写少的场景，能够提高读操作的并发性能。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ReadWriteLock</span> rwLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取读锁</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 读取共享资源的操作</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放读锁</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>StampedLock：</strong> 其次在 Java 8 引入的一种机制，是 ReadWriteLock 的扩展，提供了三种访问模式：读、写和乐观读。StampedLock 的乐观读模式允许乐观地进行读操作，避免了使用读锁的开销。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">StampedLock</span> stampedLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> stamp <span class="token operator">=</span> stampedLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取悲观读锁</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 读操作</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    stampedLock<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放悲观读锁</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>这些锁机制都提供了线程同步和控制并发访问的手段，每种锁都有其适用的场景和特性，开发者可以根据具体需求选择合适的锁来保证线程安全性。</p><blockquote><p>其次从解决问题的方式上来看：</p></blockquote><ul><li>悲观锁：就是只要不去做正确的同步措施，那就肯定会出现问题，无论共享的数据是否真的出现，都会进行加锁。 <ul><li>使用诸如 <code>synchronized</code> 关键字、<code>ReentrantLock</code> 等锁来控制对共享资源的访问，确保同一时间只有一个线程可以访问共享资源。</li></ul></li><li>乐观锁：就是不管有没有风险，先进行操作，如果没有其他线程征用共享数据，那就直接成功，如果共享数据确实被征用产生了冲突，那就再进行补偿策略，常见的补偿策略就是不断的重试，直到出现没有竞争的共享数据为止。 <ul><li>使用无锁算法，如 CAS（比较并交换）机制，或者乐观锁的实现方式，例如 <code>StampedLock</code> 的乐观读模式，都是乐观锁的例子。</li></ul></li></ul></details><h3 id="_3、synchronized怎么使用" tabindex="-1"><a class="header-anchor" href="#_3、synchronized怎么使用" aria-hidden="true">#</a> 3、synchronized怎么使用</h3><details class="hint-container details"><summary>synchronized怎么使用？</summary><blockquote><p>synchronized主要有三种用法：</p></blockquote><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>修饰静态方法</strong>：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。</p><p>如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token keyword">void</span> staic <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 <strong>class</strong> 的锁</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="_4、synchronized和volatile的区别" tabindex="-1"><a class="header-anchor" href="#_4、synchronized和volatile的区别" aria-hidden="true">#</a> 4、synchronized和volatile的区别</h3><details class="hint-container details"><summary>详情</summary><p><code>volatile</code> 和 <code>synchronized</code> 都是 Java 中用于处理多线程并发访问的关键字，但它们有着不同的作用和使用场景：</p><ol><li><p><strong>可见性：</strong></p><ul><li><code>volatile</code> 保证了变量的可见性。当一个变量被 <code>volatile</code> 关键字修饰时，线程对该变量的修改会立即刷新到主内存中，其他线程可以立即看到最新值。</li><li><code>synchronized</code> 不仅保证了可见性，还确保了原子性和有序性。进入 <code>synchronized</code> 代码块之前会获取锁，退出时释放锁，只有获取锁的线程才能执行 <code>synchronized</code> 代码块。</li></ul></li><li><p><strong>原子性：</strong></p><ul><li><code>volatile</code> 不能保证操作的原子性，特别是复合操作，如 <code>count++</code> 不是原子操作，可能导致竞态条件。</li><li><code>synchronized</code> 保证了临界区的代码在同一时刻只能有一个线程执行，因此可以确保复合操作的原子性。</li></ul></li><li><p><strong>禁止指令重排序：</strong></p><ul><li><strong><code>volatile</code>：</strong> 保证了对 <code>volatile</code> 变量的读取和写入具有可见性，并禁止了指令重排序。对 <code>volatile</code> 变量的写操作会立即刷新到主内存，读操作也会直接从主内存中获取最新值，而不是从线程的本地缓存中获取。</li><li><strong><code>synchronized</code>：</strong> 提供了更强大的特性，包括了 <code>volatile</code> 的可见性，同时还提供了互斥访问共享资源的能力。当一个线程获取到 <code>synchronized</code> 块或方法的锁时，其他线程无法同时访问被锁定的资源，确保了对临界区的互斥访问。</li></ul></li><li><p><strong>适用范围：</strong></p><ul><li><code>volatile</code> 通常用于简单变量的状态标记，比如线程间的状态控制、开关变量等，不适合用于复合操作。</li><li><code>synchronized</code> 可以用于更复杂的并发控制，适用于临界区代码的同步。</li></ul></li><li><p><strong>性能开销：</strong></p><ul><li><code>volatile</code> 的开销相对较小，因为它只是保证了可见性，没有锁的竞争和线程阻塞。</li><li><code>synchronized</code> 的开销较大，涉及到获取锁和释放锁的操作，可能导致线程阻塞和上下文切换，影响性能。</li></ul></li></ol><p>总体来说，<code>volatile</code> 更适合简单的状态标记和某些特定的场景，而 <code>synchronized</code> 更适合复杂的并发控制和临界区同步。</p></details><h3 id="_5、synchronized的实现原理" tabindex="-1"><a class="header-anchor" href="#_5、synchronized的实现原理" aria-hidden="true">#</a> 5、synchronized的实现原理</h3><details class="hint-container details"><summary>synchronized的实现原理是什么？</summary><blockquote><p>synchronized是怎么加锁的呢？</p></blockquote><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM的两个字节码指令帮我们把这个事情做了。</p><ol><li><p><strong>synchronized修饰代码块时</strong>：JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步，<code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指向同步代码块的结束位置。</p><p>反编译一段synchronized修饰代码块代码，<code>javap -c -s -v -l SynchronizedDemo.class</code>，可以看到相应的字节码指令。</p></li><li><p><strong>synchronized修饰同步方法时</strong>：JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步，这个标识指明了该方法是一个同步方法。</p></li></ol><blockquote><p>详细：monitorenter、monitorexit或者ACC_SYNCHRONIZED都是基于Monitor实现的。</p></blockquote><ul><li>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong>。</li><li>所谓的Monitor其实是一种<strong>同步工具</strong>，也可以说是一种<strong>同步机制</strong>。在Java虚拟机（HotSpot）中，Monitor是由<strong>ObjectMonitor实现</strong>的，可以叫做内部锁，或者Monitor锁。</li></ul><p>ObjectMonitor的工作原理：</p><ul><li>ObjectMonitor有两个队列：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。</li><li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ObjectMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _count        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录线程获取锁的次数</span>
    _recursions   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//锁的重入次数</span>
    _owner        <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 指向持有ObjectMonitor对象的线程</span>
    _WaitSet      <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 处于wait状态的线程，会被加入到_WaitSet</span>
    _EntryList    <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>  <span class="token comment">// 处于等待锁block状态的线程，会被加入到该列表</span>
  	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。</li><li>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li></ul></details><h3 id="_6、除了原子性-synchronized可见性-有序性-可重入性怎么实现" tabindex="-1"><a class="header-anchor" href="#_6、除了原子性-synchronized可见性-有序性-可重入性怎么实现" aria-hidden="true">#</a> 6、除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h3><details class="hint-container details"><summary>详情</summary><blockquote><p>synchronized怎么保证可见性？</p></blockquote><ul><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li><li>线程加锁后，其它线程无法获取主内存中的共享变量。</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li></ul><blockquote><p>synchronized怎么保证有序性？</p></blockquote><p>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</p><p>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</p><p>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</p><blockquote><p>synchronized怎么实现可重入的呢？</p></blockquote><p>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</p><p>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。</p><p>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</p></details><h3 id="_7、synchronized优化了解吗" tabindex="-1"><a class="header-anchor" href="#_7、synchronized优化了解吗" aria-hidden="true">#</a> 7、synchronized优化了解吗</h3><details class="hint-container details"><summary>synchronized优化了解吗？</summary><blockquote><p>synchronized优化就是引入锁升级的过程，它主要是和不同锁的状态变化相关：</p></blockquote><ul><li>Java对象头里，有一块结构，叫<code>Mark Word</code>标记字段，这块结构会随着锁的状态变化而变化。</li><li>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</li></ul><blockquote><p>synchronized做了哪些优化？</p></blockquote><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong>。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p><ul><li>偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li><li>轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</li><li>自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li><li>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li></ul><blockquote><p>锁升级的过程是什么样的？</p></blockquote><p>锁升级方向：无锁--&gt;偏向锁---&gt; 轻量级锁----&gt;重量级锁，这个方向基本上是不可逆的。</p><blockquote><p>JVM一般是这样使用锁和Mark Word的：</p></blockquote><ol><li><p>当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</p></li><li><p>当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</p></li><li><p>当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</p></li><li><p>当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</p></li><li><p>偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在【当前线程】的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，也叫所记录（lock record），同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</p></li><li><p>轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7，自旋默认10次。</p></li><li><p>自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞排队。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等）进入阻塞状态，等待将来被唤醒。就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源。</p></li></ol></details><h3 id="_8、介绍reentrantlock" tabindex="-1"><a class="header-anchor" href="#_8、介绍reentrantlock" aria-hidden="true">#</a> 8、介绍ReentrantLock</h3><details class="hint-container details"><summary>什么是ReentrantLock？</summary><p><code>ReentrantLock</code> 是juc包下面的，一个实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁。</p><ul><li>和 <code>synchronized</code> 关键字类似。</li><li>不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span>、 <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p></li><li><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></details><h3 id="_9、reentrantlock实现原理" tabindex="-1"><a class="header-anchor" href="#_9、reentrantlock实现原理" aria-hidden="true">#</a> 9、ReentrantLock实现原理</h3><details class="hint-container details"><summary>ReentrantLock的实现原理是什么？</summary><ul><li>实现：加锁（公平/非公平锁）+解锁+可重入锁</li><li>原理：CAS、AQS（ 状态变量-state、CLH队列）</li></ul><p>AQS 是一个提供了构建同步器的框架，它利用一个整型的 state 变量来表示资源的占用情况，通过自旋CAS操作来实现对 state 的原子性更新。<code>ReentrantLock</code> 在内部使用了 AQS 的机制来实现可重入锁的功能。</p><p><code>ReentrantLock</code> 主要依赖于 AQS 中的 <code>Sync</code> 内部类来实现同步功能。<code>Sync</code> 类继承自 AQS，并提供了公平锁和非公平锁的不同实现方式：</p><ul><li><strong>公平锁（FairSync）：</strong> 在 <code>ReentrantLock</code> 的构造方法中传入 <code>true</code> 参数，表示使用公平锁。公平锁会按照线程请求的顺序进行获取锁。</li><li><strong>非公平锁（NonfairSync）：</strong> 在 <code>ReentrantLock</code> 的构造方法中传入 <code>false</code> 参数（默认），表示使用非公平锁。非公平锁允许线程插队，尝试直接获取锁而不管其他线程的等待状态。</li></ul><p>主要的实现逻辑包括：</p><ol><li><strong>锁的获取：</strong> 当一个线程尝试获取锁时，<code>ReentrantLock</code> 首先会调用 <code>Sync</code> 内部类的 <code>lock</code> 方法，尝试获取锁。如果获取失败，会根据锁的公平性策略进行后续等待队列的处理。 <ul><li><strong>CAS 操作</strong>：<code>ReentrantLock</code> 使用 CAS 操作来尝试获取锁。它通过比较当前锁的状态（state）和期望值，然后根据比较结果来尝试获取锁。如果成功获取锁，就可以进入临界区执行操作；如果失败，则根据锁的公平性策略将当前线程加入到等待队列中。</li><li><strong>AQS</strong>： <ul><li><code>ReentrantLock</code> 使用 AQS 来管理等待队列和同步状态。AQS 提供了一种框架，用于构建不同类型的同步器。<code>ReentrantLock</code> 利用 AQS 实现了独占锁的功能。</li><li>AQS 使用一个整型变量（state）来表示同步状态。<code>ReentrantLock</code> 内部的状态变量（state）表示锁的占用情况，0 表示锁是自由的，大于 0 表示锁被某个线程持有。</li><li>等待队列（CLH 队列）用于管理等待获取锁的线程，它是基于 CLH（Craig、 Landin、 and Hagersten）锁队列实现的。线程获取不到锁时，会被加入到队列中等待锁的释放。</li></ul></li></ul></li><li><strong>锁的释放：</strong> 当线程释放锁时，会调用 <code>Sync</code> 内部类的 <code>unlock</code> 方法。如果当前线程是最后一个持有锁的线程，那么释放锁之后，等待队列中的下一个线程将有机会获取到锁。</li></ol></details><h3 id="_10、reentrantlock怎么实现公平和非公平锁" tabindex="-1"><a class="header-anchor" href="#_10、reentrantlock怎么实现公平和非公平锁" aria-hidden="true">#</a> 10、ReentrantLock怎么实现公平和非公平锁</h3><details class="hint-container details"><summary>ReentrantLock怎么实现公平和非公平锁？</summary><p><code>new ReentrantLock() </code>构造函数默认创建的是非公平锁 NonfairSync</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">-</span> <span class="token class-name">ReentrantLock</span>
<span class="token comment">// true 代表公平锁，false 代表非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。</p><blockquote><p>非公平锁和公平锁的两处不同：</p></blockquote><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p></details><h3 id="_11、可中断锁和不可中断锁有什么区别" tabindex="-1"><a class="header-anchor" href="#_11、可中断锁和不可中断锁有什么区别" aria-hidden="true">#</a> 11、可中断锁和不可中断锁有什么区别</h3><details class="hint-container details"><summary>可中断锁和不可中断锁有什么区别？</summary><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li></ul></details><h3 id="_12、reentrantreadwritelock" tabindex="-1"><a class="header-anchor" href="#_12、reentrantreadwritelock" aria-hidden="true">#</a> 12、ReentrantReadWriteLock</h3><details class="hint-container details"><summary>ReentrantReadWriteLock是什么？</summary><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLock</span>
        <span class="token keyword">implements</span> <span class="token class-name">ReadWriteLock</span>、 <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ReadWriteLock</span> <span class="token punctuation">{</span>
    <span class="token class-name">Lock</span> <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Lock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</li><li>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</li></ul><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p><blockquote><p>ReentrantReadWriteLock 适合什么场景：</p></blockquote><p>由于 <code>ReentrantReadWriteLock</code> 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p><blockquote><p>共享锁和独占锁有什么区别：</p></blockquote><ul><li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li><li><strong>独占锁</strong>：一把锁只能被一个线程获得。</li></ul><blockquote><p>线程持有读锁还能获取写锁吗：</p></blockquote><ul><li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li><li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</li></ul></details><h3 id="_13、说说synchronized和reentrantlock的区别" tabindex="-1"><a class="header-anchor" href="#_13、说说synchronized和reentrantlock的区别" aria-hidden="true">#</a> 13、说说synchronized和ReentrantLock的区别</h3><details class="hint-container details"><summary>说说synchronized和ReentrantLock的区别？</summary><blockquote><p>相同点：</p></blockquote><ul><li><p>都是互斥同步方案保持线程安全的实现方式</p></li><li><p>都是可重入锁</p></li></ul><blockquote><p>不同点：</p></blockquote><ul><li><strong>锁的实现：</strong> synchronized是Java语言的关键字，基于JVM字节码指令实现，而ReentrantLock是一个实现Lock接口的类，是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）是显式的</li><li><strong>加锁方式</strong>：synchronized不需要手动加/释放锁，如果是方法底层会自动声明为ACC_SYNCHRONIZED，其次会为代码块插入指令<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步，是隐式加锁的，而ReentrantLock需要手动调用lock/unlock方法进行加/释放锁。</li><li><strong>性能：</strong> 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</li><li>功能特点：ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。 <ul><li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li><li>synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。</li><li>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</li></ul></li></ul></details><h3 id="_14、如何保证多线程下i-结果正确" tabindex="-1"><a class="header-anchor" href="#_14、如何保证多线程下i-结果正确" aria-hidden="true">#</a> 14、如何保证多线程下i++ 结果正确</h3><details class="hint-container details"><summary>详情</summary><p>在多线程环境下执行 <code>i++</code> 操作，确保结果的正确性通常需要考虑并确保以下几个方面：</p><ol><li><p><strong>原子性操作：</strong> 确保对 <code>i</code> 的增加操作是原子性的，即在执行增加操作时，不会被其他线程中断或者同时执行其他操作。</p></li><li><p><strong>可见性：</strong> 确保一个线程对 <code>i</code> 的修改能够被其他线程立即看到，避免了线程间的数据不一致问题。</p></li><li><p><strong>线程安全：</strong> 确保在多线程环境下对 <code>i</code> 的操作是线程安全的，不会出现竞态条件等问题。</p></li></ol><p>为了保证多线程下 <code>i++</code> 的结果正确，可以采取以下几种方式：</p><ol><li><p><strong>使用同步机制：</strong></p><ul><li>可以使用 <code>synchronized</code> 关键字或者 <code>ReentrantLock</code> 来确保对 <code>i</code> 的自增操作是原子性的，即同一时间只有一个线程可以修改 <code>i</code> 的值。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用原子类：</strong></p><ul><li>可以使用 <code>java.util.concurrent.atomic</code> 包下的原子类，例如 <code>AtomicInteger</code>，它们提供了基本类型的原子性操作。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
atomicInteger<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用线程安全的集合类：</strong></p><ul><li>某些线程安全的集合类，例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等，在多线程环境下提供了安全的并发访问。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token class-name">String</span>、 <span class="token class-name">Integer</span><span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span>、 <span class="token punctuation">(</span>k、 v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> v <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用<code>volatile</code>修饰变量：</strong></p><ul><li>将 <code>i</code> 声明为 <code>volatile</code> 可以确保对它的操作具有可见性，但并不能保证复合操作的原子性。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>以上方法都可以保证在多线程环境下对 <code>i</code> 的自增操作是线程安全的，确保结果的正确性。选择合适的方法取决于具体的应用场景和性能要求。</p></details><h3 id="_15、什么是cas-cas有什么问题" tabindex="-1"><a class="header-anchor" href="#_15、什么是cas-cas有什么问题" aria-hidden="true">#</a> 15、什么是CAS？ CAS有什么问题</h3><details class="hint-container details"><summary>什么是CAS？ CAS有什么问题？</summary><p>CAS，compare and swap的缩写，中文翻译成比较并交换，主要是通过处理器的指令来保证操作的原⼦性的，jdk11以后改成了compare and set。</p><ul><li>CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。</li><li>只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，<strong>CAS 指令本身是能够保证原子性的</strong> 。</li><li><strong>设计思想/原理</strong>：就是给一个元素赋值的时候，先看看内存里的那个值到底变没变，如果没变我就修改，变了我就不改了，其实这是一种无锁操作，不需要挂起线程，无锁的思路就是先尝试，如果失败了，进行补偿，也就是你可以继续尝试。这样在少量竞争的情况下能很大程度提升性能。</li></ul><blockquote><p>CAS的经典三大问题：</p></blockquote><ol><li>ABA 问题：指的是一个特定的并发问题，涉及到共享资源的状态变化。 <ul><li>具体而言，ABA问题发生在一个线程先检查某个共享变量的值是A，然后在其他线程修改该变量为B，最后又修改回A，使得在第一个线程看来，共享变量的值仍然是A，但实际上已经发生了变化。</li></ul></li><li>循环性能开销：自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</li><li>只能保证一个变量的原子操作：CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</li></ol><blockquote><p>怎么解决ABA问题？</p></blockquote><ol><li><p><strong>场景描述：</strong> 在一个在线支付系统中，用户发起支付请求，支付系统处理支付并更新支付状态。假设一个用户发起支付，支付成功后状态为已支付，但之后由于某种原因，支付被撤销并重新支付，最终又恢复为之前的状态（经历了ABA变化）。</p></li><li><p><strong>可能出现的ABA问题：</strong></p><ul><li>用户A发起支付请求，支付状态变为已支付（A）。</li><li>由于某种情况（网络波动、支付系统异常等），支付被撤销，状态变为未支付（B）。</li><li>接着又发起相同金额的支付请求，支付状态再次变为已支付（A）。</li><li>最后系统恢复了之前被撤销的支付，支付状态又变为已支付（A）。</li></ul></li><li><p><strong>可能造成的影响：</strong></p><ul><li><strong>支付逻辑错误：</strong> 用户实际只发起了一次支付，但系统记录了两次支付成功，可能导致用户多次被扣款。</li><li><strong>账单不一致：</strong> 用户在账单中看到重复的支付记录，产生混乱和困惑。</li><li><strong>业务数据错误：</strong> 后续业务操作（比如发货、订单处理等）可能基于错误的支付状态进行，导致不一致的业务行为。</li><li><strong>用户体验受损：</strong> 用户的支付历史、订单状态等可能会出现混乱，影响用户对支付系统的信任和体验。</li></ul></li></ol><ul><li><mark>解决方案 - 加版本号</mark>：每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&gt;B-&gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。</li><li>Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</li></ul><blockquote><p>怎么解决循环性能开销问题？</p></blockquote><p>在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。</p><blockquote><p>怎么解决只能保证一个变量的原子操作问题？</p></blockquote><ul><li>可以考虑改用锁来保证操作的原子性</li><li>可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性</li></ul></details><h3 id="_16、什么是aqs" tabindex="-1"><a class="header-anchor" href="#_16、什么是aqs" aria-hidden="true">#</a> 16、什么是AQS</h3><details class="hint-container details"><summary>什么是AQS？</summary><p>AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p><ul><li><strong>AQS主要包括了</strong>：volatile 修饰的 int 类型的成员变量 state 来表示同步状态、CLH 队列</li><li><strong>AQS 核心思想是</strong>：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。 <ul><li>获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。</li><li>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。 <ul><li>AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列</li><li>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配</li></ul></li></ul></li></ul></details><h3 id="_17、atomicinteger-的原理" tabindex="-1"><a class="header-anchor" href="#_17、atomicinteger-的原理" aria-hidden="true">#</a> 17、AtomicInteger 的原理</h3><details class="hint-container details"><summary>AtomicInteger 的原理是什么？</summary><p>一句话概括：<strong>使用CAS实现</strong>。</p><p>以AtomicInteger的添加方法为例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span>、 valueOffset、 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>Unsafe</code>类的实例来进行添加操作，来看看具体的CAS操作：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1、 <span class="token keyword">long</span> var2、 <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1、 var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1、 var2、 var5、 var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> var5<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。</p><blockquote><p>原子类类型：基本类型、数组类型、引用类型、对象的属性修改类型</p></blockquote><ul><li><p><strong>基本类型</strong>：使用原子的方式更新基本类型</p><ul><li><p><code>AtomicInteger</code>：整型原子类</p></li><li><p><code>AtomicLong</code>：长整型原子类</p></li><li><p><code>AtomicBoolean</code>：布尔型原子类</p></li></ul></li><li><p><strong>数组类型</strong>：使用原子的方式更新数组里的某个元素</p><ul><li><p><code>AtomicIntegerArray</code>：整型数组原子类</p></li><li><p><code>AtomicLongArray</code>：长整型数组原子类</p></li><li><p><code>AtomicReferenceArray</code>：引用类型数组原子类</p></li></ul></li><li><p><strong>引用类型</strong></p><ul><li><p><code>AtomicReference</code>：引用类型原子类</p></li><li><p><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，不能解决 ABA 问题。</p></li><li><p><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p></li></ul></li><li><p><strong>对象的属性修改类型</strong></p><ul><li><p><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</p></li><li><p><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</p></li><li><p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</p></li></ul></li></ul></details><h3 id="_18、什么是死锁-如何避免" tabindex="-1"><a class="header-anchor" href="#_18、什么是死锁-如何避免" aria-hidden="true">#</a> 18、什么是死锁？如何避免</h3><details class="hint-container details"><summary>什么是死锁？如何避免死锁？</summary><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><ul><li><p>例如，有一线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，但是各自又不释放自身的资源，所以这两个线程就会互相等待而进入死锁状态。</p></li><li><p>死锁产生的四个条件：</p><ul><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>请求与保持条件：指一个线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ul></li><li><p><strong>如何预防死锁</strong>：破坏死锁的产生的必要条件即可：</p><ol><li>其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</li><li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol></li><li><p><strong>如何避免死锁</strong>：避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote></li></ul></details><h3 id="_19、如何排查死锁" tabindex="-1"><a class="header-anchor" href="#_19、如何排查死锁" aria-hidden="true">#</a> 19、如何排查死锁</h3><details class="hint-container details"><summary>如何排查死锁？</summary><blockquote><p>可以使用jdk自带的命令行工具排查：</p></blockquote><ol><li>使用jps查找运行的Java进程：jps -l</li><li>使用jstack查看线程堆栈信息：jstack -l 进程id</li></ol><p>基本就可以看到死锁的信息。</p><p>还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的<code>检测到死锁</code>按钮，将会看到线程的死锁信息。</p></details><h2 id="五、并发工具类" tabindex="-1"><a class="header-anchor" href="#五、并发工具类" aria-hidden="true">#</a> 五、并发工具类</h2><h3 id="_1、countdownlatch了解吗" tabindex="-1"><a class="header-anchor" href="#_1、countdownlatch了解吗" aria-hidden="true">#</a> 1、CountDownLatch了解吗</h3><details class="hint-container details"><summary>CountDownLatch了解吗？</summary><p>CountDownLatch，倒计数器，核心方法如下：</p><ul><li><code>await()</code>：等待latch降为0；</li><li><code>boolean await(long timeout、 TimeUnit unit)</code>：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。</li><li><code>countDown()</code>：latch数量减1；</li><li><code>getCount()</code>：获取当前的latch数量。</li></ul><p>有两个常见的应用场景：</p><blockquote><p>场景1：协调子线程结束动作：等待所有子线程运行结束</p></blockquote><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><ul><li><p>例如，我们很多人喜欢玩的moba多人竞技游戏，英雄联盟/王者荣耀，得等所有人都确认之后，才能进入对局再选游戏。</p></li><li><p><code>new CountDownLatch(5)</code>用户创建初始的latch数量（玩家数量），各玩家线程通过<code>countDownLatch.countDown()</code>完成状态确认，主线程通过<code>countDownLatch.await()</code>等待。</p></li><li><p>主线程await()，子线程countdown()</p></li></ul><blockquote><p>场景2.：协调子线程开始动作：统一各线程动作开始的时机</p></blockquote><ul><li>例如，英雄联盟/王者荣耀中也有类似的场景，游戏开始时，各玩家的初始状态必须一致，例如刚开局都是500块。</li><li>子线程await()，主线程countdown()</li></ul></details><h3 id="_2、cyclicbarrier了解吗" tabindex="-1"><a class="header-anchor" href="#_2、cyclicbarrier了解吗" aria-hidden="true">#</a> 2、CyclicBarrier了解吗</h3><details class="hint-container details"><summary>CyclicBarrier了解吗？</summary><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方</p><ol><li>因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。</li><li>CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程</li></ol></details><h3 id="_3、semaphore了解吗" tabindex="-1"><a class="header-anchor" href="#_3、semaphore了解吗" aria-hidden="true">#</a> 3、Semaphore了解吗</h3><details class="hint-container details"><summary>Semaphore了解吗？</summary><blockquote><p>对Java而言：</p></blockquote><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>我们再来看一个Semaphore的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。</p><p>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，</p><blockquote><p>对操作系统而言：</p></blockquote><ul><li><p>信号量机制操作系统中用于实现进程同步和互斥的重要工具。</p></li><li><p>通过使用信号量，进程可以对共享资源的访问进行控制，避免多个进程同时访问或修改同一资源，从而确保数据的一致性和完整性。</p><ul><li><strong>信号量</strong>本质上<strong>是</strong>一个计数器，可以用来表示系统中某种资源的数量。 <ul><li>一个信号量可以是整数类型，也可以是更复杂的数据结构。</li><li>比如，如果系统只有一台打印机可用，就可以用一个初值为1的信号量来表示打印机的可用性.</li></ul></li><li><strong>对信号量的操作</strong>主要通过一对特殊的原语来完成，这对原语是操作系统提供的函数，用于对信号量进行操作。这些原语是不可中断的，确保操作的完整性。一般来说，这对原语包括wait(S)原语和signal(S)原语。 <ul><li><code>wait(S)</code> 原语（或 P(S) 操作）用于申请资源或降低信号量的值。如果信号量的值大于零，则将其减一；否则，该操作会阻塞进程，直到信号量的值大于零为止。</li><li><code>signal(S)</code> 原语（或 V(S) 操作）用于释放资源或增加信号量的值。它增加信号量的值，并唤醒因为等待该资源而被阻塞的进程。</li></ul></li></ul></li></ul><p>这种机制使得进程可以通过对信号量的操作来实现对共享资源的控制和同步，确保在访问共享资源时的互斥性，从而避免竞态条件和数据不一致的问题。</p></details><h3 id="_4、exchanger-了解吗" tabindex="-1"><a class="header-anchor" href="#_4、exchanger-了解吗" aria-hidden="true">#</a> 4、Exchanger 了解吗</h3><details class="hint-container details"><summary>Exchanger 了解吗？</summary><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p><p>这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><ul><li>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。</li><li>Exchanger可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</li></ul></details><h3 id="_5、longadder原理" tabindex="-1"><a class="header-anchor" href="#_5、longadder原理" aria-hidden="true">#</a> 5、LongAdder原理</h3><details class="hint-container details"><summary>LongAdder原理？</summary><p><code>LongAdder</code>是Java 8 中引入的一种线程安全的累加器，用于高并发情况下对长整型（<code>long</code>类型）进行原子性的累加操作。它通常比<code>AtomicLong</code>性能更好，特别是在高度竞争情况下。</p><blockquote><p>实现原理：</p></blockquote><ul><li><code>LongAdder</code>的实现基于分段锁（Striped LongAdder）。它将一个<code>long</code>值分解为多个部分（通常是数组），每个部分都由一个独立的计数器维护。当多个线程同时尝试更新计数器时，不同的线程会被分配到不同的计数器上进行操作，而不会造成线程间的争用。</li><li>当进行累加操作时，<code>LongAdder</code>会根据当前线程的哈希码（通过对线程 ID 的散列运算获得）来选择使用其中一个计数器。如果发生冲突（即多个线程的哈希码映射到同一个计数器），则会通过CAS（Compare and Set）循环来尝试更新计数器的值。如果更新失败，它会将任务分散到其他的计数器上，以减少竞争。在最终获取结果时，会将所有分段的计数器值累加起来得到最终的结果。</li></ul><p><code>LongAdder</code>实现的关键点在于通过分段的方式降低了线程之间的竞争，从而提高了并发更新性能。这使得在高并发场景下，<code>LongAdder</code>能够比<code>AtomicLong</code>更高效地处理累加操作。</p><ol><li><p><strong>减少竞争：</strong> <code>AtomicLong</code>是基于CAS（Compare and Set）操作实现的，它在高并发情况下可能导致多个线程同时竞争更新同一个变量，这会增加线程之间的竞争和CAS操作的失败重试次数，降低性能。而<code>LongAdder</code>使用了分段的思想，将一个<code>long</code>值分解成多个部分（通常是数组），不同的线程更新不同的部分，避免了大量线程竞争同一个变量的情况，从而减少了竞争。</p></li><li><p><strong>合并操作：</strong> <code>LongAdder</code>在获取最终结果时，会将所有分段的计数器值进行累加。这样，虽然在更新操作时会牺牲一定的内存以维护分段计数器数组，但在获取最终结果时，合并操作会更加高效。相比之下，<code>AtomicLong</code>在高并发情况下可能会产生大量的竞争和CAS重试，导致性能下降。</p></li></ol></details><h2 id="六、线程池" tabindex="-1"><a class="header-anchor" href="#六、线程池" aria-hidden="true">#</a> 六、线程池</h2><h3 id="_1、什么是线程池-为什么要有线程池" tabindex="-1"><a class="header-anchor" href="#_1、什么是线程池-为什么要有线程池" aria-hidden="true">#</a> 1、什么是线程池？为什么要有线程池</h3><details class="hint-container details"><summary>什么是线程池？为什么要有线程池？</summary><p><strong>线程池：</strong> 简单理解，它就是一个管理线程的池子。</p><p><strong>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。</strong></p><ul><li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li><li><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li><li><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li></ul></details><h3 id="_2、线程池的应用有哪些" tabindex="-1"><a class="header-anchor" href="#_2、线程池的应用有哪些" aria-hidden="true">#</a> 2、线程池的应用有哪些</h3><details class="hint-container details"><summary>线程池的应用有哪些？</summary><p>线程池是一种管理和复用线程的机制，它能够在多任务处理中提供一定程度的优化和控制。线程池在许多应用场景中都有着广泛的应用，也基于它的机制：</p><ol><li><strong>Web服务器：</strong> 在Web服务器中，线程池用于管理和处理客户端请求。当有请求到达时，不需要为每个请求创建一个新线程，而是从线程池中获取可用线程来处理请求，这样可以减少线程创建和销毁的开销，提高服务器的吞吐量和响应速度 <ul><li>BIO的优化</li></ul></li><li><strong>并发任务处理：</strong> 在并发编程中，线程池可以用于管理和执行大量的并行任务。例如，当需要处理大量数据或执行一系列异步任务时，线程池可以有效地管理线程资源，控制并发度，避免资源过度占用，提高系统的性能。</li><li><strong>定时任务调度：</strong> 线程池也经常用于执行定时任务或周期性任务。通过线程池可以轻松地调度和执行这些任务，而不必每次都手动创建和管理线程。</li><li><strong>数据库连接池：</strong> 在数据库访问中，线程池可以用于管理数据库连接。通过复用连接，避免频繁地创建和关闭数据库连接，提高数据库访问的效率和性能。</li></ol><p>线程池的应用范围广泛，主要优势在于有效地管理和复用线程资源，提高系统的性能和响应能力，同时避免了频繁创建和销毁线程所带来的开销。</p></details><h3 id="_3、有哪几种常见的线程池" tabindex="-1"><a class="header-anchor" href="#_3、有哪几种常见的线程池" aria-hidden="true">#</a> 3、有哪几种常见的线程池</h3><details class="hint-container details"><summary>有哪些常见的线程池？</summary><p>主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。</p><ul><li>newFixedThreadPool (固定数目线程的线程池)</li><li>newCachedThreadPool (可缓存线程的线程池)</li><li>newSingleThreadExecutor (单线程的线程池)</li><li>newScheduledThreadPool (定时及周期执行的线程池)</li></ul></details><h3 id="_4、线程池的参数有哪些" tabindex="-1"><a class="header-anchor" href="#_4、线程池的参数有哪些" aria-hidden="true">#</a> 4、线程池的参数有哪些</h3><details class="hint-container details"><summary>线程池的参数有哪些？</summary><p>线程池有七大参数，需要重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>、<code>handler</code>这四个。</p><ol><li><p><strong>corePoolSize</strong>：此值是用来初始化线程池中核心线程数，当<mark>线程池中线程池数 &lt; corePoolSize</mark>时，系统默认是添加一个任务才创建一个线程池。当线程数 = corePoolSize时，新任务会追加到workQueue中。</p></li><li><p><strong>maximumPoolSize</strong>：<code>maximumPoolSize</code>表示<code>允许的最大线程数 = (非核心线程数+核心线程数)</code>，当<code>BlockingQueue</code>也满了，但<mark>线程池中总线程数 &lt; maximumPoolSize</mark>时候就会再次创建新的线程。</p></li><li><p><strong>keepAliveTime</strong>：非核心线程 =(maximumPoolSize - corePoolSize ) ，非核心线程闲置下来不干活最多存活时间。</p></li><li><p>unit：线程池中非核心线程保持存活的时间的单位</p></li><li><p>workQueue：线程池等待队列，维护着等待执行的<code>Runnable</code>对象。当运行当线程数= corePoolSize时，新的任务会被添加到<code>workQueue</code>中，如果<code>workQueue</code>也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。</p></li><li><p>threadFactory：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。</p></li><li><p><strong>handler</strong>：<code>corePoolSize</code>、<code>workQueue</code>、<code>maximumPoolSize</code>都不可用的时候执行的饱和策略</p></li></ol></details><h3 id="_5、线程池的拒绝策略有哪些" tabindex="-1"><a class="header-anchor" href="#_5、线程池的拒绝策略有哪些" aria-hidden="true">#</a> 5、线程池的拒绝策略有哪些</h3><details class="hint-container details"><summary>线程池的拒绝策略有哪些？</summary><ul><li>AbortPolicy ：直接抛出异常，默认使用此策略</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务</li><li>DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务</li><li>DiscardPolicy ：当前任务直接丢弃</li></ul><p>示例：AbortPolicy - 经理：我们系统瘫痪了、CallerRunsPolicy - 谁写的bug你找谁去、DiscardOldestPolicy - 走排期，你加塞、DiscardPolicy - 做不了一点，明天再来吧</p></details><h3 id="_6、线程池有哪几种工作队列" tabindex="-1"><a class="header-anchor" href="#_6、线程池有哪几种工作队列" aria-hidden="true">#</a> 6、线程池有哪几种工作队列</h3><details class="hint-container details"><summary>线程池有哪几种工作队列？</summary><ul><li>ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</li><li>LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</li><li>DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</li><li>PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列</li><li>SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</li></ul></details><h3 id="_7、线程池提交execute和submit有什么区别" tabindex="-1"><a class="header-anchor" href="#_7、线程池提交execute和submit有什么区别" aria-hidden="true">#</a> 7、线程池提交execute和submit有什么区别</h3><details class="hint-container details"><summary>线程池提交execute和submit有什么区别？</summary><blockquote><p>区别：在于提交的任务是否需要返回值</p></blockquote><ol><li>execute 用于提交不需要返回值的任务</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>threadsPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// TODO Auto-generated method stub } </span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>harReturnValuetask<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token class-name">Object</span> s <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 处理中断异常 </span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 处理无法执行任务异常 </span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 关闭线程池 executor.shutdown();</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="_8、线程池怎么关闭" tabindex="-1"><a class="header-anchor" href="#_8、线程池怎么关闭" aria-hidden="true">#</a> 8、线程池怎么关闭</h3><details class="hint-container details"><summary>线程池怎么关闭？</summary><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><p><strong>shutdown() 将线程池状态置为shutdown、并不会立即停止</strong>：</p><ol><li>停止接收外部submit的任务</li><li>内部正在跑的任务和队列里等待的任务，会执行完</li><li>等到第二步完成后，才真正停止</li></ol><p><strong>shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定</strong>：</p><ol><li>和shutdown()一样，先停止接收外部提交的任务</li><li>忽略队列里等待的任务</li><li>尝试将正在跑的任务interrupt中断</li><li>返回未执行的任务列表</li></ol><p>shutdown 和shutdownnow简单来说区别如下：</p><ul><li>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li><li>shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。</li></ul></details><h3 id="_9、线程池异常怎么处理" tabindex="-1"><a class="header-anchor" href="#_9、线程池异常怎么处理" aria-hidden="true">#</a> 9、线程池异常怎么处理</h3><details class="hint-container details"><summary>线程池异常怎么处理？</summary><p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p><p>常见的异常处理方式：</p><ol><li><code>try-catch</code>捕获异常</li><li><code>submit</code>执行，<code>Future.get</code>接受异常</li><li>重&#39;写<code>ThreadPoolExecutor.afterExcute</code>方法，处理传递的异常引用</li><li>实例化时，传入自己的<code>ThreadFactory</code>设置<code>Thread.UncaughtExceptionHandler</code>处理未检测的异常</li></ol></details><h3 id="_10、线程池的线程数应该怎么配置" tabindex="-1"><a class="header-anchor" href="#_10、线程池的线程数应该怎么配置" aria-hidden="true">#</a> 10、线程池的线程数应该怎么配置</h3><details class="hint-container details"><summary>线程池的线程数应该怎么配置？</summary><blockquote><p>线程池的线程数配置应该看线程池的作用：</p></blockquote><p>线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。</p><ol><li>计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。</li><li>IO密集型：数据库链接，网络通讯传输等。</li></ol><p>一般的经验，不同类型线程池的参数配置：</p><ol><li>计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在<strong>页缺失</strong>(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li><p>IO密集型：线程数适当大一点，机器的Cpu核心数*2。</p></li><li><p>混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。</p></li></ol><p>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。</p></details><h3 id="_11、线程池有几种状态" tabindex="-1"><a class="header-anchor" href="#_11、线程池有几种状态" aria-hidden="true">#</a> 11、线程池有几种状态</h3><details class="hint-container details"><summary>线程池有几种状态？</summary><p>线程池有这几个状态：<code>RUNNING</code>、SHUTDOWN、STOP、TIDYING、TERMINATED。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//线程池状态</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span>   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span>       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span>    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程池各个状态切换图：</p><p><strong>RUNNING</strong></p><ul><li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li><li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li><li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li></ul><p><strong>SHUTDOWN</strong></p><ul><li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li></ul><p><strong>STOP</strong></p><ul><li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>线程池中执行的任务为空,进入TIDYING状态;</li></ul><p><strong>TIDYING</strong></p><ul><li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li><li>terminated()执行完毕，进入TERMINATED状态</li></ul><p><strong>TERMINATED</strong></p><ul><li>该状态表示线程池彻底终止</li></ul></details><h3 id="_12、线程池工作流程" tabindex="-1"><a class="header-anchor" href="#_12、线程池工作流程" aria-hidden="true">#</a> 12、线程池工作流程</h3><details class="hint-container details"><summary>说说线程池的工作流程？</summary><blockquote><p>线程池的工作原理：</p></blockquote><ol><li><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p></li><li><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><ul><li><p>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p></li><li><p>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p></li><li><p>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p></li><li><p>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。</p></li></ul></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p></li><li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p></li></ol><blockquote><p>具体示例：</p></blockquote><p>比如我们去银行窗口取款，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。</p><p>如果去办业务，可能会遇到什么情况呢？</p><ol><li>发现有空间的在营业的窗口，直接去找小姐姐办理业务。</li><li>发现没有空闲的窗口，就在排队区排队等。</li><li>老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。</li><li>小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。</li><li>六个窗口都满了，等待区也没位置了，我急了，你呢，要闹，经理赶紧出来了，经理该怎么办呢？ <ol><li>我们银行系统已经瘫痪</li><li>谁叫你来办的你找谁去</li><li>看你比较急，去队里加个塞</li><li>今天没办法，不行你看改一天</li></ol></li></ol></details><h3 id="_13、线程池如何实现参数的动态修改" tabindex="-1"><a class="header-anchor" href="#_13、线程池如何实现参数的动态修改" aria-hidden="true">#</a> 13、线程池如何实现参数的动态修改</h3><details class="hint-container details"><summary>线程池如何实现参数的动态修改？</summary><p>线程池提供了几个 setter方法来设置线程池的参数。</p><ul><li>在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例通过setter方法来修改线程池的参数。</li><li>如果限制了配置中心的使用，也可以自己去扩展<strong>ThreadPoolExecutor</strong>，重写方法，监听线程池参数变化，来动态修改线程池参数。</li></ul></details><h3 id="_14、你能设计实现一个线程池" tabindex="-1"><a class="header-anchor" href="#_14、你能设计实现一个线程池" aria-hidden="true">#</a> 14、你能设计实现一个线程池</h3><details class="hint-container details"><summary>你能设计实现一个线程池？</summary><p>我们自己的实现就是完成这个核心流程：</p><ol><li>线程池中要有N个工作线程</li><li>把任务提交给线程池运行</li><li>如果线程池已满，把任务放入队列</li><li>最后当有空闲时，获取队列中任务来执行</li></ol><p>在帮你调整格式和完善代码前，有一些错误需要修正，比如变量命名、缺失的部分等。让我对代码进行修正和整理，然后再呈现给你。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPoolExecutor</span> <span class="token keyword">implements</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Can not execute! ctl.count:&quot;</span> <span class="token operator">+</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; workQueue size:&quot;</span> <span class="token operator">+</span> workQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> maximumPoolSize<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Worker</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        worker<span class="token punctuation">.</span>thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctl<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
        <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Runnable</span> task <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> maximumPoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                ctl<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;workQueue size:&quot;</span> <span class="token operator">+</span> workQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThreadPoolExecutor</span> myThreadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> taskNum <span class="token operator">=</span> i<span class="token punctuation">;</span>
            myThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;任务编号：&quot;</span> <span class="token operator">+</span> taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="_15、单机线程池执行断电了应该怎么处理" tabindex="-1"><a class="header-anchor" href="#_15、单机线程池执行断电了应该怎么处理" aria-hidden="true">#</a> 15、单机线程池执行断电了应该怎么处理</h3><details class="hint-container details"><summary>单机线程池执行断电了应该怎么处理？</summary><p>在使用之前就对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，执行中打印过程日志，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销<code>正在处理</code>的已经执行成功的操作。然后重新执行整个阻塞队列。</p><ul><li>也就是说，对阻塞队列持久化</li><li>正在处理任务事务控制</li><li>断电之后正在处理任务的回滚，通过日志恢复该次操作</li><li>服务器重启后阻塞队列中的数据再加载</li></ul></details>`,133),l=[o];function c(i,p){return a(),s("div",null,l)}const u=n(t,[["render",c],["__file","java-thread.html.vue"]]);export{u as default};

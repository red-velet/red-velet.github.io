import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as s,a as n}from"./app-KXX3jVXZ.js";const e={},i=n(`<h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h1><h2 id="一、内存区域" tabindex="-1"><a class="header-anchor" href="#一、内存区域" aria-hidden="true">#</a> 一、内存区域</h2><h3 id="_1、什么是jvm" tabindex="-1"><a class="header-anchor" href="#_1、什么是jvm" aria-hidden="true">#</a> 1、什么是jvm</h3><details class="hint-container details"><summary>说说你理解的jvm?</summary><p><strong>是什么</strong>：JVM就是我们的Java 虚拟机。</p><p><strong>作用</strong>：</p><ol><li>我们书写的Java源代码提供我们的编译器（javac）编译成字节码文件（.class），然后我们的Java虚拟机提供它的指定的字节码文件规范进行解释，翻译成对应的机器指令然后进行运行的。</li><li>我们的Java语言会自动进行垃圾回收，而这也是JVM为我们承担的任务</li></ol><p><strong>特点</strong>：</p><ol><li>它是 Java 语言实现平台无关性的基石（跨平台），只要其他平台有Java虚拟机那就能运行Java语言</li><li>因为只要和 class 的文件格式关联，任何语言，都能被 JVM 运行，例如kotlin编译后也是class文件。</li></ol></details><h3 id="_2、jvm运行过程" tabindex="-1"><a class="header-anchor" href="#_2、jvm运行过程" aria-hidden="true">#</a> 2、jvm运行过程</h3><details class="hint-container details"><summary>说说jvm运行过程？</summary><ol><li><p><strong>类加载</strong>：</p><ul><li><strong>加载（Loading）：</strong> 类加载器加载字节码文件，生成对应的 Class 对象。</li><li><strong>验证（Verification）：</strong> 确保字节码符合 JVM 规范，并且不会对系统造成损害。</li><li><strong>准备（Preparation）：</strong> 为类变量（静态变量）分配内存，并设置默认初始值。</li><li><strong>解析（Resolution）：</strong> 将符号引用转换为直接引用，比如将类和方法的引用转换为内存地址的引用。</li></ul></li><li><p><strong>初始化（Initialization）：</strong></p><ul><li>JVM 在这个阶段执行类构造器 <code>&lt;clinit&gt;()</code> 方法，初始化类变量，执行静态代码块。这个阶段是类加载过程的最后一步，确保类变量被正确初始化。</li></ul></li><li><p><strong>执行字节码（Bytecode Execution）：</strong></p><ul><li>JVM 开始执行程序的主要逻辑，按照字节码指令逐行执行，这是程序的实际运行阶段。</li></ul></li><li><p><strong>垃圾回收（Garbage Collection）：</strong></p><ul><li>JVM 负责管理内存，在程序运行过程中，通过垃圾回收器回收不再使用的对象，释放内存空间。</li></ul></li><li><p><strong>即时编译（Just-In-Time Compilation - JIT）：</strong></p><ul><li>JVM 通过即时编译器将热点代码（频繁执行的部分）转换为本地机器代码，以提高执行效率。</li></ul></li><li><p><strong>优化和监控（Optimization and Profiling）：</strong></p><ul><li>JVM 可能会根据程序的执行情况进行优化，比如内联、去虚拟化等。同时，也会进行性能监控，收集程序运行的信息，用于优化和改进。</li></ul></li><li><p><strong>卸载（Unloading）：</strong></p><ul><li>当类不再被引用或者程序结束时，JVM 可能会卸载不再需要的类，释放相应的内存空间。</li></ul></li></ol></details><h3 id="_3、jvm-后台运行的系统线程主要有哪些" tabindex="-1"><a class="header-anchor" href="#_3、jvm-后台运行的系统线程主要有哪些" aria-hidden="true">#</a> 3、JVM 后台运行的系统线程主要有哪些</h3><details class="hint-container details"><summary>JVM 后台运行的系统线程主要有哪些？</summary><p>JVM 后台运行的系统线程包括：</p><ol><li><p><strong>主线程（Main Thread）：</strong> 这是 Java 应用程序启动时创建的线程，负责执行 <code>main()</code> 方法。它也被称为应用程序的入口点。</p></li><li><p><strong>垃圾回收器线程（Garbage Collector Threads）：</strong> JVM 中的垃圾回收器会有多个线程，每个线程负责执行不同类型的垃圾回收操作。例如，串行垃圾回收器（Serial Garbage Collector）会有一个专门的线程执行垃圾回收，而并行垃圾回收器（Parallel Garbage Collector）可能会使用多个线程并行进行垃圾回收操作。</p></li><li><p><strong>编译器线程（Compiler Threads）：</strong> 当 JVM 使用即时编译器（JIT）将字节码编译成本地机器代码时，会涉及到编译器线程。这些线程负责将热点代码编译成高效的本地代码。</p></li><li><p><strong>信号分发线程（Signal Dispatcher Thread）：</strong> 这个线程负责接收操作系统发送的信号，并将其转发给 JVM 的特定处理程序。</p></li><li><p><strong>周期性任务线程（Periodic Task Threads）：</strong> JVM 中会有一些线程执行周期性的任务，比如执行周期性的垃圾回收或者其他后台任务。</p></li><li><p><strong>Finalizer 线程（Finalizer Thread）：</strong> 这个线程负责执行对象的 <code>finalize()</code> 方法，用于释放对象占用的资源。</p></li><li><p><strong>虚拟机退出线程（VM Shutdown Hook Thread）：</strong> 这个线程用于执行在 JVM 即将关闭时注册的关闭钩子（Shutdown Hooks），可以用来执行一些清理或资源释放操作。</p></li></ol></details><h3 id="_4、jvm的内存区域" tabindex="-1"><a class="header-anchor" href="#_4、jvm的内存区域" aria-hidden="true">#</a> 4、jvm的内存区域</h3><details class="hint-container details"><summary>说说jvm的内存区域是怎么分布的？</summary><p>JVM 内存区域最简单粗暴的划分可以分为<code>堆</code>和<code>栈</code>，当然，按照虚拟机规范，可以划分为：线程私有区和线程共享区</p><blockquote><p>线程私有区：</p></blockquote><ul><li><strong>程序计数器</strong>： <ul><li>是什么：我们可以将其称为 PC 寄存器，是一块较小的内存空间</li><li>有什么作用：用来配合我们的线程执行我们的代码的，是当前线程所执行的字节码的行号指示器。 <ul><li>因为可能会有很多线程都去执行那一段代码，而不同线程执行的时间又不同，执行途中也可能因为阻塞等原因停下，所以它的作用就是记录当前线程执行到哪了</li></ul></li></ul></li><li><strong>栈</strong>： <ul><li><strong>Java 虚拟机栈</strong>： <ul><li>是什么：是线程执行 Java 方法的一个内存模型，也就是说它和我们的方法调用执行有关，栈又是由一个个栈帧组成，每调用一个方法JVM 会同步生成一个栈帧</li><li>有什么作用：栈帧主要就用于记录方法执行过程中相关的数据，例如它里面有局部变量表存储方法调用过程中的创建的局部变量、传入的基础数据类型参数，操作数栈用于方法内的计算，动态连接用于解析对应对象的真实内存。</li></ul></li><li>本地方法栈： <ul><li>是什么，有什么作用：本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务，也就是使用了native标识的方法，比如我们Object类的<code>wait()和notify()方法、clone()方法、getClass()方法</code>。</li></ul></li></ul></li></ul><blockquote><p>线程共享区：</p></blockquote><ul><li><strong>Java 堆</strong>： <ul><li>是什么：从Java程序来看 <ol><li>对于 Java 应用程序来说， 堆是虚拟机所管理的内存中最大的一块</li><li>在虚拟机启动时创建，是被所有线程共享的一块内存区域</li></ol></li><li>是什么：从垃圾回收角度来看 <ol><li>Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作<code>GC 堆</code>。</li><li>现代垃圾收集器大部分都是基于分代收集理论设计的，所以 Java 堆可以划分为<code>新生代</code>（<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>）、<code>老年代</code></li></ol></li><li>作用：但是无论从什么角度看，这个内存区域的唯一目的就是存放对象实例，Java 里<mark>几乎所有的对象实例</mark>都在这里分配内存。</li></ul></li><li><strong>方法区</strong>： <ul><li>是什么和有什么作用：和Java堆类似，它也是各个线程共享的内存区域，主要用于<strong>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据（类常量池、运行时常量池、字符串常量池）</strong>，它是一个逻辑上的实现，具体真正的实现有例如 jdk1.7及其之前使用永久代、jdk1.8及其之后的元空间作为方法区的实现。 <ol><li><p><strong>类常量池：</strong> 类常量池是每个类的一部分，存储了编译时期生成的字面量常量、符号引用等信息。这些信息包括类、方法和接口的名称、字段的名称和描述符、方法的名称和描述符等。<strong>类常量池是在编译时确定的，随着类加载到内存中而被创建</strong>。</p></li><li><p><strong>运行时常量池：</strong> 运行时常量池是类常量池的一部分，它在类加载到内存时被 JVM 所创建，用于存储类加载后的符号引用解析信息、动态生成的常量等。在运行时，它是方法区的一部分。</p></li><li><p><strong>字符串常量池：</strong> 字符串常量池是运行时常量池的一部分，专门用来存储字符串字面量。字符串常量池是 String 类的私有静态成员变量，用于存储在编译期间由双引号引起来的字符串常量。Java 中的字符串常量池具有重用相同字符串的特性，即相同内容的字符串在常量池中只有一份拷贝。</p></li></ol></li></ul></li></ul></details><h3 id="_5、jdk1-6、1-7、1-8-内存区域有什么变化" tabindex="-1"><a class="header-anchor" href="#_5、jdk1-6、1-7、1-8-内存区域有什么变化" aria-hidden="true">#</a> 5、jdk1.6、1.7、1.8 内存区域有什么变化</h3><details class="hint-container details"><summary>jdk在1.6、1.7、1.8历史变化中的内存区域有什么变化吗？</summary><ul><li>JDK1.6： <ol><li>使用永久代实现方法区</li><li>常量池位于永久代</li><li>大小、垃圾回收受JVM管理</li></ol></li><li>JDK1.7： <ol><li>字符串常量池、静态变量，存放在堆上</li><li>类常量池、运行时常量池仍然位于永久代</li><li>大小、垃圾回收受JVM管理</li></ol></li><li>JDK1.8： <ol><li>彻底干掉了永久代，而在<strong>直接内存</strong>中划出一块区域作为<strong>元空间</strong></li><li>类常量池、运行时常量池都移动到元空间。</li><li><strong>自动调整大小：</strong> 元空间的大小可以根据需要动态调整，不再受固定大小的永久代限制。</li><li><strong>受 JVM 管理：</strong> 元空间的管理依然由 JVM 进行，包括垃圾回收：垃圾回收的工作主要针对无用的类元数据信息进行处理，而不是直接回收元空间内存。</li></ol></li></ul></details><h3 id="_6、栈和堆有什么区别" tabindex="-1"><a class="header-anchor" href="#_6、栈和堆有什么区别" aria-hidden="true">#</a> 6、栈和堆有什么区别</h3><details class="hint-container details"><summary>栈和堆有什么区别，你说说看？</summary><blockquote><p>1、功能和作用：</p></blockquote><p>堆主要用来存放对象的，栈主要是用来执行程序的</p><p>（1）栈，可以看成是方法的运行模型，所有方法的调用都是通过栈帧来进行的，而且它是线程私有，JVM会为每个线程都分配一个栈区，JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。当线程进入一个Java方法函数的时候，就会在当前线程的栈里压入一个栈帧，用于保存当前线程的状态（参数、局部变量、中间计算过程和其他数据），当退出函数方法时，修改栈指针就可以把栈中的内容销毁，采用的是后进先出的数据结构，最后调用的方法最先执行完成并退出栈。</p><p>（2）堆，唯一的目的就是用于存放对象实例，每个Java应用都唯一对应一个JVM实例，每个JVM实例都唯一对应一个堆，并由堆内存被应用所有的线程共享。</p><blockquote><p>2、存储数据：</p></blockquote><p>Java中分配堆栈内存是由JVM自动分配和管理的。</p><p>Java中的数据类型有两种：一种是8个基本类型（即int, short, long, byte, float, double, boolean, char），一种是引用类型。</p><p>（1）函数中<strong>基本类型和对象的引用</strong>都是在栈内存中分配。当在一段代码块中定义一个变量时，由于这些变量大小可知，生存期可知，出于追求速度的原因，Java就在栈中为这个变量分配内存空间，当<strong>超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间</strong>。</p><p>（2）对于引用类型：Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配。也就是说在建立一个对象时，从两个地方都分配内存，在堆中分配的内存实际用于建立这个对象，而在栈中分配的内存只是一个指向这个堆对象的引用而已。<strong>在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理，根据判断对象引用</strong>。</p><blockquote><p>3、访问速度：</p></blockquote><ul><li>栈的访问速度比堆快，因为它的分配和释放内存都是有序的，而且大小固定，由JVM指定。</li><li>堆的话看是直接指针还是句柄</li></ul></details><h3 id="_7、为什么使用元空间替代永久代作为方法区的实现" tabindex="-1"><a class="header-anchor" href="#_7、为什么使用元空间替代永久代作为方法区的实现" aria-hidden="true">#</a> 7、为什么使用元空间替代永久代作为方法区的实现</h3><details class="hint-container details"><summary>为什么要使用元空间替代永久代作为方法区的实现呢？</summary><p>为什么使用？ –&gt; 1.肯定之前的有问题 2.现在的和之前的有什么区别</p><ol><li><p>元空间替代永久代后，它的大小不受JVM控制了，那可能是之前永久代来实现方法区的决定的设计导致了 Java 应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize 的上限，即使不设置也有默认大小，而 J9 和 JRockit 只要没有触碰到进程可用内存的上限，例如 32 位系统中的 4GB 限制，就不会出问题），而且有极少数方法 （例如 String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。</p></li><li><p>元空间的内存管理更为灵活，并且不再依赖传统的垃圾回收机制，因此在类加载、卸载等场景下表现更优，能够提供更好的性能和内存管理效果。</p><ol><li>传统的垃圾回收方式主要针对对象实例的回收</li><li>元空间的内存管理更侧重于类元数据的释放，通常是基于类加载器和类的引用关系来进行管理和释放。 <ul><li>当某个类不再被引用或使用，且不再需要时，元空间会进行相应的类卸载，释放相关的内存空间。这种方式与</li></ul></li></ol></li></ol></details><h3 id="_8、jvm中对象的创建的过程" tabindex="-1"><a class="header-anchor" href="#_8、jvm中对象的创建的过程" aria-hidden="true">#</a> 8、jvm中对象的创建的过程</h3><details class="hint-container details"><summary>java对象的创建的过程是怎么样的？</summary><p>在 JVM 中对象的创建，我们从一个 new 指令开始：</p><ol><li>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用</li><li>检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程</li><li>类加载检查通过后，接下来虚拟机将为新生对象分配内存。</li><li>内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。</li><li>接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。</li></ol><p>这个过程大概如下：</p><ol><li><strong>类加载</strong>：加载类的字节码文件到内存，并在方法区创建一个对应的Class对象，用于描述类的结构信息。</li><li><strong>分配内存</strong>：在堆内存中为新创建的对象分配内存空间。</li><li><strong>初始化零值</strong>：将分配的内存空间初始化为零值，即对象的成员变量在此阶段都为默认值（例如，int 类型默认为 0，引用类型默认为 null）。</li><li><strong>设置对象头</strong>：虚拟机会根据对象的类型设置对象头信息，包括对象的哈希码、GC 分代年龄等。</li><li><strong>执行<code>&lt;init&gt;</code>方法</strong>：在构造器方法<code>&lt;init&gt;</code>中进行对象的初始化工作，即根据构造器的实际内容为对象的成员变量赋值。</li></ol></details><h3 id="_9、内存分配的方式有几种" tabindex="-1"><a class="header-anchor" href="#_9、内存分配的方式有几种" aria-hidden="true">#</a> 9、内存分配的方式有几种</h3><details class="hint-container details"><summary>内存分配的方式有几种？</summary><blockquote><p>两种方式的选择由 Java 堆是否规整决定，Java 堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的</p></blockquote><ol><li>指针碰撞：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li>空闲列表：如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li><li></li></ol></details><h3 id="_10、jvm-里-new-对象时-堆会发生抢占吗-jvm-是怎么设计来保证线程安全的" tabindex="-1"><a class="header-anchor" href="#_10、jvm-里-new-对象时-堆会发生抢占吗-jvm-是怎么设计来保证线程安全的" aria-hidden="true">#</a> 10、JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？</h3><details class="hint-container details"><summary>JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？</summary><ol><li>会，假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。</li><li>保证线程安全： <ol><li>每个人先分点零食，零食吃完再吃主食：每个线程在 Java 堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li><li>先预定主食，再尝试购买，如果已售罄，则重新开始购买流程：采用 CAS 分配重试的方式来保证更新操作的原子性</li></ol></li></ol></details><h3 id="_11、说一下对象的内存布局组成结构" tabindex="-1"><a class="header-anchor" href="#_11、说一下对象的内存布局组成结构" aria-hidden="true">#</a> 11、说一下对象的内存布局组成结构</h3><details class="hint-container details"><summary>说一下一个Java对象的组成结构？</summary><blockquote><p>对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充</p></blockquote><ol><li><strong>对象头</strong>主要由两部分组成： <ol><li>第一部分存储对象自身的运行时数据（Mark Word）：它是个动态的结构，随着对象状态变化，包括<code>哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳</code>等</li><li>第二部分是类型指针，<strong>指向对象的类元数据类型</strong>（即对象代表哪个类）。</li><li>此外，如果对象是一个 Java 数组，那还应该有一块用于记录数组长度的数据</li></ol></li><li><strong>实例数据</strong>用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。</li><li><strong>对齐填充</strong>不是必须的，没有特别含义，仅仅起着占位符的作用</li></ol></details><h3 id="_12、访问对象的有几种方式" tabindex="-1"><a class="header-anchor" href="#_12、访问对象的有几种方式" aria-hidden="true">#</a> 12、访问对象的有几种方式</h3><details class="hint-container details"><summary>如果我要访问一个对象的有几种方式？</summary><blockquote><p>句柄和直接指针两种：</p></blockquote><ul><li>句柄访问：Java 堆中将可能会划分出一块内存来作为句柄池，栈中的引用存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 <ul><li>使用句柄来访问的最大好处就是栈中的引用存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而栈中的引用本身不需要被修改。</li><li>句柄池 - 驿站，真实的数据 - 商家厂房，栈中的引用 - 用户取货码</li></ul></li><li>直接指针：栈中的引用存储的直接就是对象地址 <ul><li>速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本</li><li>用户直接根据商家的地址去拿货</li></ul></li></ul></details><h3 id="_13、内存溢出和内存泄漏是什么意思" tabindex="-1"><a class="header-anchor" href="#_13、内存溢出和内存泄漏是什么意思" aria-hidden="true">#</a> 13、内存溢出和内存泄漏是什么意思？</h3><details class="hint-container details"><summary>内存溢出和内存泄漏是什么意思？</summary><p>首先这两个都是属于Java异常体系的error - 错误，是程序无法处理的</p><ul><li>内存泄露：当某一个对象不再有用的时候，占用的内存却不能被回收，就是申请的内存空间没有被正确释放，导致内存被白白占用。</li><li>内存溢出：就是申请的内存超过了可用内存，内存不够了。</li></ul><p>就比如我们去用花呗付款，超过了花呗已使用额度就用不了 - 内存溢出，如果可以使用的额度用换了还不还，那么下个月就没东西用力 - 内存泄漏</p><p>两者关系：内存泄露可能会导致内存溢出</p><hr><blockquote><p>内存泄漏：</p></blockquote><ul><li>静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。</li><li>创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。</li><li>单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。</li><li>hash 值发生变化：如果我们使用的不是不变类型的key，那么对象 Hash 值改变，使用 HashMap、HashSet 等容器中时候，由于对象修改之后的 Hah 值和存储进容器时的 Hash 值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么 String 类型被设置成了不可变类型</li><li><strong>ThreadLocal 使用不当</strong>：ThreadLocal 的弱引用导致内存泄漏，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。</li></ul><blockquote><p>内存溢出：</p></blockquote><p>在 JVM 的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OutOfMemoryError）异常的可能</p><ul><li>Java堆溢出：因为堆用于储存对象实例，只要不断创建不可被回收的对象，比如我们可以创建一个ArrayList集合，一直while循环添加静态内部类对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生OOM。</li><li>Java栈溢出：因为堆是由一个个栈中组成，如果我们使用一个方法内总是无限制条件递归调用本方法，那么就会触发栈溢出。</li><li>Java方法区溢出： <ul><li><strong>大量动态生成类：</strong> 比如使用CGLIB、ASM等字节码生成工具，如果持续不断地生成新的类，方法区可能会耗尽。</li><li><strong>大量常量池：</strong> 如果不断往常量池添加数据，可能导致方法区溢出。这种情况通常发生在运行时大量动态生成字符串常量或者类加载器大量加载类的场景。</li><li><strong>持续不断的加载类：</strong> 在动态加载大量类文件时，如果无法及时回收不再使用的类，也可能导致方法区溢出。</li></ul></li></ul></details><h2 id="二、垃圾回收" tabindex="-1"><a class="header-anchor" href="#二、垃圾回收" aria-hidden="true">#</a> 二、垃圾回收</h2><h3 id="_1、如何判断对象是垃圾-对象是否死亡-有什么方法" tabindex="-1"><a class="header-anchor" href="#_1、如何判断对象是垃圾-对象是否死亡-有什么方法" aria-hidden="true">#</a> 1、如何判断对象是垃圾，对象是否死亡，有什么方法</h3><details class="hint-container details"><summary>如何判断对象是垃圾，对象是否死亡，有什么方法？</summary><blockquote><p>引用计数算法和可达性分析算法：</p></blockquote><ul><li><strong>引用计数算法</strong>：每个对象中都维护了一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</li><li><strong>可达性分析算法</strong>：实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</li></ul><blockquote><p>废弃常量、类：</p></blockquote><p>有两种常见的垃圾回收策略分别用于判断常量和类的是否无用：根引用和类加载器。</p><ol><li>废弃常量判断： 在Java中，常量池中的常量可能会成为废弃常量，如果这些常量不再被任何活动对象或类所引用，那么它们可以被判定为废弃常量。垃圾回收器在清理常量池时，会考虑这些废弃常量并将其回收。</li><li>无用类判断： 判断一个类是否是无用的，通常涉及到类加载器和类引用链的分析。如果一个类满足以下条件，则可以判定为无用类： <ul><li>该类的所有实例都已经被回收，即没有任何对象是该类的实例。</li><li>该类的<code>Class</code>对象没有被引用，即没有任何代码通过反射调用该类的方法或访问其字段。</li><li>该类所在的<code>ClassLoader</code>已经被回收，即该类的<code>ClassLoader</code>没有存在的必要，没有其他类需要加载。</li></ul></li></ol></details><h3 id="_2、java-中可作为-gc-roots-的对象有哪几种" tabindex="-1"><a class="header-anchor" href="#_2、java-中可作为-gc-roots-的对象有哪几种" aria-hidden="true">#</a> 2、Java 中可作为 GC Roots 的对象有哪几种</h3><details class="hint-container details"><summary>Java 中可作为 GC Roots 的对象有哪几种？</summary><blockquote><p>可以作为 GC Roots 的主要有四种对象：</p></blockquote><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI 引用的对象</li></ul></details><h3 id="_3、说一下对象有哪几种引用" tabindex="-1"><a class="header-anchor" href="#_3、说一下对象有哪几种引用" aria-hidden="true">#</a> 3、说一下对象有哪几种引用</h3><details class="hint-container details"><summary>说一下Java中对象有哪几种引用方式？</summary><blockquote><p>Java 中的引用有四种，分为强引用、软引用、弱引用和虚引用4 种，强度依次逐渐减弱。</p></blockquote><ul><li>强引用是最传统的<code>引用</code>的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象，<strong>不可达才会被回收</strong>。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用，<strong>内存不足才会被回收</strong>。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ReferenceQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//强引用对象滞空，保留软引用</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用，<strong>一定被回收</strong>。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ReferenceQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WeakReference</span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//强引用对象滞空，保留软引用</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用，<strong>一定被回收</strong>。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ReferenceQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//强引用对象滞空，保留软引用</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="_4、finalize-方法了解吗-有什么作用" tabindex="-1"><a class="header-anchor" href="#_4、finalize-方法了解吗-有什么作用" aria-hidden="true">#</a> 4、finalize()方法了解吗？有什么作用</h3><details class="hint-container details"><summary>finalize()方法了解吗？有什么作用？</summary><p>垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。</p><ul><li>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。</li><li>如果对象在在 finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。</li></ul></details><h3 id="_5、java-堆的内存分区了解吗" tabindex="-1"><a class="header-anchor" href="#_5、java-堆的内存分区了解吗" aria-hidden="true">#</a> 5、Java 堆的内存分区了解吗</h3><details class="hint-container details"><summary>Java 堆的内存分区了解吗？</summary><blockquote><p>按照垃圾收集角度：</p></blockquote><p>Java 堆划分为<strong>新生代 <strong>和</strong>老年代</strong>两个区域</p><ul><li><strong>新生代</strong>：eden、from、to，比例是 8：1：1 <ul><li><strong>Eden空间</strong>：是对象最初分配的区域。大多数对象都是在这里被创建的。</li><li><strong>Survivor空间</strong>：包括两个区域，一般分别称为from和to。在新生代的垃圾收集过程中，存活下来的对象会被移动到这两个Survivor区域之一。</li><li>新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</li></ul></li><li><strong>老年代</strong>： <ul><li>主要存放存活时间较长的对象，所以垃圾收集频率较低</li><li>如从新生代晋升过来的对象或者是大对象直接分配到老年代。</li></ul></li></ul></details><h3 id="_6、minor-gc、major-gc、mixed-gc、full-gc-都是什么意思" tabindex="-1"><a class="header-anchor" href="#_6、minor-gc、major-gc、mixed-gc、full-gc-都是什么意思" aria-hidden="true">#</a> 6、Minor GC、Major GC、Mixed GC、Full GC 都是什么意思</h3><details class="hint-container details"><summary>Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC 都是什么意思?</summary><p><strong>部分收集</strong>（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：</p><ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前<strong>只有CMS 收集器</strong>会有单独收集老年代的行为。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前<strong>只有 G1 收集器</strong>会有这种行为。</li></ul><p><strong>整堆收集</strong>（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p></details><h3 id="_7、minor-gc和full-gc-什么时候触发" tabindex="-1"><a class="header-anchor" href="#_7、minor-gc和full-gc-什么时候触发" aria-hidden="true">#</a> 7、Minor GC和Full GC 什么时候触发</h3><details class="hint-container details"><summary>Minor GC/Young GC 和 Full GC什么时候触发</summary><blockquote><p>Minor GC/Young GC：</p></blockquote><p>新创建的对象优先在新生代 Eden 区进行分配，如果 Eden 区没有足够的空间时，就会触发 Young GC 来清理新生代。</p><blockquote><p>FullGC：</p></blockquote><ul><li><strong>Young GC 之前检查老年代</strong>：在要进行 Young GC 的时候，发现<code>老年代可用的连续内存空间</code> &lt; <code>新生代历次Young GC后升入老年代的对象总和的平均大小</code>，说明本次 Young GC 后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。</li><li><strong>Young GC 之后老年代空间不足</strong>：执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次 Full GC</li><li><strong>老年代空间不足</strong>，老年代内存使用率过高，达到一定比例，也会触发 Full GC。</li><li><strong>空间分配担保失败</strong>（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。</li><li><strong>方法区内存空间不足</strong>：如果方法区由永久代实现，永久代空间不足 Full GC。</li><li><strong>System.gc()等命令触发</strong>：System.gc()、jmap -dump 等命令会触发 full gc。</li></ul></details><h3 id="_8、对象什么时候会进入老年代" tabindex="-1"><a class="header-anchor" href="#_8、对象什么时候会进入老年代" aria-hidden="true">#</a> 8、对象什么时候会进入老年代</h3><details class="hint-container details"><summary>对象什么时候会进入老年代？</summary><blockquote><p>长期存活的对象将进入老年代：</p></blockquote><p>在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次 YoungGC 之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到 15(默认)之后,这个对象将会被移入老年代。</p><p>可以通过这个参数设置这个年龄值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span> <span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxTenuringThreshold</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>大对象直接进入老年代：</p></blockquote><p>有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。</p><p>HotSpot 虚拟机提供了这个参数来设置。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span>：<span class="token class-name">PretenureSizeThreshold</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>动态对象年龄判定：</p></blockquote><p>为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><blockquote><p>空间分配担保</p></blockquote><p>假如在 Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。</p></details><h3 id="_9、你能说说young-gc和full-gc的过程吗" tabindex="-1"><a class="header-anchor" href="#_9、你能说说young-gc和full-gc的过程吗" aria-hidden="true">#</a> 9、你能说说young gc和full gc的过程吗</h3><details class="hint-container details"><summary>详情</summary><p>当谈到垃圾回收（Garbage Collection，GC）时，通常会涉及到两种主要类型的垃圾回收过程：Young Generation GC和Full GC。这两种过程都是Java虚拟机（JVM）用来管理内存的一部分。</p><ol><li><p>Young Generation GC（年轻代垃圾回收）：<br> 在JVM中，堆内存被划分为不同的区域，其中年轻代（Young Generation）通常是对象被创建后的初始分配区域。它又分为Eden空间和两个Survivor空间（通常称为S0和S1）。在年轻代GC中，新创建的对象首先被分配到Eden空间。当Eden空间满了之后，会触发一次年轻代GC。</p><p>年轻代GC的过程包括：</p><ul><li>将存活的对象从Eden空间和Survivor空间移动到另一个Survivor空间，同时进行年龄计数（对象每经历一次年轻代GC，年龄加一）。</li><li>当对象的年龄达到一定阈值时，会被移动到年老代（Old Generation）。</li><li>未被引用的对象会被标记为垃圾并清理掉，释放内存。</li></ul></li><li><p>Full GC（完全垃圾回收）：<br> Full GC涉及整个堆内存，包括年轻代和年老代。它的触发条件包括：</p><ul><li>年轻代没有足够空间容纳存活的对象。</li><li>年老代空间不足。</li><li>显式调用<code>System.gc()</code>。</li></ul><p>Full GC的过程包括：</p><ul><li>首先进行年轻代GC，清理年轻代中的垃圾。</li><li>然后，对整个堆内存进行检查和清理，包括年轻代和年老代。这是一个相对耗时的过程，因为它需要对整个堆内存进行遍历和处理。</li></ul></li></ol></details><h3 id="_10、跨代引用问题" tabindex="-1"><a class="header-anchor" href="#_10、跨代引用问题" aria-hidden="true">#</a> 10、跨代引用问题</h3><details class="hint-container details"><summary>什么是跨代引用问题？</summary><p>假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担</p><p>跨代引用相对于同代引用来说仅占极少数，不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为记忆集，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用）<br> 此后当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的</p><p>记忆集（Remembered Set)：一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，在对象层面来说就是非收集区域对象对收集区域对象的引用的记录</p><p>它存放在收集区域，比如在新生代里面存放着老年代对新生代对象的每一个引用。这样在收集新生代的时候，我们就可以根据记忆集知道哪些对象被老年代对象所引用，不能回收，这就解决了跨代引用的问题</p><ul><li>卡表（Card Table）：是以卡精度的方式实现的记忆集，也是目前最常用的方式。记忆集是抽象的概念，而卡表就是记忆集的一种具体实现</li><li>在 HotSpot 虚拟机里是通过写屏障技术维护卡表状态的。写屏障可以看作在虚拟机层面对 <strong>引用类型字段赋值</strong> 这个动作的 AOP 切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内</li></ul></details><h3 id="_11、空间分配担保机制" tabindex="-1"><a class="header-anchor" href="#_11、空间分配担保机制" aria-hidden="true">#</a> 11、空间分配担保机制</h3><details class="hint-container details"><summary>什么是空间分配担保机制？</summary><p><strong>1.谁进行空间担保？</strong></p><p>JVM使用分代收集算法，将堆内存划分为年轻代和老年代，两块内存分别采用不同的垃圾回收算法，空间担保指的是老年代进行空间分配担保</p><p><strong>2.什么是空间分配担保？</strong></p><p>在发生<strong>Minor GC</strong>之前，虚拟机会检查<strong>老年代最大可用的连续空间</strong>是否<strong>大于新生代所有对象的总空间</strong>，</p><p>如果大于，则此次<strong>Minor GC是安全的</strong></p><p>如果小于，则虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于<strong>历次晋升到老年代的对象的平均大小</strong>，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</p><p><strong>3.为什么要进行空间担保？</strong></p><p>是因为新生代采用<strong>复制收集算法</strong>，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。<strong>老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象</strong>，但一共有多少对象在内存回收后存活下来是不可预知的，<strong>因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考</strong>。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p></details><h3 id="_13、垃圾收集算法了解吗" tabindex="-1"><a class="header-anchor" href="#_13、垃圾收集算法了解吗" aria-hidden="true">#</a> 13、垃圾收集算法了解吗</h3><details class="hint-container details"><summary>垃圾收集算法有了解吗？</summary><p>垃圾收集算法主要有三类：</p><ol><li><p><strong>标记-清除算法</strong><code>标记-清除</code>（Mark-Sweep）算法分为两个阶段：</p><ul><li><p><strong>标记</strong> : 标记出所有需要回收的对象</p></li><li><p><strong>清除</strong>：回收所有被标记的对象</p><ul><li>缺点： <ol><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li><li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li></ol></li></ul></li></ul></li><li><p><strong>标记-复制算法</strong>：解决了标记-清除算法面对大量可回收对象时执行效率低的问题。</p><ul><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</li><li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 <ul><li>缺点：存在空间的浪费，新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。</li></ul></li></ul></li><li><p><strong>标记-整理算法</strong>：为了降低内存的消耗，引入的一种针对性的算法：</p><ul><li>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</li><li>主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要 Stop The World 才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。</li></ul></li></ol></details><h3 id="_14、你了解垃圾回收器有哪些-详细介绍一下" tabindex="-1"><a class="header-anchor" href="#_14、你了解垃圾回收器有哪些-详细介绍一下" aria-hidden="true">#</a> 14、你了解垃圾回收器有哪些，详细介绍一下？</h3><details class="hint-container details"><summary>你了解垃圾回收器有哪些，详细介绍一下？</summary><blockquote><p>根据进行垃圾回收的不同地点，也就是它们的工作区域分为不同的垃圾回收器：</p></blockquote><ul><li><strong>针对的新生代进行young gc的</strong>： <ul><li>serial、ParNew、Parallel Scavenge（GCTimeRatio、UseAdaptSizePolicy可控制吞吐量 = 运行代码时间 / （运行代码时间 + 垃圾回收时间））都是标记复制算法</li></ul></li><li><strong>针对的老年代进行old gc的</strong>： <ul><li>serial old标记整理、Parallel Old标记整理、cms标记清除</li></ul></li><li><strong>针对新手代和老年代mixed gc的</strong>：G1标记清除、标记整理</li></ul></details><h3 id="_15、说一下cms垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_15、说一下cms垃圾回收器" aria-hidden="true">#</a> 15、说一下cms垃圾回收器？</h3><details class="hint-container details"><summary>详情</summary><p><strong>CMS（Concurrent Mark Sweep）收集器是一种主打的就是并发和减少回收停顿时间为目标的收集器。它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong></p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；它就是仅仅把gc roots对象能连到的对象加入到扫描栈中。</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。加入到扫描栈中的对象，（栈中引用的对象、方法区的静态属性、常量等引用对象，本地方法栈的引用对象），以这些对象触发，遍历整个堆内存的一个存活对象的对象图，把所有存活标记 <ul><li>但这存在一个对象消失问题：扫描过程中插入了一条或多条从黑色对象到白色对象的新引用，并且同时去掉了灰色对象到该白色对象的直接引用或者间接引用。 <ul><li>增量更新：黑色对象插入白色引用，就记录一下引用关系，等到并发标记后，再重写扫描一遍</li><li>原始快照：把删除的引用记录下路，再次扫描有没有删除</li></ul></li></ul></li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul></details><h3 id="_16、什么是strop-the-world-有哪些区域需要停顿-为什么要停顿-什么是-oopmap-什么是安全点" tabindex="-1"><a class="header-anchor" href="#_16、什么是strop-the-world-有哪些区域需要停顿-为什么要停顿-什么是-oopmap-什么是安全点" aria-hidden="true">#</a> 16、什么是Strop The World？ 有哪些区域需要停顿，为什么要停顿？什么是 OopMap ？什么是安全点</h3><details class="hint-container details"><summary>详情</summary><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为<code>Stop The World</code>。也简称为 STW。</p><p>在 HotSpot 中，有个数据结构（映射表）称为<code>OopMap</code>。一旦类加载动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，记录到 OopMap。在即时编译过程中，也会在<code>特定的位置</code>生成 OopMap，记录下栈上和寄存器里哪些位置是引用。</p><p>这些特定的位置主要在：</p><ul><li>1.循环的末尾（非 counted 循环）</li><li>2.方法临返回前 / 调用方法的 call 指令后</li><li>3.可能抛异常的位置</li></ul><p>这些位置就叫作<strong>安全点(safepoint)。</strong> 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。</p><p>用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。</p></details><h3 id="_17、三色标记法了解吗-在哪使用的-为什么要引入" tabindex="-1"><a class="header-anchor" href="#_17、三色标记法了解吗-在哪使用的-为什么要引入" aria-hidden="true">#</a> 17、三色标记法了解吗，在哪使用的，为什么要引入</h3><details class="hint-container details"><summary>三色标记法了解吗，在哪使用的，为什么要引入？</summary><blockquote><p>什么是？在哪使用的？为什么要引入？</p></blockquote><p>三色标记法主要用于并发标记阶段，用于实现<strong>并发垃圾回收器中的增量标记</strong>，例如在Java虚拟机的并发标记-清除（CMS）垃圾回收器中。</p><ul><li>并发标记是指在垃圾回收的过程中，能够允许程序继续执行，而不需要完全暂停程序的运行。这对于大型应用和需要高吞吐量的场景非常重要，以减少停顿时间。</li></ul><blockquote><p>三色标记法的核心思想：将对象的标记状态分为三个不同的颜色(白色、灰色和黑色)</p></blockquote><ol><li>白色：表示对象尚未被访问，即从根节点出发还没有遍历到的对象。</li><li>灰色：表示对象已经被访问，但其引用的其他对象还未被访问。</li><li>黑色：表示对象已经被访问，并且其引用的其他对象也都被访问过。</li></ol><p>在并发标记阶段，初始时所有的对象都是白色的。标记从根对象（如栈中的对象引用）开始，将根对象标记为灰色，然后逐步遍历灰色对象的引用，将被引用的对象标记为灰色，而引用被完全遍历后则标记为黑色。</p><p>三色标记法的引入主要是为了在并发标记的过程中解决引用关系变化的问题。由于并发环境中，对象的引用关系可能会发生变化，即对象可能被添加或删除引用。使用三色标记法，可以通过将对象标记为灰色来识别正在遍历的对象，从而确保即使引用关系变化，也能正确地标记和遍历对象。</p></details><h3 id="_18、g1垃圾收集器了解吗-详细说说-g1中为什么划分region" tabindex="-1"><a class="header-anchor" href="#_18、g1垃圾收集器了解吗-详细说说-g1中为什么划分region" aria-hidden="true">#</a> 18、g1垃圾收集器了解吗，详细说说 ？G1中为什么划分Region</h3><details class="hint-container details"><summary>g1垃圾收集器了解吗，详细说说 ？G1中为什么划分Region？</summary><p>g1，垃圾第一，它相对传统的垃圾回收器不同，它是一个全年代的垃圾回收器，他一个人就能负责新生代和老年代的垃圾回收。</p><p>g1最大的特点就是它对对内存的划分模式和之前的所有垃圾回收器都不一样，之前谈到过是基于分代回收，会把堆空间分为新生代和老年代，1：3，它会进行整个进行物理划分，分为两个模块，而G1呢，是直接将整个堆空间切成一个一个的小内存，而不像之前切成两份，</p><p>每个小内存的大小相等，把一个豆腐切成小块，一个小块叫做一个region区域，虽然不像一切一刀切成两半，但是他还保存了新生代和老年代的概念，其实就是说每个region他都是属于新生代或者老年代的，这样呢，只不过每个region是一快一块的，所以说整个新生代可能不是一块连续的物理地址，而是各个region块组成的新生代，老年代同样如此，总结就是取消了物理的分代，而是将堆内存划分为多个大小相等的region区域，每个region通过组合来形成代。</p><p>g1最大的特点就是可以设置一个垃圾回收的停顿的一个预期时间，比如说我们可以制定她在一个小时内发生stw时间不超过一分钟。</p><p>region就是一块内存空间，它就可能会产生垃圾，所以说每个region都可能会产生垃圾他都是回收的目标，所以说每个都维护了一个隐藏属性，被称为回收价值，回收价值就是说根据region内部垃圾的一个比率，对象存活率，回收的一个预期时间等等进行评估得到一个指数，那g1呢，通过跟踪每个region块的回收价值，这样就可以尽可能的把垃圾回收造成影响控制在一个可控范围内，同时呢，尽量在有限的时间内回收更多的垃圾。之前物理划分的时候，你肯定就是回收整个代码，你不能说cms进行回收的时候，只回收一部分，它会扫描整个老年代，而g1可以跟踪region的价值，组合一些region，比如我这次要回收新生代，我就组合一些最有回收价值的region，对它进行回收，而不是对整个内存进行回收，时间优势是建立在逻辑分代上。</p><p>而且每个region是动态变化的，它既可以是新生代，也可能是老年代，刚开始的时候都不属于，是空白的，然后就会将region分为新生代，新生代在做垃圾回收的时候，采用的是复制算法，复制算法会把整个区域内的对象拷贝走，再将整个区域清空，清空之后呢，整个区域就可能被选为老年代，所以说g1对象内存模型中，region所属的年龄是动态变化的，新生代和老年代的区域也是在动态变化的，这一切都是g1进行的自动控制的，所以到这呢，g1就没有新生代多少空间，老年代多少空间。这个概念了。</p></details><h3 id="_19、g1的工作流程是怎么样的-详细展开" tabindex="-1"><a class="header-anchor" href="#_19、g1的工作流程是怎么样的-详细展开" aria-hidden="true">#</a> 19、g1的工作流程是怎么样的，详细展开</h3><details class="hint-container details"><summary>详情</summary><ul><li><p>新生代：</p><ol><li>默认2048个region，数量-新生代-5%，100个（8eden：2surivior）</li><li>新生代的region占比到达60%进行垃圾回收，复制算法-stw，200ms</li><li>晋升老年代：经过多次复制后达到年龄阈值；动态年龄判断</li><li>g1提供称为humongous的region区去存放大对象</li></ol></li><li><p>老年代：老年代的region占比到达45%-900多个触发混合回收（humongous、新生代、老年代垃圾回收）- 复制算法，</p></li></ul><hr><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</p><p><strong>并发标记：</strong> 新增对象，发生引用关系变化 - 原始快照 - 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p><p><strong>最终标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p><p><strong>混合回收：</strong> 计算各个region区域的回收价值，然后stw，选择新生代、老年代、大对象的最具回收价值，通过复制算法进行回收</p><ul><li>分多次做完：比如一次要回收240个region，会分八次，避免回收时间过长</li></ul></details><h3 id="_20、cms和g1有什么区别" tabindex="-1"><a class="header-anchor" href="#_20、cms和g1有什么区别" aria-hidden="true">#</a> 20、CMS和G1有什么区别</h3><details class="hint-container details"><summary>CMS和G1有什么区别/为什么要引入G1？</summary><blockquote><p>为什么有了 CMS，为什么还要引入 G1？</p></blockquote><p>优点：CMS 最主要的优点在名字上已经体现出来——并发收集、低停顿。</p><p>缺点：CMS 同样有三个明显的缺点。</p><ul><li>Mark Sweep 算法会导致内存碎片比较多</li><li>CMS 的并发能力比较依赖于 CPU 资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。</li><li>并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。</li></ul><p>G1 主要解决了内存碎片过多的问题</p><blockquote><p>CMS和G1有什么区别：</p></blockquote><ol><li>内存布局：CMS是只针对老年代的，也是基于分代回收，而G1则是使用Region块，是针对整个对空间，没有分代的概念，G1-垃圾第一，动态地选择垃圾最多的区域进行回收，以达到更好的垃圾回收效果。</li><li>回收过程：CMS会产生内存碎片，需要搭配serial old使用，而G1不会。</li></ol></details><h3 id="_21、垃圾收集器应该如何选择" tabindex="-1"><a class="header-anchor" href="#_21、垃圾收集器应该如何选择" aria-hidden="true">#</a> 21、垃圾收集器应该如何选择？</h3><details class="hint-container details"><summary>垃圾收集器应该如何选择？</summary><blockquote><p>基于垃圾收集器的特点：</p></blockquote><ul><li>Serial ：如果应用程序有一个很小的内存空间（大约 100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。</li><li>Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受 1 秒或更长的停顿时间。</li><li>CMS/G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约 1 秒以内。</li><li>ZGC：如果响应时间是高优先级的，或者堆空间比较大。</li></ul></details><h2 id="三、类加载" tabindex="-1"><a class="header-anchor" href="#三、类加载" aria-hidden="true">#</a> 三、类加载</h2><h3 id="_1、类加载过程和类的生命周期" tabindex="-1"><a class="header-anchor" href="#_1、类加载过程和类的生命周期" aria-hidden="true">#</a> 1、类加载过程和类的生命周期</h3><details class="hint-container details"><summary>详情</summary><blockquote><p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段</p></blockquote><p>加载 、链接（验证、准备、解析）、初始化 、使用、卸载。</p><ol><li><p><strong>加载</strong>：</p><ol><li><p>通过一个类的全限定名获取该类的二进制流。</p></li><li><p>将该二进制流中的静态存储结构转化为方法去运行时数据结构。</p></li><li><p>在内存中生成该类的 Class 对象，作为该类的数据访问入口。</p></li></ol></li><li><p><strong>验证</strong>：确保 Class 文件的字节流中的信息不回危害到虚拟机</p><ul><li>文件格式验证：验证字节流是否符合 Class 文件的规范，如 主次版本号是否在当前虚拟机范围内，常量池中的常量是否 有不被支持的类型.</li><li>元数据验证：对字节码描述的信息进行语义分析，如这个类是 否有父类，是否集成了不被继承的类等。</li><li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验 证数据流和控制流的分析，确定程序语义是否正确，主要针 对方法体的验证。如：方法中的类型转换是否正确，跳转指 令是否正确等。</li><li>符号引用验证：这个动作在后面的解析过程中发生，主要是 为了确保解析动作能正确执行。</li></ul></li><li><p><strong>准备</strong>：为类的静态变量分配内存并将其初始化为默认值，这些 内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆 中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span><span class="token comment">//在准备阶段 value 初始值为 0 。在初始化阶段才会变为 123 。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>解析</strong>：将符号引用到直接引用的转换动作。解析动作并不一 定在初始化动作完成之前，也有可能在初始化之后。</p></li><li><p><strong>初始化</strong>：前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，这里就是我们自己的主场了，这里才真正开始执行类中定义的 Java 程序代码（静态代码块）。</p></li></ol></details><h3 id="_2、哪些时候会触发类加载" tabindex="-1"><a class="header-anchor" href="#_2、哪些时候会触发类加载" aria-hidden="true">#</a> 2、哪些时候会触发类加载？</h3><details class="hint-container details"><summary>详情</summary><p>类加载是Java虚拟机在运行时将类的字节码文件加载到内存中并转化为可执行的类对象的过程。类加载可以在以下情况下触发：</p><ol><li><p><strong>首次访问类：</strong> 当程序首次访问一个类时，如果该类还没有被加载到内存中，就会触发类加载。这包括通过<code>new</code>关键字创建对象、调用静态方法、访问静态变量等操作。</p></li><li><p><strong>类继承关系：</strong> 当一个类继承自另一个类，子类在首次被访问时，父类也会被加载。同样，接口的实现类也会在首次被访问时加载。</p></li><li><p><strong>类引用：</strong> 如果在代码中通过类名引用了某个类的静态成员（如静态方法、静态变量），这会触发类的加载。</p></li><li><p><strong>显式调用：</strong> 可以使用<code>Class.forName()</code>方法显式地加载一个类。</p></li><li><p><strong>反射：</strong> 使用Java的反射机制，如<code>Class.forName()</code>、<code>ClassLoader.loadClass()</code>等方法，可以在运行时加载类。</p></li><li><p><strong>初始化子类：</strong> 如果一个类的子类初始化了，父类也会被初始化。</p></li><li><p><strong>启动类加载器：</strong> Java虚拟机的启动类加载器会加载Java标准库的类，以及其他被虚拟机认为是基础类的类。</p></li></ol><p>需要注意的是，并不是所有的类在程序启动时都会被加载，而是根据类的访问情况和程序的运行情况来动态地加载。加载的类会经过加载、连接（验证、准备、解析）和初始化等阶段，最终生成可执行的类对象，供程序运行时使用。</p></details><h3 id="_3、类加载器有哪些" tabindex="-1"><a class="header-anchor" href="#_3、类加载器有哪些" aria-hidden="true">#</a> 3、类加载器有哪些</h3><details class="hint-container details"><summary>你知道的类加载器有哪些？</summary><blockquote><p>主要有四种类加载器:</p></blockquote><ul><li><strong>启动类加载器</strong>(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。</li><li><strong>扩展类加载器</strong>(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li><strong>系统类加载器</strong>（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li><strong>用户自定义类加载器</strong> (user class loader)，用户通过继承 java.lang.ClassLoader 类的方式自行实现的类加载器。</li></ul></details><h3 id="_4、创建对象有几种方式" tabindex="-1"><a class="header-anchor" href="#_4、创建对象有几种方式" aria-hidden="true">#</a> 4、创建对象有几种方式？</h3><details class="hint-container details"><summary>创建一个Java对象有几种方式？</summary><p>new、反射获取className -&gt; Class对象、克隆（深拷贝）、序列化和反序列化</p></details><h3 id="_5、什么是双亲委派机制" tabindex="-1"><a class="header-anchor" href="#_5、什么是双亲委派机制" aria-hidden="true">#</a> 5、什么是双亲委派机制</h3><details class="hint-container details"><summary>什么是双亲委派机制？为什么要使用？</summary><blockquote><p>双亲委派模型的工作过程：</p></blockquote><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p><blockquote><p>为什么要使用：</p></blockquote><ul><li><p>为了保证应用程序的稳定有序。</p></li><li><p>例如类 java.lang.Object，它存放在 rt.jar 之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证 Object 的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类。</p></li></ul><p><strong>好处：</strong></p><ol><li><strong>安全性：</strong> 使用双亲委派机制可以防止恶意类替换系统核心类，因为核心类通常由启动类加载器加载，而用户自定义的类由应用类加载器加载，这样恶意类无法通过类加载器的层次结构来替代核心类。</li><li><strong>类的隔离性：</strong> 双亲委派机制可以确保不同的类加载器加载不同的类，从而实现类的隔离，避免了类的冲突和混淆。</li><li><strong>重用性：</strong> 可以有效地利用已加载的类，减少内存占用和性能开销，因为父加载器加载的类对子加载器是可见的，但子加载器加载的类对父加载器不可见。</li></ol><p><strong>坏处：</strong></p><ol><li><p><strong>限制性：</strong> 双亲委派机制会限制某些特定的类加载需求，比如一些应用可能需要在运行时动态加载一些类，而这在双亲委派机制下可能变得复杂。</p></li><li><p><strong>热更新问题：</strong> 在某些场景下，如热更新，可能需要打破双亲委派机制，导致一些类加载冲突和安全性问题。</p></li><li><p><strong>性能开销：</strong> 双亲委派机制可能在类加载过程中引入一些性能开销，因为需要逐级向上查找父加载器是否已加载该类。</p></li></ol></details><h3 id="_6、打破双亲委派怎么操作" tabindex="-1"><a class="header-anchor" href="#_6、打破双亲委派怎么操作" aria-hidden="true">#</a> 6、打破双亲委派怎么操作</h3><details class="hint-container details"><summary>打破双亲委派怎么操作？有什么具体案例？</summary><p>打破双亲委派机制意味着在自定义类加载器中实现一种类加载机制，不再严格遵循传统的双亲委派模型。这可以通过继承<code>ClassLoader</code>类并重写<code>loadClass</code>方法来实现。在重写的方法中，可以根据自定义的逻辑来加载类，而不是一味地向上委托给父加载器。</p><p>Tomcat打破双亲委派机制主要是为了解决类加载隔离和动态模块化的问题。Tomcat是一个Servlet容器，用于运行Java Web应用程序，每个Web应用程序都有自己的类加载器，它们可以独立加载和管理各自的类库。这种隔离性是非常重要的，因为不同的Web应用程序可能使用不同版本的类库，如果不进行隔离，可能会出现类冲突和版本不兼容的问题。</p><p>在传统的双亲委派机制下，类加载器在加载类时会委托给父类加载器去尝试加载，这可能会导致类库的冲突，特别是在多个Web应用程序同时运行的情况下。为了解决这个问题，Tomcat引入了自定义的类加载机制，具体体现在以下几个方面：</p><ol><li><p><strong>Web应用程序的类加载器隔离：</strong> 每个Web应用程序都有自己的类加载器，它们之间是相互隔离的，不会互相影响。这意味着每个Web应用程序可以独立加载和管理它所需的类库，从而避免了类冲突和版本不一致的问题。</p></li><li><p><strong>打破双亲委派：</strong> Tomcat打破了双亲委派机制，即在加载Web应用程序的类时，不再委托给父类加载器。这样做的目的是让每个Web应用程序可以自己控制类的加载过程，不受其他Web应用程序的影响。</p></li><li><p><strong>Common类加载器：</strong> Tomcat引入了一个称为Common类加载器的特殊类加载器，用于加载Tomcat本身的类库，这些类库是所有Web应用程序共享的。这样可以减少重复加载，提高资源利用率。</p></li></ol><p>每个应用都有自己的类加载器，优先使用自己的，再引入一个公共类加载器加载tomcat本身的</p><p>总的来说，Tomcat打破双亲委派机制是为了在Servlet容器中实现类加载的隔离性，确保每个Web应用程序都能独立加载和管理类库，避免类冲突和版本不兼容的问题。</p></details><h3 id="_7、tomcat-的类加载机制" tabindex="-1"><a class="header-anchor" href="#_7、tomcat-的类加载机制" aria-hidden="true">#</a> 7、Tomcat 的类加载机制</h3><details class="hint-container details"><summary>Tomcat 的类加载机制了解吗？</summary><blockquote><p>Tomcat 实际上也是破坏了双亲委派模型的。</p></blockquote><p>Tomact 是 web 容器，我们可以在tomcat的webapp目录下面部署多个应用程序。但是不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。</p><ul><li><p>如多个应用都要依赖 mysql-connecter.jar，但是 A 应用需要依赖 5.0 版本，但是 B 应用需要依赖 5.7 版本。这两个版本中都有一个类是 com.mysql.jdbc.Driver。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。</p></li><li><p>所以，Tomcat 破坏了<strong>双亲委派原则</strong>，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。每一个 WebAppClassLoader 负责加载本身的目录下的 class 文件，加载不到时再交 CommonClassLoader 加载，这和双亲委派刚好相反。</p><ul><li>在每个应用程序的<code>WEB-INF/lib</code>目录下放置应用程序所需的第三方类库，这些类库只对该应用程序可见，避免了全局类库版本冲突。</li><li>使用<code>WEB-INF/classes</code>目录放置应用程序的自定义类。</li></ul></li></ul></details><h2 id="四、jvm调优" tabindex="-1"><a class="header-anchor" href="#四、jvm调优" aria-hidden="true">#</a> 四、JVM调优</h2><h3 id="_1、常用的命令行性能监控和故障处理工具" tabindex="-1"><a class="header-anchor" href="#_1、常用的命令行性能监控和故障处理工具" aria-hidden="true">#</a> 1、常用的命令行性能监控和故障处理工具</h3><details class="hint-container details"><summary>有哪些常用的命令行性能监控和故障处理工具？</summary><blockquote><p>操作系统工具：</p></blockquote><ul><li>top：显示系统整体资源使用情况</li><li>vmstat：监控内存和 CPU</li><li>iostat：监控 IO 使用</li><li>netstat：监控网络使用</li></ul><blockquote><p>JDK 性能监控工具：</p></blockquote><ul><li>jps：虚拟机进程查看</li><li>jstat：虚拟机运行时信息查看</li><li>jinfo：虚拟机配置查看</li><li>jmap：内存映像（导出）</li><li>jhat：堆转储快照分析</li><li>jstack：Java 堆栈跟踪</li><li>jcmd：实现上面除了 jstat 外所有命令的功能</li></ul></details><h3 id="_2、常用的可视化的性能监控和故障处理工具" tabindex="-1"><a class="header-anchor" href="#_2、常用的可视化的性能监控和故障处理工具" aria-hidden="true">#</a> 2、常用的可视化的性能监控和故障处理工具</h3><details class="hint-container details"><summary>你了解哪些可视化的性能监控和故障处理工具？</summary><blockquote><p>JDK自带：</p></blockquote><ul><li>JConsole：可以查询线程的数量、CPU负载/占用率、类加载数量等</li><li>VisualVM：可以实时监控应用程序的性能指标，查看堆内存、线程、垃圾回收等信息，并进行分析和诊断。</li><li>Java Mission Control：用于生产环境的性能调优和故障排查。提供了诸多插件和功能，可用于分析JVM性能、垃圾回收、代码热点等。</li></ul></details><h3 id="_3、jvm-的常见参数配置" tabindex="-1"><a class="header-anchor" href="#_3、jvm-的常见参数配置" aria-hidden="true">#</a> 3、JVM 的常见参数配置</h3><details class="hint-container details"><summary>JVM 的常见参数配置知道哪些？</summary><blockquote><p>堆配置：</p></blockquote><ul><li>-Xms：初始堆大小</li><li>-Xms：最大堆大小</li><li>-XX:NewSize=n：设置年轻代大小</li><li>-XX:NewRatio=n：设置年轻代和年老代的比值。如：为 3 表示年轻代和年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4</li><li>-XX:SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如 3 表示 Eden： 3 Survivor：2，一个 Survivor 区占整个年轻代的 1/5</li><li>-XX:MaxPermSize=n：设置持久代大小</li></ul><blockquote><p>收集器设置：</p></blockquote><ul><li>-XX:+UseSerialGC：设置串行收集器</li><li>-XX:+UseParallelGC：设置并行收集器</li><li>-XX:+UseParalledlOldGC：设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC：设置并发收集器</li></ul><blockquote><p>并行收集器设置</p></blockquote><ul><li>-XX:ParallelGCThreads=n：设置并行收集器收集时使用的 CPU 数。并行收集线程数</li><li>-XX:MaxGCPauseMillis=n：设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）</li><li>-XX:GCTimeRatio=n：设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n)</li><li>-XX:+CMSIncrementalMode：设置为增量模式。适用于单 CPU 情况</li><li>-XX:ParallelGCThreads=n：设置并发收集器年轻代手机方式为并行收集时，使用的 CPU 数。并行收集线程数</li></ul><blockquote><p>打印 GC 回收的过程日志信息</p></blockquote><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h3 id="_4、线上服务-cpu-占用过高怎么排查" tabindex="-1"><a class="header-anchor" href="#_4、线上服务-cpu-占用过高怎么排查" aria-hidden="true">#</a> 4、线上服务 CPU 占用过高怎么排查</h3><details class="hint-container details"><summary>线上服务 CPU 占用过高怎么排查？</summary><blockquote><p>问题分析：CPU 高一定是某个程序长期占用了 CPU 资源。</p></blockquote><ol><li><p>先需要找出那个进程占用 CPU 高。</p><ul><li><code>top </code>列出系统各个进程的资源占用情况。</li></ul></li><li><p>然后根据找到对应进行里哪个线程占用 CPU 高。</p><ul><li><code>top -Hp 进程id</code> 列出对应进程里面的线程占用资源情况</li></ul></li><li><p>找到对应线程 ID 后，再打印出对应线程的堆栈信息</p><ul><li><p><code>printf &quot;%x\\n&quot; PID</code> 把线程 ID 转换为 16 进制。</p></li><li><p><code>jstack PID</code> 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为 16 进制的线程 ID 对应的线程信息。</p></li></ul></li><li><p>最后根据线程的堆栈信息定位到具体业务方法，从代码逻辑中找到问题所在。</p><ul><li>查看是否有线程长时间的 watting 或 blocked，如果线程长期处于 watting 状态下， 关注 watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。</li></ul></li></ol><h3 id="_5、内存飙高问题怎么排查" tabindex="-1"><a class="header-anchor" href="#_5、内存飙高问题怎么排查" aria-hidden="true">#</a> 5、内存飙高问题怎么排查</h3><details class="hint-container details"><summary>内存飙高问题怎么排查？</summary><blockquote><p>分析： 内存飚高如果是发生在 java 进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收</p></blockquote><ol><li><p>先观察垃圾回收的情况</p><ul><li><p><code>jstat -gc PID 1000</code> 查看 GC 次数，时间等信息，每隔一秒打印一次。</p></li><li><p><code>jmap -histo PID | head -20</code> 查看堆内存占用空间最大的前 20 个对象类型,可初步查看是哪个对象占用了内存。</p><ul><li><p>如果每次 GC 次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；</p></li><li><p>如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p></li></ul></li></ul><ol start="2"><li>导出堆内存文件快照 <ul><li><code>jmap -dump:live,format=b,file=/home/myheapdump.hprof PID dump</code> 堆内存信息到文件。</li></ul></li></ol></li><li><p>使用 visualVM 对 dump 文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p></li></ol></details></details></details><h3 id="_6、频繁-minor-gc" tabindex="-1"><a class="header-anchor" href="#_6、频繁-minor-gc" aria-hidden="true">#</a> 6、频繁 minor gc</h3><details class="hint-container details"><summary>频繁 minor gc 怎么办？</summary><blockquote><p>频繁 minor gc：</p></blockquote><ol><li><strong>内存空间真不足</strong>： <ul><li>可能是真不足，那就增大新生代空间<code>-Xmn</code>来降低 Minor GC 的频率，其次可以查看代码<strong>优化对象的生命周期</strong>，尽量减少对象的创建和短暂存活，如对象重用、缓存等方式。</li></ul></li><li><strong>内存泄漏导致空间不足</strong>：使用内存分析工具（如VisualVM、JVisualVM）分析内存使用情况，查看内存泄漏或不合理的对象创建，再定位到代码去查看。</li><li><strong>分析是否有同类型对象频繁晋升到老年代</strong>：优化代码，减少对象的长期存活时间，减少对象晋升到老年代的情况。</li><li><strong>垃圾收集器不行</strong>：换一个，不同的垃圾收集器对于Minor GC的触发条件和机制可能略有不同，选择不合适的垃圾收集器可能导致过于频繁的Minor GC。</li></ol></details><h3 id="_7、频繁-full-gc" tabindex="-1"><a class="header-anchor" href="#_7、频繁-full-gc" aria-hidden="true">#</a> 7、频繁 full gc</h3><details class="hint-container details"><summary>频繁 full gc 怎么办？</summary><blockquote><p>排查有哪些原因导致 Full GC？</p></blockquote><ul><li><strong>大对象</strong>：系统一次性加载了过多数据到内存中（比如 SQL 查询未做分页），导致大对象进入了老年代。</li><li><strong>内存泄漏</strong>：频繁创建了大量对象，但是无法被回收（比如 IO 对象使用完后未调用 close 方法释放资源），先引发 FGC，最后导致 OOM.</li><li>程序频繁生成一些<strong>长生命周期的对象</strong>，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发 FGC. （即本文中的案例）</li><li><strong>程序 BUG</strong></li><li>代码中<strong>显式调用了 gc</strong>方法，包括自己的代码甚至框架中的代码。</li><li>JVM 参数设置问题：包括总内存大小、新生代和老年代的大小、Eden 区和 S 区的大小、元空间大小、垃圾回收算法等等。</li></ul><blockquote><p>清楚排查问题时能使用哪些工具</p></blockquote><ul><li>公司的监控系统：大部分公司都会有，可全方位监控 JVM 的各项指标。</li><li>JDK 的自带工具，包括 jmap、jstat 等常用命令：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看堆内存各区域的使用率以及GC情况</span>
jstat <span class="token parameter variable">-gcutil</span> <span class="token parameter variable">-h20</span> pid <span class="token number">1000</span>
<span class="token comment"># 查看堆内存中的存活对象，并按空间排序</span>
jmap <span class="token parameter variable">-histo</span> pid <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n20</span>
<span class="token comment"># dump堆内存文件</span>
jmap <span class="token parameter variable">-dump:format</span><span class="token operator">=</span>b,file<span class="token operator">=</span>heap pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可视化的堆内存分析工具：JVisualVM、MAT 等</li></ul><blockquote><p>排查指南</p></blockquote><ul><li>查看监控，以了解出现问题的时间点以及当前 FGC 的频率（可对比正常情况看频率是否正常）</li><li>了解该时间点之前有没有程序上线、基础组件升级等情况。</li><li>了解 JVM 的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析 JVM 参数设置是否合理。</li><li>再对步骤 1 中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用 gc 方法比较容易排查。</li><li>针对大对象或者长生命周期对象导致的 FGC，可通过 jmap -histo 命令并结合 dump 堆内存文件作进一步分析，需要先定位到可疑对象。</li><li>通过可疑对象定位到具体代码再次分析，这时候要结合 GC 原理和 JVM 参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</li></ul></details><h3 id="_8、如何定位内存泄漏问题" tabindex="-1"><a class="header-anchor" href="#_8、如何定位内存泄漏问题" aria-hidden="true">#</a> 8、如何定位内存泄漏问题</h3><details class="hint-container details"><summary>如何定位内存泄漏问题？</summary><blockquote><p>内存泄漏是内在病源，外在病症表现可能有：</p></blockquote><ul><li>应用程序长时间连续运行时性能严重下降</li><li>CPU 使用率飙升，甚至到 100%</li><li>频繁 Full GC，各种报警，例如接口超时报警等</li><li>应用程序抛出 <code>OutOfMemoryError</code> 错误</li><li>应用程序偶尔会耗尽连接对象</li></ul><p>严重<strong>内存泄漏</strong>往往伴随频繁的 <strong>Full GC</strong>，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：</p><p>1）使用 <code>jps</code> 查看运行的 Java 进程 ID</p><p>2）使用<code>top -p [pid]</code> 查看进程使用 CPU 和 MEM 的情况</p><p>3）使用 <code>top -Hp [pid]</code> 查看进程下的所有线程占 CPU 和 MEM 的情况</p><p>4）将线程 ID 转换为 16 进制：<code>printf &quot;%x\\n&quot; [pid]</code>，输出的值就是线程栈信息中的 <strong>nid</strong>。</p><p>例如：<code>printf &quot;%x\\n&quot; 29471</code>，换行输出 <strong>731f</strong>。</p><p>5）抓取线程栈：<code>jstack 29452 &gt; 29452.txt</code>，可以多抓几次做个对比。</p><p>在线程栈信息中找到对应线程号的 16 进制值，如下是 <strong>731f</strong> 线程的信息。线程栈分析可使用 Visualvm 插件 <strong>TDA</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token string">&quot;Service Thread&quot;</span> #<span class="token number">7</span> daemon prio<span class="token operator">=</span><span class="token number">9</span> os_prio<span class="token operator">=</span><span class="token number">0</span> tid<span class="token operator">=</span><span class="token number">0x00007fbe2c164000</span> nid<span class="token operator">=</span><span class="token number">0x731f</span> runnable <span class="token punctuation">[</span><span class="token number">0x0000000000000000</span><span class="token punctuation">]</span>
  <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Thread<span class="token punctuation">.</span>State</span><span class="token operator">:</span> <span class="token constant">RUNNABLE</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>6）使用<code>jstat -gcutil [pid] 5000 10</code> 每隔 5 秒输出 GC 信息，输出 10 次，查看 <strong>YGC</strong> 和 <strong>Full GC</strong> 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。</p><p>或使用 <code>jstat -gccause [pid] 5000</code> ，同样是输出 GC 摘要信息。</p><p>或使用 <code>jmap -heap [pid]</code> 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。</p><p>7）如果发现 <code>Full GC</code> 次数太多，就很大概率存在内存泄漏了</p><p>8）使用 <code>jmap -histo:live [pid]</code> 输出每个类的对象数量，内存大小(字节单位)及全限定类名。</p><p>9）生成 <code>dump</code> 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了</p><p>使用 jmap 生成 dump 文件：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code># jmap <span class="token operator">-</span>dump<span class="token operator">:</span>live<span class="token punctuation">,</span>format<span class="token operator">=</span>b<span class="token punctuation">,</span>file<span class="token operator">=</span><span class="token number">29471.d</span>ump <span class="token number">29471</span>
<span class="token class-name">Dumping</span> heap <span class="token keyword">to</span> <span class="token operator">/</span>root<span class="token operator">/</span>dump <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">Heap</span> dump file created
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>10）dump 文件分析</p><p>可以使用 <strong>jhat</strong> 命令分析：<code>jhat -port 8000 29471.dump</code>，浏览器访问 jhat 服务，端口是 8000。</p><p>通常使用图形化工具分析，如 JDK 自带的 <strong>jvisualvm</strong>，从菜单 &gt; 文件 &gt; 装入 dump 文件。</p><p>或使用第三方式具分析的，如 <strong>JProfiler</strong> 也是个图形化工具，<strong>GCViewer</strong> 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 <strong>GCEasy</strong>。</p><p><strong>注意</strong>：如果 dump 文件较大的话，分析会占比较大的内存。</p><p>11）在 dump 文析结果中查找存在大量的对象，再查对其的引用。</p><p>基本上就可以定位到代码层的逻辑了。</p></details><h3 id="_9、如何定位内存溢出问题" tabindex="-1"><a class="header-anchor" href="#_9、如何定位内存溢出问题" aria-hidden="true">#</a> 9、如何定位内存溢出问题</h3><details class="hint-container details"><summary>如何定位内存溢出问题？</summary><p>内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。</p><p>排查过程和排查内存泄漏过程类似。</p></details>`,99),o=[i];function t(r,p){return l(),s("div",null,o)}const u=a(e,[["render",t],["__file","java-jvm.html.vue"]]);export{u as default};

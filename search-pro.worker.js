const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":898,\"nextId\":898,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-d5cb7e12\",\"2\":\"v-d5cb7e12#一、宝塔安装和配置\",\"3\":\"v-d5cb7e12#_1、命令行安装\",\"4\":\"v-d5cb7e12#_2、应用设置\",\"5\":\"v-d5cb7e12#_2-1-更改面板设置\",\"6\":\"v-d5cb7e12#二、安装nginx\",\"7\":\"v-d5cb7e12#_1、安装\",\"8\":\"v-d5cb7e12#_2、设置配置文件\",\"9\":\"v-d5cb7e12#三、安装mysql\",\"10\":\"v-d5cb7e12#_1、安装-1\",\"11\":\"v-d5cb7e12#_2、配置和远程连接\",\"12\":\"v-d5cb7e12#四、安装redis\",\"13\":\"v-d5cb7e12#_1、安装-2\",\"14\":\"v-d5cb7e12#_2、配置和远程连接-1\",\"15\":\"v-d5cb7e12#五、安装jdk\",\"16\":\"v-d5cb7e12#_1、下载并解压\",\"17\":\"v-d5cb7e12#_1-下载\",\"18\":\"v-d5cb7e12#_2-解压\",\"19\":\"v-d5cb7e12#_2、-配置环境变量\",\"20\":\"v-d5cb7e12#_3、安装成功测试\",\"21\":\"v-d5cb7e12#六、部署java项目\",\"22\":\"v-d5cb7e12#_1、前端部署\",\"23\":\"v-d5cb7e12#_2、后端部署\",\"24\":\"v-d5cb7e12#七、安装ffmpeg\",\"25\":\"v-d5cb7e12@0\",\"26\":\"v-d5cb7e12@1\",\"27\":\"v-7a5c0f68\",\"28\":\"v-7a5c0f68#一、宝塔安装和配置\",\"29\":\"v-7a5c0f68#_1、命令行安装\",\"30\":\"v-7a5c0f68#_2、应用设置\",\"31\":\"v-7a5c0f68#_2-1-更改面板设置\",\"32\":\"v-7a5c0f68#二、安装nginx\",\"33\":\"v-7a5c0f68#_1、安装\",\"34\":\"v-7a5c0f68#_2、设置配置文件\",\"35\":\"v-7a5c0f68#三、安装mysql\",\"36\":\"v-7a5c0f68#_1、安装-1\",\"37\":\"v-7a5c0f68#_2、配置和远程连接\",\"38\":\"v-7a5c0f68#四、安装redis\",\"39\":\"v-7a5c0f68#_1、安装-2\",\"40\":\"v-7a5c0f68#_2、配置和远程连接-1\",\"41\":\"v-7a5c0f68#五、安装jdk\",\"42\":\"v-7a5c0f68#_1、下载并解压\",\"43\":\"v-7a5c0f68#_1-下载\",\"44\":\"v-7a5c0f68#_2-解压\",\"45\":\"v-7a5c0f68#_2、-配置环境变量\",\"46\":\"v-7a5c0f68#_3、安装成功测试\",\"47\":\"v-7a5c0f68#六、部署java项目\",\"48\":\"v-7a5c0f68#_1、前端部署\",\"49\":\"v-7a5c0f68#_2、后端部署\",\"50\":\"v-7a5c0f68#七、安装ffmpeg\",\"51\":\"v-7a5c0f68@0\",\"52\":\"v-7a5c0f68@1\",\"53\":\"v-bfaf860a\",\"54\":\"v-41fafe2e\",\"55\":\"v-41fafe2e#一、简介\",\"56\":\"v-41fafe2e#_1、主要任务\",\"57\":\"v-41fafe2e#_2、网络应用模型\",\"58\":\"v-41fafe2e#_1-c-s模型\",\"59\":\"v-41fafe2e#_2-p2p模型\",\"60\":\"v-41fafe2e#二、动态主机配置协议dhcp\",\"61\":\"v-41fafe2e#_1、概述\",\"62\":\"v-41fafe2e#_1-dhcp是什么\",\"63\":\"v-41fafe2e#_2-dhcp和udp\",\"64\":\"v-41fafe2e#_2、工作流程\",\"65\":\"v-41fafe2e#三、域名系统dns\",\"66\":\"v-41fafe2e#_1、概述-1\",\"67\":\"v-41fafe2e#_1-dns\",\"68\":\"v-41fafe2e#_2-dns相关名词\",\"69\":\"v-41fafe2e#_2、域名\",\"70\":\"v-41fafe2e#_3、域名服务器\",\"71\":\"v-41fafe2e#_1-域名服务器分类\",\"72\":\"v-41fafe2e#_2-域名解析方式\",\"73\":\"v-41fafe2e#_4、dns解析过程\",\"74\":\"v-41fafe2e#_1-查看浏览器缓存\",\"75\":\"v-41fafe2e#_2-查看系统缓存\",\"76\":\"v-41fafe2e#_3-查看路由器缓存\",\"77\":\"v-41fafe2e#_4-查看isp-dns-缓存\",\"78\":\"v-41fafe2e#_5-询问根域名服务器\",\"79\":\"v-41fafe2e#_6-询问顶级域名服务器\",\"80\":\"v-41fafe2e#_7-询问权威域名-主域名-服务器\",\"81\":\"v-41fafe2e#_8-保存结果至缓存\",\"82\":\"v-41fafe2e#四、文件传输协议ftp\",\"83\":\"v-41fafe2e#_1、ftp是什么\",\"84\":\"v-41fafe2e#_2、ftp的工作原理\",\"85\":\"v-41fafe2e#_1-介绍\",\"86\":\"v-41fafe2e#_2-传输过程\",\"87\":\"v-41fafe2e#_3、ftp和tcp\",\"88\":\"v-41fafe2e#五、电子邮件\",\"89\":\"v-41fafe2e#_1、电子邮件系统和电子邮件\",\"90\":\"v-41fafe2e#_1-电子邮件系统\",\"91\":\"v-41fafe2e#_2-电子邮件格式\",\"92\":\"v-41fafe2e#_2、smtp\",\"93\":\"v-41fafe2e#i-组成\",\"94\":\"v-41fafe2e#ii-工作流程\",\"95\":\"v-41fafe2e#iii-smtp协议的缺点\",\"96\":\"v-41fafe2e#_3、mime拓展\",\"97\":\"v-41fafe2e#_4、pop\",\"98\":\"v-41fafe2e#_5、因特网邮件访问协议-imap\",\"99\":\"v-41fafe2e#_5、基于万维网的电子邮件\",\"100\":\"v-41fafe2e#_6、总结\",\"101\":\"v-41fafe2e#六、万维网\",\"102\":\"v-41fafe2e#_1、介绍和组成\",\"103\":\"v-41fafe2e#_1-概述\",\"104\":\"v-41fafe2e#_2-组成\",\"105\":\"v-41fafe2e#_2、超文本传输协议http\",\"106\":\"v-41fafe2e#_1-http的作用\",\"107\":\"v-41fafe2e#_2-http的报文结构\",\"108\":\"v-41fafe2e#_3-http的连接过程\",\"109\":\"v-41fafe2e#_4-http的特点\",\"110\":\"v-41fafe2e#_5-cookie状态\",\"111\":\"v-41fafe2e#_3、http1-0\",\"112\":\"v-41fafe2e#_4、http1-1\",\"113\":\"v-41fafe2e#_5、http-2-0\",\"114\":\"v-41fafe2e#_6、万维网缓冲与代理服务器\",\"115\":\"v-41fafe2e@0\",\"116\":\"v-41fafe2e@1\",\"117\":\"v-3d57cebe\",\"118\":\"v-3d57cebe#一、简介\",\"119\":\"v-3d57cebe#_1、概述\",\"120\":\"v-3d57cebe#_2、组成结构\",\"121\":\"v-3d57cebe#_2、分类\",\"122\":\"v-3d57cebe#二、数据链路层的功能\",\"123\":\"v-3d57cebe#_1、数据链路管理\",\"124\":\"v-3d57cebe#主要过程包括-链路建立、链路保持、链路释放\",\"125\":\"v-3d57cebe#a-有确认的面向连接服务\",\"126\":\"v-3d57cebe#b-有确认的无连接服务\",\"127\":\"v-3d57cebe#c-无确认的无连接服务\",\"128\":\"v-3d57cebe#_2、封装成帧和透明传输\",\"129\":\"v-3d57cebe#a-封装成帧功能的含义\",\"130\":\"v-3d57cebe#b-数据包的帧封装原理\",\"131\":\"v-3d57cebe#c-比特流的帧组装原理\",\"132\":\"v-3d57cebe#d-透明传输\",\"133\":\"v-3d57cebe#_3、差错检测\",\"134\":\"v-3d57cebe#i-奇偶校验码\",\"135\":\"v-3d57cebe#ii-循环冗余校验\",\"136\":\"v-3d57cebe#_4、可靠传输\",\"137\":\"v-3d57cebe#i-停止-等待协议-自动请求重传\",\"138\":\"v-3d57cebe#ii-回退n帧协议\",\"139\":\"v-3d57cebe#iii-选择重传协议\",\"140\":\"v-3d57cebe#_5、流量控制\",\"141\":\"v-3d57cebe#i-基于反馈的流量控制方案\",\"142\":\"v-3d57cebe#ii-基于速率的流量控制方案\",\"143\":\"v-3d57cebe#三、介质访问控制\",\"144\":\"v-3d57cebe#_1、概述-1\",\"145\":\"v-3d57cebe#_2、信道划分介质控制\",\"146\":\"v-3d57cebe#_1-静态划分信道\",\"147\":\"v-3d57cebe#i-频分多路复用-fdm\",\"148\":\"v-3d57cebe#ii-时分多路复用-tdm\",\"149\":\"v-3d57cebe#iii-波分多路复用-wdm\",\"150\":\"v-3d57cebe#iv-码分多路复用-cdm\",\"151\":\"v-3d57cebe#_2-动态划分信道\",\"152\":\"v-3d57cebe#i-随机访问介质控制\",\"153\":\"v-3d57cebe#ii-轮询访问介质控制\",\"154\":\"v-3d57cebe#四、局域网\",\"155\":\"v-3d57cebe#_1、概述-2\",\"156\":\"v-3d57cebe#_1-主要特点\",\"157\":\"v-3d57cebe#_2-三个要素\",\"158\":\"v-3d57cebe#_3-常见的局域网拓扑结构\",\"159\":\"v-3d57cebe#_2、虚拟局域网\",\"160\":\"v-3d57cebe#五、广域网\",\"161\":\"v-3d57cebe#_1、概述-3\",\"162\":\"v-3d57cebe#_2、广域网与局域网的比较\",\"163\":\"v-3d57cebe#六、mac地址、ip地址、arp协议\",\"164\":\"v-3d57cebe#_1、mac地址\",\"165\":\"v-3d57cebe#_1-概念\",\"166\":\"v-3d57cebe#_2-组成\",\"167\":\"v-3d57cebe#_2、ip地址\",\"168\":\"v-3d57cebe#_3、arp协议\",\"169\":\"v-3d57cebe#六、常见设备\",\"170\":\"v-3d57cebe#_1、集线器\",\"171\":\"v-3d57cebe#_2、网桥\",\"172\":\"v-3d57cebe#_3、交换机\",\"173\":\"v-3d57cebe#_1-概述\",\"174\":\"v-3d57cebe#_2-自学习和转发帧流程\",\"175\":\"v-3d57cebe#_3-stp生成树协议\",\"176\":\"v-3d57cebe@0\",\"177\":\"v-3d57cebe@1\",\"178\":\"v-ad8bc2e0\",\"179\":\"v-ad8bc2e0#一、简介\",\"180\":\"v-ad8bc2e0#_1、主要任务\",\"181\":\"v-ad8bc2e0#_2、为什么需要\",\"182\":\"v-ad8bc2e0#_3、怎么理解\",\"183\":\"v-ad8bc2e0#_4、有什么作用\",\"184\":\"v-ad8bc2e0#i-屏蔽网络差异-提供透明传输\",\"185\":\"v-ad8bc2e0#ii-为网络间通信提供路由选择\",\"186\":\"v-ad8bc2e0#iii-数据包封装和解封装\",\"187\":\"v-ad8bc2e0#iv-拥塞控制\",\"188\":\"v-ad8bc2e0#二、网络层协议及报文格式\",\"189\":\"v-ad8bc2e0#_1、ipv4协议\",\"190\":\"v-ad8bc2e0#_1-主要功能\",\"191\":\"v-ad8bc2e0#_1寻址\",\"192\":\"v-ad8bc2e0#_2数据报的封装\",\"193\":\"v-ad8bc2e0#_3分段与重组\",\"194\":\"v-ad8bc2e0#_2-ipv4数据报首部\",\"195\":\"v-ad8bc2e0#_2、arp协议\",\"196\":\"v-ad8bc2e0#_1-主要功能-1\",\"197\":\"v-ad8bc2e0#_2-arp报文格式\",\"198\":\"v-ad8bc2e0#_3-arp映射表\",\"199\":\"v-ad8bc2e0#_3、icmp协议及报文格式\",\"200\":\"v-ad8bc2e0#_1-主要功能-2\",\"201\":\"v-ad8bc2e0#_2-icmp报文类型\",\"202\":\"v-ad8bc2e0#_3-icmp报文格式\",\"203\":\"v-ad8bc2e0#三、路由算法和路由协议\",\"204\":\"v-ad8bc2e0#_1、路由算法分类\",\"205\":\"v-ad8bc2e0#_1-静态路由\",\"206\":\"v-ad8bc2e0#_2-动态路由\",\"207\":\"v-ad8bc2e0#_2、rip协议\",\"208\":\"v-ad8bc2e0#_1-概述\",\"209\":\"v-ad8bc2e0#_2-存在问题\",\"210\":\"v-ad8bc2e0#_3、ospf协议\",\"211\":\"v-ad8bc2e0#_4、isis协议\",\"212\":\"v-ad8bc2e0#_5、bgp协议\",\"213\":\"v-ad8bc2e0#四、ipv4地址\",\"214\":\"v-ad8bc2e0#_1、概述\",\"215\":\"v-ad8bc2e0#_1-ipv4地址介绍\",\"216\":\"v-ad8bc2e0#_2-子网掩码介绍\",\"217\":\"v-ad8bc2e0#_2、分类编址的ipv4\",\"218\":\"v-ad8bc2e0#_3、划分子网ipv4\",\"219\":\"v-ad8bc2e0#_4、无分类编址ipv4\",\"220\":\"v-ad8bc2e0#_4-1-概述\",\"221\":\"v-ad8bc2e0#_4-3-路由聚合\",\"222\":\"v-ad8bc2e0#_5、ipv4应用规划\",\"223\":\"v-ad8bc2e0#五、vpn和nat\",\"224\":\"v-ad8bc2e0@0\",\"225\":\"v-ad8bc2e0@1\",\"226\":\"v-4f41a7dd\",\"227\":\"v-4f41a7dd#一、简介\",\"228\":\"v-4f41a7dd#二、基本任务\",\"229\":\"v-4f41a7dd#_1、任务\",\"230\":\"v-4f41a7dd#_2、传输媒体\",\"231\":\"v-4f41a7dd#_3、传输方式\",\"232\":\"v-4f41a7dd#_1-串行传输\",\"233\":\"v-4f41a7dd#_2-并行传输\",\"234\":\"v-4f41a7dd#_4、传输模式\",\"235\":\"v-4f41a7dd#_1-异步传输\",\"236\":\"v-4f41a7dd#_2-同步传输\",\"237\":\"v-4f41a7dd#_5、数据通信方式\",\"238\":\"v-4f41a7dd#_6、编码\",\"239\":\"v-4f41a7dd#_7、调制\",\"240\":\"v-4f41a7dd#三、拓展\",\"241\":\"v-4f41a7dd@0\",\"242\":\"v-4f41a7dd@1\",\"243\":\"v-2a2acaa2\",\"244\":\"v-2a2acaa2#一、名词解析\",\"245\":\"v-2a2acaa2#_1、各种网络\",\"246\":\"v-2a2acaa2#_1-网络\",\"247\":\"v-2a2acaa2#_2-互联网\",\"248\":\"v-2a2acaa2#_3-因特网\",\"249\":\"v-2a2acaa2#_2、isp\",\"250\":\"v-2a2acaa2#_3、实体和协议\",\"251\":\"v-2a2acaa2#_3、服务\",\"252\":\"v-2a2acaa2#二、数据交换方式\",\"253\":\"v-2a2acaa2#_1、电路交换\",\"254\":\"v-2a2acaa2#_2、分组交换\",\"255\":\"v-2a2acaa2#_3、报文交换\",\"256\":\"v-2a2acaa2#三、计算机网络\",\"257\":\"v-2a2acaa2#_1、定义\",\"258\":\"v-2a2acaa2#_2、分类\",\"259\":\"v-2a2acaa2#_3、性能指标\",\"260\":\"v-2a2acaa2#_1-速率\",\"261\":\"v-2a2acaa2#_2-带宽\",\"262\":\"v-2a2acaa2#_3-吞吐量\",\"263\":\"v-2a2acaa2#_4-时延\",\"264\":\"v-2a2acaa2#_5-时延带宽积\",\"265\":\"v-2a2acaa2#_6-往返时间\",\"266\":\"v-2a2acaa2#_7-利用率\",\"267\":\"v-2a2acaa2#_8-丢包率\",\"268\":\"v-2a2acaa2#_4、体系结构\",\"269\":\"v-2a2acaa2@0\",\"270\":\"v-2a2acaa2@1\",\"271\":\"v-42b43135\",\"272\":\"v-42b43135#一、简介\",\"273\":\"v-42b43135#_1、主要任务\",\"274\":\"v-42b43135#_2、为什么需要\",\"275\":\"v-42b43135#_3、端到端的服务\",\"276\":\"v-42b43135#_4、tsap和tpdu\",\"277\":\"v-42b43135#_1-tsap\",\"278\":\"v-42b43135#_2-tpdu\",\"279\":\"v-42b43135#_5、寻址与端口号\",\"280\":\"v-42b43135#_6、复用和分用\",\"281\":\"v-42b43135#二、tcp协议\",\"282\":\"v-42b43135#_1、tcp协议的特性\",\"283\":\"v-42b43135#_2、tcp的报文格式\",\"284\":\"v-42b43135#_3、tcp的连接管理\",\"285\":\"v-42b43135#_1-tcp连接的建立\",\"286\":\"v-42b43135#_2-tcp连接释放\",\"287\":\"v-42b43135#_4、tcp的可靠传输\",\"288\":\"v-42b43135#_1-校验\",\"289\":\"v-42b43135#_2-序号\",\"290\":\"v-42b43135#_3-确认号\",\"291\":\"v-42b43135#_4-重传\",\"292\":\"v-42b43135#_5、tcp的流量控制\",\"293\":\"v-42b43135#_1-概述\",\"294\":\"v-42b43135#_2-实现方式\",\"295\":\"v-42b43135#_6、tcp的拥塞控制\",\"296\":\"v-42b43135#_1-概述-1\",\"297\":\"v-42b43135#_2-实现方式-1\",\"298\":\"v-42b43135#a-慢开始和拥塞避免\",\"299\":\"v-42b43135#b-快重传和快恢复\",\"300\":\"v-42b43135#三、udp协议\",\"301\":\"v-42b43135#_1、udp协议的特性\",\"302\":\"v-42b43135#_2、udp的报文格式\",\"303\":\"v-42b43135#_3、udp的校验过程\",\"304\":\"v-42b43135#_1、伪首部\",\"305\":\"v-42b43135#_2、校验过程\",\"306\":\"v-42b43135@0\",\"307\":\"v-42b43135@1\",\"308\":\"v-58e482f5\",\"309\":\"v-58e482f5#一、前置扫盲\",\"310\":\"v-58e482f5#_1、数据结构分类\",\"311\":\"v-58e482f5#_1-1-逻辑结构-线性与非线性\",\"312\":\"v-58e482f5#_1-2-物理结构-顺序与链式\",\"313\":\"v-58e482f5#_2、算法效率评估\",\"314\":\"v-58e482f5#_2-1-时间复杂度\",\"315\":\"v-58e482f5#_2-1-1-统计具体时间\",\"316\":\"v-58e482f5#_2-1-2-统计增长趋势\",\"317\":\"v-58e482f5#_2-2-空间复杂度\",\"318\":\"v-58e482f5@0\",\"319\":\"v-58e482f5@1\",\"320\":\"v-537a3b07\",\"321\":\"v-537a3b07#一、观察者设计模式\",\"322\":\"v-537a3b07#_1、介绍\",\"323\":\"v-537a3b07#_2、核心思想\",\"324\":\"v-537a3b07#_3、组成和基本流程\",\"325\":\"v-537a3b07#_4、使用场景和具体案例\",\"326\":\"v-537a3b07#_5、发布订阅模式\",\"327\":\"v-537a3b07#_6、观察者的进阶使用\",\"328\":\"v-537a3b07#_7、总结\",\"329\":\"v-537a3b07#二、模板设计模式\",\"330\":\"v-537a3b07#_1、介绍-1\",\"331\":\"v-537a3b07#_2、核心思想-1\",\"332\":\"v-537a3b07#_3、组成和基本流程-1\",\"333\":\"v-537a3b07#_4、使用场景和具体案例-1\",\"334\":\"v-537a3b07#_4-1-复用\",\"335\":\"v-537a3b07#具体案例1-inputstream\",\"336\":\"v-537a3b07#具体案例2-生成报告模板\",\"337\":\"v-537a3b07#_4-2-拓展\",\"338\":\"v-537a3b07#具体案例1-java-servelt\",\"339\":\"v-537a3b07#_5、总结\",\"340\":\"v-537a3b07#三、策略设计模式\",\"341\":\"v-537a3b07#_1、介绍-2\",\"342\":\"v-537a3b07#_2、核心思想-2\",\"343\":\"v-537a3b07#_3、组成和基本流程-2\",\"344\":\"v-537a3b07#_4、使用场景和具体案例-2\",\"345\":\"v-537a3b07#_6、总结\",\"346\":\"v-537a3b07#_7、结合工厂设计模式\",\"347\":\"v-537a3b07#四、责任链设计模式\",\"348\":\"v-537a3b07#_1、介绍-3\",\"349\":\"v-537a3b07#_2、核心思想-3\",\"350\":\"v-537a3b07#_3、组成和基本流程-3\",\"351\":\"v-537a3b07#_4、使用场景和具体案例-3\",\"352\":\"v-537a3b07#具体案例\",\"353\":\"v-537a3b07#具体案例-链表实现\",\"354\":\"v-537a3b07#具体案例-数组实现\",\"355\":\"v-537a3b07#_5、总结-1\",\"356\":\"v-537a3b07#五、状态设计模式\",\"357\":\"v-537a3b07#_1、介绍-4\",\"358\":\"v-537a3b07#_2、核心思想-4\",\"359\":\"v-537a3b07#_3、组成和基本流程-4\",\"360\":\"v-537a3b07#_4、使用场景\",\"361\":\"v-537a3b07#_5、总结-2\",\"362\":\"v-537a3b07#六、迭代器设计模式\",\"363\":\"v-537a3b07#_1、介绍-5\",\"364\":\"v-537a3b07#_2、核心思想-5\",\"365\":\"v-537a3b07#_3、组成和基本流程-5\",\"366\":\"v-537a3b07#_4、使用场景和具体案例-4\",\"367\":\"v-537a3b07#_5、总结-3\",\"368\":\"v-537a3b07#七、访问者设计模式\",\"369\":\"v-537a3b07#_1、介绍-6\",\"370\":\"v-537a3b07#_2、核心思想-6\",\"371\":\"v-537a3b07#_3、组成和基本流程-6\",\"372\":\"v-537a3b07#_4、使用场景和具体案例-5\",\"373\":\"v-537a3b07#_6、总结-1\",\"374\":\"v-537a3b07#八、备忘录设计模式\",\"375\":\"v-537a3b07#_1、介绍-7\",\"376\":\"v-537a3b07#_2、核心思想-7\",\"377\":\"v-537a3b07#_3、组成和基本流程-7\",\"378\":\"v-537a3b07#_4、使用场景和具体案例-6\",\"379\":\"v-537a3b07#_5、总结-4\",\"380\":\"v-537a3b07#九、命令设计模式\",\"381\":\"v-537a3b07#_1、介绍-8\",\"382\":\"v-537a3b07#_2、核心思想-8\",\"383\":\"v-537a3b07#_3、组成和基本流程-8\",\"384\":\"v-537a3b07#_4、使用场景和具体案例-7\",\"385\":\"v-537a3b07#_5、总结-5\",\"386\":\"v-537a3b07#_6、和策略设计模式比较\",\"387\":\"v-537a3b07#十、解释器设计模式\",\"388\":\"v-537a3b07#_1、介绍-9\",\"389\":\"v-537a3b07#_2、核心思想-9\",\"390\":\"v-537a3b07#_3、组成和基本流程-9\",\"391\":\"v-537a3b07#_4、使用场景和具体案例-8\",\"392\":\"v-537a3b07#_1、介绍-10\",\"393\":\"v-537a3b07#_2、实现步骤\",\"394\":\"v-537a3b07#_3、代码实现\",\"395\":\"v-537a3b07#_4、解析和注释\",\"396\":\"v-537a3b07#_5、总结-6\",\"397\":\"v-537a3b07#十一、中介设计模式\",\"398\":\"v-537a3b07#_1、介绍-11\",\"399\":\"v-537a3b07#_2、核心思想-10\",\"400\":\"v-537a3b07#_3、组成和基本流程-10\",\"401\":\"v-537a3b07#_1、介绍-12\",\"402\":\"v-537a3b07#_2、实现步骤-1\",\"403\":\"v-537a3b07#_3、代码实现-1\",\"404\":\"v-537a3b07#_4、解析和注释-1\",\"405\":\"v-537a3b07#_4、使用场景和具体案例-9\",\"406\":\"v-537a3b07#_1、介绍-13\",\"407\":\"v-537a3b07#_2、实现步骤-2\",\"408\":\"v-537a3b07#_3、代码实现-2\",\"409\":\"v-537a3b07#_4、解析和注释-2\",\"410\":\"v-537a3b07#_5、总结-7\",\"411\":\"v-537a3b07#_6、和观察者对比\",\"412\":\"v-537a3b07@0\",\"413\":\"v-537a3b07@1\",\"414\":\"v-1ae84fca\",\"415\":\"v-1ae84fca#一、单例设计模式\",\"416\":\"v-1ae84fca#_1、介绍\",\"417\":\"v-1ae84fca#_2、核心思想\",\"418\":\"v-1ae84fca#_3、组成和基本流程\",\"419\":\"v-1ae84fca#_4、使用场景\",\"420\":\"v-1ae84fca#_5、具体案例\",\"421\":\"v-1ae84fca#_6、总结\",\"422\":\"v-1ae84fca#二、工厂设计模式\",\"423\":\"v-1ae84fca#_1、简单工厂\",\"424\":\"v-1ae84fca#_1-1-介绍\",\"425\":\"v-1ae84fca#_1-2-核心思想\",\"426\":\"v-1ae84fca#_1-3-组成\",\"427\":\"v-1ae84fca#_1-4-基本流程\",\"428\":\"v-1ae84fca#_1-5-使用场景\",\"429\":\"v-1ae84fca#_1-6-具体案例\",\"430\":\"v-1ae84fca#_1-7-总结\",\"431\":\"v-1ae84fca#_2、工厂方法\",\"432\":\"v-1ae84fca#_2-1-介绍\",\"433\":\"v-1ae84fca#_2-2-核心思想\",\"434\":\"v-1ae84fca#_2-3-组成和基本流程\",\"435\":\"v-1ae84fca#_2-4-使用场景\",\"436\":\"v-1ae84fca#_2-5-具体案例\",\"437\":\"v-1ae84fca#_2-6-总结\",\"438\":\"v-1ae84fca#_3、抽象工厂\",\"439\":\"v-1ae84fca#_3-1-介绍\",\"440\":\"v-1ae84fca#_3-2-核心思想\",\"441\":\"v-1ae84fca#_3-3-组成和基本流程\",\"442\":\"v-1ae84fca#_3-4-使用场景\",\"443\":\"v-1ae84fca#_3-5-具体案例\",\"444\":\"v-1ae84fca#_3-6-总结\",\"445\":\"v-1ae84fca#三、建造者设计模式\",\"446\":\"v-1ae84fca#_1、简介\",\"447\":\"v-1ae84fca#_2、核心思想-1\",\"448\":\"v-1ae84fca#_3、组成和基本流程-1\",\"449\":\"v-1ae84fca#_4、使用场景-1\",\"450\":\"v-1ae84fca#_5、具体案例-1\",\"451\":\"v-1ae84fca#_6、总结-1\",\"452\":\"v-1ae84fca#_7、和工厂设计模式的区别\",\"453\":\"v-1ae84fca#四、原型设计模式\",\"454\":\"v-1ae84fca#_1、浅拷贝\",\"455\":\"v-1ae84fca#_2、深拷贝\",\"456\":\"v-1ae84fca@0\",\"457\":\"v-1ae84fca@1\",\"458\":\"v-282ab0b2\",\"459\":\"v-282ab0b2#一、单一原则\",\"460\":\"v-282ab0b2#_1、简介\",\"461\":\"v-282ab0b2#_2、例子\",\"462\":\"v-282ab0b2#_3、总结\",\"463\":\"v-282ab0b2#二、开闭原则\",\"464\":\"v-282ab0b2#_1、简介-1\",\"465\":\"v-282ab0b2#_2、例子-1\",\"466\":\"v-282ab0b2#_3、总结-1\",\"467\":\"v-282ab0b2#三、里氏替换原则\",\"468\":\"v-282ab0b2#_1、简介-2\",\"469\":\"v-282ab0b2#_2、例子-2\",\"470\":\"v-282ab0b2#_3、总结-2\",\"471\":\"v-282ab0b2#四、接口隔离原则\",\"472\":\"v-282ab0b2#_1、简介-3\",\"473\":\"v-282ab0b2#_2、例子-3\",\"474\":\"v-282ab0b2#_3、总结-3\",\"475\":\"v-282ab0b2#五、依赖倒置原则\",\"476\":\"v-282ab0b2#_1、简介-4\",\"477\":\"v-282ab0b2#_2、例子-4\",\"478\":\"v-282ab0b2#_3、总结-4\",\"479\":\"v-282ab0b2#六、kiss原则\",\"480\":\"v-282ab0b2#_1、简介-5\",\"481\":\"v-282ab0b2#_2、例子-5\",\"482\":\"v-282ab0b2#_3、总结-5\",\"483\":\"v-282ab0b2#七、dry原则\",\"484\":\"v-282ab0b2#_1、简介-6\",\"485\":\"v-282ab0b2#_2、例子-6\",\"486\":\"v-282ab0b2#_3、总结-6\",\"487\":\"v-282ab0b2#八、迪米特原则\",\"488\":\"v-282ab0b2#_1、简介-7\",\"489\":\"v-282ab0b2#_2、例子-7\",\"490\":\"v-282ab0b2#_3、总结-7\",\"491\":\"v-282ab0b2@0\",\"492\":\"v-282ab0b2@1\",\"493\":\"v-0b6ba206\",\"494\":\"v-0b6ba206#一、代理设计模式\",\"495\":\"v-0b6ba206#_1、静态代理\",\"496\":\"v-0b6ba206#_2、动态代理\",\"497\":\"v-0b6ba206#基于-jdk-实现的动态代理\",\"498\":\"v-0b6ba206#基于-cglib-实现的动态代理\",\"499\":\"v-0b6ba206#二、装饰器设计模式\",\"500\":\"v-0b6ba206#_1、简介\",\"501\":\"v-0b6ba206#_2、基本流程\",\"502\":\"v-0b6ba206#_3、案例\",\"503\":\"v-0b6ba206#三、桥接设计模式\",\"504\":\"v-0b6ba206#_1、简介-1\",\"505\":\"v-0b6ba206#_2、基本流程-1\",\"506\":\"v-0b6ba206#_3、案例-1\",\"507\":\"v-0b6ba206#四、适配器设计模式\",\"508\":\"v-0b6ba206#_1、简介-2\",\"509\":\"v-0b6ba206#_2、基本流程-2\",\"510\":\"v-0b6ba206#_3、使用场景和案例\",\"511\":\"v-0b6ba206#_4、实际案例\",\"512\":\"v-0b6ba206#_5、总结\",\"513\":\"v-0b6ba206#五、门面设计模式\",\"514\":\"v-0b6ba206#_1、介绍\",\"515\":\"v-0b6ba206#_2、核心思想\",\"516\":\"v-0b6ba206#_3、组成和基本流程\",\"517\":\"v-0b6ba206#_4、使用场景\",\"518\":\"v-0b6ba206#_5、具体案例\",\"519\":\"v-0b6ba206#_6、总结\",\"520\":\"v-0b6ba206#_7、与适配器设计模式的区别\",\"521\":\"v-0b6ba206#六、组合设计模式\",\"522\":\"v-0b6ba206#_1、介绍-1\",\"523\":\"v-0b6ba206#_2、核心思想-1\",\"524\":\"v-0b6ba206#_3、组成和基本流程-1\",\"525\":\"v-0b6ba206#_4、案例\",\"526\":\"v-0b6ba206#_5、总结-1\",\"527\":\"v-0b6ba206#七、享元设计模式\",\"528\":\"v-0b6ba206#_1、介绍-2\",\"529\":\"v-0b6ba206#_2、核心思想-2\",\"530\":\"v-0b6ba206#_3、组成和基本流程-2\",\"531\":\"v-0b6ba206#_4、使用场景-1\",\"532\":\"v-0b6ba206#_6、具体案例-仅标题\",\"533\":\"v-0b6ba206#_7、总结\",\"534\":\"v-0b6ba206@0\",\"535\":\"v-0b6ba206@1\",\"536\":\"v-4ab3a26b\",\"537\":\"v-4ab3a26b#_1、发展历程\",\"538\":\"v-4ab3a26b#_2、配置环境\",\"539\":\"v-4ab3a26b#_3、项目结构\",\"540\":\"v-4ab3a26b#_4、界面显示和逻辑处理\",\"541\":\"v-4ab3a26b@0\",\"542\":\"v-4ab3a26b@1\",\"543\":\"v-576e4dc2\",\"544\":\"v-489f6134\",\"545\":\"v-2e819dc2\",\"546\":\"v-55099d5a\",\"547\":\"v-55099d5a#_1、应用层的主要功能是什么-可以列举一些常见的应用层协议\",\"548\":\"v-55099d5a#_2、什么是http-http的报文格式\",\"549\":\"v-55099d5a#_3、什么是https-为什么要使用它\",\"550\":\"v-55099d5a#_4、它的工作流程是怎么样的\",\"551\":\"v-55099d5a#_5、客户端怎么去校验证书的合法性\",\"552\":\"v-55099d5a#_6、http和https的区别是什么\",\"553\":\"v-55099d5a#_7、http-有哪些请求方式\",\"554\":\"v-55099d5a#_8、什么是restful-api-它的特点是什么-可以举例说明一个符合restful设计风格的api吗\",\"555\":\"v-55099d5a#_9、get-请求和-post-请求的区别是什么\",\"556\":\"v-55099d5a#_10、get-的长度限制是多少\",\"557\":\"v-55099d5a#_11、http-请求的过程与原理\",\"558\":\"v-55099d5a#_12、uri和url的区别是什么\",\"559\":\"v-55099d5a#_13、常用的http-状态码有哪些-介绍一下\",\"560\":\"v-55099d5a#_14、http-协议是无状态的-你是怎么理解的\",\"561\":\"v-55099d5a#_15、session-和-cookie-有什么联系和区别\",\"562\":\"v-55099d5a#_16、http-1-0-1-1-2-0-的区别有哪些\",\"563\":\"v-55099d5a#_17、什么是http-3\",\"564\":\"v-55099d5a#_18、http-如何实现长连接-在什么时候会超时\",\"565\":\"v-55099d5a#_19、什么是websocket-它相对于http有哪些优势\",\"566\":\"v-55099d5a#_20、说说-websocket-与-socket-的区别\",\"567\":\"v-55099d5a#_21、什么是dns-它的作用是什么\",\"568\":\"v-55099d5a#_22、smtp和pop3是什么协议-它们分别用于什么\",\"569\":\"v-55099d5a#_23、什么是ftp-它是用来做什么的\",\"570\":\"v-55099d5a#_24、应用层常用端口有哪些\",\"571\":\"v-55099d5a@0\",\"572\":\"v-7a2de5aa\",\"573\":\"v-7a2de5aa#_1、数据链路层的主要功能是什么\",\"574\":\"v-7a2de5aa#_2、什么是mac地址-它与ip地址有何区别\",\"575\":\"v-7a2de5aa#_3、数据帧的结构是怎样的\",\"576\":\"v-7a2de5aa#_4、流控制和差错控制是什么-你能列举一些常见的流控制和差错控制协议吗\",\"577\":\"v-7a2de5aa#_5、数据链路层中的封装、透明传输和可靠传输是什么\",\"578\":\"v-7a2de5aa#_6、以太网协议是怎样运作的\",\"579\":\"v-7a2de5aa#_7、什么是虚拟局域网-vlan-它的作用是什么\",\"580\":\"v-7a2de5aa#_8、交换机和集线器有哪些区别-交换机与路由器的区别又是什么\",\"581\":\"v-7a2de5aa#_9、在数据链路层中-csma-cd是什么-在哪种网络中使用\",\"582\":\"v-7a2de5aa#_10、解释一下半双工与全双工通信的区别\",\"583\":\"v-7a2de5aa#_11、arp协议是用来做什么的-它的作用是什么\",\"584\":\"v-7a2de5aa#_13、hdlc协议在数据链路层中有什么作用\",\"585\":\"v-7a2de5aa@0\",\"586\":\"v-1533ac35\",\"587\":\"v-1533ac35#_1、网络层的主要作用是什么\",\"588\":\"v-1533ac35#_2、网络层提供了哪些服务\",\"589\":\"v-1533ac35#i-屏蔽网络差异-提供透明传输\",\"590\":\"v-1533ac35#ii-为网络间通信提供路由选择\",\"591\":\"v-1533ac35#iii-数据包封装和解封装\",\"592\":\"v-1533ac35#iv-拥塞控制\",\"593\":\"v-1533ac35#_2、ip协议的定义和作用\",\"594\":\"v-1533ac35#_2、域名和-ip-的关系-一个-ip-可以对应多个域名吗\",\"595\":\"v-1533ac35#_3、什么是子网掩码-它的作用是什么\",\"596\":\"v-1533ac35#_4、如何进行子网划分\",\"597\":\"v-1533ac35#_5、什么是默认网关\",\"598\":\"v-1533ac35#_6、什么是路由器-它在网络中的作用是什么\",\"599\":\"v-1533ac35#_7、什么是ip地址-ipv4和ipv6的区别是什么\",\"600\":\"v-1533ac35#_8、ip地址的分类有哪些-a类、b类和c类地址的范围是多少\",\"601\":\"v-1533ac35#_9、为什么有了-ip-地址-还要-mac-地址\",\"602\":\"v-1533ac35#_10、ipv4-地址不够如何解决\",\"603\":\"v-1533ac35#_11、常见的路由协议有哪些\",\"604\":\"v-1533ac35#_12、什么是cidr\",\"605\":\"v-1533ac35#_13、什么是nat-它的作用是什么\",\"606\":\"v-1533ac35#_14、什么是静态路由和动态路由-它们之间有什么区别\",\"607\":\"v-1533ac35#_15、什么是arp-说说它的工作流程和作用\",\"608\":\"v-1533ac35#_16、什么是ospf协议-它的工作原理是什么\",\"609\":\"v-1533ac35#_17、什么是bgp协议-它的作用是什么\",\"610\":\"v-1533ac35#_18、-什么是防火墙-它的作用是什么\",\"611\":\"v-1533ac35#_19、解释一下icmp协议的作用。\",\"612\":\"v-1533ac35#_20、什么是dhcp-它的作用是什么\",\"613\":\"v-1533ac35#_21、什么是ip地址分配方式-静态分配和动态分配\",\"614\":\"v-1533ac35#_22、ping的工作原理是什么\",\"615\":\"v-1533ac35@0\",\"616\":\"v-6279ced8\",\"617\":\"v-6279ced8#_1、物理层的主要功能是什么\",\"618\":\"v-6279ced8#_2、介绍一下常见工作在物理层的设备有哪些\",\"619\":\"v-6279ced8#_3、什么是调制和解调-能列举一些常见的调制技术吗\",\"620\":\"v-6279ced8#_5、解释一下带宽和频谱-它们之间有何区别\",\"621\":\"v-6279ced8#频谱则关注信号中各个频率成分的分布情况\",\"622\":\"v-6279ced8#_6、奈氏准则和香农公式在通信中扮演着什么样的角色\",\"623\":\"v-6279ced8#_7、未完待续\",\"624\":\"v-6279ced8@0\",\"625\":\"v-022903e5\",\"626\":\"v-022903e5#一、基础题\",\"627\":\"v-022903e5#_1、说说计算机网络体系结构\",\"628\":\"v-022903e5#_2、每一层对应的网络协议有哪些\",\"629\":\"v-022903e5#_3、数据在各层之间是怎么传输的呢-数据是如何变化的\",\"630\":\"v-022903e5#二、场景题\",\"631\":\"v-022903e5#_1、从浏览器地址栏输入-url-到显示主页的过程\",\"632\":\"v-022903e5#_2、说说-dns-的解析过程\",\"633\":\"v-022903e5@0\",\"634\":\"v-d2fe2ccc\",\"635\":\"v-d2fe2ccc#_1、传输层的主要功能是什么\",\"636\":\"v-d2fe2ccc#_2、传输层提供了哪两种主要的协议\",\"637\":\"v-d2fe2ccc#_3、tcp和udp的区别是什么-在什么情况下会选择使用tcp或udp\",\"638\":\"v-d2fe2ccc#_4、说说什么是三次握手和工作流程\",\"639\":\"v-d2fe2ccc#_5、为什么不能是两次握手-不能是四次握手\",\"640\":\"v-d2fe2ccc#_6、三次握手中每一次没收到报文会发生什么情况\",\"641\":\"v-d2fe2ccc#_7、第二次握手传回了-ack-为什么还要传回-syn\",\"642\":\"v-d2fe2ccc#_8、第-3-次握手可以携带数据吗\",\"643\":\"v-d2fe2ccc#_9、什么是半连接队列和-syn-flood-攻击有什么关系\",\"644\":\"v-d2fe2ccc#_10、详细说说-tcp-四次挥手的过程\",\"645\":\"v-d2fe2ccc#_11、tcp-挥手为什么需要四次呢\",\"646\":\"v-d2fe2ccc#_12、tcp-四次挥手过程中-为什么需要等待-2msl-才进入-closed-关闭状态\",\"647\":\"v-d2fe2ccc#_13、保活计时器有什么用\",\"648\":\"v-d2fe2ccc#_14、close-wait-和-time-wait-的状态和意义\",\"649\":\"v-d2fe2ccc#_15、time-wait-状态过多会导致什么问题-怎么解决\",\"650\":\"v-d2fe2ccc#_16、说说-tcp-报文首部格式\",\"651\":\"v-d2fe2ccc#_17、tcp-是如何保证可靠性的\",\"652\":\"v-d2fe2ccc#_18、什么是拥塞控制-tcp如何进行拥塞控制\",\"653\":\"v-d2fe2ccc#_19、什么是流量控制-tcp如何进行流量控制\",\"654\":\"v-d2fe2ccc#_20、什么是滑动窗口协议-它在传输层中的作用是什么\",\"655\":\"v-d2fe2ccc#_21、tcp的滑动窗口大小如何动态调整\",\"656\":\"v-d2fe2ccc#_22、什么是tcp的粘包和拆包问题-如何解决\",\"657\":\"v-d2fe2ccc#_23、什么是tcp的超时重传机制-它是如何工作的\",\"658\":\"v-d2fe2ccc#_24、什么是快速重传和快速恢复\",\"659\":\"v-d2fe2ccc#_25、什么是nagle算法-它的作用是什么\",\"660\":\"v-d2fe2ccc#_26、什么是延迟确认机制-delayed-ack\",\"661\":\"v-d2fe2ccc#_27、什么是udp协议-它适用于哪些场景\",\"662\":\"v-d2fe2ccc#_28、说说-tcp-报文首部格式\",\"663\":\"v-d2fe2ccc#_29、为什么-xx-采用-udp-协议\",\"664\":\"v-d2fe2ccc#_30、udp-协议为什么不可靠\",\"665\":\"v-d2fe2ccc#_31、dns-为什么要用-udp\",\"666\":\"v-d2fe2ccc#_32、运输层常用端口有哪些\",\"667\":\"v-d2fe2ccc@0\",\"668\":\"v-4551977c\",\"669\":\"v-4551977c#一、基础\",\"670\":\"v-4551977c#_1、java集合框架体系\",\"671\":\"v-4551977c#_2、那这几个父类接口有什么区别\",\"672\":\"v-4551977c#_3、无序性和不可重复性\",\"673\":\"v-4551977c#_4、为什么要使用集合-如何挑选合适的集合\",\"674\":\"v-4551977c#_5、comparable-和-comparator\",\"675\":\"v-4551977c#_6、java里线程安全的集合\",\"676\":\"v-4551977c#二、单值集合\",\"677\":\"v-4551977c#_1、说说你对arraylist的理解\",\"678\":\"v-4551977c#_2、说说你对linkedlist的理解\",\"679\":\"v-4551977c#_3、arraylist和linkedlist的区别\",\"680\":\"v-4551977c#_4、arraylist序列化\",\"681\":\"v-4551977c#_5、arraylist是不是线程安全的\",\"682\":\"v-4551977c#_6、你是否了解copyonwritearraylist\",\"683\":\"v-4551977c#_7、hashset实现原理\",\"684\":\"v-4551977c#二、双值集合\",\"685\":\"v-4551977c#_1、说说你对hashmap的理解\",\"686\":\"v-4551977c#_2、hashmap的实现原理\",\"687\":\"v-4551977c#_3、hashmap可以添加null-元素可以重复吗\",\"688\":\"v-4551977c#_4、为什么hashmap-的长度是-2-的幂次方-倍数\",\"689\":\"v-4551977c#_5、如果初始化hashmap-传入的值不是2的倍数-它会怎么处理\",\"690\":\"v-4551977c#_6、你和我简单的说一说hash算法\",\"691\":\"v-4551977c#_7、你还知道哪些哈希函数的构造方法呢\",\"692\":\"v-4551977c#_8、解决哈希冲突有哪些方法呢\",\"693\":\"v-4551977c#_9、hashmap的哈希-扰动函数是怎么设计的\",\"694\":\"v-4551977c#_10、为什么哈希-扰动函数能降hash碰撞\",\"695\":\"v-4551977c#_11、hashmap的put-流程\",\"696\":\"v-4551977c#_12、扩容在什么时候呢-为什么扩容因子是0-75\",\"697\":\"v-4551977c#_13、为什么hashmap链表转红黑树的阈值为8呢\",\"698\":\"v-4551977c#_14、你对红黑树了解多少-为什么不用二叉树-平衡树呢\",\"699\":\"v-4551977c#_15、红黑树怎么保持平衡的知道吗\",\"700\":\"v-4551977c#_16、hashmap怎么查找元素的呢\",\"701\":\"v-4551977c#_17、jdk1-8对hashmap主要做了哪些优化呢\",\"702\":\"v-4551977c#_18、hashmap-常见的遍历方式\",\"703\":\"v-4551977c#_19、hashmap可以按照key来排序吗-如果不可以-有没有可以的实现\",\"704\":\"v-4551977c#_20、hashmap-和-hashset-区别\",\"705\":\"v-4551977c#_21、hashmap-和-treemap-区别\",\"706\":\"v-4551977c#_22、hashmap-和-hashtable-的区别\",\"707\":\"v-4551977c#_23、hashmap为什么线程不安全\",\"708\":\"v-4551977c#_24、有什么办法能解决hashmap线程不安全的问题呢\",\"709\":\"v-4551977c#_25、快速失败-fail-fast-和安全失败-fail-safe\",\"710\":\"v-4551977c#_26、并发修改异常是什么-什么情况下会发生\",\"711\":\"v-4551977c#_27、concurrenthashmap的底层实现原理是什么\",\"712\":\"v-4551977c#_28、concurrenthashmap-为什么-key-和-value可以为null吗\",\"713\":\"v-4551977c#_29、concurrenthashmap能保证复合性操作吗\",\"714\":\"v-4551977c#_30、linkedhashmap-底层实现\",\"715\":\"v-4551977c#_31、linkedhashmap和-hashmap-有什么区别\",\"716\":\"v-4551977c@0\",\"717\":\"v-34fdc371\",\"718\":\"v-34fdc371#一、内存区域\",\"719\":\"v-34fdc371#_1、什么是jvm\",\"720\":\"v-34fdc371#_2、jvm运行过程\",\"721\":\"v-34fdc371#_3、jvm-后台运行的系统线程主要有哪些\",\"722\":\"v-34fdc371#_4、jvm的内存区域\",\"723\":\"v-34fdc371#_5、jdk1-6、1-7、1-8-内存区域有什么变化\",\"724\":\"v-34fdc371#_6、栈和堆有什么区别\",\"725\":\"v-34fdc371#_7、为什么使用元空间替代永久代作为方法区的实现\",\"726\":\"v-34fdc371#_8、jvm中对象的创建的过程\",\"727\":\"v-34fdc371#_9、内存分配的方式有几种\",\"728\":\"v-34fdc371#_10、jvm-里-new-对象时-堆会发生抢占吗-jvm-是怎么设计来保证线程安全的\",\"729\":\"v-34fdc371#_11、说一下对象的内存布局组成结构\",\"730\":\"v-34fdc371#_12、访问对象的有几种方式\",\"731\":\"v-34fdc371#_13、内存溢出和内存泄漏是什么意思\",\"732\":\"v-34fdc371#二、垃圾回收\",\"733\":\"v-34fdc371#_1、如何判断对象是垃圾-对象是否死亡-有什么方法\",\"734\":\"v-34fdc371#_2、java-中可作为-gc-roots-的对象有哪几种\",\"735\":\"v-34fdc371#_3、说一下对象有哪几种引用\",\"736\":\"v-34fdc371#_4、finalize-方法了解吗-有什么作用\",\"737\":\"v-34fdc371#_5、java-堆的内存分区了解吗\",\"738\":\"v-34fdc371#_6、minor-gc、major-gc、mixed-gc、full-gc-都是什么意思\",\"739\":\"v-34fdc371#_7、minor-gc和full-gc-什么时候触发\",\"740\":\"v-34fdc371#_8、对象什么时候会进入老年代\",\"741\":\"v-34fdc371#_9、你能说说young-gc和full-gc的过程吗\",\"742\":\"v-34fdc371#_10、跨代引用问题\",\"743\":\"v-34fdc371#_11、空间分配担保机制\",\"744\":\"v-34fdc371#_13、垃圾收集算法了解吗\",\"745\":\"v-34fdc371#_14、你了解垃圾回收器有哪些-详细介绍一下\",\"746\":\"v-34fdc371#_15、说一下cms垃圾回收器\",\"747\":\"v-34fdc371#_16、什么是strop-the-world-有哪些区域需要停顿-为什么要停顿-什么是-oopmap-什么是安全点\",\"748\":\"v-34fdc371#_17、三色标记法了解吗-在哪使用的-为什么要引入\",\"749\":\"v-34fdc371#_18、g1垃圾收集器了解吗-详细说说-g1中为什么划分region\",\"750\":\"v-34fdc371#_19、g1的工作流程是怎么样的-详细展开\",\"751\":\"v-34fdc371#_20、cms和g1有什么区别\",\"752\":\"v-34fdc371#_21、垃圾收集器应该如何选择\",\"753\":\"v-34fdc371#三、类加载\",\"754\":\"v-34fdc371#_1、类加载过程和类的生命周期\",\"755\":\"v-34fdc371#_2、哪些时候会触发类加载\",\"756\":\"v-34fdc371#_3、类加载器有哪些\",\"757\":\"v-34fdc371#_4、创建对象有几种方式\",\"758\":\"v-34fdc371#_5、什么是双亲委派机制\",\"759\":\"v-34fdc371#_6、打破双亲委派怎么操作\",\"760\":\"v-34fdc371#_7、tomcat-的类加载机制\",\"761\":\"v-34fdc371#四、jvm调优\",\"762\":\"v-34fdc371#_1、常用的命令行性能监控和故障处理工具\",\"763\":\"v-34fdc371#_2、常用的可视化的性能监控和故障处理工具\",\"764\":\"v-34fdc371#_3、jvm-的常见参数配置\",\"765\":\"v-34fdc371#_4、线上服务-cpu-占用过高怎么排查\",\"766\":\"v-34fdc371#_5、内存飙高问题怎么排查\",\"767\":\"v-34fdc371#_6、频繁-minor-gc\",\"768\":\"v-34fdc371#_7、频繁-full-gc\",\"769\":\"v-34fdc371#_8、如何定位内存泄漏问题\",\"770\":\"v-34fdc371#_9、如何定位内存溢出问题\",\"771\":\"v-34fdc371@0\",\"772\":\"v-0cbf8da4\",\"773\":\"v-0cbf8da4#_1、基本类型和包装类型的区别\",\"774\":\"v-0cbf8da4#_2、包装类的缓存机制\",\"775\":\"v-0cbf8da4#_3、成员变量与局部变量的区别\",\"776\":\"v-0cbf8da4#_4、静态变量有什么作用\",\"777\":\"v-0cbf8da4#_5、字符型常量和字符串常量的区别\",\"778\":\"v-0cbf8da4#_6、静态方法为什么不能调用非静态成员\",\"779\":\"v-0cbf8da4#_7、静态方法和实例方法有何不同\",\"780\":\"v-0cbf8da4#_8、重载和重写有什么区别\",\"781\":\"v-0cbf8da4#_9、面向对象和面向过程的区别\",\"782\":\"v-0cbf8da4#_10、面向对象三大特征\",\"783\":\"v-0cbf8da4#_11、接口和抽象类有什么共同点和区别\",\"784\":\"v-0cbf8da4#_12、深拷贝和浅拷贝区别了解吗\",\"785\":\"v-0cbf8da4#_13、object-类的常见方法有哪些\",\"786\":\"v-0cbf8da4#_14、-和-equals-的区别\",\"787\":\"v-0cbf8da4#_15、什么是hashcode\",\"788\":\"v-0cbf8da4#_16、为什么重写-equals-时必须重写-hashcode-方法\",\"789\":\"v-0cbf8da4#_18、string、stringbuffer、stringbuilder-的区别\",\"790\":\"v-0cbf8da4#_19、字符串拼接用-还是-stringbuilder\",\"791\":\"v-0cbf8da4#_20、这句话创建了几个字符串对象\",\"792\":\"v-0cbf8da4#_21、string-类型的变量和常量做-运算时发生了什么\",\"793\":\"v-0cbf8da4#_22、java异常的体系介绍一下\",\"794\":\"v-0cbf8da4#_23、throwable有哪些常用方法\",\"795\":\"v-0cbf8da4#_24、try-catch-finally-使用介绍一下\",\"796\":\"v-0cbf8da4#_25、finally-中的代码一定会执行吗\",\"797\":\"v-0cbf8da4#_26、什么是泛型\",\"798\":\"v-0cbf8da4#_27、什么是反射\",\"799\":\"v-0cbf8da4#_27、反射的原理是什么\",\"800\":\"v-0cbf8da4#_28、反射的应用场景有哪些\",\"801\":\"v-0cbf8da4@0\",\"802\":\"v-7d695854\",\"803\":\"v-7d695854#一、基础\",\"804\":\"v-7d695854#_1、程序、进程、线程\",\"805\":\"v-7d695854#_2、并行跟并发\",\"806\":\"v-7d695854#_3、线程有几种创建方式\",\"807\":\"v-7d695854#_4、线程有哪些常用的调度方法\",\"808\":\"v-7d695854#_5、线程有几种状态-生命周期\",\"809\":\"v-7d695854#_6、线程上下文切换\",\"810\":\"v-7d695854#_7、守护线程\",\"811\":\"v-7d695854#_8、线程间通信方式\",\"812\":\"v-7d695854#_9、sleep-方法和-wait-方法\",\"813\":\"v-7d695854#_10、为什么-wait-方法不定义在-thread-中\",\"814\":\"v-7d695854#_11、线程安全\",\"815\":\"v-7d695854#二、threadlocal\",\"816\":\"v-7d695854#_1、什么是threadlocal\",\"817\":\"v-7d695854#_2、threadlocal使用场景\",\"818\":\"v-7d695854#_3、threadlocal-内存泄露\",\"819\":\"v-7d695854#_4、threadlocalmap的结构\",\"820\":\"v-7d695854#_5、threadlocalmap的hash冲突\",\"821\":\"v-7d695854#_6、threadlocalmap的扩容机制\",\"822\":\"v-7d695854#_7、父子线程怎么共享数据\",\"823\":\"v-7d695854#三、java内存模型\",\"824\":\"v-7d695854#_1、java内存模型-jmm\",\"825\":\"v-7d695854#_2、说说你对原子性、可见性、有序性的理解\",\"826\":\"v-7d695854#_3、那说说什么是指令重排-指令重排有限制吗\",\"827\":\"v-7d695854#_4、volatile有什么作用\",\"828\":\"v-7d695854#_5、volatile实现原理了解吗\",\"829\":\"v-7d695854#_6、为什么volatile不能保证原子性\",\"830\":\"v-7d695854#四、锁\",\"831\":\"v-7d695854#_1、保证线程安全有什么方案\",\"832\":\"v-7d695854#_2、介绍一下java里面常见的锁\",\"833\":\"v-7d695854#_3、synchronized怎么使用\",\"834\":\"v-7d695854#_4、synchronized和volatile的区别\",\"835\":\"v-7d695854#_5、synchronized的实现原理\",\"836\":\"v-7d695854#_6、除了原子性-synchronized可见性-有序性-可重入性怎么实现\",\"837\":\"v-7d695854#_7、synchronized优化了解吗\",\"838\":\"v-7d695854#_8、介绍reentrantlock\",\"839\":\"v-7d695854#_9、reentrantlock实现原理\",\"840\":\"v-7d695854#_10、reentrantlock怎么实现公平和非公平锁\",\"841\":\"v-7d695854#_11、可中断锁和不可中断锁有什么区别\",\"842\":\"v-7d695854#_12、reentrantreadwritelock\",\"843\":\"v-7d695854#_13、说说synchronized和reentrantlock的区别\",\"844\":\"v-7d695854#_14、如何保证多线程下i-结果正确\",\"845\":\"v-7d695854#_15、什么是cas-cas有什么问题\",\"846\":\"v-7d695854#_16、什么是aqs\",\"847\":\"v-7d695854#_17、atomicinteger-的原理\",\"848\":\"v-7d695854#_18、什么是死锁-如何避免\",\"849\":\"v-7d695854#_19、如何排查死锁\",\"850\":\"v-7d695854#五、并发工具类\",\"851\":\"v-7d695854#_1、countdownlatch了解吗\",\"852\":\"v-7d695854#_2、cyclicbarrier了解吗\",\"853\":\"v-7d695854#_3、semaphore了解吗\",\"854\":\"v-7d695854#_4、exchanger-了解吗\",\"855\":\"v-7d695854#_5、longadder原理\",\"856\":\"v-7d695854#六、线程池\",\"857\":\"v-7d695854#_1、什么是线程池-为什么要有线程池\",\"858\":\"v-7d695854#_2、线程池的应用有哪些\",\"859\":\"v-7d695854#_3、有哪几种常见的线程池\",\"860\":\"v-7d695854#_4、线程池的参数有哪些\",\"861\":\"v-7d695854#_5、线程池的拒绝策略有哪些\",\"862\":\"v-7d695854#_6、线程池有哪几种工作队列\",\"863\":\"v-7d695854#_7、线程池提交execute和submit有什么区别\",\"864\":\"v-7d695854#_8、线程池怎么关闭\",\"865\":\"v-7d695854#_9、线程池异常怎么处理\",\"866\":\"v-7d695854#_10、线程池的线程数应该怎么配置\",\"867\":\"v-7d695854#_11、线程池有几种状态\",\"868\":\"v-7d695854#_12、线程池工作流程\",\"869\":\"v-7d695854#_13、线程池如何实现参数的动态修改\",\"870\":\"v-7d695854#_14、你能设计实现一个线程池\",\"871\":\"v-7d695854#_15、单机线程池执行断电了应该怎么处理\",\"872\":\"v-7d695854@0\",\"873\":\"v-42ee762e\",\"874\":\"v-42ee762e@0\",\"875\":\"v-5d2dbfb0\",\"876\":\"v-5d2dbfb0@0\",\"877\":\"v-18e43bbc\",\"878\":\"v-18e43bbc@0\",\"879\":\"v-eb29014c\",\"880\":\"v-eb29014c@0\",\"881\":\"v-509d1a32\",\"882\":\"v-509d1a32@0\",\"883\":\"v-41d45d51\",\"884\":\"v-41d45d51@0\",\"885\":\"v-30274d26\",\"886\":\"v-30274d26@0\",\"887\":\"v-ee9fc8aa\",\"888\":\"v-ee9fc8aa@0\",\"889\":\"v-7232a4f2\",\"890\":\"v-7232a4f2@0\",\"891\":\"v-667f72d5\",\"892\":\"v-667f72d5@0\",\"893\":\"v-aa7ac45e\",\"894\":\"v-aa7ac45e@0\",\"895\":\"v-169b367c\",\"896\":\"v-1c1045a0\",\"897\":\"v-1a3269d6\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,13],\"1\":[2,12],\"2\":[2],\"3\":[2,43],\"4\":[2],\"5\":[3,18],\"6\":[2],\"7\":[2,5],\"8\":[2,204],\"9\":[2],\"10\":[2,5],\"11\":[2,50],\"12\":[2],\"13\":[2,5],\"14\":[2,23],\"15\":[2],\"16\":[2],\"17\":[3,15],\"18\":[3,21],\"19\":[2,28],\"20\":[2,7],\"21\":[2,8],\"22\":[2,26],\"23\":[2,19],\"24\":[2,39],\"25\":[null,null,1],\"26\":[null,null,1],\"27\":[2,12],\"28\":[2],\"29\":[2,43],\"30\":[2],\"31\":[3,18],\"32\":[2],\"33\":[2,5],\"34\":[2,204],\"35\":[2],\"36\":[2,5],\"37\":[2,50],\"38\":[2],\"39\":[2,5],\"40\":[2,23],\"41\":[2],\"42\":[2],\"43\":[3,15],\"44\":[3,21],\"45\":[2,28],\"46\":[2,7],\"47\":[2,8],\"48\":[2,26],\"49\":[2,19],\"50\":[2,39],\"51\":[null,null,1],\"52\":[null,null,1],\"53\":[1,3],\"54\":[1,7],\"55\":[2],\"56\":[2,32],\"57\":[2],\"58\":[4,40],\"59\":[3,20],\"60\":[2],\"61\":[2],\"62\":[3,24],\"63\":[3,15],\"64\":[2,53],\"65\":[2],\"66\":[2],\"67\":[3,19],\"68\":[3,17],\"69\":[2,39],\"70\":[2],\"71\":[3,45],\"72\":[3,13],\"73\":[2,2],\"74\":[3,6],\"75\":[3,8],\"76\":[3,7],\"77\":[5,11],\"78\":[3,20],\"79\":[3,7],\"80\":[5,4],\"81\":[3,22],\"82\":[2],\"83\":[2,52],\"84\":[2],\"85\":[3,45],\"86\":[3,35],\"87\":[2,27],\"88\":[2],\"89\":[2],\"90\":[3,17],\"91\":[3,16],\"92\":[2,3],\"93\":[3,5],\"94\":[3,62],\"95\":[3,4],\"96\":[2,38],\"97\":[2,12],\"98\":[3,15],\"99\":[2,24],\"100\":[2,1],\"101\":[2],\"102\":[2],\"103\":[3,7],\"104\":[3,45],\"105\":[2],\"106\":[3,6],\"107\":[3,26],\"108\":[3,8],\"109\":[3,9],\"110\":[3,9],\"111\":[3,18],\"112\":[3,18],\"113\":[4,28],\"114\":[2,38],\"115\":[null,null,1],\"116\":[null,null,1],\"117\":[1,3],\"118\":[2],\"119\":[2,49],\"120\":[2,49],\"121\":[2,23],\"122\":[2],\"123\":[2,8],\"124\":[4,4],\"125\":[3,22],\"126\":[3,12],\"127\":[3,7],\"128\":[2],\"129\":[3,16],\"130\":[3,12],\"131\":[3,84],\"132\":[3,26],\"133\":[2,8],\"134\":[3,26],\"135\":[3,36],\"136\":[2,10],\"137\":[5,46],\"138\":[3,43],\"139\":[3,39],\"140\":[2,20],\"141\":[3,17],\"142\":[3,15],\"143\":[2],\"144\":[2,47],\"145\":[2],\"146\":[3],\"147\":[4,6],\"148\":[4,12],\"149\":[4,3],\"150\":[4,28],\"151\":[3],\"152\":[3,135],\"153\":[3,51],\"154\":[2],\"155\":[2,13],\"156\":[3,13],\"157\":[3,7],\"158\":[3,61],\"159\":[2,118],\"160\":[2],\"161\":[2,35],\"162\":[2,37],\"163\":[4],\"164\":[2],\"165\":[3,19],\"166\":[3,61],\"167\":[2,22],\"168\":[2,46],\"169\":[2,3],\"170\":[2,23],\"171\":[2,21],\"172\":[2],\"173\":[3,27],\"174\":[3,36],\"175\":[3,54],\"176\":[null,null,1],\"177\":[null,null,1],\"178\":[1,4],\"179\":[2],\"180\":[2,9],\"181\":[2,27],\"182\":[2,14],\"183\":[2],\"184\":[4,86],\"185\":[3,1],\"186\":[3,9],\"187\":[3,6],\"188\":[2],\"189\":[2,11],\"190\":[3],\"191\":[1,9],\"192\":[1,7],\"193\":[1,11],\"194\":[3,11],\"195\":[2],\"196\":[3,25],\"197\":[3,6],\"198\":[3,29],\"199\":[2],\"200\":[3,51],\"201\":[3,53],\"202\":[3,5],\"203\":[2,2],\"204\":[2],\"205\":[3,88],\"206\":[3,31],\"207\":[2,9],\"208\":[3,53],\"209\":[3,16],\"210\":[2,96],\"211\":[2,36],\"212\":[2,64],\"213\":[2],\"214\":[2],\"215\":[3,34],\"216\":[3,23],\"217\":[2,54],\"218\":[2,56],\"219\":[2],\"220\":[3,50],\"221\":[3,46],\"222\":[2,51],\"223\":[2,54],\"224\":[null,null,1],\"225\":[null,null,1],\"226\":[1,6],\"227\":[2,50],\"228\":[2],\"229\":[2,32],\"230\":[2,67],\"231\":[2],\"232\":[3,7],\"233\":[3,10],\"234\":[2,13],\"235\":[3,20],\"236\":[3,17],\"237\":[2,17],\"238\":[2,71],\"239\":[2,57],\"240\":[2,109],\"241\":[null,null,1],\"242\":[null,null,1],\"243\":[1,4],\"244\":[2],\"245\":[2,2],\"246\":[3,8],\"247\":[3,10],\"248\":[3,6],\"249\":[2,16],\"250\":[2,15],\"251\":[2,35],\"252\":[2,2],\"253\":[2,53],\"254\":[2,41],\"255\":[2,21],\"256\":[2],\"257\":[2,39],\"258\":[2,2],\"259\":[2],\"260\":[3,49],\"261\":[3,23],\"262\":[3,24],\"263\":[3,25],\"264\":[3,11],\"265\":[3,6],\"266\":[3,2],\"267\":[3,2],\"268\":[2,140],\"269\":[null,null,1],\"270\":[null,null,1],\"271\":[1,1],\"272\":[2],\"273\":[2,21],\"274\":[2,34],\"275\":[2,43],\"276\":[2,9],\"277\":[3,22],\"278\":[3,11],\"279\":[2,70],\"280\":[2,40],\"281\":[2],\"282\":[2,46],\"283\":[2,5],\"284\":[2,3],\"285\":[3,54],\"286\":[3,38],\"287\":[2,12],\"288\":[3,5],\"289\":[3,8],\"290\":[3,17],\"291\":[3,45],\"292\":[2],\"293\":[3,9],\"294\":[3,86],\"295\":[2],\"296\":[3,92],\"297\":[3,40],\"298\":[3,12],\"299\":[3,41],\"300\":[2],\"301\":[2,61],\"302\":[2,20],\"303\":[2],\"304\":[2,22],\"305\":[2,9],\"306\":[null,null,1],\"307\":[null,null,1],\"308\":[1],\"309\":[2],\"310\":[2],\"311\":[3,25],\"312\":[4,41],\"313\":[2,8],\"314\":[3,21],\"315\":[3,48],\"316\":[3,224],\"317\":[2,39],\"318\":[null,null,1],\"319\":[null,null,1],\"320\":[1,9],\"321\":[2],\"322\":[2,10],\"323\":[2,9],\"324\":[2,29],\"325\":[2,96],\"326\":[2,150],\"327\":[2,130],\"328\":[2,24],\"329\":[2],\"330\":[2,17],\"331\":[2,9],\"332\":[2,40],\"333\":[2,85],\"334\":[3],\"335\":[2,78],\"336\":[2,54],\"337\":[3],\"338\":[3,87],\"339\":[2,27],\"340\":[2],\"341\":[2,10],\"342\":[2,16],\"343\":[2,104],\"344\":[2,109],\"345\":[2,30],\"346\":[2,193],\"347\":[2],\"348\":[2,20],\"349\":[2,10],\"350\":[2,101],\"351\":[2,12],\"352\":[1,35],\"353\":[2,75],\"354\":[2,46],\"355\":[2,91],\"356\":[2],\"357\":[2,13],\"358\":[2,9],\"359\":[2,76],\"360\":[2,111],\"361\":[2,63],\"362\":[2],\"363\":[2,14],\"364\":[2,6],\"365\":[2,67],\"366\":[2,97],\"367\":[2,87],\"368\":[2,3],\"369\":[2,10],\"370\":[2,5],\"371\":[2,44],\"372\":[2,228],\"373\":[2,20],\"374\":[2],\"375\":[2,60],\"376\":[2,7],\"377\":[2,69],\"378\":[2,74],\"379\":[2,12],\"380\":[2],\"381\":[2,9],\"382\":[2,26],\"383\":[2,93],\"384\":[2,71],\"385\":[2,26],\"386\":[2,53],\"387\":[2],\"388\":[2,9],\"389\":[2,6],\"390\":[2,67],\"391\":[2,19],\"392\":[2,8],\"393\":[2,23],\"394\":[2,58],\"395\":[2,34],\"396\":[2,21],\"397\":[2],\"398\":[2,8],\"399\":[2,6],\"400\":[2,25],\"401\":[2,11],\"402\":[2,17],\"403\":[2,71],\"404\":[2,30],\"405\":[2,23],\"406\":[2,10],\"407\":[2,17],\"408\":[2,83],\"409\":[2,30],\"410\":[2,21],\"411\":[2,46],\"412\":[null,null,1],\"413\":[null,null,1],\"414\":[1,3],\"415\":[2],\"416\":[2,8],\"417\":[2,7],\"418\":[2,26],\"419\":[2,42],\"420\":[2],\"421\":[2,61],\"422\":[2,120],\"423\":[2],\"424\":[2,10],\"425\":[3,6],\"426\":[3,8],\"427\":[3,8],\"428\":[3,5],\"429\":[3,51],\"430\":[3,46],\"431\":[2],\"432\":[3,13],\"433\":[2,6],\"434\":[3,30],\"435\":[3,7],\"436\":[3,168],\"437\":[3,20],\"438\":[2],\"439\":[3,11],\"440\":[3,7],\"441\":[2,27],\"442\":[3,5],\"443\":[3,166],\"444\":[3,14],\"445\":[2],\"446\":[2,10],\"447\":[2,6],\"448\":[2,119],\"449\":[2,14],\"450\":[2,121],\"451\":[2,20],\"452\":[2,49],\"453\":[2,13],\"454\":[2,105],\"455\":[2,202],\"456\":[null,null,1],\"457\":[null,null,1],\"458\":[1,23],\"459\":[2],\"460\":[2,14],\"461\":[2,114],\"462\":[2,12],\"463\":[2],\"464\":[2,17],\"465\":[2,114],\"466\":[2,11],\"467\":[2],\"468\":[2,23],\"469\":[2,85],\"470\":[2,38],\"471\":[2],\"472\":[2,23],\"473\":[2,63],\"474\":[2,67],\"475\":[2],\"476\":[2,22],\"477\":[2,19],\"478\":[2,10],\"479\":[2],\"480\":[2,23],\"481\":[2,66],\"482\":[2,31],\"483\":[2],\"484\":[2,7],\"485\":[2,72],\"486\":[2,39],\"487\":[2],\"488\":[2,42],\"489\":[2,62],\"490\":[2,111],\"491\":[null,null,1],\"492\":[null,null,1],\"493\":[1,9],\"494\":[2,37],\"495\":[2,361],\"496\":[2,59],\"497\":[3,148],\"498\":[3,136],\"499\":[2],\"500\":[2,69],\"501\":[2,25],\"502\":[2,102],\"503\":[2],\"504\":[2,40],\"505\":[2,36],\"506\":[2,121],\"507\":[2],\"508\":[2,22],\"509\":[2,9],\"510\":[2,113],\"511\":[2,52],\"512\":[2,35],\"513\":[2],\"514\":[2,10],\"515\":[2,8],\"516\":[2,25],\"517\":[2,22],\"518\":[2,111],\"519\":[2,26],\"520\":[2,8],\"521\":[2],\"522\":[2,8],\"523\":[2,6],\"524\":[2,94],\"525\":[2,166],\"526\":[2,66],\"527\":[2],\"528\":[2,8],\"529\":[2,7],\"530\":[2,21],\"531\":[2,7],\"532\":[4,6],\"533\":[2,29],\"534\":[null,null,1],\"535\":[null,null,1],\"536\":[1,6],\"537\":[2,19],\"538\":[2,113],\"539\":[2,239],\"540\":[2,65],\"541\":[null,null,1],\"542\":[null,null,1],\"543\":[1,5],\"544\":[3,5],\"545\":[1,5],\"546\":[2],\"547\":[3],\"548\":[3],\"549\":[3],\"550\":[2],\"551\":[2],\"552\":[2],\"553\":[3],\"554\":[6],\"555\":[5],\"556\":[3],\"557\":[3],\"558\":[2],\"559\":[4],\"560\":[4],\"561\":[5],\"562\":[6],\"563\":[3],\"564\":[4],\"565\":[4],\"566\":[7],\"567\":[4],\"568\":[4],\"569\":[4],\"570\":[2],\"571\":[null,null,1],\"572\":[2],\"573\":[3,59],\"574\":[4,75],\"575\":[3,74],\"576\":[4,122],\"577\":[4,45],\"578\":[3,36],\"579\":[5,87],\"580\":[4,73],\"581\":[6,50],\"582\":[2,38],\"583\":[4,71],\"584\":[3,46],\"585\":[null,null,1],\"586\":[2],\"587\":[2,33],\"588\":[2,2],\"589\":[4,13],\"590\":[3,1],\"591\":[3,9],\"592\":[3,6],\"593\":[2,41],\"594\":[6,38],\"595\":[3,31],\"596\":[2,42],\"597\":[2,17],\"598\":[3,1],\"599\":[3,1],\"600\":[4,1],\"601\":[6,1],\"602\":[3,1],\"603\":[2,1],\"604\":[2,1],\"605\":[3,1],\"606\":[3,1],\"607\":[4,1],\"608\":[3,1],\"609\":[3,1],\"610\":[3,1],\"611\":[3,1],\"612\":[3,1],\"613\":[4,1],\"614\":[2,1],\"615\":[null,null,1],\"616\":[2],\"617\":[3,15],\"618\":[3,42],\"619\":[4,68],\"620\":[4,22],\"621\":[1,6],\"622\":[3,34],\"623\":[2],\"624\":[null,null,1],\"625\":[1],\"626\":[2],\"627\":[2],\"628\":[2],\"629\":[3],\"630\":[2],\"631\":[4],\"632\":[4],\"633\":[null,null,1],\"634\":[2],\"635\":[3],\"636\":[3],\"637\":[4],\"638\":[2],\"639\":[3],\"640\":[2],\"641\":[5],\"642\":[4],\"643\":[5],\"644\":[4],\"645\":[3],\"646\":[8],\"647\":[2],\"648\":[6],\"649\":[5],\"650\":[4],\"651\":[3],\"652\":[3],\"653\":[3],\"654\":[3],\"655\":[2],\"656\":[3],\"657\":[3],\"658\":[2],\"659\":[3],\"660\":[5],\"661\":[3],\"662\":[4],\"663\":[6],\"664\":[3],\"665\":[4],\"666\":[2],\"667\":[null,null,1],\"668\":[2],\"669\":[2],\"670\":[2,17],\"671\":[2,33],\"672\":[2,14],\"673\":[3,15],\"674\":[4,32],\"675\":[2,2],\"676\":[2],\"677\":[2,29],\"678\":[2,21],\"679\":[2,7],\"680\":[2,16],\"681\":[2,21],\"682\":[2,18],\"683\":[2,31],\"684\":[2],\"685\":[2,54],\"686\":[2,50],\"687\":[3,26],\"688\":[6,56],\"689\":[4,60],\"690\":[2,57],\"691\":[3,25],\"692\":[2,26],\"693\":[4,23],\"694\":[4,86],\"695\":[3,42],\"696\":[4,47],\"697\":[2,26],\"698\":[5,35],\"699\":[3,6],\"700\":[3,12],\"701\":[3,59],\"702\":[3,50],\"703\":[5,39],\"704\":[5,49],\"705\":[5,68],\"706\":[5,123],\"707\":[3,78],\"708\":[2,27],\"709\":[7,67],\"710\":[3,64],\"711\":[2,108],\"712\":[6,34],\"713\":[2,43],\"714\":[3,45],\"715\":[4,54],\"716\":[null,null,1],\"717\":[2],\"718\":[2],\"719\":[2,27],\"720\":[2,73],\"721\":[3,59],\"722\":[2,113],\"723\":[7,31],\"724\":[2,67],\"725\":[2,45],\"726\":[2,49],\"727\":[2,23],\"728\":[8,45],\"729\":[2,34],\"730\":[2,26],\"731\":[3,102],\"732\":[2],\"733\":[4,51],\"734\":[6,15],\"735\":[2,61],\"736\":[4,29],\"737\":[3,28],\"738\":[7,29],\"739\":[5,56],\"740\":[2,40],\"741\":[4,51],\"742\":[2,58],\"743\":[2,42],\"744\":[2,54],\"745\":[4,24],\"746\":[3,56],\"747\":[9,49],\"748\":[4,44],\"749\":[4,80],\"750\":[3,56],\"751\":[2,47],\"752\":[3,23],\"753\":[2],\"754\":[2,77],\"755\":[3,50],\"756\":[2,37],\"757\":[3,8],\"758\":[2,61],\"759\":[2,50],\"760\":[3,51],\"761\":[2],\"762\":[2,32],\"763\":[2,22],\"764\":[3,71],\"765\":[4,45],\"766\":[2,49],\"767\":[4,32],\"768\":[4,103],\"769\":[2,173],\"770\":[2,6],\"771\":[null,null,1],\"772\":[2],\"773\":[2,27],\"774\":[2,16],\"775\":[2,43],\"776\":[2,18],\"777\":[2,26],\"778\":[2,16],\"779\":[2,21],\"780\":[2,51],\"781\":[2,22],\"782\":[2,50],\"783\":[2,48],\"784\":[2,18],\"785\":[3,83],\"786\":[5,6],\"787\":[3,69],\"788\":[6,93],\"789\":[5,68],\"790\":[3,16],\"791\":[2,29],\"792\":[3,30],\"793\":[3,138],\"794\":[2,20],\"795\":[5,53],\"796\":[3,11],\"797\":[2,86],\"798\":[2,28],\"799\":[2,46],\"800\":[2,31],\"801\":[null,null,1],\"802\":[2],\"803\":[2],\"804\":[4,61],\"805\":[2,16],\"806\":[2,18],\"807\":[2,95],\"808\":[3,35],\"809\":[2,36],\"810\":[2,28],\"811\":[2,83],\"812\":[5,34],\"813\":[6,49],\"814\":[2,32],\"815\":[2],\"816\":[2,103],\"817\":[2,49],\"818\":[3,41],\"819\":[2,47],\"820\":[2,28],\"821\":[2,59],\"822\":[2,54],\"823\":[2],\"824\":[4,23],\"825\":[4,25],\"826\":[3,64],\"827\":[2,90],\"828\":[2,28],\"829\":[2,61],\"830\":[2],\"831\":[2,114],\"832\":[2,106],\"833\":[2,49],\"834\":[2,66],\"835\":[2,87],\"836\":[6,45],\"837\":[2,139],\"838\":[2,49],\"839\":[2,93],\"840\":[2,52],\"841\":[2,13],\"842\":[2,64],\"843\":[2,60],\"844\":[3,83],\"845\":[3,134],\"846\":[2,50],\"847\":[3,73],\"848\":[3,68],\"849\":[2,15],\"850\":[2],\"851\":[2,50],\"852\":[2,27],\"853\":[2,64],\"854\":[3,29],\"855\":[2,63],\"856\":[2],\"857\":[3,28],\"858\":[2,38],\"859\":[2,16],\"860\":[2,37],\"861\":[2,19],\"862\":[2,34],\"863\":[2,43],\"864\":[2,34],\"865\":[2,21],\"866\":[2,39],\"867\":[2,43],\"868\":[2,70],\"869\":[2,15],\"870\":[2,103],\"871\":[2,13],\"872\":[null,null,1],\"873\":[2],\"874\":[null,null,1],\"875\":[2],\"876\":[null,null,1],\"877\":[2],\"878\":[null,null,1],\"879\":[1],\"880\":[null,null,1],\"881\":[1],\"882\":[null,null,1],\"883\":[1],\"884\":[null,null,1],\"885\":[1],\"886\":[null,null,1],\"887\":[2],\"888\":[null,null,1],\"889\":[2],\"890\":[null,null,1],\"891\":[2],\"892\":[null,null,1],\"893\":[2],\"894\":[null,null,1],\"895\":[1],\"896\":[2],\"897\":[2]},\"averageFieldLength\":[2.5198712392393006,37.53619024869094,0.20491744793891656],\"storedFields\":{\"0\":{\"h\":\"个人简介\",\"t\":[\" 欲买桂花同载酒，终不似，少年游。 Github | CSDN\",\"提示\",\"注意\",\"::: error :::\",\"提示\",\"博客封面图片：\",\"图例-封面图片\"]},\"1\":{\"h\":\"云服务器/虚拟机安装宝塔及软件配置\",\"t\":[\" 教学：使用云服务器，进行各种软件的安装、配置、项目部署及远程连接（宝塔、Nginx、JDK、Mysql、Redis、Ffmpeg） \"]},\"2\":{\"h\":\"一、宝塔安装和配置\"},\"3\":{\"h\":\"1、命令行安装\",\"t\":[\"使用终端模拟器-xshell远程连接服务器，运行下列命令：\",\"命令不需要换行，整行复制执行\",\"运行过程中如有选择，输入y选择即可\",\"安装完成牢记不要清除界面，界面会有临时的进入网站、用户名、密码\",\"yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh \",\"安装成功：\",\"安装成功效果\",\"设置安全组：云服务器实例 -> 安全组 -> 添加图中端口放行\",\"阿里云服务器实例添加安全组端口\",\"如需开放其他软件的端口也是在此操作： \",\"例如：常用的mysql(3306)、redis(5379)、https(443)等等\",\"使用外网地址和用户名密码进行登录：\",\"复制外网面板地址，输入用户名和密码访问即可\"]},\"4\":{\"h\":\"2、应用设置\"},\"5\":{\"h\":\"2.1 更改面板设置\",\"t\":[\"修改默认用户名和密码：\",\"宝塔面板设置-修改默认用户名和密码\",\"宝塔安全设置：宝塔 –> 安全 –>系统防火墙 –> 添加端口规则\",\"如需开放其他软件的端口也是在此操作： \",\"例如：常用的mysql(3306)、redis(5379)、https(443)等等\",\"宝塔安全设置-开放端口\"]},\"6\":{\"h\":\"二、安装Nginx\"},\"7\":{\"h\":\"1、安装\",\"t\":[\"宝塔里面软件商店搜索nginx（此处选中是nginx1.22版本），然后选择极速安装即可，安装完成让其显示在首页\"]},\"8\":{\"h\":\"2、设置配置文件\",\"t\":[\"nginx.conf核心：\",\"server { #监听端口,网站默认打开自带80，但是会自动隐藏 listen 80; #将该服务器块与特定的域名（这里是localhost）相关联 server_name localhost; #端口的反向代理：接受针对根路径的访问会被导航到此处 location /{ #导航到服务器的/server/front-end/vuepress-blog/dist目录下,默认使用index.html root /server/front-end/vuepress-blog/dist; try_files $uri $uri/ /index.html; index index.html index.htm; } #反向代理：接受针对以/api开头的请求会被导航到此处 location /api { #代理到服务器的http://localhost:7090/api地址 proxy_pass http://localhost:7090/api; proxy_set_header x-forwarded-for $remote_addr; } access_log /www/wwwlogs/access.log; } \",\"nginx.conf：\",\"user root; worker_processes auto; error_log /www/wwwlogs/nginx_error.log crit; pid /www/server/nginx/logs/nginx.pid; worker_rlimit_nofile 51200; stream { log_format tcp_format '$time_local|$remote_addr|$protocol|$status|$bytes_sent|$bytes_received|$session_time|$upstream_addr|$upstream_bytes_sent|$upstream_bytes_received|$upstream_connect_time'; access_log /www/wwwlogs/tcp-access.log tcp_format; error_log /www/wwwlogs/tcp-error.log; include /www/server/panel/vhost/nginx/tcp/*.conf; } events { use epoll; worker_connections 51200; multi_accept on; } http { include mime.types; include proxy.conf; default_type application/octet-stream; server_names_hash_bucket_size 512; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 256k; fastcgi_intercept_errors on; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml; gzip_vary on; gzip_proxied expired no-cache no-store private auth; gzip_disable \\\"MSIE [1-6]\\\\.\\\"; limit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server_tokens off; access_log off; server { listen 80; server_name localhost; location /{ root /server/front-end/vuepress-blog/dist; try_files $uri $uri/ /index.html; index index.html index.htm; } location /api { proxy_pass http://localhost:7090/api; proxy_set_header x-forwarded-for $remote_addr; } access_log /www/wwwlogs/access.log; } include /www/server/panel/vhost/nginx/*.conf; } \",\"测试在/server/front-end/vuepress/dist目录下创建index.html：\",\"创建目录：mkdir -p /server/front-end/vuepress/dist\",\"创建index.html：vim index.html、添加内容、wq保存退出\",\"在本地访问服务器地址即可\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>helloworld</title> </head> <body> helloworld </body> </html> \",\"创建文件夹和index.html文件\",\"本地访问效果\"]},\"9\":{\"h\":\"三、安装Mysql\"},\"10\":{\"h\":\"1、安装\",\"t\":[\"宝塔里面软件商店搜索mysql（此处选中是5.7版本），然后选择极速安装即可，安装完成让其显示在首页\"]},\"11\":{\"h\":\"2、配置和远程连接\",\"t\":[\"查看root密码：宝塔界面 –> 数据库 –> mysql –> root密码\",\"宝塔界面查看安装mysql的root密码\",\"终端登录mysql，授予用户远程连接的权限：mysql -uroot -p\",\"#开启访问权限 (mysql5.5) GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '你的密码' WITH GRANT OPTION; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Zz172425..' WITH GRANT OPTION; #开启访问权限 本地/远程(mysql8.0) grant all on *.* to 'root'@'%' identified by '你的密码'; #刷新权限 flush privileges; #退出 exit \",\"开放3306端口：宝塔 –> 安全 –>系统防火墙 –> 添加端口规则\",\"宝塔开放端口3306\",\"云服务器开放端口3306\",\"navicate远程连接：\",\"navicate远程连接云服务器数据库\"]},\"12\":{\"h\":\"四、安装Redis\"},\"13\":{\"h\":\"1、安装\",\"t\":[\"宝塔里面软件商店搜索redis（此处选中是7.2版本），然后选择极速安装即可，安装完成让其显示在首页\"]},\"14\":{\"h\":\"2、配置和远程连接\",\"t\":[\"进行配置：开放端口：6379\",\"阿里云安全组开放： 所有ip都可以访问 - 0.0.0.0/0 - 6379\",\"宝塔界面 - 安全 - 端口规则 开放：所有ip都可以访问 -TCP - 6379\",\"redis配置：bind-0.0.0.0 密码-requirepass-你的密码\",\"配置redis设置\",\"another redis desktop manager远程连接：\",\"远程连接redis\",\"连接成功界面\"]},\"15\":{\"h\":\"五、安装Jdk\"},\"16\":{\"h\":\"1、下载并解压\"},\"17\":{\"h\":\"（1）下载\",\"t\":[\"需要注册Oracle账号\",\"下载地址：https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\",\"oracle官网下载jdk\",\"下载完后使用xftp等工具将文件上传至Linux\"]},\"18\":{\"h\":\"（2）解压\",\"t\":[\"（1）创建安装目录：mkdir /usr/local/jdk，上传安装包到此目录\",\"（2）解压：tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/jdk\",\"（3）进入解压后的目录：cd /usr/local/jdk\",\"存放jdk\"]},\"19\":{\"h\":\"2、 配置环境变量\",\"t\":[\"#配置环境变量，使用vim命令修改/etc/profile文件 vim /etc/profile #在文件末尾加入如下配置 #java环境变量 JAVA_HOME=/usr/local/jdk/jdk1.8.0_171 PATH=$JAVA_HOME/bin:$PATH #重新加载profile.文件，使更改的配置立即生效 source /etc/profile \",\"修改环境变量\",\"具体修改操作\"]},\"20\":{\"h\":\"3、安装成功测试\",\"t\":[\"#查看java版本 java -version #查看javac版本 javac -version \",\"测试安装效果\"]},\"21\":{\"h\":\"六、部署Java项目\",\"t\":[\"假如服务器地址为47.21.36.122，则访问：47.21.36.122 == 47.21.36.122:80\"]},\"22\":{\"h\":\"1、前端部署\",\"t\":[\"前端进行编译打包：如npm run build\",\"将打包的文件上传到服务器：例如打包后的dist目录上传到/server/front-end/q-pan/dist\",\"配置nginx反向代理： \",\"配置访问文件地址： \",\"例如配置-/ --> /server/front-end/q-pan/dist/\",\"本地访问47.21.36.122:80 –> 47.21.36.122:80/server/front-end/q-pan/dist\",\"配置前端项目访问后端接口代理： \",\"例如配置-/api --> localhost:8081/api\",\"本地访问47.21.36.122:80/api –> 47.21.36.122:8081/api\"]},\"23\":{\"h\":\"2、后端部署\",\"t\":[\"项目修改配置文件application.properties的数据库、redis等地址为云服务器地址\",\"项目打jar包上传到具体目录：mvc package打包，或者idea图形化界面打包，将jar包上传服务器指定目录\",\"进入上传的目录 \",\"后台启动运行：nohup java -jar qpan-backend-1.0-SNAPSHOT.jar &\"]},\"24\":{\"h\":\"七、安装Ffmpeg\",\"t\":[\"1、安装所需软件\",\"yum install -y automake autoconf libtool gcc gcc-c++ \",\"2、安装epel 源\",\"yum install epel-release -y \",\"3、安装第三方更新源\",\"rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm \",\"4、安装ffmpeg\",\"yum repolist \",\"yum install ffmpeg ffmpeg-devel \",\"5、查看安装的版本\",\"ffmpeg -version \"]},\"25\":{\"c\":[\"网站建设\"]},\"26\":{\"c\":[\"宝塔\"]},\"27\":{\"h\":\"云服务器/虚拟机安装宝塔及软件配置\",\"t\":[\" 教学：使用云服务器，进行各种软件的安装、配置、项目部署及远程连接（宝塔、Nginx、JDK、Mysql、Redis、Ffmpeg） \"]},\"28\":{\"h\":\"一、宝塔安装和配置\"},\"29\":{\"h\":\"1、命令行安装\",\"t\":[\"使用终端模拟器-xshell远程连接服务器，运行下列命令：\",\"命令不需要换行，整行复制执行\",\"运行过程中如有选择，输入y选择即可\",\"安装完成牢记不要清除界面，界面会有临时的进入网站、用户名、密码\",\"yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh \",\"安装成功：\",\"安装成功效果\",\"设置安全组：云服务器实例 -> 安全组 -> 添加图中端口放行\",\"阿里云服务器实例添加安全组端口\",\"如需开放其他软件的端口也是在此操作： \",\"例如：常用的mysql(3306)、redis(5379)、https(443)等等\",\"使用外网地址和用户名密码进行登录：\",\"复制外网面板地址，输入用户名和密码访问即可\"]},\"30\":{\"h\":\"2、应用设置\"},\"31\":{\"h\":\"2.1 更改面板设置\",\"t\":[\"修改默认用户名和密码：\",\"宝塔面板设置-修改默认用户名和密码\",\"宝塔安全设置：宝塔 –> 安全 –>系统防火墙 –> 添加端口规则\",\"如需开放其他软件的端口也是在此操作： \",\"例如：常用的mysql(3306)、redis(5379)、https(443)等等\",\"宝塔安全设置-开放端口\"]},\"32\":{\"h\":\"二、安装Nginx\"},\"33\":{\"h\":\"1、安装\",\"t\":[\"宝塔里面软件商店搜索nginx（此处选中是nginx1.22版本），然后选择极速安装即可，安装完成让其显示在首页\"]},\"34\":{\"h\":\"2、设置配置文件\",\"t\":[\"nginx.conf核心：\",\"server { #监听端口,网站默认打开自带80，但是会自动隐藏 listen 80; #将该服务器块与特定的域名（这里是localhost）相关联 server_name localhost; #端口的反向代理：接受针对根路径的访问会被导航到此处 location /{ #导航到服务器的/server/front-end/vuepress-blog/dist目录下,默认使用index.html root /server/front-end/vuepress-blog/dist; try_files $uri $uri/ /index.html; index index.html index.htm; } #反向代理：接受针对以/api开头的请求会被导航到此处 location /api { #代理到服务器的http://localhost:7090/api地址 proxy_pass http://localhost:7090/api; proxy_set_header x-forwarded-for $remote_addr; } access_log /www/wwwlogs/access.log; } \",\"nginx.conf：\",\"user root; worker_processes auto; error_log /www/wwwlogs/nginx_error.log crit; pid /www/server/nginx/logs/nginx.pid; worker_rlimit_nofile 51200; stream { log_format tcp_format '$time_local|$remote_addr|$protocol|$status|$bytes_sent|$bytes_received|$session_time|$upstream_addr|$upstream_bytes_sent|$upstream_bytes_received|$upstream_connect_time'; access_log /www/wwwlogs/tcp-access.log tcp_format; error_log /www/wwwlogs/tcp-error.log; include /www/server/panel/vhost/nginx/tcp/*.conf; } events { use epoll; worker_connections 51200; multi_accept on; } http { include mime.types; include proxy.conf; default_type application/octet-stream; server_names_hash_bucket_size 512; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 256k; fastcgi_intercept_errors on; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml; gzip_vary on; gzip_proxied expired no-cache no-store private auth; gzip_disable \\\"MSIE [1-6]\\\\.\\\"; limit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server_tokens off; access_log off; server { listen 80; server_name localhost; location /{ root /server/front-end/vuepress-blog/dist; try_files $uri $uri/ /index.html; index index.html index.htm; } location /api { proxy_pass http://localhost:7090/api; proxy_set_header x-forwarded-for $remote_addr; } access_log /www/wwwlogs/access.log; } include /www/server/panel/vhost/nginx/*.conf; } \",\"测试在/server/front-end/vuepress/dist目录下创建index.html：\",\"创建目录：mkdir -p /server/front-end/vuepress/dist\",\"创建index.html：vim index.html、添加内容、wq保存退出\",\"在本地访问服务器地址即可\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>helloworld</title> </head> <body> helloworld </body> </html> \",\"创建文件夹和index.html文件\",\"本地访问效果\"]},\"35\":{\"h\":\"三、安装Mysql\"},\"36\":{\"h\":\"1、安装\",\"t\":[\"宝塔里面软件商店搜索mysql（此处选中是5.7版本），然后选择极速安装即可，安装完成让其显示在首页\"]},\"37\":{\"h\":\"2、配置和远程连接\",\"t\":[\"查看root密码：宝塔界面 –> 数据库 –> mysql –> root密码\",\"宝塔界面查看安装mysql的root密码\",\"终端登录mysql，授予用户远程连接的权限：mysql -uroot -p\",\"#开启访问权限 (mysql5.5) GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '你的密码' WITH GRANT OPTION; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Zz172425..' WITH GRANT OPTION; #开启访问权限 本地/远程(mysql8.0) grant all on *.* to 'root'@'%' identified by '你的密码'; #刷新权限 flush privileges; #退出 exit \",\"开放3306端口：宝塔 –> 安全 –>系统防火墙 –> 添加端口规则\",\"宝塔开放端口3306\",\"云服务器开放端口3306\",\"navicate远程连接：\",\"navicate远程连接云服务器数据库\"]},\"38\":{\"h\":\"四、安装Redis\"},\"39\":{\"h\":\"1、安装\",\"t\":[\"宝塔里面软件商店搜索redis（此处选中是7.2版本），然后选择极速安装即可，安装完成让其显示在首页\"]},\"40\":{\"h\":\"2、配置和远程连接\",\"t\":[\"进行配置：开放端口：6379\",\"阿里云安全组开放： 所有ip都可以访问 - 0.0.0.0/0 - 6379\",\"宝塔界面 - 安全 - 端口规则 开放：所有ip都可以访问 -TCP - 6379\",\"redis配置：bind-0.0.0.0 密码-requirepass-你的密码\",\"配置redis设置\",\"another redis desktop manager远程连接：\",\"远程连接redis\",\"连接成功界面\"]},\"41\":{\"h\":\"五、安装Jdk\"},\"42\":{\"h\":\"1、下载并解压\"},\"43\":{\"h\":\"（1）下载\",\"t\":[\"需要注册Oracle账号\",\"下载地址：https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\",\"oracle官网下载jdk\",\"下载完后使用xftp等工具将文件上传至Linux\"]},\"44\":{\"h\":\"（2）解压\",\"t\":[\"（1）创建安装目录：mkdir /usr/local/jdk，上传安装包到此目录\",\"（2）解压：tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/jdk\",\"（3）进入解压后的目录：cd /usr/local/jdk\",\"存放jdk\"]},\"45\":{\"h\":\"2、 配置环境变量\",\"t\":[\"#配置环境变量，使用vim命令修改/etc/profile文件 vim /etc/profile #在文件末尾加入如下配置 #java环境变量 JAVA_HOME=/usr/local/jdk/jdk1.8.0_171 PATH=$JAVA_HOME/bin:$PATH #重新加载profile.文件，使更改的配置立即生效 source /etc/profile \",\"修改环境变量\",\"具体修改操作\"]},\"46\":{\"h\":\"3、安装成功测试\",\"t\":[\"#查看java版本 java -version #查看javac版本 javac -version \",\"测试安装效果\"]},\"47\":{\"h\":\"六、部署Java项目\",\"t\":[\"假如服务器地址为47.21.36.122，则访问：47.21.36.122 == 47.21.36.122:80\"]},\"48\":{\"h\":\"1、前端部署\",\"t\":[\"前端进行编译打包：如npm run build\",\"将打包的文件上传到服务器：例如打包后的dist目录上传到/server/front-end/q-pan/dist\",\"配置nginx反向代理： \",\"配置访问文件地址： \",\"例如配置-/ --> /server/front-end/q-pan/dist/\",\"本地访问47.21.36.122:80 –> 47.21.36.122:80/server/front-end/q-pan/dist\",\"配置前端项目访问后端接口代理： \",\"例如配置-/api --> localhost:8081/api\",\"本地访问47.21.36.122:80/api –> 47.21.36.122:8081/api\"]},\"49\":{\"h\":\"2、后端部署\",\"t\":[\"项目修改配置文件application.properties的数据库、redis等地址为云服务器地址\",\"项目打jar包上传到具体目录：mvc package打包，或者idea图形化界面打包，将jar包上传服务器指定目录\",\"进入上传的目录 \",\"后台启动运行：nohup java -jar qpan-backend-1.0-SNAPSHOT.jar &\"]},\"50\":{\"h\":\"七、安装Ffmpeg\",\"t\":[\"1、安装所需软件\",\"yum install -y automake autoconf libtool gcc gcc-c++ \",\"2、安装epel 源\",\"yum install epel-release -y \",\"3、安装第三方更新源\",\"rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm \",\"4、安装ffmpeg\",\"yum repolist \",\"yum install ffmpeg ffmpeg-devel \",\"5、查看安装的版本\",\"ffmpeg -version \"]},\"51\":{\"c\":[\"网站建设\"]},\"52\":{\"c\":[\"宝塔\"]},\"53\":{\"h\":\"首页\",\"t\":[\"思维导图：\",\"基础学习路线图-待完善\"]},\"54\":{\"h\":\"应用层\",\"t\":[\"应用层位于最顶层，是为用户提供特定网络应用程序所需的服务和功能所产生的（电子邮件、文件传输、远程登录、网页浏览）。\"]},\"55\":{\"h\":\"一、简介\"},\"56\":{\"h\":\"1、主要任务\",\"t\":[\"应用层的主要任务是什么？ 主要和什么有关\",\"主要任务：是提供特定网络应用程序所需的服务和功能。它负责处理特定的应用需求，例如电子邮件、文件传输、远程登录、网页浏览等。应用层协议定义了应用程序之间的通信规则和数据交换的格式。\",\"主要和用户应用程序有关。\",\"应用层协议定义了应用程序之间的通信规则和数据交换的格式，这些协议包括HTTP、FTP、SMTP等。\",\"每个应用程序都使用特定的应用层协议来完成其特定功能。\",\"应用层的任务是为用户提供所需的服务，使得用户能够方便地完成特定的网络任务，因此它主要与用户应用程序和用户需求相关联。\",\"总的来说，应用层是网络中最直接面向用户的层次，它为用户提供了各种实用的网络服务，也是用户与网络之间交互的接口。\",\"应用层协议定义了什么\",\"应用进程交换的报文类型 \",\"请求还是响应\",\"各种报文类型的语法 \",\"报文中的各个字段及其详细描述\",\"字段的语义 \",\"包含在字段中的信息的含义\",\"进程何时、如何发送报文，以及对报文进行响应的规则\"]},\"57\":{\"h\":\"2、网络应用模型\"},\"58\":{\"h\":\"（1）C/S模型\",\"t\":[\"客户/服务器方式 (C/S)：C/S方式强调了服务提供者和请求者之间的层次关系\",\"在客户/服务器模型中，网络服务的提供者和网络服务的请求者分别扮演着不同的角色，它们之间存在明显的区别和层次。\",\"客户和服务器是指通信中所涉及的两个应用进程\",\"客户/服务器方式所描述的是进程之间服务和被服务的关系\",\"客户是服务请求方，服务器是服务提供方\",\"服务器总是处于运行等待状态，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址\",\"通常情况下，有一个或多个服务器端（提供服务）和多个客户端（请求服务）相互交互，客户端向服务器请求服务或资源，服务器接收到请求后，进行相应的处理并将结果返回给客户端。\",\"基于C/S方式的应用服务通常是服务集中型的，即应用服务集在网络中比客户计算机少得多的服务器计算机上由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况,为此，在C/S应用中，常用计算机群集(或服务器场)构建一个强大的虚拟服务器.\",\"常见的例子包括Web应用，数据库服务等。\"]},\"59\":{\"h\":\"（2）P2P模型\",\"t\":[\"对等方式 (P2P方式)：P2P方式强调了节点之间的对等关系，没有明确的服务提供者和请求者的区分\",\"对等方式，也称为点对点方式，是指在网络中的各个节点（通常是计算机）之间具有相同的地位，彼此之间可以直接通信和共享资源，而无需依赖中央服务器。\",\"在P2P网络中，每个节点既可以是资源的提供者，也可以是资源的请求者。所有节点都能够直接与其他节点通信，共享资源或者服务。\",\"这种模型适用于需要大量资源共享和分布式处理的场景，如文件共享网络、实时通信等\",\"电驴，快播\"]},\"60\":{\"h\":\"二、动态主机配置协议DHCP\"},\"61\":{\"h\":\"1、概述\"},\"62\":{\"h\":\"（1）DHCP是什么\",\"t\":[\"是什么：DHCP（Dynamic Host Configuration Protocol）是一种网络协议\",\"有什么用，解决什么问题：用于在计算机网络中自动分配IP地址和其他网络配置参数给设备。它的出现解决了手动配置网络参数的繁琐和容易出错的问题。\",\"功能： \",\"自动分配IP地址：DHCP允许网络中的设备在连接到网络时自动获取IP地址，而无需手动配置。这使得网络管理变得更加高效，特别是在大型网络环境下。\",\"分配其他网络配置参数：除了IP地址，DHCP还可以自动分配子网掩码、默认网关、DNS服务器等网络配置信息，使设备能够顺利地进行通信。\"]},\"63\":{\"h\":\"（2）DHCP和UDP\",\"t\":[\"DHCP与UDP的关系：\",\"DHCP是一种协议，用于自动分配IP地址和其他网络配置给主机。\",\"DHCP使用UDP作为传输层协议来进行通信。\",\"DHCP和UDP的端口号：\",\"DHCP服务器使用端口号67（UDP源端口）和端口号68（UDP目的端口）进行通信。\",\"DHCP客户端使用端口号68（UDP源端口）和端口号67（UDP目的端口）进行通信。\",\"这些端口号是DHCP协议规定的默认端口号，用于标识DHCP客户端和服务器之间的通信。\"]},\"64\":{\"h\":\"2、工作流程\",\"t\":[\"DHCP的工作流程：\",\"DHCP发现（DHCP Discover）：\",\"客户端广播发送一个DHCP发现消息，请求可用的DHCP服务器。\",\"源地址为0.0.0.0，目的地址为广播地址255.255.255.255。\",\"DHCP提供（DHCP Offer）：\",\"DHCP服务器接收到广播后，如果有可用的IP地址，会向客户端发送DHCP提供消息，其中包含了IP地址和相关配置信息。\",\"源地址为DHCP服务器的地址，目的地址为广播地址。\",\"DHCP请求（DHCP Request）：\",\"客户端收到多个DHCP提供消息后，一般会选择第一个接收到的DHCP提供消息。\",\"客户端向选定的DHCP服务器发送DHCP请求消息，请求分配IP地址。\",\"源地址为0.0.0.0，目的地址为广播地址255.255.255.255。\",\"DHCP确认（DHCP Acknowledgment）：\",\"DHCP服务器接收到客户端的请求后，验证事务ID是否相符。\",\"若相符，DHCP服务器从地址池中分配一个IP地址，通过ARP协议确认此地址未被使用。\",\"将新的IP地址封装在DHCP确认消息中，发送给客户端。\",\"源地址为DHCP服务器的地址，目的地址为广播地址。\",\"IP地址租用：\",\"客户端收到DHCP确认消息后，再次使用ARP协议确认IP地址是否可用，确认成功后将该IP地址应用，并开始使用。\",\"客户端根据DHCP服务器提供的租约时长来使用IP地址。\",\"IP地址续约：\",\"在租约过程中，客户端会在租约到达一定时长前（一般为租约时长的一半）向DHCP服务器发送续约请求，以获取新的租约。\",\"IP地址释放：\",\"客户端可以随时向DHCP服务器发送释放请求，以释放其当前使用的IP地址。\",\"这个流程描述了DHCP客户端和服务器之间交互的整个过程，包括了客户端寻找DHCP服务器、获取IP地址、使用和续约IP地址以及释放IP地址等步骤。\"]},\"65\":{\"h\":\"三、域名系统DNS\"},\"66\":{\"h\":\"1、概述\"},\"67\":{\"h\":\"（1）DNS\",\"t\":[\"DNS（Domain Name System - 域名系统）：\",\"是什么：是一种用于将域名（例如：www.example.com）转换为对应的IP地址的分布式系统。\",\"有什么作用：DNS它起到了互联网中类似“电话号码簿”的作用，使得我们可以通过易于记忆的域名来访问网站，而不必记住复杂的IP地址。\"]},\"68\":{\"h\":\"（2）DNS相关名词\",\"t\":[\"以下是DNS的一些重要概念：\",\"域名：是一个网站的人类可读形式的名称，例如：www.example.com。\",\"IP地址：是一个用于在互联网上唯一标识一个设备（例如服务器或路由器）的数字序列。\",\"域名服务器：也称为DNS服务器，是负责将域名解析为相应IP地址的服务器。\",\"域名解析：是指将一个域名转换为对应的IP地址的过程。\"]},\"69\":{\"h\":\"2、域名\",\"t\":[\"域名：www.google.com\",\"顶级域名\",\"国家顶级域名：cn，us，uk\",\"通用顶级域名：com，net，org，gov，int，aero，museum，travel\",\"基础结构域名/反向域名：arpa\",\"二级域名\",\"类别域名：ac，com，edu，gov，mil，net，org\",\"行政区域名：jx，hb，bj\",\"自己注册的：必须要全球唯一\",\"三级域名\",\"四级域名\",\"……\",\"域名的注意事项：\",\"域名不区分大小写\",\"域名中的符号只能有 “-”\",\"域名中的每一段称为一个标号\",\"单个标号的长度不超过36个字符\",\"整体域名不超过255个字符\"]},\"70\":{\"h\":\"3、域名服务器\"},\"71\":{\"h\":\"（1）域名服务器分类\",\"t\":[\"图例-域名服务器\",\"根域名服务器：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。根域名服务器知道所有顶级域名服务器的域名和 IP地址。如果本地域名服务器无法对域名进行解析，就首先求助于根域名服务器。（.com等顶级域名服务器所在的地址）。\",\"顶级域名服务器：负责管理特定顶级域名下的次级域名信息，比如管理.com域名下的所有子域名（.com等 域名下的权威域名服务器列表。）。 \",\"顶级域名服务器负责管理在该服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步需要查询的域名服务器的 IP 地址）。\",\"权威域名服务器：负责一个区的域名服务器，负责知道管理 google.com 域名下的具体解析记录，如 www.google.com 对应的 IP 地址。 \",\"这就是前面已经讲过的负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告知发出查询请求的DNS客户，下一步应当找哪一个权威域名服务器。\",\"本地域名服务器：本地域名服务器并上述的树状结构的DNS域名服务器，但是它对域名系统非常重要。当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者ISP都可以拥有一个本地域名服务器。\"]},\"72\":{\"h\":\"（2）域名解析方式\",\"t\":[\"DNS协议使用**UPD**传输，是**无连接**的\",\"递归查询：本地域名服务器的查询请求层层转发到根服务器，最后得到所找域名的IP地址。\",\"图例-递归查询\",\"迭代查询：每次查询所得的下一级域名服务器IP返回给本地域名服务器，本地域名服务器亲自动手。\",\"图例-迭代查询\"]},\"73\":{\"h\":\"4、DNS解析过程\",\"t\":[\"完整的DNS解析过程有以下几个步骤：\"]},\"74\":{\"h\":\"（1）查看浏览器缓存\",\"t\":[\"当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的 IP 地址（若曾经访问过该域名且没有清空缓存便存在）。\"]},\"75\":{\"h\":\"（2）查看系统缓存\",\"t\":[\"当浏览器缓存中无域名对应 IP 则会自动检查用户计算机系统 Hosts 文件 DNS 缓存是否有该域名对应 IP。\"]},\"76\":{\"h\":\"（3）查看路由器缓存\",\"t\":[\"当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客服端的 DNS 缓存。\"]},\"77\":{\"h\":\"（4）查看ISP DNS 缓存\",\"t\":[\"当在用户客服端查找不到域名对应 IP 地址，则将进入 ISP DNS 缓存中进行查询。比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找。\"]},\"78\":{\"h\":\"（5）询问根域名服务器\",\"t\":[\"当以上均未完成，则进入根服务器进行查询。全球仅有 13 台根域名服务器，1 个主根域名服务器，其余 12 为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com、.cn等）服务器 IP 告诉本地 DNS 服务器。\"]},\"79\":{\"h\":\"（6）询问顶级域名服务器\",\"t\":[\"顶级域名服务器收到请求后查看区域文件记录，若无记录则将其管辖范围内权威域名服务器的 IP 地址告诉本地 DNS 服务器。\"]},\"80\":{\"h\":\"（7）询问权威域名（主域名）服务器\",\"t\":[\"权威域名服务器接收到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确记录。\"]},\"81\":{\"h\":\"（8）保存结果至缓存\",\"t\":[\"本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址即可访问目标Web服务器。至此，DNS递归查询的整个过程结束。\",\"DNS系统承担着将域名解析成IP地址的重要作用，是计算机之间实现访问互联的关键和基础。因此，DNS解析的安全对于维持网络稳定运行至关重要。企业相关管理者和运营者一定要做好域名及域名解析的安全防护工作，定期进行数据扫描分析，启用全方位DNS风险监测，实时关注DNS运行状态，同时做好妥善的应急备份准备，一旦发现问题，出现故障，第一时间响应解决，才能将DNS故障风险及其带来的损失降至最低点。\"]},\"82\":{\"h\":\"四、文件传输协议FTP\"},\"83\":{\"h\":\"1、FTP是什么\",\"t\":[\"FTP（File Transfer Protocol）：\",\"FTP是一种用于在网络上进行文件传输的标准通信协议，用于提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。\",\"FTP是基于C/S的协议，使用TCP实现可靠传输\",\"FTP由什么组成：\",\"FTP服务器：依照FTP协议提供服务，进行文件传送的计算机\",\"FTP客户端：连接FTP服务器，遵循FTP协议与服务器传送文件的电脑\",\"用户通过一个客户机程序连接至在远程计算机上运行的服务器程序进行文件传输\",\"FTP有什么作用和应用：\",\"文件的上传、下载、增删改查、备份恢复、分享\",\"文件上传和下载：FTP允许用户将文件从本地计算机上传至远程服务器，或者从远程服务器下载到本地计算机。 \",\"FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。FTP的另一个常见用途是让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器\",\"文件管理：用户可以通过FTP在本地计算机和远程服务器之间进行文件和文件夹的管理，包括创建、删除、重命名等操作。 \",\"FTP提供交互式的访问，运行客户指明文件的类型与格式(如指明是否使用ASCII码)，并允许文件具有存取权限(如访问文件的用户必须经过授权，并输入有效的口令)\",\"备份和恢复：通过FTP，用户可以轻松地将重要文件备份到远程服务器上，以防止本地数据丢失。\",\"共享文件：FTP也可用于在不同用户之间共享文件，只需提供相应的访问权限即可。 \",\"FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件\"]},\"84\":{\"h\":\"2、FTP的工作原理\"},\"85\":{\"h\":\"（1）介绍\",\"t\":[\"FTP（File Transfer Protocol）的基本工作原理是基于客户端-服务器模型的，它使用两个独立的连接来完成文件传输：\",\"控制连接（Control Connection）：用于传输控制信息，如用户认证、命令传输等。控制连接是持久的，在整个FTP会话期间保持打开状态。 \",\"用于传送控制命令的TCP连接在整个会话过程都保持开启状态\",\"例如：登录：用户通过用户名密码的方式登录到服务器，也可以通过匿名登陆访问公开共享的文件。\",\"数据连接（Data Connection）：用于传输文件数据。每次需要传输文件时都会建立一个新的数据连接，传输完成后再关闭。 \",\"用于传送数据的TCP连接只会在有数据传送时开启，数据结束传送后就关闭\",\"数据连接的建立方式有两种模式： \",\"主动模式（Active Mode）：在主动模式下，客户端会在随机的端口上监听，等待服务器连接。当需要传输文件时，服务器会通过控制连接告诉客户端在哪个端口上建立数据连接，客户端会在该端口上等待服务器的连接。\",\"被动模式（Passive Mode）：在被动模式下，服务器会在随机的端口上监听，等待客户端连接。当需要传输文件时，服务器会告诉客户端在哪个端口上建立数据连接，客户端会主动连接服务器的端口。\"]},\"86\":{\"h\":\"（2）传输过程\",\"t\":[\"具体的传输过程如下：\",\"客户端连接到FTP服务器：客户端通过TCP连接（默认端口为21）连接到FTP服务器。\",\"客户端进行身份验证：客户端通过用户名和密码进行身份验证。\",\"客户端发送FTP命令：一旦连接建立并且用户通过了身份验证，客户端可以发送各种FTP命令来执行相应的操作，如上传、下载、删除等。\",\"建立数据连接：当需要传输文件时，客户端发送相应的FTP命令，服务器会在数据端口（默认端口20）上等待客户端建立数据连接。\",\"传输文件：一旦数据连接建立，文件的数据会通过数据连接传输。\",\"关闭数据连接：文件传输完成后，数据连接会被关闭。\",\"执行其他操作：客户端可以继续发送FTP命令执行其他操作，如上传更多文件、删除文件等。\",\"关闭控制连接：当会话结束时，控制连接会被关闭。\",\"图例-xftp传输过程/工作流程\"]},\"87\":{\"h\":\"3、FTP和TCP\",\"t\":[\"FTP（File Transfer Protocol）是基于TCP/IP协议的应用层协议，它使用了TCP协议来实现可靠的文件传输。\",\"具体来说：\",\"FTP使用TCP作为传输层协议，通过TCP提供的可靠数据传输服务来保证文件的正确传输。\",\"FTP默认使用了两个端口：\",\"控制连接端口：默认为21，用于建立控制连接，传输控制信息（如命令、用户认证等）。\",\"数据连接端口：默认为22，用于传输文件数据。\",\"控制连接和数据连接共同构成了FTP会话，控制连接负责传输控制信息，而数据连接负责实际的文件传输。\",\"总的来说，FTP是在TCP协议的基础上实现的文件传输协议，利用了TCP的可靠传输特性来确保文件的正确传输。\"]},\"88\":{\"h\":\"五、电子邮件\"},\"89\":{\"h\":\"1、电子邮件系统和电子邮件\"},\"90\":{\"h\":\"（1）电子邮件系统\",\"t\":[\"电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议\",\"用户代理：用户与电子邮件系统的接口，又称为电子邮件客户端软件\",\"邮件服务器：电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱\",\"协议：邮件发送协议(如SMTP)、邮件读取协议(如POP3，IMAP)\"]},\"91\":{\"h\":\"（2）电子邮件格式\",\"t\":[\"电子邮件格式：首部 + 正文\",\"首部\",\"From（系统自动生成）：redvelet@qq.com\",\"To（必须填入）：redvelet@163.com\",\"Subject（可选）：电子邮件格式\",\"主体\",\"正文内容\"]},\"92\":{\"h\":\"2、SMTP\",\"t\":[\"SMTP（简单邮件传输协议），SMTP是用于在网络上传输电子邮件的协议\"]},\"93\":{\"h\":\"（Ⅰ）组成\",\"t\":[\"SMTP客户：负责发送邮件的SMTP进程\",\"SMTP服务器：负责接收邮件的进程\",\"SMTP使用的端口号为25\"]},\"94\":{\"h\":\"（Ⅱ）工作流程\",\"t\":[\"SMTP工作流程：\",\"建立连接\",\"邮件发送\",\"连接释放\",\"SMTP详细工作流程：\",\"建立连接：\",\"发送方（邮件客户端）通过SMTP与邮件服务器（SMTP服务器）建立连接。\",\"客户端使用TCP连接到服务器的25端口（默认SMTP端口）。\",\"身份确认：\",\"客户端向服务器发送HELO命令，告知自己的SMTP服务器域名。\",\"服务器回复应答代码250，表示服务就绪。\",\"发件人确认：\",\"客户端使用MAIL FROM:<发件人地址>命令告知服务器发件人地址。\",\"服务器回复应答代码250，表示发件人地址合法。\",\"收件人确认：\",\"客户端使用RCPT TO:<收件人地址>命令告知服务器收件人地址。\",\"服务器回复应答代码250，表示收件人地址合法。\",\"准备发送邮件内容：\",\"客户端向服务器发送DATA命令，告知准备发送邮件内容。\",\"服务器回复应答代码354，表示准备好接收邮件内容。\",\"发送邮件内容：\",\"客户端发送邮件内容，包括邮件头和邮件正文。\",\"结束邮件内容：\",\"客户端在发送完邮件内容后，使用.作为结束符，告知服务器邮件内容发送完毕。\",\"邮件接收确认：\",\"服务器接收邮件内容后，返回应答代码250，表示邮件接收成功。\",\"断开连接：\",\"客户端向服务器发送QUIT命令，告知准备断开连接。\",\"服务器回复应答代码221，表示接受请求并主动断开连接。\",\"需要注意的是，SMTP协议主要负责邮件的发送，而接收邮件则通常使用POP3（Post Office Protocol Version 3）或IMAP（Internet Message Access Protocol）协议。\"]},\"95\":{\"h\":\"（Ⅲ）SMTP协议的缺点\",\"t\":[\"SMTP不能传送可执行文件或者其他二进制对象\",\"SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字\",\"SMTP服务器会拒绝超过一定长度的邮件\"]},\"96\":{\"h\":\"3、MIME拓展\",\"t\":[\"MIME（Multipurpose Internet Mail Extensions）是对SMTP协议的一个重要扩展，它解决了SMTP在传送非ASCII码文本和多媒体邮件方面的局限性。\",\"具体来说，MIME引入了以下功能：\",\"传送二进制和多媒体数据：SMTP原始协议只能传送ASCII码文本，而MIME引入了一种机制，使得邮件可以包含二进制文件、图像、音频和视频等多媒体内容。\",\"字符编码：MIME定义了一种机制来处理非英语国家的文字，包括中文、俄文以及带有重音符号的法文或德文等。这样就可以确保在邮件中正确地传输和显示这些字符。\",\"邮件内容格式标准化：MIME定义了多种邮件内容的格式，例如文本、HTML、图像等，使得邮件客户端能够正确地解析和显示邮件内容。\",\"传输编码：MIME允许对邮件内容进行编码，以便在传输过程中不受邮件系统的修改。这保证了邮件内容的完整性。\",\"总的来说，MIME的引入大大扩展了电子邮件的功能，使其能够处理更多种类的信息，从简单的文本到复杂的多媒体内容。这也是为什么我们可以在电子邮件中收到包括图片、附件、网页链接等各种形式的信息。\"]},\"97\":{\"h\":\"4、POP\",\"t\":[\"POP3（邮局协议3），采用基于TCP连接的客户/服务器方式，并使用110端口号进行通信\",\"POP3 是一种简单、功能有限的邮件读取协议。\",\"用户可以通过下载并删除或下载并保留的方式将邮件从邮件服务器下载到本地计算机。\",\"不允许用户在邮件服务器上进行邮件管理，例如创建文件夹、对邮件进行分类等。\"]},\"98\":{\"h\":\"5、因特网邮件访问协议 IMAP\",\"t\":[\"IMAP4（因特网邮件访问协议），采用基于TCP连接的客户/服务器方式，并使用143端口号进行通信\",\"IMAP4 是一种功能更强大的邮件读取协议。\",\"用户可以在本地计算机上操作邮件服务器中的邮箱，就像在本地操控一样。因此，IMAP 是一种联机协议。\",\"允许用户在邮件服务器上进行邮件管理，包括创建文件夹、分类管理等。\"]},\"99\":{\"h\":\"5、基于万维网的电子邮件\",\"t\":[\"基于万维网的电子邮件：使用浏览器登录电子邮箱来收发电子邮件\",\"用户代理\",\"浏览器\",\"通过HTTP协议与邮件服务器连接\",\"邮件服务器\",\"使用供应商的邮件服务器而不是自己的\",\"邮件服务器之间的通信协议仍然为SMTP\",\"通过浏览器登录（提供用户名和口令）邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。\",\"这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。\",\"邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理。\",\"可以跨邮件服务器：代理和服务器之间采用SMTP、POP3，服务器和服务器之间采用HTTP\",\"图例-基于万维网的电子邮件\"]},\"100\":{\"h\":\"6、总结\",\"t\":[\"电子邮件总结\"]},\"101\":{\"h\":\"六、万维网\"},\"102\":{\"h\":\"1、介绍和组成\"},\"103\":{\"h\":\"（1）概述\",\"t\":[\"万维网：\",\"万维网并非某种特殊的计算机网络。它是基于C/S的协议一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用\",\"万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网\"]},\"104\":{\"h\":\"（2）组成\",\"t\":[\"万维网组成：\",\"统一资源定位符URL：是一个用于标识资源位置的字符串，它可以唯一地标识一个网页、图片、视频等资源。例如，https://www.chiou.com 是一个网站的URL == 资源在万维网中的唯一标识\",\"组成方式：<协议>://<主机>:<端口>/<路径>\",\"URL不区分大小写\",\"文档：\",\"超文本标记语言HTML：HTML是一种标记语言，用于创建网页的结构和内容。它通过标签定义文本的格式、链接、图像等元素。\",\"CSS（Cascading Style Sheets）：CSS是一种样式表语言，用于控制网页的外观和布局，包括字体、颜色、间距等样式。\",\"JavaScript：JavaScript是一种脚本语言，可以在浏览器中添加交互性和动态性。它可以用于处理用户输入、改变网页内容等。\",\"超文本传输协议HTTP：HTTP是万维网上用于传输数据的协议，它定义了浏览器和Web服务器之间的通信规则。\"]},\"105\":{\"h\":\"2、超文本传输协议HTTP\"},\"106\":{\"h\":\"（1）HTTP的作用\",\"t\":[\"超文本传输协议HTTP：\",\"HTTP定义了： \",\"浏览器(即万维网进程)怎样向万维网服务器请求万维网文档\",\"万维网服务器怎样把万维网文档传送给浏览器\"]},\"107\":{\"h\":\"（2）HTTP的报文结构\",\"t\":[\"HTTP报文分为请求报文和响应报文两种类型。\",\"请求报文：包括请求行、请求头部和请求主体 \",\"请求行 \",\"方法：GET、SET等\",\"URL\",\"版本：协议版本\",\"换行标志\",\"首部行：说明浏览器等的一些信息\",\"响应报文：包括状态行、响应头部和响应主体。 \",\"状态行 \",\"状态码+短语：404 NOT FOUND等\",\"换行标志\",\"首部行\",\"图例-http报文结构\",\"如下：\",\"图例-GET请求的HTTP报文\"]},\"108\":{\"h\":\"（3）HTTP的连接过程\",\"t\":[\"浏览器分析URL\",\"浏览器向DNS请求解析IP地址\",\"DNS解析出IP地址\",\"浏览器与服务器建立TCP连接\",\"浏览器发出取文件命令\",\"服务器响应\",\"释放TCP连接\",\"浏览器显示\"]},\"109\":{\"h\":\"（4）HTTP的特点\",\"t\":[\"HTTP是无状态的\",\"每一次连接是一样的\",\"通过cookie识别用户，存储用户信息\",\"HTTP采用TCP作为传输层协议\",\"HTTP是面向连接的：采用TCP协议\",\"HTTP本身是无连接的：通信双方在交换HTTP报文之前不需要先建立HTTP连接\"]},\"110\":{\"h\":\"（5）Cookie状态\",\"t\":[\"COOKIE：提供了一种机制使得万维网服务器能够\\\"记住\\\"用户，而无需用户主动提供用户标识信息。也就是说，Cookie是一种对无状态的HTTP进行状态化的技术\",\"图例-Cookie工作原理\"]},\"111\":{\"h\":\"3、HTTP1.0\",\"t\":[\"HTTP/1.0采用非持续连接方式 - 短连接。在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP连接。 \",\"当收到响应后就立即关闭连接。每请求一个文档就要有两倍的RTT的开销。\",\"若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费2RTT的时间。\",\"为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。\"]},\"112\":{\"h\":\"4、HTTP1.1\",\"t\":[\"HTTP/1.1采用持续连接方式。 \",\"在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就可以实现。\",\"HTTP/1.1的持续连接还可以使用流水线方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文 \",\"这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多往返时间，使TCP连接中的空闲时间减少，提高了下载文档的效率。\"]},\"113\":{\"h\":\"5、HTTP/2.0\",\"t\":[\"HTTP/2.0是HTTP协议的下一代标准，它在性能和效率上做了很多改进。其中最显著的改进之一是引入了多路复用（Multiplexing）技术。\",\"在HTTP/1.x中，每个请求都需要在一个独立的TCP连接上进行传输，这可能会导致连接的浪费和效率低下。而HTTP/2.0允许在同一个连接上同时传输多个请求和响应，避免了建立多个连接的开销。\",\"此外，HTTP/2.0还引入了头部压缩（Header Compression）技术，可以减小传输的数据量，特别是在发送大量的请求头信息时，可以显著降低网络延迟。\",\"这些优化措施使得HTTP/2.0相对于HTTP/1.x在性能上有了显著的提升，特别是对于现代复杂的网页和应用程序来说，它可以提供更快的加载速度和更高的性能表现。\"]},\"114\":{\"h\":\"6、万维网缓冲与代理服务器\",\"t\":[\"如果原始服务器中的文档已经修改，但是代理服务器中仍然有缓存，那么主机访问文档时是否会访问到未修改的文档从而发送错误呢？\",\"如果原始服务器中的文档已经被修改，但代理服务器中仍然保留了旧版本的缓存，当主机访问文档时，代理服务器会检查缓存中的响应的对象的修改时间和有效日期字段。如果文档在代理服务器中未过期，代理服务器将直接返回缓存的响应报文，这可能会导致主机拿到的是过时的文档，而不是最新的版本。\",\"然而，如果文档在代理服务器中已经过期或者被标记为无效，代理服务器会向原始服务器发送一个请求，同时在请求头部中包含一个名为\\\"If-modified-since\\\"的字段，其中记录了上次文档的修改时间。如果原始服务器中文档的修改时间与代理服务器缓存的文档的修改时间不一致，说明文档已经发生了变化，原始服务器将返回最新版本的文档。如果它们一致，原始服务器会返回一个状态码为304 Not Modified的响应，表示文档没有发生变化，此时代理服务器会使用它本地的缓存。\",\"总结起来，如果原始服务器中的文档已经被修改，但代理服务器中仍然有缓存，主机访问文档时，会发送一个带有\\\"If-modified-since\\\"字段的请求给原始服务器，如果文档没有发生变化，原始服务器会返回一个状态码为304的响应，此时代理服务器会使用它本地的缓存，否则会获取最新版本的文档。\"]},\"115\":{\"c\":[\"计算机基础\"]},\"116\":{\"c\":[\"计算机网络\"]},\"117\":{\"h\":\"数据链路层\",\"t\":[\"数据链路层是OSI模型中的第二层，它位于物理层之上，是真正用于数据传输的逻辑通道\"]},\"118\":{\"h\":\"一、简介\"},\"119\":{\"h\":\"1、概述\",\"t\":[\"数据链路层是什么？\",\"数据链路层是OSI模型中的第二层，它位于物理层之上，是真正用于数据传输的逻辑通道\",\"例如：要在一条通信线路上传送数据，除了必须建立一条物理线路（物理层的功能）之外，还必须有一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。 \",\"实现这些规程或协议的硬件和软件加上物理线路就构成了数据链路层。\",\"数据链路层的功能/作用是什么？\",\"在原始的、有差错的物理传输线路的基础上，采取差错检测、差错控制与流量控制等方法，将有差错的物理线路改进成逻辑上无差错的数据链路，以便向网络层提供高质量的服务。\",\"就像我们乘坐高铁/火车，我们买票、进站、乘车、出站都要经历铁路部门的规则 \",\"买票-流量控制\",\"进站出站检测、上车前后验票 - 差错检测\",\"数据链路层就是保证我们传输的数据能有序的、进出站，最终使这条数据通信之“路”发挥它本来的作用。\",\"解决问题：\",\"通过数据链路层解析物理层发出去的信号怎么样选择、如何到达目的地\",\"比特流的分界线\",\"链路(Link)：从一个结点到相邻结点的一段物理线路，中间没有任何其他交换结点\",\"数据链路(Data Link)：把实现通信协议的硬件和软件加到链路上，就构成了数据链路\",\"数据链路层以帧为单位传输和处理数据\"]},\"120\":{\"h\":\"2、组成结构\",\"t\":[\"在数据链路层中，通常由两个子层组成：\",\"介质访问控制子层（Media Access Control, MAC）： \",\"物理层相邻的是MAC子层，为LLC子层服务\",\"与各种传输介质访问有关的问题都放在“MAC子层”来解决。其主要功能包括：数据帧的封装/卸装，帧的寻址和识别（通过MAC地址进行的），帧的接收与发送，帧的差错控制、介质访问冲突控制等。\",\"逻辑链路控制子层（Logical Link Control, LLC）： \",\"网络层相邻的是LLC子层，而LLC子层则是接受MAC子层服务，为网络层服务\",\"数据链路层中与传输介质访问无关的问题都集中在LLC子层来解决，为网络层提供服务。其主要功能包括逻辑链路的建立和释放、提供与网络层的接口（也就是前面说到的SAP）、数据传输差错控制、给数据帧加上传输序列号等。\",\"由于网络层上可能有许多种通信协议同时存在，而且每一种通信协议又可能同时与多个对象沟通，因此当LLC子层从MAC子层收到一个数据包时必须能够判断要送给网络层的是哪一个通信协议。为了达到这种功能，在LLC子层中提供了“数据链路层”的SAP，作为与“网络层”通信交互的接口\",\"介质访问控制子层和辑链路控制子层\",\"逻辑链路控制子层提供了抽象和服务，而介质访问控制子层则管理实际的物理传输。这种层级结构使得数据链路层能够适应不同类型的物理介质和网络拓扑。\"]},\"121\":{\"h\":\"2、分类\",\"t\":[\"数据链路层主要分为两类：\",\"1、点对点的数据链路层：核心问题 - 封装成帧、差错检测、可靠传输\",\"两个相邻节点的通过链路连接，没有第三者\",\"应用：PPP协议，常用于广域网\",\"2、使用广播信道的数据链路层：确定目的主机问题、碰撞问题\",\"所有主机共享通信介质\",\"应用：早期以太网、局域网\",\"拓扑结构：星型（逻辑总线型）、总线型\"]},\"122\":{\"h\":\"二、数据链路层的功能\"},\"123\":{\"h\":\"1、数据链路管理\",\"t\":[\"什么是数据链路管理？\",\"在数据链路层中要形成一条更有利于数据传输的数据链路，而不是直接利用下面物理层中建立的物理链路，因为下面物理层中建立的物理链路有着很多传输介质的差异：\",\"数据链路是由数据链路层中的LLC子层通过相应的通信规程（也就是通常所说的协议）建立并管理的。\"]},\"124\":{\"h\":\"主要过程包括：链路建立、链路保持、链路释放\",\"t\":[\"不同协议建立的数据链路，提供的服务类型也不同。\",\"数据链路层的提供的服务类型：\"]},\"125\":{\"h\":\"（a）有确认的面向连接服务\",\"t\":[\"提供服务时，必须先建立好双方通信连接；\",\"提供服务时，必须要求对方确认后才进行。\",\"独占链路，只有在当前数据传输完成，释放了链路后，其他用户才可能与同一个接收端进行数据传输\",\"这种服务类型存在三个阶段，即数据链路建立、数据传输、数据链路释放\",\"就像我们打电话，我们打电话给某个人时，首先就是要拿起电话拨号（相当于建立连接的过程），然后对方拿起电话，问一下看是不是打错了（这就是一个确认过程）。确认不是打错的电话后，双方 开始通话。\"]},\"126\":{\"h\":\"（b）有确认的无连接服务\",\"t\":[\"不需要建立专门的数据链路\",\"接收端在接收到的每一个数据帧时都向发送端确认\",\"事实上是因为这类服务所用的数据链路已建立起来，而且是永久存在的，所以不用另外建立，如局域网中的链路，就像寄快递，送快递的路线早就建立好了，我们只需要寄出去，等收件人确认就好了，不用关心快递运送的路线。\"]},\"127\":{\"h\":\"（c）无确认的无连接服务\",\"t\":[\"不需要建立专门的数据链路\",\"接收端在接收到的每一个数据帧时不需要向发送端确认\",\"这种服务类型看似不可靠，但它是建立在可靠的通信线路基础之上的，所以数据传输仍然是非常可靠的，就像公司内部的专线网络VPN。\"]},\"128\":{\"h\":\"2、封装成帧和透明传输\"},\"129\":{\"h\":\"（a）封装成帧功能的含义\",\"t\":[\"在发送端，数据链路层是接收来自网络层的数据分组/数据包，是将来自网络层的数据分组封装成数据帧.\",\"在接收端，数据链路层是接收来自物理层的比特流，将来自物理层的一个个比特流组装成数据帧.\",\"封装成帧大多指：PPP帧、以太网MAC帧\",\"🔺PPP帧、以太网MAC帧： \",\"MAC帧不需要帧定界符，在物理层发送前会添加前导码8个（前7个为时间同步码，后面1个字节为帧开始定界符）\"]},\"130\":{\"h\":\"（b）数据包的帧封装原理\",\"t\":[\"第一步：网络层的数据包到达数据链路层后加上数据链路层的协议头和协议尾就构成了一个数据帧。\",\"第二步：在每个数据帧的前部加上一个帧头部，在帧的结尾处加上一个帧尾部，把数据帧作为帧的数据部分，就构成了一个完整帧。 \",\"其中帧有大小限制，不同网络类型下不同。\",\"帧头和帧尾就是作为帧的起始和结束标志，也就是帧边界。\",\"帧封装流程\"]},\"131\":{\"h\":\"（c）比特流的帧组装原理\",\"t\":[\"在发送端数据链路层中的帧到达物理层后就会以比特位为单位进行传输，发送端以比特位方式一位位地传输到接收端的物理层。\",\"接收端的物理层把比特流向数据链路层传输，到达后又要将比特流封装成数据帧\",\"核心问题 - 帧同步问题：使接收端的数据链路层对从物理层传输而来的一串串比特流以帧为单位进行区分，怎么区分不同帧之间的定界问题。\",\"帧同步方法：\",\"（Ⅰ）字节计数法\",\"以一个特殊字符代表一个帧的起始，并以一个专门的字段来标识当前帧内字节数。接收端通过对该特殊字符的识别从比特流中区分出每个帧的起始，并根据字节数，判断帧的结尾\",\"字节计数法\",\"（Ⅱ）字符填充的首尾定界符法\",\"用一些特定的控制字符来定界一个帧的起始与结束，如在帧的头部加上了两个SYN控制字符，用于标识该帧的开始，在结束位置加了ETX控制字符，用于标识该帧的结束。\",\"如：BSC协议\",\"字符填充的首尾定界符法\",\"（Ⅲ）比特填充的首尾定界符法\",\"通过在帧头和帧尾各插入一个特定的比特串（如01111110）来标识一个数据帧的起始与结束。\",\"如：SDLC、HDLC协议\",\"（Ⅳ）违法编码法\",\"在物理层采用特定的比特编码方法时采用。\",\"例如，曼彻斯特编码方法，将数据1编码成高-低电平对，将数据0编码成低-高电平对。而高-高电平对和低-低电平对在数据比特中是违法的，因此可以借用这些违法编码序列来定界帧的起始与终止。\",\"（Ⅴ）PPP同步传输协议\",\"面向字符传输，PPP帧结构如下\",\"PPP帧结构\",\"总共8个字节，帧头5个，帧尾3个。\",\"标志(Flag)字段：值固定为01111110（0x7E），标志帧的起始或结束。\",\"协议(Protocol)字段：表示封装的是哪个网络层协议包表示PPP帧的定界符。\",\"地址(Address)字段：值为0xFF，目前没有特定作用，保留字段。\",\"控制(Control)字段：值为0x03，也是保留字段，目前没有特定作用。\",\"协议(Protocol)字段：指明帧的数据部分送交哪个协议处理。例如：\",\"0x0021 表示数据部分为1P数据报（IP数据报）。\",\"0xC021 表示数据部分为LCP分组。\",\"0x8021 表示数据部分为NCP分组。\",\"FCS（帧检验序列）字段：CRC计算出的校验位，用于检测帧在传输过程中是否发生了错误。\"]},\"132\":{\"h\":\"（d）透明传输\",\"t\":[\"因为在帧的有效数据当中，可能出现和帧定界的控制字符一样的字符，为了防止将这些字符当中帧定界的字符，错误的处理帧，所以我们采方法使得数据当中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符\",\"对于面向字节/字符的链路\",\"发送方：帧头帧尾有标志位用来划分一个个帧，如果帧内部恰好也出现了标志位，则在第一次扫描时在标志位前面加一个转义字符帮助区分哪个是真正的帧头。考虑到转义字符也可能在帧内部出现，因此在转义字符前也加转义字符。\",\"接收方：接到消息后但凡看到转义字符开头就会去掉转义字符并且对其后一个字符不做特殊处理\",\"对于面向比特的链路\",\"发送方：在发送前，对帧的数据部分进行扫描，每5个连续的比特1后就插入1个比特0，防止其与首部尾部的标志位混淆(零比特填充法)。\",\"接收方接收时将每5个连续的比特1后面的0剔除即可\"]},\"133\":{\"h\":\"3、差错检测\",\"t\":[\"封装成帧功能解决了帧同步问题，也就是接收端可以区分每个数据帧的起始和结束了，但是还没有解决数据正确传输的两方面问题。\",\"如果有帧出现了错误怎么办？—> 差错检测\",\"如果有帧丢失了怎么办？—> 可靠传输\"]},\"134\":{\"h\":\"（Ⅰ）奇偶校验码\",\"t\":[\"奇偶校验码(PCC)：根据被传输的一组二进制代码的数位中“1”的个数是奇数或偶数来进行校验的。\",\"实现：\",\"发送端：在待发送的传输的二进制代码最后专门设置1个奇偶校验位，用它控制这组代码中1的个数为奇数或偶数（具体是偶数还是奇数，要视所采用的是偶校验还是奇校验）\",\"接收端：看里面的“1”的个数是否仍与原来一样的奇数或偶数，来确定数据传输的正确性。\",\"问题：\",\"如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码；如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码(漏检)\",\"所以奇偶校验方法只可以用来检查单个码元错误，检错能力较差，所以一般只用于本身误码率较低的环境\"]},\"135\":{\"h\":\"（Ⅱ）循环冗余校验\",\"t\":[\"循环冗余校验(CRC)：根据帧内的FCS来进行校验的。\",\"实现: \",\"收发双方：约定好一个生成多项式G(x)= 用来作为除数的二进制比特串（或多项式）\",\"发送方： \",\"基于待发送的数据（原始帧）和生成多项式(上面选定的除)进行计算(二进制除法运算)得到差错检测码【冗余码FCS】\",\"将其添加到待传输数据的后面一起传输\",\"接收方：通过生成多项式(上面选定的除) 和【冗余码FCS】来计算收到的数据是否产生了误码\",\"假设比特串为n位，那么在原始帧后面加上n-1个0，并用二进制除法除以该比特串，最后的余数就是FCS校验码，将FCS校验码放在原始帧最后，接收端拿到数据后，用二进制除法除以比特串，若余数为0，则没有差错，反之有差错。\"]},\"136\":{\"h\":\"4、可靠传输\",\"t\":[\"不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做\",\"可靠传输：想办法实现发送端发送什么，接收端就收到什么，可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输，是否使用可靠传输取决于应用需求。\"]},\"137\":{\"h\":\"（Ⅰ）停止-等待协议/自动请求重传\",\"t\":[\"停止-等待协议SW（自动请求重传ARQ）：\",\"实现原理：发送方每发送一个数据分组后，就停止发送下一个数据分组，等待接收方的确认分组或否认分组，若收到确认分组，则继续发送下一个分组，若收到否认分组，则重复之前发送的那个数据分组。\",\"存在的问题：数据分组丢失、确认分组丢失、确认分组超时\",\"数据分组丢失的情况：超时重传\",\"确认分组丢失、确认分组超时的情况：数据分组、确认分组进行编号，防止重复发送、重复确认\",\"总结：\",\"接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组\",\"为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。\",\"为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。\",\"超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。\",\"使用卫星链路及重传时，信道利用率较低。\"]},\"138\":{\"h\":\"（Ⅱ）回退N帧协议\",\"t\":[\"回退N帧协议 (Go-Back-N) ：\",\"回退N帧协议是一种滑动窗口协议，用于实现可靠的数据传输。它允许发送方连续发送多个分组，而不必等待确认，接收方按序接收分组。\",\"实现原理： \",\"发送方窗口：发送方可以连续发送多个分组，窗口的大小为N。\",\"接收方窗口：接收方窗口大小为1，只能按序接收分组。\",\"确认分组：接收方只能发送最后一个正确接收的分组的确认，其他分组的确认将被丢弃。\",\"超时重传：发送方设置定时器，超时后会重新发送窗口内的所有分组。\",\"整个工作流程： \",\"发送方连续发送窗口内的分组。\",\"接收方按序接收分组，发送确认。\",\"如果接收方检测到分组失序，则丢弃后续分组，直到接收到正确的分组为止。\",\"发送方根据接收到的确认信息移动发送窗口。\",\"如果发送方未收到确认，或者收到了错误的确认，则超时重传窗口内的所有分组或者重传末尾帧确认后开始。\",\"总结：回退N帧协议是一种常用的滑动窗口协议，适用于许多实时性要求不高，但需要高可靠性的网络通信场景。 \",\"适用于具有较高信道质量的网络环境，且丢包率较低的情况，充分利用了网络带宽，发送方可以连续发送多个分组。\",\"如果丢失一个分组，会导致窗口内的所有分组都需要重传，可能会浪费带宽。\"]},\"139\":{\"h\":\"（Ⅲ）选择重传协议\",\"t\":[\"选择重传协议 (Selective Repeat, SR) ：\",\"是一种滑动窗口协议，用于实现可靠的数据传输。它允许发送方连续发送多个分组，接收方可以选择性地确认分组，同时允许接收方接收乱序的分组。\",\"实现原理：\",\"发送方窗口：发送方可以连续发送多个分组，窗口的大小为N。\",\"接收方窗口：接收方窗口大小为N，可以接收窗口内的分组。\",\"确认分组：接收方可以选择性地确认分组，只会确认已经正确接收的分组。\",\"超时重传：发送方为每个分组设置独立的定时器，超时后会重新发送相应的分组。\",\"整个工作流程：\",\"发送方连续发送窗口内的分组。\",\"接收方按序接收分组，发送确认。\",\"接收方可以选择性地确认分组，如果接收到的分组有误，则丢弃并不会发送确认。\",\"发送方根据接收到的确认信息移动发送窗口。\",\"如果发送方未收到确认，或者收到了错误的确认，则超时重传相应的分组。\",\"总结：适用于具有一定信道质量的网络环境，可以容忍一定程度的丢包情况。\",\"充分利用了网络带宽，发送方可以连续发送多个分组。\",\"允许接收方接收乱序的分组，提高了网络利用率。\",\"发送方和接收方都需要维护更复杂的状态信息。\"]},\"140\":{\"h\":\"5、流量控制\",\"t\":[\"流量控制并不是数据链路层所特有的功能，许多高层协议中也提供流量控功能，只不过流量控制的对象不同而已。比如，对于数据链路层来说控制的是相邻两节点之间数据链路上的流量，而对于传输层来说控制的是从源到最终目的端之间的流量。\",\"流量控制：对发送端数据传输速率的控制，使其数据发送速率不超过接收端所能承受的数据接收能力。\",\"发送端的数据发送速度与接收端的数据接收速度要匹配，否则接收端来不及接收就会造成数据在传输过程中的丢失。\",\"发送端的数据发送速度要与线路上的承载速率（与线路信道带宽有关）相匹配，否则也会造成数据在传输过程中的丢失\",\"是考虑到在接收端还需要对来自物理层的比特流进行一系列的处理，如帧封装，向发送端发送返回确认帧等，所以通常是要使发送端的发送速率略小于接收端的数据处理能力。\",\"流量控制实现方法\"]},\"141\":{\"h\":\"（Ⅰ）基于反馈的流量控制方案\",\"t\":[\"差错控制中的“自动重发请求”就是基于反馈的流量控制。\",\"XON/XOFF（继续/停止）：\",\"接收端认为不能继续接收数据时（也就是接收端的缓存空间满了或者接近满时），接收端会向发送端发送一个XOFF控制字符\",\"当发送端收到对应的XOFF控制字符时就停止数据的继续发送；\",\"当接收端可以继续接收数据时，接收端会再向发送端发送一个XON控制字符\",\"发送端收到这个控制字符后就知道可以恢复数据发送了，继续发送数据，一直这么循环下去。\"]},\"142\":{\"h\":\"（Ⅱ）基于速率的流量控制方案\",\"t\":[\"基于窗口滑动机制的速率控制方，差错控制中的回退N帧协议和选择重传协议就是基于速率的流量控制\",\"收发双方维持收发窗口N：\",\"假设发送端缓存空间大小为3个帧，那么发送端连着发了3个帧后，缓存空间满了，就要停止，等待接收端的确认，当发送端收到接收端对前两个帧的确认后，发送端将前两个帧从缓存空间中删去，再发送两个帧，此时缓存空间又满了，又要等待确认.....如此循环下去。\"]},\"143\":{\"h\":\"三、介质访问控制\"},\"144\":{\"h\":\"1、概述\",\"t\":[\"介质访问控制子层（MAC子层）：\",\"是局域网体系结构中划分的子层，对于广播型网络（如以太局域网、WLAN）是非常重要的，因为它担负了两方面的主要职责： \",\"解决如何在局域网内寻址（也就是找到目的节点）\",\"解决如何在多路通信中介质争用的现象。\",\"由于数据链路层主要分为两类：点对点的数据链路层、使用广播信道的数据链路层\",\"不同节点之间通过介质（信道）进行访问，在广播信道中所有主机共享通信介质，这就引发了一个共享信道争用的问题。而介质访问控制就是采取一定的措施，使两对节点之间的通信不会发生互相干扰，主要分为分为两种：\",\"静态划分信道\",\"信道划分介质访问控制：频分多路复用、时分多路复用、波分多路复用、码分多路复用 \",\"多路复用：将多个信号组合在一个信道上进行传输，到目的后再分离为多个信号，本质上是将广播信号变为多个点对点链路\",\"动态划分信道\",\"随机访问介质控制：随机介入控制协议（CMSA/CD、CMSA/CA等）\",\"轮询访问介质控制：轮询协议、令牌传递协议\",\"我们把：如何协调多个发送和接收站点对一个共享传输媒体的占用的问题成为媒体接入控制MAC(Medium Access Control)\"]},\"145\":{\"h\":\"2、信道划分介质控制\"},\"146\":{\"h\":\"（1）静态划分信道\"},\"147\":{\"h\":\"（Ⅰ）频分多路复用（FDM）\",\"t\":[\"各个用户分配不同的频带，之后始终使用相同的频带进行通信。\",\"不同的用户在同样的时间占用不同的带宽（模拟信号角度的带宽）\",\"系统效率较高\",\"实现简单\"]},\"148\":{\"h\":\"（Ⅱ）时分多路复用（TDM）\",\"t\":[\"将时间划分为等长的时分复用帧，每一帧划分为若干时隙。\",\"每一个用户在一个TDM帧中占用固定序号的时隙。\",\"改进：统计时分复用（STDM）\",\"使用集中器收集各个用户的数据，并按照先后顺序存入自己的缓存，之后按照先后顺序填充STDM帧，帧满即发送出去。\",\"STDM帧大小小于连接在集中器上的用户数。\"]},\"149\":{\"h\":\"（Ⅲ）波分多路复用（WDM）\",\"t\":[\"介质为光纤，原理类似于光的频分多路复用。\"]},\"150\":{\"h\":\"（Ⅳ）码分多路复用（CDM）\",\"t\":[\"码分多址（CDMA）：将一个比特位用一组特定的码片发送，每一个用户拥有唯一的码片，用不同的码来区分不同的用户信号，允许同时传输多个信号。\",\"码片直接发送代表1，反码发送代表0。\",\"对于各个用户的码片，要求其规格化内积等于0，且其自身的内积为1\",\"复用与多址的区别：\",\"复用：是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分\",\"多址：(更确切地应该称为多点接入)处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久地分配给用户的应用中，多址是不需要的(对于无线广播或电视广播站就是这样)\"]},\"151\":{\"h\":\"（2）动态划分信道\"},\"152\":{\"h\":\"（Ⅰ）随机访问介质控制\",\"t\":[\"在随机接入中，所有站点通过竞争随机地在信道上发送数据，发送信息时占用全部带宽。\",\"如果恰巧有两个或更多的站点在同一时刻发送数据，则会发生碰撞（即冲突）。在发生冲突后，这些站点的发送都会失败。因此，这类协议需要解决如何尽量避免冲突以及在发生冲突后如何尽快恢复通信。\",\"CMSA/CD协议：载波监听多址接入/碰撞检测 - 早期的双绞线，以太网，广播信道的有线局域网\",\"多个站点连接在一条总线上，竞争使用总线进行通信。\",\"每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧\",\"如果检测到总线空闲，就立即发送帧。\",\"若检测到总线忙，则继续检测并等待总线转为空闲。\",\"一旦发送帧，站点会边发送边监听总线，以检测是否发生碰撞。\",\"若发现碰撞，立即停止发送，然后进行退避（等待一段随机时间）后再次尝试发送。\",\"如果发送成功，站点等待总线转为空闲96比特时间后，再发送下一个帧。\",\"以太网规定：\",\"最小帧长为64字节，即512比特(512比特时间即为争用期)\",\"最大帧长为1518-mac帧，vlan帧-1522\",\"如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节，以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞。\",\"CMSA/CA协议：载波监听多址接入/碰撞避免 - 广播信道的无线局域网\",\"802.11无线局域网使用CSMA/CA协议，在CSMA的基础上增加了一个碰撞避免CA功能，而不再实现碰撞检测功能 \",\"由于不可能避免所有的碰撞，并且无线信道误码率较高，802.11标准还使用了数据链路层确认机制(停止-等待协议)来保证数据被正确接收\",\"在无线局域网中，仍然可以使用载波监听多址接入CSMA，即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以避免碰撞\",\"在无线局域网中，不能使用碰撞检测CD，原因如下：\",\"由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度(可能差百万倍)。如果要在无线网卡上实现碰撞检测CD，对硬件的要求特别高。\",\"即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性(存在隐蔽站的问题-不相交)，进行碰撞检测的意义也不大。\",\"802.11的MAC层标准定义了两种不同的媒体接入控制方式：\",\"分布式协调功能DCF：在DCF方式下，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获取发送权，这是802.11定义的默认方式\",\"点协调功能PCF：PCF方式使用集中控制的接入算法(一般在接入点AP实现集中控制)，是802.11定义的可选方式，在实际中较少使用\",\"名词拓展：\",\"IFS：802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔\",\"SIF：这是最短的帧间间隔，用来分隔开属于一次对话的各帧。\",\"一个站点应当能够在这段时间内从发送方式切换到接收方式。\",\"使用SIFS的帧类型由ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧\",\"DIFS：它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧\",\"信道预约：RTS、CTS\",\"衍生问题：\",\"①为什么源站检测到信道空闲后，还需要等待DIFS时间才将帧发送呢？\",\"​ 因为其他站此时可能有优先级更高的帧需要发送，因此有DIFS时间进行缓冲，若这个时间内没有高优先级的帧要发送，则说明信道是真正的空闲\",\"②为什么目的站接收到帧后还需要等到SIFS时间才返回ACK确认帧呢？\",\"​ SIFS是最短的帧间间隔，用来分割一次对话的各帧，在这个时间里由接收状态转变为发送状态\",\"③当其他站要发送数据，但是发现此时信道正忙时就会退避一段时间，等信道不忙后再进行操作，接着等待DIFS时间(与①同理)，但为什么等待了DIFS时间后还要退避一段随机时间呢？\",\"​ 因为可能有多个站点在信道忙时都想发送帧，因此它们都会被搁置直至信道不忙，在DIFS时间后他们会同时发送，而实际上多个站点同时发送数据会碰撞。因此需要一个随机时间将他们进行错峰发送。\"]},\"153\":{\"h\":\"（Ⅱ）轮询访问介质控制\",\"t\":[\"轮询访问：用户在发送数据前需要等待授权\",\"轮询协议：主结点轮流“邀请”从属结点发送数据。\",\"一个中心节点负责协调和控制所有用户的访问，一个主节点以循环方式轮询每个站点，询问是否有数据要发送，只有被轮询到的站点才能发送数据。最大的缺点是可能存在单点故障问题，因为所有通信依赖于主站的正常运行。\",\"缺点：\",\"单点故障（主节点故障则整个网络瘫痪），因为所有通信依赖于主站的正常运行\",\"轮询开销\",\"等待延时\",\"令牌传递协议：\",\"控制由多个节点分散执行，每个节点在特定条件下可以自由接入，通过令牌传递，所有站点被连接成一个环形网络。\",\"一个特殊的控制锁（令牌）沿着环（网络）逐站传递。\",\"只有接收到令牌的站点才有权发送数据，并在发送完数据后将令牌传递给下一个站点。 \",\"修改标志位，将令牌占用\",\"将数据附加在令牌后，形成数据帧\",\"再将令牌发送出去\",\"令牌继续循环 \",\"目标主机将数据部分复制副本\",\"非目标主机直接传走\",\"令牌再次回到发送主机 \",\"进行校验，若数据出错则再次发送\",\"将数据移除，标志位复位，继续传送令牌\",\"这种方法可以避免冲突，但如果令牌丢失或损坏，可能会导致通信中断。\",\"缺点： \",\"每一个主机能占用令牌的时间是有限的，没有传递完则需要等待下一轮循环到自己再继续发送\",\"等待延迟\",\"单点故障（一个节点故障则循环不能继续）\"]},\"154\":{\"h\":\"四、局域网\"},\"155\":{\"h\":\"1、概述\",\"t\":[\"局域网（Local Area Network），简称LAN，是指在一个较小的地理范围（如所学校）内，将各种计算机、终端与外部设备等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络。\"]},\"156\":{\"h\":\"（1）主要特点\",\"t\":[\"1、为一个单位所拥有，且地理范围和站点数目均有限。\",\"2、所有站点共享较高的总带宽（即较高的数据传输速率)。\",\"3、较低的时延和较低的误码率。\",\"4、各站为平等关系而非主从关系。\",\"5、能进行广播和组播。\"]},\"157\":{\"h\":\"（2）三个要素\",\"t\":[\"局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式，其中最重要的是介质访问控制方式，它决定着局域网的技术特性。\"]},\"158\":{\"h\":\"（3）常见的局域网拓扑结构\",\"t\":[\"主要有以下4大类: ①星形结构;②环形结构;③总线形结构;④星形和总线形结合的复合型结构。\",\"局域网可以使用双绞线、铜缆和光纤等多种传输介质，其中双绞线为主流传输介质。\",\"局域网的介质访问控制方法主要有CSMA/CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌 环主要用于环形局域网。\",\"三种特殊的局域网拓扑实现如下: \",\"以太网（目前使用范围最广的局域网)。 \",\"逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构。\",\"令牌环（Token Ring，IEEE 802.5)，不用了。逻辑拓扑是环形结构，物理拓扑是星形结构。\",\"FDDI(光纤分布数字接口，IEEE 802.8)。逻辑拓扑是环形结构，物理拓扑是双环结构。\",\"WLAN（采用IEEE 802.11标准）：无线局域网\",\"IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，并将数据链路层拆分为两个子层：逻辑链路控制(LLC)子层和媒体接入控制(MAC)子层。 \",\"与接入传输媒体有关的内容都放在MAC子层：它向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，主要功能包括: 组帧和拆卸帧、比特传输差错检测、 透明传输。\",\"LLC子层：与传输媒体无关，它向网络层提供无确认无连接、面向连接、带确认无连接、高速传送4种不同的连接服务类型。\",\"由于以太网在局域网市场中取得垄断地位，几乎成为局域网的代名词，而802委员会制定的LLC子层作用已经不大，因此现在许多网卡仅装有MAC协议而没有LLC协议。\"]},\"159\":{\"h\":\"2、虚拟局域网\",\"t\":[\"虚拟局域网又称VLAN，由于传统的局域网缺乏流量隔离：广播流量会跨越整个机构网络（ARP、RIP、DHCP协议）一个单位的不同部门共享一个局域网，对安全不利，所以引入了VLAN。\",\"传统局域网带来的问题：\",\"广播风暴：大量广播消息可能导致网络拥塞。\",\"难以管理和维护：管理一个庞大的广播域会变得复杂。\",\"潜在的安全问题：所有设备处于同一个广播域，可能会有安全隐患。\",\"频繁的广播信息：TCP/IP协议栈中的许多协议都会使用广播，例如ARP、RIP、DHCP等。\",\"VLAN原理：\",\"将局域网内的设备划分成与物理位置无关的逻辑组的技术，VLAN是通过软件的方式实现的，因此节点的位置不受物理位置的限制\",\"每个VLAN是一个单独的广播域/不同的子网\",\"实现\",\"基于端口：交换机中除了转发表，还存在一张VLAN表，记录了各个端口号和它对应的VLAN号\",\"基于MAC地址：VALN表中记录的是各个MAC地址和它对应的VLAN号\",\"基于IP地址：可以进行跨路由器扩展\",\"不同组的VLAN之间通过将帧上附加相应的VLAN标签进行通信：\",\"LAN和VALN格式\",\"交换机端口是VLAN的另一种实现方式，它通过在交换机上配置端口的成员关系来实现VLAN的划分和隔离。\",\"Access Port：配置为特定VLAN，只能属于一个VLAN，用于连接终端设备。\",\"Trunk Port：可以传送多个VLAN的数据帧，通常用于连接交换机之间或交换机与路由器之间的链路。\",\"Hybrid Port：既可以属于一个VLAN，也可以传送多个VLAN的数据帧。\",\"交换机各端口的缺省VLAN ID：\",\"在思科交换机上称为Native VLAN，即本征VLAN。\",\"在华为交换机上称为Port VLAN ID，即端口VLAN ID，简记为PVID。\",\"Access Port：\",\"Access端口的基本特性和工作原理：\",\"Access端口通常用于连接用户计算机或其他终端设备。\",\"Access端口只能属于一个VLAN。这意味着它会将连接到该端口的所有帧都归属于同一个VLAN。\",\"PVID(Port VLAN ID) 值是与端口所属VLAN的VID相同。默认情况下，PVID为1。\",\"Access端口接收并处理“未打标签”的普通以太网MAC帧。如果一个帧来自一个Access端口，并且它没有VLAN标签，交换机会根据该端口的PVID为该帧打上相应的VLAN标签。\",\"Access端口发送处理方法：如果帧中的VID与端口的PVID相等，交换机会将VLAN标签移除并将帧转发；否则，它将不会转发该帧。\",\"Trunk Port：\",\"Trunk端口的基本特性和工作原理：\",\"Trunk端口一般用于交换机之间或交换机与路由器之间的互连。\",\"Trunk端口可以属于多个VLAN。\",\"用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1。\",\"Trunk端口发送处理方法： \",\"对于VID等于PVID的帧，“去标签”再转发；\",\"对于VID不等于PVID的帧，直接转发。\",\"Trunk端口接收处理方法：接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。\",\"!!!互连的Trunk端口的PVlD值不等，可能会造成转发错误\",\"Hybrid Port：\",\"Hybrid端口的基本特性和工作原理：\",\"Hybrid端口既可用于交换机之间或交换机与路由器之间的互连（与Trunk端口相似），也可用于交换机与用户计算机之间的互连（与Access端口相似）。\",\"Hybrid端口可以属于多个VLAN（与Trunk端口相似）。\",\"用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1（与Trunk端口相似）。\",\"Hybrid端口发送处理方法（与Trunk端口不同）：\",\"查看帧的VID是否在端口的去标签列表中：\",\"若存在，则“去标签”后再转发；\",\"若不存在，则直接转发。\",\"Hybrid端口接收处理方法（与Trunk端口相似）：\",\"接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。\",\"接收“已打标签的帧”。\"]},\"160\":{\"h\":\"五、广域网\"},\"161\":{\"h\":\"1、概述\",\"t\":[\"是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。广域网的通信子网主要使用分组交换技术。\",\"广域网（Wide Area Network，WAN）通常是指覆盖范围很广（远超一个城市的范围）的长距离网络，又称外网、公网\",\"是因特网的核心部分，其任务是长距离运送主机所发送的数据。\",\"连接广域网各结点交换机的链路都是高速链路，它可以是长达几千千米的光缆线路，也可以是长达几万千米的点对点卫星链路。\",\"因此广域网首要考虑的问题是通信容量必须足够大，以便支持日益增长的通信量。\",\"广域网不等于互联网，互联网可以连接不同类型的网络（既可以连接局域网，又可以连接广域网)，通常使用路由器来连接，广域网的通信子网主要使用分组交换技术。 \",\"结点交换机和路由器都用来转发分组，它们的工作原理也类似。 \",\"结点交换机在单个网络中转发分组，功能是将分组存储并转发\",\"路由器在多个网络构成的互联网中转发分组，功能是将分组存储并转发\",\"广域网\"]},\"162\":{\"h\":\"2、广域网与局域网的比较\",\"t\":[\"广域网\",\"局域网\",\"覆盖范围\",\"范围很广，用于跨区域网络\",\"范围较小，通常位于一个区域\",\"连接方式\",\"结点之间都是点到点连接，但为了提高网络的可靠性，一个结点交换机往往与多个结点交换机相连\",\"基本都采用多点接入技术\",\"OSI模型层次\",\"物理层、数据链路层、网络层\",\"物理层、数据链路层、\",\"相同点\",\"都是互联网的重要组成构件，从互联网的角度上看，二者平等（不是包含关系）\",\"连接到一个广域网或一个局域网上的主机在该网内进行通信时，只需要使用其网络的物理地址\",\"主要侧重点\",\"资源共享\",\"数据传输\",\"广域网中的一个重要问题是路由选择和分组转发。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组是通过转发表进行转发的。\",\"常见的两种广域网数据链路层协议是 PPP 协议和 HDLC 协议。\"]},\"163\":{\"h\":\"六、MAC地址、IP地址、ARP协议\"},\"164\":{\"h\":\"1、MAC地址\"},\"165\":{\"h\":\"（1）概念\",\"t\":[\"MAC地址位于数据链路层，也被称为硬件地址（物理地址），用于媒体接入控制 MAC，用于多个主机连接在同一个广播信道上，实现两个主机之间的通信\",\"一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器 (无线网卡)。 \",\"每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以 会拥有更多的MAC地址。\",\"MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识\"]},\"166\":{\"h\":\"（2）组成\",\"t\":[\"IEEE 802 局域网中的MAC地址：\",\"组成：由6个字节组成，共48位，通常以十六进制表示\",\"组合：MAC地址有2^48个可能的组合，这是一个非常大的数字，约等于2.81 x 10^14，也就是280万亿。\",\"前24位是由IEEE注册管理机构分配的组织唯一标识符（OU）\",\"后24位是由获得该组织唯一标识符的厂商自行随意分配的网络接口标识符。\",\"第一个字节的最高位（b1）用于指示地址的全球管理或本地管理。\",\"b1 = 0 表示全球管理。\",\"b1 = 1 表示本地管理。\",\"第一个字节的次高位（b0）用于指示单播还是多播地址。\",\"b0 = 0 表示单播地址。\",\"b0 = 1 表示多播地址。\",\"单播、多播和广播MAC地址是用于在以太网网络中标识设备的特殊地址类型：\",\"单播（Unicast）MAC地址：一对一通信方式\",\"单播地址是用于将数据从一个发送者传递到一个特定的接收者的地址。\",\"当设备发送数据帧时，目的地址部分包含的是接收者的MAC地址。\",\"这意味着只有目标设备会接收到这个数据帧。\",\"多播（Multicast）MAC地址：针对特定组的设备的一对多通信方式\",\"多播地址是用于将数据从一个发送者传递到一组特定的接收者的地址。\",\"在MAC地址中，多播地址是一种特殊的地址，用于指示数据应传递给特定组中的设备。\",\"多播地址的范围是在特定的范围内，而不是针对单个设备。\",\"多播通信是一对多的通信方式，但只针对加入了特定多播组的设备。\",\"b0是位是1则为多播地址。\",\"广播（Broadcast）MAC地址：一对所有通信方式\",\"广播地址是用于将数据从一个发送者传递到同一广播信道上的所有设备的地址。\",\"广播地址是一个特殊的地址，通常被用于向整个网络发送信息，以便所有设备都能接收到。\",\"广播是一种一对所有的通信方式。\"]},\"167\":{\"h\":\"2、IP地址\",\"t\":[\"IP地址是TCP/IP体系结构的网际层所使用的的地址\",\"IP地址是Internet上的主机和路由器所使用的的地址，由两部分信息构成 \",\"网络编号：标识因特网上数以百万计的网络\",\"主机编号：标识同一网络上不同主机(或路由器各接口)\",\"MAC地址不具备区分不同网络的功能，而IP地址可以通过网络号做到\",\"如果只是一个单独网络，不接入因特网，则使用MAC地址就足够了(这不是一般用户的应用方式)，如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用\",\"数据包转发过程中IP地址与MAC地址变换情况：\",\"数据报转发过程中源IP地址和目的IP地址保持不变\",\"数据包转发过程中源MAC地址和目的MAC地址(由ARP协议获得)逐个链路改变\"]},\"168\":{\"h\":\"3、ARP协议\",\"t\":[\"地址解析协议ARP属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址，ARP协议只能在一段链路或一个网络上使用，不能全链路，只能跨链路\",\"数据的发送需要经过链路，仅仅知道IP地址是无法在数据链路层实现传输的，因此我们需要得到IP地址与MAC地址的对应关系，即地址解析。\",\"每台主机都会有一个ARP高速缓存表，记录有IP地址与MAC地址的对应关系\",\"初始ARP高速缓存表为空，假设此时B知道C的IP地址，准备发送信息，但是由于不知道C的MAC地址，因此无法封装数据帧，所以此时会广播一个ARP请求报文(封装在MAC帧中，目的地址为广播地址FF-FF-FF-FF-FF-FF)， \",\"内容如下： \",\"我的IP地址是：xxx ；我的MAC地址是：XXX；我想知道C主机的MAC地址是多少？这个广播帧会被该广播域的所有主机收到\",\"A主机收到后交由上层处理，发现B问的不是他，所以不予理会，C收到后交由上层处理，发现这个IP地址正是自己，因此首先将B的MAC地址和IP地址的对应关系记录到自己的高速缓存表中，接着返回给ARP响应报文(封装在MAC帧中，目的地址为B的MAC地址)，其中包含自己的MAC地址\",\"ARP高速缓存条目有静态与动态两种类型\",\"动态：代表是通过广播自动获取的条目，生命周期默认为两分钟\",\"静态：是手工设置的条目，不同操作系统下的生命周期不同。\"]},\"169\":{\"h\":\"六、常见设备\",\"t\":[\"集线器、网桥、交换机\"]},\"170\":{\"h\":\"1、集线器\",\"t\":[\"集线器HUB的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。\",\"使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议\",\"集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测(由各站网卡检测)\",\"集线器一般都有少量的容错能力和网络管理功能。 \",\"例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作\",\"集线器是半双工模式，收发不能同时进行，收到帧后会广播到除本身接口外的各个接口。\"]},\"171\":{\"h\":\"2、网桥\",\"t\":[\"网桥介绍：\",\"网桥是两端口二层网络设备，用来连接不同网段的计算机网络设备，同时它又可隔离冲突域，因为它的两个端口不是共享一条背板总线（分别有一条独立的交换信道），比当时的集线器（Hub）性能更好（集线器上各端口都是共享同一条背板总线的）。\",\"网桥除了可以扩展网络的物理连接范围外，还可以对MAC地址进行分区。但因为网桥只有两个端口，故一般两个端口都是连接集线器，每个物理网段的主机都连接到各自的集线器上。\",\"后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。\"]},\"172\":{\"h\":\"3、交换机\"},\"173\":{\"h\":\"（1）概述\",\"t\":[\"交换机是一种负责转发信号的网络设备，可以为接入交换机的任意两个网络节点提供独享的电信号通路\",\"以太网交换机通常由多个接口，每个接口都可以直接与一台主机或另一个以太网交换机相连。 \",\"一般都工作在全双工方式\",\"以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞(不使用CSMA/CD协议)\",\"以太网交换机一般都具有多种速率的接口\",\"以太网交换机工作在数据链路层(也包括物理层)，它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧\",\"以太网交换机是一种即插即用的设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的\",\"交换机每个接口是一个独立的碰撞域\",\"帧的两种转发方式：\",\"存储转发\",\"直通交换：采用基于硬件的交叉矩阵(交换时延非常小，但不检查是否有差错)\"]},\"174\":{\"h\":\"（2）自学习和转发帧流程\",\"t\":[\"以太网交换机收到帧后，会在帧交换表中查找帧的目的MAC地址对应的接口号，然后通过该接口转发帧。\",\"以太网交换机是即插即用设备，刚上电启动时，内部的帧交换表是空的。随着网络中各主机间的通信，以太网交换机通过自学习算法逐渐建立起帧交换表。\",\"自学习和转发帧的流程：\",\"收到帧后进行登记，登记的内容包括帧的源MAC地址及进入交换机的接口号。\",\"根据帧的目的MAC地址和交换机的帧交换表对帧进行转发，分为以下三种情况：\",\"明确转发：交换机知道应当从哪个（或哪些）接口转发该帧（单播、多播或广播）。\",\"盲目转发：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）。\",\"明确丢弃：交换机知道不应该转发该帧，将其丢弃。\",\"帧交换表中的每条记录都有自己的有效时间，到期会被删除。这是因为可能发生以下情况：\",\"交换机的接口改接了另一台主机。\",\"主机更换了网卡。\",\"这个过程使得以太网交换机能够动态地学习网络中各设备的MAC地址，并根据这些学习到的信息，选择性地将数据帧转发到特定的接口，提高了网络的性能和效率。\"]},\"175\":{\"h\":\"（3）STP生成树协议\",\"t\":[\"STP（Spanning Tree Protocol，生成树协议）是用于在以太网交换网络中防止环路的协议。它是一种链路层协议，可以确保在具有多个交换机的网络中，只有一条活动路径。\",\"以下是关于STP的一些基本信息：\",\"作用：防止网络中的环路，保证网络拓扑是一个树形结构，从而避免数据包在网络中无限循环。\",\"选择根桥：\",\"STP使用Bridge ID（桥标识）来选择网络中的根桥，Bridge ID由优先级和MAC地址组成，优先级越低越优先。\",\"选择根桥后，网络中的所有交换机会选择一条到根桥的最短路径作为活动路径。\",\"选择根端口：每个交换机选择到根桥的最短路径，其中选择的端口称为根端口。\",\"选择指定端口：对于每条链路，交换机中的一个端口会被选为指定端口，这是到达根桥的次短路径。\",\"阻塞端口：为了防止环路，STP会将一些端口设为阻塞状态，暂时不参与转发数据。\",\"定时机制：STP会定期发送BPDU（Bridge Protocol Data Unit）来保持拓扑信息的更新，以便在网络发生变化时适时调整。\",\"快速收敛：当网络发生故障或拓扑变化时，STP可以快速重新计算生成树，以保证网络尽快恢复正常。\",\"RSTP（Rapid Spanning Tree Protocol）：是STP的改进版本，提供了更快的收敛时间和更强的稳定性。\",\"STP是构建现代局域网的基础，它确保了网络拓扑的稳定性和可靠性。通过避免环路的产生，STP保证了数据在网络中的有效传输。\"]},\"176\":{\"c\":[\"计算机基础\"]},\"177\":{\"c\":[\"计算机网络\"]},\"178\":{\"h\":\"网络层\",\"t\":[\"网络层的就是是为了实现不同网络之间的互连，为不同主机提供通信服务，允许数据包在这些网络之间传输，就是把数据分组从源端传到目的端\"]},\"179\":{\"h\":\"一、简介\"},\"180\":{\"h\":\"1、主要任务\",\"t\":[\"网络层的主要任务：\",\"网络层的主要任务是实现不同网络之间的互连，为不同主机提供通信服务，允许数据包在这些网络之间传输，就是把数据分组从源端传到目的端。\",\"网络层传输单位是数据报。\",\"当数据报过大时，还是会进行分组之后再发送。\"]},\"181\":{\"h\":\"2、为什么需要\",\"t\":[\"为什么需要网络层：\",\"因为我们的网络比较大，不再是拘于物理层和数据链路层的局域网了，而是更大的广域网、互联网。而在这个更大的网络中，如果我们要是信息送达给对方，单靠数据链路层的mac地址寻址是不够的，因为：\",\"数据是在不同设备间进行传输的，一直经历帧的封装的解封，这个过程中，帧的mac地址是不断变化的，例如A –> D，要经过B、C两个路由器，那么最后达到D的数据中的mac地址就是C的mac地址，所以说当源端和目的端位于不同网络的时候，直接通信是不可行的（找不到对方），此时就需要由网络层解决。\",\"所以我们需要一个不变的地址，那就是本层网络层的IP地址。\",\"网络层-简单工作流程\"]},\"182\":{\"h\":\"3、怎么理解\",\"t\":[\"怎么理解网络层：\",\"如果我们把物理层和数据链路层比作市内交通，那么，网络层就像是连接不同城市之间的高速公路系统。\",\"它负责在不同的网络之间传输数据包，类似于高速公路连接不同城市之间的交通流。\",\"网络层的主要任务是确定数据的最佳路径，并且确保数据能够从源地址传输到目标地址。\",\"就像高速公路可以有多条路径连接不同城市一样，网络层也能根据不同的条件选择最佳的数据传输路径(路由器)，比如最短路径或者最快路径，以确保数据的有效传输。\"]},\"183\":{\"h\":\"4、有什么作用\"},\"184\":{\"h\":\"（Ⅰ）屏蔽网络差异，提供透明传输\",\"t\":[\"网络层能够为上层传输层解决不同网络的规范要求差异，寻找一个不同网络间能共同遵守的网络通信规范，以便不同网络间能相互识别，并接受对方的访问请求，这样传输层就可以在不同网络间进行透明（也就是不管不同网络间的差异，就像通信双方是直接互连一样）数据传输了。\",\"网络层向传输层提供的服务：\",\"①面向连接的网络服务：虚电路服务\",\"②无连接的网络服务：数据报服务\",\"面向连接的虚电路服务： \",\"可靠通信由网络保证：在虚拟电路通信中，网络确保了通信的可靠性。这意味着网络会尽最大努力确保分组在传输过程中能够正确、按序到达，且不会丢失或重复。\",\"建立网络层连接：在虚拟电路通信中，通信双方需要在网络层建立一个连接，这个连接是虚拟的，也就是说，它是逻辑上的连接，而非实际的物理连接。\",\"虚拟电路（Virtual Circuit）：通信双方沿着已建立的虚拟电路发送分组。在连接建立阶段，目的主机的地址会被使用来建立连接，但之后在传输过程中，每个分组的首部只需携带一个虚拟电路的编号。\",\"可靠传输协议的使用：如果在这种通信方式下使用了可靠传输的网络协议，那么发送的分组将最终可以正确到达接收方，且保证无差错、按序到达、不丢失和不重复。\",\"释放虚拟电路：在通信结束后，需要释放之前所建立的虚拟电路，以便释放网络资源。\",\"实际应用：许多广域分组交换网络，如曾经的X.25、帧中继FR、异步传输模式ATM等，都使用了面向连接的虚拟电路服务，以提供可靠的通信服务。\",\"无连接的数据报服务： \",\"可靠通信由用户主机保证：在这种通信方式下，可靠通信的责任落在了用户主机（端点）的头上，而不是网络本身。用户主机必须使用适当的协议来保证数据的可靠传输。\",\"无需建立网络层连接：不像虚拟电路通信，这种通信方式不需要在网络层建立连接。每个分组被独立发送，不需要提前建立连接。\",\"分组可以走不同的路径：每个分组可以根据网络的情况走不同的路径，这使得网络能够更加灵活地处理分组传输。\",\"分组头部必须携带目的主机的完整地址：每个分组的头部包含了目的主机的完整地址，这样网络可以根据这个地址来确定分组的传输路径。\",\"分组可能出现误码、丢失、重复和失序：由于网络本身不提供端到端的可靠传输服务，传输过程中分组可能会遭受误码、丢失、重复或失序的情况。\",\"简化的网络处理功能：因为网络本身不提供可靠传输服务，路由器可以相对简单，这也降低了网络设备的成本。\",\"将复杂功能置于网络边缘：因特网采用了这种设计思想，即将复杂的网络处理功能放在网络边缘（用户主机和其内部的运输层），而将相对简单的分组交付功能放在网络核心。\"]},\"185\":{\"h\":\"（Ⅱ）为网络间通信提供路由选择\",\"t\":[\"能根据一定的原则和路由选择算法在多个结点的通信子网中选择一条到达目的节点的最佳路径\"]},\"186\":{\"h\":\"（Ⅲ）数据包封装和解封装\",\"t\":[\"对来自传输层的报文：为其报文头部添加一些网络层协议控制信息封装成数据包。数据包的头部包含源节点和目标节点的网络层地址（例如IP地址）。\",\"对从低层到达网络层的报文：去掉在数据链路层加上的数据链路层协议控制信息（也就是帧头和帧尾），还原出原来的数据包格式，这就是包的解封装过程\"]},\"187\":{\"h\":\"（Ⅳ）拥塞控制\",\"t\":[\"避免网络传输路径中数据的传输延迟或死锁\",\"在数据链路层提到了流量控制功能，那是针对数据链路中点对点传输速率的控制\",\"而这里的拥塞控制是针对在网络传输路径中的端到端传输效率的控制（如避免路由器缓存空间爆满而造成丢包的情况）。\"]},\"188\":{\"h\":\"二、网络层协议及报文格式\"},\"189\":{\"h\":\"1、IPV4协议\",\"t\":[\"IPV4协议：将多个分组交换网络（数据报交换方式）连接起来的最典型通信协议\",\"​ 该协议是无连接的服务，负责在源地址和目的地址之间传送数据报，然后为了适应不同网络对分组大小的要求，需要对上层传来的报文进行分割，最后调用本地网络协议将数据报传送给下一个网关或目的计算机。\"]},\"190\":{\"h\":\"（1）主要功能\"},\"191\":{\"h\":\"①寻址\",\"t\":[\"在同一以太局域网内部，结点间的寻址可以通过二层MAC地址进行，但在不同网络之间，是不能通过MAC地址的，因为用于MAC地址寻址的广播帧只能在同一个以太网段内部进行\",\"在不同网络中只能通过三层地址(该协议中为IP地址)进行寻址.\"]},\"192\":{\"h\":\"②数据报的封装\",\"t\":[\"目的：标识此IP数据报发送节点和接收节点的IP地址及控制信息\",\"从传输层到达的数据段都需要经过IP协议进行重新封装的。\",\"因为IP协议是无连接的服务，并且采用数据报交换方式，所以封装后形成的是IP数据报。\"]},\"193\":{\"h\":\"③分段与重组\",\"t\":[\"作用：把那些被拆分的分段重新组合起来，还原成原来的大的数据报的问题\",\"因为不同网络上的链路可以传输的最大报文大小是不同的，这就是我们通常所说的MTU（最大传输单元）。\",\"为了使我们要传输的数据报能在不同网络中传输，当一些尺寸较大的数据报要在某个MTU值比较小的网络链路上传输时就可能需要对原来的数据报进行拆分，形成一个个小的分段，然后再把这些分段依次传输出去。\"]},\"194\":{\"h\":\"（2）IPV4数据报首部\",\"t\":[\"IP数据报 = IP首部 + 数据\",\"格式：每行4个字节，32位Bit，固定部分20字节，可变部分40字节\",\"IPV4数据报首部格式\"]},\"195\":{\"h\":\"2、ARP协议\"},\"196\":{\"h\":\"（1）主要功能\",\"t\":[\"ARP（Address Resolution Protocol，地址解析协议）是将IP地址解析为以太网MAC地址（或称物理地址）的协议。\",\"ARP协议 = ARP报文 + ARP映射表\",\"功能：完成主机或路由器IP地址到MAC地址的映射\",\"在局域网中，当主机或其他网络设备有数据要发送给另一个主机或设备时，它必须知道对方的IP地址（即网络层地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理网络发送，因此发送站还必须有接收站的MAC地址（即物理地址），所以需要一个从IP地址到物理地址的映射。\"]},\"197\":{\"h\":\"（2）ARP报文格式\",\"t\":[\"tip：ARP是一个独立的三层协议，所以ARP报文在向数据链路层传输时不需要经过IP协议的封装，而是直接生成自己的报文，然后再到数据链路层封装成帧\",\"ARP报文格式\"]},\"198\":{\"h\":\"（3）ARP映射表\",\"t\":[\"无论是主机，还是交换机都会有一个用来缓存同一网段设备IP地址和MAC地址的ARP映射表，用于数据帧的转发。\",\"动态ARP表项：由ARP协议通过ARP报文自动生成和维护\",\"静态ARP表项：通过手工配置（通过对应设备的IP地址与MAC地址绑定命令进行）和维护\",\"静态ARP表项又分为短静态ARP表项和长静态ARP表项，区别在于地址表项是否绑定了VLAN。\",\"流程：\",\"检查ARP高速缓存\",\"有对应表项则写入MAC帧\",\"没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组\",\"目的主机收到请求后就向源主机单播一个ARP响应分组\",\"源主机收到后将此映射写入ARP缓存（10-20min更新一次）\",\"ARP映射表工作流程\",\"若在不同网络上，主机A向主机B发送数据，则主机A要先使用ARP协议询问本网络网关地址，然后发数据给网关后，网关再在主机B所在网络询问主机B的地址，并发送数据。\"]},\"199\":{\"h\":\"3、ICMP协议及报文格式\"},\"200\":{\"h\":\"（1）主要功能\",\"t\":[\"ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是IPv4协议簇中的一个子协议，用于在IP主机、路由器之间传递控制消息。\",\"控制消息：指网络通不通、主机是否可达、路由是否可用等网络本身的消息。\",\"与ARP协议不同，ICMP依靠IP协议来完成其任务，所以ICMP报文中要封装IP头部。\",\"主要功能：\",\"在网际层使用，为了更有效地转发IP数据报和提高交付成功的机会，主要用于网络层的错误处理和状态通知\",\"主机或路由器使用ICMP来发送差错报告报文和询问报文（ICMP报文被封装在IP数据报中发送） \",\"用于分组网间探测PING \",\"用来测试主机或路由器间的连通性【eNSP的ping命令】\",\"应用层直接使用网际层的ICMP(没有通过运输层的TCP或UDP)\",\"使用ICMP回送请求和回答报文\",\"用于跟踪路由tracerouce：用来测试IP数据报从源主机到达目的主机要经过哪些路由器 \",\"Windows版本：tracert命令 \",\"应用层直接使用网际层ICMP，使用了ICMP回送请求和回答报文以及差错报告报文\",\"实现方法：由主机发送出去的数据包中的生存时间字段TTL由1开始逐渐增加，每个路由器都会返回一个时间超过报文，由此达到跟踪路由器的目的\",\"Unix版本：traceroute命令 \",\"在运输层使用UDP协议，仅使用ICMP差错报告报文\",\"不发送ICMP的情况：\",\"对ICMP差错报告报文不再发送ICMP差错报告报文\",\"对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文\",\"对具有多播地址的数据报都不发送ICMP差错报告报文\",\"对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文\"]},\"201\":{\"h\":\"（2）ICMP报文类型\",\"t\":[\"回答报文、询问报文\",\"回答报文（差错报文）类型：\",\"终点不可达：当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络位置、目的主机未知等13种错误\",\"源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报发送速率放慢\",\"时间超过：当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段值减1。若结果不为0，则将该IP数据报转发出去；若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文\",\"参数问题：当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文\",\"改变路由(重定向)：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)如主机1的默认路由是R1，信息经过R1时，R1发现最佳路由不是自己，而是R2，所以通过ICMP告知主机1\",\"询问报文类型：\",\"回送请求和回答：ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文，这种询问报文用来测试目的站是否可达及了解其有关状态\",\"时间戳请求和回答：ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间，在ICMP时间戳回答报文中有一个32比特的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒，这种询问报文用来进行时钟同步和测量时间\"]},\"202\":{\"h\":\"（3）ICMP报文格式\",\"t\":[\"组成格式/封装过程：\",\"ICMP报文组成过程\",\"详细报文首部：\",\"ICMP报文首部\"]},\"203\":{\"h\":\"三、路由算法和路由协议\",\"t\":[\"路由其实是一种网络层中进行数据报分组交换从而进行路径选择行为的功能。\"]},\"204\":{\"h\":\"1、路由算法分类\"},\"205\":{\"h\":\"（1）静态路由\",\"t\":[\"静态路由 - 非自适应路由算法，需要手动配置路由信息\",\"静态路由中包括目的节点或目的网络的IP地址，及数据包从当前路由器开始路由的第一个下一跳（通常就是网关）所对应的接口或IP地址。\",\"如果某条静态路由中间经过的跳数大于1（也就是整条路由路径经历了三个或以上路由器结点），则必须在除最后一个路由器外的其他路由器上依次配置到达相同目的节点或目的网络的静态路由 \",\"优点：简单可靠，开销小，适用于负荷稳定、拓扑变化不大的网络\",\"缺点：路由更新慢，不能及时适应网络状态的变化。一般只在小规模网络中采用，不适用于大网络,可能由于①配置错误 ②聚合了不存在的网络 ③网络故障 的问题而出现路由环路错误\",\"路由环路问题展示\",\"具体实现：\",\"1、静态路由 2、扩散法：当一个路由器接口收到一个报文分组后，即向它所有接口（包括接收该分组的源接口）进行复制扩散 3、随机走动法：当结点收到分组后，向所有与之相邻的结点中随机选择出一个将分组转发出去 4、最短路径法：将源节点到网络中所有结点的最短通路都找出来，作为这个结点的路由表。 5、基于流量的路由算法：结合了网络拓扑结构和通信流量两方面的因素进行路由选择\",\"路由环路解决：\",\"路由环路-IP数据报永久兜圈\",\"在IP数据报首部设置TTL字段 - 过期时间\",\"IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃\",\"对于聚合后或由于网络故障而不存在的路由条目设置黑洞路由\",\"所谓黑洞路由，即路由器应该丢弃的路由，下一跳位null0\",\"拓展：\",\"默认路由：指定了当路由表中没有适配的路由信息时，数据包应该发送到哪个特定的下一跳路由器或接口。\",\"0.0.0.0/0 是一个特殊的IP地址段，也称为默认路由或默认路由表项。\",\"它表示匹配所有可能的IP地址，也就是说，如果没有找到更具体的路由匹配某个目标地址，系统就会使用默认路由来指示数据包的下一跳。\",\"在IPv4网络中，0.0.0.0/0 通常用于指示数据包应该发送到默认的网关或者默认的下一跳路由器。这在大多数情况下意味着将数据包发送到连接网络的设备，让该设备决定如何处理这个数据包。\",\"默认路由在网络配置中非常重要，因为它允许网络管理员定义一个通用的路径，以便将未知目的地的数据包发送到一个已知的位置，而不必为每个可能的目的地配置具体的路由。\",\"需要注意的是，0.0.0.0/0 可能会在不同的上下文中具有不同的含义，比如在防火墙配置中，它可能表示所有的IP地址或所有网络，取决于具体的设置和规则。\",\"特定主机路由：指定了数据包应该被发送到目标网络中的一个特定主机。这种配置在需要直接连接到特定主机的情况下非常有用。\",\"具体主机IP/32。网络号前缀长度32保证了这是第一个被匹配的静态条目\"]},\"206\":{\"h\":\"（2）动态路由\",\"t\":[\"动态路由 - 自适应路由算法，路由器彼此交换信息，按照算法优化出路由表\",\"在网络中某条路由所包括的路由器同时启动了某种动态路由协议，通告了各自所直接连接的网络后，则这些路由器间就会自动生成这些路由器直接连接的网络间的路由表项，管理员无须一一手动创建，且这些路由表项会自动更新维护。\",\"优点：路由更新快、适用于大型网络，能及时响应链路变化和网络拓扑变化\",\"缺点：算法复杂，增加网络负担\",\"自适应路由算法分为两类：\",\"总体式路由算法：\",\"每个路由器都拥有网络中某个区域或者整个网络中所有其他路由器的全部信息以及网络的流量状态\",\"应用：链路状态路由算法（OSPF）、分级路由算法（ISIS协议）\",\"分散性：\",\"每个路由器只与直接相连的路由器交换路由信息，每个路由器只有相邻路由器的路由信息，而没有网络中的其他路由器的路由信息\",\"应用：距离向量算法（RIP）\"]},\"207\":{\"h\":\"2、RIP协议\",\"t\":[\"RIP协议 - Bellman-Ford路由算法和Ford-Fulkerson算法。主要在RIP（Route Information Protocol）协议中使用\"]},\"208\":{\"h\":\"（1）概述\",\"t\":[\"RIP概述：使用跳数作为度量来衡量到达目的网络的距离\",\"路由器到直连网络的距离定义为1\",\"路由器到非直连网络的距离定义为所经过的路由器数+1\",\"允许一条路径最多只能包含15个路由器。\\\"距离\\\"等于16时相当于不可达。因此，RIP只适用于小型互联网，端口为520\",\"RIP的基本思想如下：\",\"每个路由器维护一个距离矢量（通常是延时或跳数）表，然后通过相邻路由器之间的距离矢量通告进行距离矢量表的更新。\",\"每个距离矢量表项包括两部分（通信子网中的其他每个路由器在表中占据一个表项）： \",\"到达目的节点的最佳输出线路\",\"到达目的节点所需时间或距离\",\"每隔一段时间，路由器会向所有邻居结点发送它到每个目的节点的距离表，同时它也接收每个邻居结点发来的距离矢量表。这样以此类推，经过一段时间后便可将网络中各路由器所获得的距离矢量信息在各路由器上统一起来\",\"从本结点起，每经过一个路由器（也可以是提供路由功能的三层交换机，下同），就加一跳。也就是对应路由条目中除源站点所在网络直接连接的路由器外，到达目的站点所经过的路由器数.\",\"所有的路由会周期性交换信息，学习完全依靠邻居路由器，交换的是完整的路由表项。\",\"RIP的基本工作过程：\",\"路由器刚开始工作时，只知道自己到直连网络的距离为1。\",\"每个路由器仅和相邻路由器周期性地交换并更新路由信息。\",\"若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛。\",\"RIP的路由条目的更新规则：\",\"发现了新的网络，添加\",\"到达目的网络，相同下一跳，最新消息，更新\",\"到达目的网络，不同下一跳，新路由优势，更新\",\"到达目的网络，不同下一跳，新路由劣势，不更新\",\"到达目的网络，不同下一跳，等价负载均衡\"]},\"209\":{\"h\":\"（2）存在问题\",\"t\":[\"存在“坏消息传播得慢”的问题，又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。\",\"可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。 \",\"限制最大路径距离为15(16表示不可达)\",\"当路由表发生变化时就立即发送更新报文（即“触发更新”），而不仅是周期性发送\",\"让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“水平分割”）\"]},\"210\":{\"h\":\"3、OSPF协议\",\"t\":[\"OSPF协议 - 链路状态路由算法，它不仅是要根据所经过的路由器多少，还要根据路径中各段链路的状态来计算最佳路由路径。而这个链路状态包括：接口的IP地址、子网掩码、网络类型（如以太网链路或串行点对点链路）、该链路的端口开销（Cost）、该链路上的所有的相邻路由器。\",\"网络中的路由器并不向邻居路由器传递路由表项，只是向邻居路由器通告它的一些链路状态\",\"链路状态路由算法的基本思想是：\",\"网络中各个结点不必交换通往目的站点的距离，而是维护一张网络拓扑图，在网络拓扑结构发生变化时及时更新拓扑图即可。\",\"具体步骤如下：\",\"使用洪泛法向自治系统内所有路由器发送信息\",\"路由器通过输出端口向所有相邻的路由器发送信息\",\"每一个相邻路由器又再次将此信息发往其所有的相邻路由器\",\"发送的信息就是与本路由器相邻的所有路由器的链路状态\",\"本路由器和哪些路由器相邻\",\"该链路的度量/代价：费用、距离、延时、带宽等\",\"只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息\",\"OSPF分组分类：\",\"问候(Hello)分组：用来发现和维护邻居路由器的可达性\",\"数据库描述(Database Description)分组：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息\",\"链路状态请求信息(Link State Request)分组：向邻居路由器请求发送某些链路状态项目的详细信息\",\"链路状态更新(Link State Update)分组：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态\",\"链路状态确认(Link State Acknowledgement)分组：这是对链路状态更新分组的确认分组\",\"OSPF工作原理和工作流程：OSPF相邻路由器之间通过交互问候(Hello)分组，建立和维护邻居关系\",\"工作原理：\",\"Hello分组封装在IP数据报中，发往组播地址224.0.0.5\",\"发送周期为10秒\",\"40秒未收到来自邻居路由器的Hello`分组，则认为该邻居路由器不可达\",\"工作流程\",\"相邻路由器之间周期性发送问候分组(Hello)，以便建立和维护邻居关系\",\"建立邻居关系后，给邻居路由器发送数据库描述分组(DD)，也就是将自己链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器\",\"收到数据库描述分组后，若发现自己缺少其中某些链路状态项目，则会发送链路状态请求分组(LSR)。\",\"对方收到链路状态请求分组后，则会将其所缺少的链路状态项目的详细信息封装在链路状态更新分组(LSU)中发送回去\",\"收到链路状态更新分组后，将这些信息添加到自己的链路状态数据库中\",\"OSPF的链路状态通告LSA：\",\"使用OSPF的每个路由器都会产生链路状态通告LSA，包含以下内容 \",\"直连网络的链路状态信息\",\"邻居路由器的链路状态信息\",\"LSA被封装在链路状态更新分组LSU中，采用洪泛法发送\",\"使用OSPF的每个路由器都有一个链路状态数据库LSDB，用于存储LSA \",\"通过各路由器洪泛法发送封装有自己LSA的LSU分组，各路由器的LSDB最终达到一致\",\"使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各种到达其他各路由器的最短路径带权有向图，即构建各自的路由表。\"]},\"211\":{\"h\":\"4、ISIS协议\",\"t\":[\"ISIS协议 - 分级路由算法，在分级路由算法中，路由器被分成很多组，称为区域。每个路由器都只有自己所在区域路由器的信息，而没有其他区域路由器的信息。\",\"在其路由表中，路由器只需要存储其他每个区域的一条记录。\",\"在分级路由算法的思想下，出现了自治系统、内部网关协议、外部网关协议等概念\",\"ISIS协议分层展示\",\"自治系统AS：\",\"一个自治系统(AS)是一个有权自主地决定在本系统中应采用各种路由协议的小型单位。 \",\"这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元（例如一所大学，一个企业或者一个公司个体）。\",\"一个自治系统有时也被称为是一个路由选择域（routing domain）\",\"内部网关协议IGP：\",\"IGP间交换路由信息的协议。\",\"IGP协议包括RIP、OSPF、IS-IS、IGRP、EIGRP。\",\"外部网关协议：\",\"AS之间使用的路由协议，如BGP-4协议\"]},\"212\":{\"h\":\"5、BGP协议\",\"t\":[\"BGP协议 - 边界网关协议：\",\"在不同自治系统内，度量路由的代价可能不同。\",\"因此，对于自治系统之间的路由选择，使用\\\"代价\\\"作为度量来寻找最佳路由是不行的 \",\"比如A系统路由选择度量是距离，B系统是带宽……那么A到系统E的路由怎样走最好呢？由于没有统一度量，所以不能直接得到最佳路由\",\"自治系统之间的路由选择必须考虑相关策略(政治、经济、安全等)，如中国的数据报尽量要绕开美国的自治系统\",\"BGP工作原理：\",\"在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”\",\"不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接，端口号为179 \",\"在此TCP连接上交换BGP报文以建立BGP会话\",\"利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）\",\"使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站(neighbor)或对等站(peer)\",\"BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP,例如OSPF或RIP。\",\"BGP发言人交换网络可达性的信息(要到达某个网络所要经过的一系列自治系统)\",\"当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。也就是构造出树形结构(防环路)的自治系统连通图\",\"BGP-4的4中报文：\",\"OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化\",\"UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由\",\"KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性\",\"NOTIFICATION(通知)报文：用来发送检测到的差错\"]},\"213\":{\"h\":\"四、IPV4地址\"},\"214\":{\"h\":\"1、概述\"},\"215\":{\"h\":\"（1）IPV4地址介绍\",\"t\":[\"IPv4地址是是什么：\",\"IPv4地址是一个32比特的标识符，用于给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的标识符\",\"32比特的IPV4地址不方便阅读、记录以及输入等，因此IPV4地址采用点分十进制表示方法以方便用户使用。\",\"IPv4 32位地址：11000000.10101000.00000000.00000001 ，点分十进制表示192.168.0.1\",\"每一组由点分隔的十进制数对应了四组8位的二进制数。\",\"IP地址由因特网名字和数字分配机构ICANN（Internet Corporation for Assigned Names and Numbers）进行分配。\",\"IPv4地址编址方法：\",\"IPv4地址编址经历了三个主要历史阶段：分类编址、划分子网、无分类编址。\"]},\"216\":{\"h\":\"（2）子网掩码介绍\",\"t\":[\"我们在为设备配置IP地址时，通常是不能仅配置IPv4地址，而必须同时配置所谓的子网掩码。\",\"为什么要有子网掩码（它的作用是什么）：\",\"IPv4地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络ID和主机ID两部分，以便于IPv4地址的寻址操作。\",\"子网掩码：\",\"由1和0组成，且长度也是32位，我们也可以把它分成网络ID和主机ID两部分，且各自的长度与IPv4地址的网络ID和主机ID部分对应相等。\",\"子网掩码中的 \",\"网络ID部分全是1表示，1的数目等于网络ID的长度；\",\"主机ID部分全是0表示，0的数目等于主机ID的长度。\",\"这样做的目的是为了在寻址过程中使子网掩码与对应的IPv4地址做逻辑与运算时用0遮住IPv4地址中原主机ID部分，而不改变原网络ID部分，这样就一来就得到了目的IPv4地址的网络ID，从而确定目的主机所在的网络.\"]},\"217\":{\"h\":\"2、分类编址的IPV4\",\"t\":[\"IPv4的分类编址主要分为五类：A、B、C、D、E。每个类别都有不同的地址范围和可用主机数量。\",\"分类编址的IPV4\",\"详细表格：\",\"网络类别\",\"最大网络数\",\"第一个可用的网络\",\"最后一个可用网络\",\"每个网络中最大主机数\",\"A\",\"126（2^7 - 2）\",\"1\",\"126\",\"16,777,214\",\"B\",\"16,383（2^14 - 1）\",\"128.1\",\"191.255\",\"65,534\",\"C\",\"2,097,151（2^21 - 1）\",\"192.0.1\",\"233.255.255\",\"254\",\"D\",\"E\",\"私网IP地址：不能直接用私网ip地址访问\",\"在设计IPv4地址时就专门在前面介绍的A、B、C这类IPv4地址中各自划分了一段专用于各组织局域网内部的地址段，这就是我们前面所说的私网IP地址（又称局域网专用IP地址或者专用网络地址）。\",\"私网IPv4地址在不同公司内部的局域网中是可以重复使用的，且无须向IP地址管理机构申请、注册和购买的。在A、B、C类地址中各自划分的局域网专用地址段如下:\",\"（1）10.0.0.0/8（10.0.0.0，255.0.0.0） （2）172.16.0.0/12（172.16.0.0，255.240.0.0） （3）192.168.0.0/16（192.168.0.0，255.255.0.0） \"]},\"218\":{\"h\":\"3、划分子网IPV4\",\"t\":[\"引出：当你为新增网络申请新的网络号时，会带来以下弊端：\",\"需要等待时间和花费更多的费用。\",\"会增加其他路由器中路由表记录的数量。\",\"浪费原有网络号中剩余的大量IPv4地址。\",\"解决办法：\",\"可以从主机号部分借用一部分比特作为子网号。\",\"32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号。\",\"正确的选项是：\",\"子网掩码使用连续的比特1来对应网络号和子网号。\",\"将划分子网的IPv4地址与其相应的子网掩码，进行逻辑与运算就可得到IPv4地址所在子网的网络地址。\",\"默认的子网掩码是：\",\"A类：255.0.0.0、 B类：255.255.0.0、C类：255.255.255.0\",\"例题\",\"某主机的1P地址为180.80.77.55，子网掩码为255.255.252.0，如该主机向其所在子网发送广播分组，则目的地址可以是\",\"A.180.80.76.0\",\"B.180.80.76.255\",\"C.180.80.77.255\",\"D.180.80.79.255\",\"由IP地址网络号可知，这是B类网络，子网掩码255.255.252.0，为11111111.11111111.11111100.00000000，子网掩码后两位表示借用的比特位-6位：\",\"划分出的子网数量有：2^6个，\",\"每个子网可分配的地址数量：2^(16-6)个\",\"主机所在子网的网络地址为：180.80.01001100.00000000 - 180.80.01001111.11111111，点分十进制标识180.80.76.0 ~ 180.79.255\"]},\"219\":{\"h\":\"4、无分类编址IPV4\"},\"220\":{\"h\":\"4.1 概述\",\"t\":[\"CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念\",\"CIDR可以更加有效地分配IPv4地址空间\",\"CIDR使用\\\"斜线记法\\\"，或称CIDR记法。即在IPv4地址后面加上斜线\\\"/\\\"，在斜线后面写上网络前缀所占比特数量，网络主机号位32 - 斜线后面的数字\",\"例题\",\"请给出C1DR地址块128.14.35.7/20的全部细节（最小地址，最大地址，地址数量，聚合C类网数量，地址掩码)。\",\"斜线后面为20：网络号20位，主机号12位：\",\"128.14.35.7/20 —> 128.14.00100011.00000111\",\"最小地址-主机号全为0：128.14.00100000.00000000 = 点分十进制表示：128.14.32.0\",\"最大地址-主机号全为1：128.14.00101111.11111111 = 点分十进制表示：128.14.47.255\",\"地址数量：2^(32-20)\",\"聚合c类网的数量：2^(32-20) / 2 ^8\",\"地址掩码 - 网络位全1，主机全0：11111111.11110000.00000000 = 点分十进制表示：255.255.240.0\"]},\"221\":{\"h\":\"4.3 路由聚合\",\"t\":[\"路由聚合（构造超网）是网络设计中的一个重要概念，它有助于减少路由表的大小，提高路由器的性能。以下是一个例子：\",\"目的网络 下一跳 共同前缀 172.1.4.0/25 R1 172.1.00000100.0 172.1.4.128/25 R1 172.1.00000100.128 172.1.5.0/24 R1 172.1.00000101.0 172.1.6.0/24 R1 172.1.00000110.0 172.1.7.0/24 R1 172.1.00000111.0 \",\"在这个例子中，我们有五个目的网络，每个网络都有一个下一跳和共同前缀。\",\"为了减少路由表的大小，可以将具有相同共同前缀的路由进行聚合。\",\"例如，他们的前缀前两个字节和第三个字节的前6位相同，共22位。\",\"如：172.1.4.0/25和172.1.4.128/25共享相同的前缀172.1.00000100，不同的补0\",\"因此可以聚合成的聚合地址块172.1.4.0/22。\",\"网络前缀越长，地址块越小，路由越具体。\",\"最长前缀匹配：若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条， 因为这样的路由更具体。\"]},\"222\":{\"h\":\"5、IPV4应用规划\",\"t\":[\"IP地址的应用规划是指在一个网络环境中，如何合理地分配和管理IP地址以满足网络通信的需求。以下是IP地址的应用规划涉及的一些重要方面：\",\"子网划分：将一个大的IP地址范围分割成多个小的子网，以适应不同部门或网络区域的需求。每个子网都有自己的网络地址和广播地址。 \",\"定长子网掩码-FLSM： \",\"在FLSM中，每个子网使用相同长度的子网掩码。这意味着所有子网中可以容纳的主机数量是相同的，FLSM常用于早期的网络设计，它简单直观，但可能会造成IP地址的浪费。。\",\"例如，如果使用/24的子网掩码，每个子网将包含2^8 (256) 个IP地址，其中包括一个网络地址和一个广播地址，因此可用的主机IP数量是254个。\",\"变长子网掩码-VLSM： \",\"VLSM允许在同一个网络中使用不同长度的子网掩码。这样可以根据各个子网的实际需求，分配不同大小的IP地址块，VLSM是现代网络设计的常用方法，特别是在复杂网络环境中，可以根据具体需求分配不同大小的子网。。\",\"举例来说，如果某个子网需要容纳更多主机，可以分配一个较小的子网掩码（例如，/26）。而对于另一个只需要较少主机的子网，可以分配一个较大的子网掩码（例如，/28）。\",\"VLSM可以高效地利用IP地址空间，减少了浪费。\",\"IP地址分配：确定每个子网中可用的IP地址范围，并将这些地址分配给主机、设备或服务器。这确保了每个设备都有一个唯一的IP地址。\",\"保留地址：确定哪些地址用于特定目的，比如网络地址、广播地址和保留地址（如回环地址等）。\"]},\"223\":{\"h\":\"五、VPN和NAT\",\"t\":[\"VPN虚拟专用网：是一种通过公共因特网创建安全连接的技术。在这种网络中，各个主机使用本机构内部可自由分配的专用地址进行通信，而这些地址在公共因特网上是不可见的。\",\"内联网VPN（Intranet VPN）： 用于连接企业内部的分支机构、办公室或远程员工。内联网VPN通常用于建立企业内部的安全通信网络。\",\"外联网VPN（Extranet VPN）： 用于连接不同组织之间的网络，比如合作伙伴、供应商或客户。外联网VPN允许不同组织之间安全地共享资源和信息。\",\"远程接入VPN（Remote Access VPN）： 允许个人用户或远程办公者通过公共网络（如互联网）连接到企业网络，以便访问内部资源。\",\"NAT网络地址转换：用于在私有网络和公共网络之间进行通信。它的主要目的是将内部私有网络中的多个主机共享一个公共IP地址，以节约公共IP地址的使用。\",\"私有IP地址和公共IP地址： NAT允许内部网络使用私有IP地址（如在RFC1918标准中定义的10.0.0.0/8、172.16.0.0/12和192.168.0.0/16）进行通信，而将公共IP地址留给NAT设备用于与公共网络通信。\",\"地址转换： 当内部主机发送数据包到公共网络时，NAT设备将内部主机的私有IP地址和端口号转换为NAT设备的公共IP地址和一个唯一的端口号，以便在公共网络中唯一标识这个连接。\",\"解决IPv4地址枯竭问题： NAT允许在IPv4地址有限的情况下，通过在内部网络中使用私有IP地址来连接到公共网络，从而节约公共IP地址的使用。\",\"由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。\",\"这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫作网络地址与端口号转换NAPT。\",\"但是NAT构建的局域网不能充当服务器。\"]},\"224\":{\"c\":[\"计算机基础\"]},\"225\":{\"c\":[\"计算机网络\"]},\"226\":{\"h\":\"物理层\",\"t\":[\"物理层是计算机网络体系结构中的底层层级，位于网络模型的最底部，它并非指具体的硬件设备，而是涉及数据传输的实际介质和信号传输的方式，是由实物所承载的。\"]},\"227\":{\"h\":\"一、简介\",\"t\":[\"物理层：\",\"物理层是计算机网络体系结构中的底层层级，位于网络模型的最底部。\",\"物理层并非指具体的硬件设备，而是涉及数据传输的实际介质和信号传输的方式，是由实物所承载的，所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，就是物理层的象征。它包括以下几个方面 \",\"传输介质：涉及传输数据所使用的介质，例如铜线、光纤、无线电波等。\",\"数据传输方式：包括串行传输（一位接一位地传输）和并行传输（多位同时传输）等不同的数据传输方式。\",\"数据编码：将数字数据转换成模拟信号或数字信号的过程，以便在传输介质上传输。这包括将数字信号转换成适合在传输媒介上传输的模拟信号或数字信号的过程。\",\"数据传输速率：确定数据传输的速率和时序，例如比特率（数据传输速率）和带宽（传输媒体的能力）等。\",\"总结：考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。\",\"物理层的特点/特性：\",\"机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置\",\"电气特性：指明在接口电缆的各条线上出现的电压范围\",\"功能特性：指明某条线上出现的某一电平的电压表示何种意义\",\"过程特性：指明对于不同功能的各种可能事件的出现顺序\",\"四大特性包括了物理层相关内容的规范和定义，确保数据能够在物理层上以正确的方式进行传输\"]},\"228\":{\"h\":\"二、基本任务\"},\"229\":{\"h\":\"1、任务\",\"t\":[\"根据物理层在体系结构中的功能，划分为具体的任务如下：\",\"比特传输：通过连接传输媒体在不同计算机上传输数据比特流(传送0和1)，进行双方的通信\",\"数据编码和解码： \",\"将数字数据转换成模拟信号或数字信号的过程，以便在传输介质上传输。\",\"接收端对传输过来的信号进行解码，还原成数字数据。\",\"传输介质管理：管理和利用各种传输介质，包括铜线、光纤、无线电波等，确保数据能够在介质中有效传输。\",\"信号的传输方式管理：管理不同的信号传输方式，例如串行传输和并行传输，以及调制技术的选择和应用。\",\"传输速率控制：确定和控制数据传输的速率，包括比特率和带宽，以满足通信双方的需求和传输介质的限制。\",\"物理层标准与协议：制定和遵循物理层标准和协议，确保不同设备之间的互操作性和兼容性，例如以太网、Wi-Fi等。\"]},\"230\":{\"h\":\"2、传输媒体\",\"t\":[\"物理层的传输媒体/介质分为导引型和非导引型传输媒体。\",\"具体图例：\",\"导引型传输媒体：有摸得到的实物进行传导信号的方式\",\"同轴电缆：电缆各层都是同轴心的，因此称同轴电缆 -（同轴电缆价格较贵且布线不够灵活和方便） \",\"基带同轴电缆(50Ω )：数字传输，过去用于局域网\",\"宽带同轴电缆(75Ω)：模拟传输，目前主要用于有线电视\",\"双绞线电缆：把两根互相绝缘的铜导线并排放在一起，然后按照一定规则绞合起来就构成了双绞线，这是一种古老且常用的传输媒体 \",\"无屏蔽双绞线UTP电缆：①抵御部分来自外界的电磁波干扰 ②减少相邻导线的电磁干扰\",\"屏蔽双绞线STP电缆，其与UTP相比增加了金属丝编织的屏蔽层，提高了抗电磁干扰能力\",\"光纤/光缆：通过光的反射进行传播，光纤很细，因此必须将其做成结实的光缆。一根光缆少则一根光纤，多则可包括数百根\",\"非导引型传输媒体：传导信号的东西摸不到\",\"无线电波：低频和中频频段用地面波传播；高频和甚高频靠电离层(地球上方100~500千米高空的带电离子层)反射\",\"微波：微波会穿透电离层进入宇宙，因此其不能通过电离层反射到很远的地方 \",\"地面微波接力通信：微波是直线传播的，而地球表面是个曲面，因此传播距离受到限制，一般只有50KM左右；如果采用100米高的天线塔，则传播距离可增大到100公里。 为实现远距离通信，必须在一个微波通信信道的两个终端之间建立若干个中继站，中继站把前一阵送来的信号经过放大后再发送到下一站\",\"红外线：点对点无线传输、直线传播，中间不能有障碍物，传输距离短、传输速率低(4Mb/s~16Mb/s)\",\"可见光：即光源作为信号源，前景好，暂时未被大范围应用\"]},\"231\":{\"h\":\"3、传输方式\"},\"232\":{\"h\":\"（1）串行传输\",\"t\":[\"是指数据是1个比特1个比特依次发送\",\"发送端与接收端之间只用1条数据传输线即可（数据在传输线路上是串行传输）。\",\"如下图：每次发送一个bit，每个bit依次发送\",\"串行传输\"]},\"233\":{\"h\":\"（2）并行传输\",\"t\":[\"是指一次发送n个比特而不是一个比特\",\"在发送端和接收端之间要有n条传输线路（一般使用在计算机内部【如CPU和内存】数据传输方式是并行传输）。\",\"如下图：每次发送一个/n个字符，及每次发送n个比特\",\"并行传输\"]},\"234\":{\"h\":\"4、传输模式\",\"t\":[\"串行传输存在的问题：\",\"串行传输接收端存在一个字符同步的问题：如何从串行数据比特流中正确地划分出发送的一个个字符。\",\"因为网络设备间大多数使用的是串行传输方式，所以在串行数据通信中数据的同步问题非常重要。\",\"发送端一位一位地把信息通过介质发往接收端，接收端必须识别信息的开始和结束，而且必须知道每一位的持续时间，只有这样，接收端才能从传输线路上正确地取出被传送的数据。\",\"根据实现字符同步的方式不同：同步传输、异步传输\"]},\"235\":{\"h\":\"（1）异步传输\",\"t\":[\"异步传输：是指数据的传输不需要发送端和接收端之间保持严格的时钟同步\",\"通信双方没有相同的时钟参考（也就是发送端和接收端不同时开始工作），但双方在数据传输速率上是同步的。即指每个字符之间是异步的，但一个字符内的每一位还是同步的。 \",\"异步传输以字符为独立的传输单位，字节间的时间间隔不是固定的。\",\"每个数据帧（每次传输的内容）都包含了足够的控制信息来确定数据的起始和结束\",\"在发送每一字符代码的前面均加上一个“起始位”信号，用以标记一个字符的开始；\",\"在一个字符代码的最后加上一个“停止位”信号，用以标记一个字符的结束。\"]},\"236\":{\"h\":\"（2）同步传输\",\"t\":[\"同步传输：同步传输是指数据的传输是在发送端和接收端之间保持时钟同步的情况下进行的。\",\"通信双方 - 发送端和接收端通过共享一个时钟信号来保持同步。\",\"数据块以稳定的比特流形式传输，字节之间没有间隔。\",\"接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是1。\",\"为保持同步，需要采取方法使双方的时钟保持同步，可以采取外同步或内同步的方式。、 \",\"外同步：在收发双方之间加一条单独的时钟信号线\",\"内同步：发送端将时钟同步信号编码到发送数据中一起传输(如曼彻斯特编码)\"]},\"237\":{\"h\":\"5、数据通信方式\",\"t\":[\"单工/半双工/全双工：\",\"单工通信：通信双方只有一个数据传输方向(无线电广播)\",\"半双工通信：通信双方可以相互传输数据，但不能同时进行(对讲机)\",\"全双工通信：通信双方可以同时发送和接收消息(电话)单工需要一条信道；其他的需要两条(一个方向一条)\",\"数据通信方式\"]},\"238\":{\"h\":\"6、编码\",\"t\":[\"什么是编码：\",\"编码是将数字信号转换为另一种形式，以便在物理介质上传输。它通常是将数字比特序列转换为模拟信号或另一种数字信号，以适应特定的传输介质。 \",\"消息：包括文字、图片、音频和视频\",\"数据：是运送消息的实体，计算机中的网卡将比特1和0变换成相应电信号发送到网线，即信号。\",\"信号：是数据的电磁表现，由信源(网卡)发出的原始电信号称为基带信号，信号通过信道传输 \",\"数字基带信号：CPU和内存传输的信号\",\"模拟基带信号：麦克风收到声音后转变的电信号 \",\"码元：构成信号的一种波形\",\"总结：物理层传输的比特流0/1，但是实际传输还是通过信号传输，信号可以为电/光，编码则是进行转换，将数据通过这种方式的编码转换为0/1.\",\"编码方式：不归零编码、归零编码、曼彻斯特编码、差分曼彻斯特编码\",\"不归零编码：正电平代表比特1，负电平代表比特0。在整个码元时间内，电平不会出现零电平。 \",\"问题：这种编码方式如何区分连续几个相同电平呢？ \",\"通过发送方发送和接收方接收严格同步，并使用额外一根传输线来传输时钟信号，进行同步。\",\"归零编码：每个码元传输结束后信号都要\\\"归零\\\"，所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。 \",\"问题：归零编码把时钟信号用\\\"归零\\\"方式编码在了数据之内，这称为\\\"自同步\\\"信号 \",\"归零编码中的大部分数据带宽都用来传输\\\"归零\\\"而浪费掉了(编码效率低)\",\"曼彻斯特编码：码元的中间时刻既表示时钟，又表示数据。根据正负跳变来区分比特 \",\"问题：具体如何根据跳变实现同步？ \",\"第一次数据跳变的时间记录下来【即半个码元的时间】，此后每过一个码元的时间就进行检测，根据跳变方向决定数据为0还是1。\",\"差分曼彻斯特编码：跳变仅表示时钟 、码元开始处电平是否发生变化表示数据，以两码元的临界点区分是否发生变化。 \",\"比曼彻斯特变化少，更适合较高的传输速率\"]},\"239\":{\"h\":\"7、调制\",\"t\":[\"什么是调制：\",\"如果需要将信号在模拟信道传输，则需要使用调制\",\"调制：是指将数字信号转换为模拟信号，以便在传输介质上传输。调制涉及改变信号的某些特性（如频率、相位或幅度）以适应特定的传输介质 \",\"基本调制：一个码元对应一个比特，调幅（AM）、调频（FM）、调相（PM）\",\"混合调制：一个码元对应多个比特，QAM-16（可以调制出16种码元(波形)）\",\"编码和调制区别：\",\"在电话通信中，涉及到了编码和调制两个过程。\",\"编码：\",\"当你说话时，声音被转换成模拟的声波信号。这是一个模拟信号，表示了声音的波形。\",\"调制：\",\"模拟信号需要在电话线路或无线传输中传递。电话系统会将模拟信号转化为适合在电缆、光纤或空气中传输的信号，这就是调制的过程。通常，电话系统会使用调频调制（FM）或者其他调制技术将模拟信号转化为适合传输的信号。\",\"传输：\",\"经过调制后的信号被发送到电话线路或者无线信道中。\",\"解调：\",\"在接收端，接收到的信号需要被解调回原始的模拟信号。这是电话系统中的解调器（Modem）所做的工作。\",\"解码：\",\"解调后的信号被转换回原始的声音信号。\",\"这样，双方之间的通话就能实现，你们可以听到对方的声音。整个过程中，编码将声音转换成模拟信号，调制使其适合传输，解调和解码则将其还原成可听的声音。\"]},\"240\":{\"h\":\"三、拓展\",\"t\":[\"信号的极限容量：计算信道传输的速率（极限、实际）\",\"影响因素：码元传输速率（频率带宽）、信号传输距离、噪声干扰、传输媒体质量\",\"奈式准则和香农公式：\",\"混合调制：码元和比特的关系\",\"每个码元可携带的比特数量(波特率)= log2​(码元数量)\",\"不管采用何种调制技术，对于解题，我们只关心可以调制出不同基本波形（码元）的数量，设为X；则每个码元可携带的比特数量为log2X;\",\"数据传输速率= 码元传输速率 * 每个码元可携带的比特数量\",\"数据传输速率=码元传输速率*1og2​X\",\"奈式准则：\",\"理想低通道的最高码元传输速率 = 2W Baud = 2W（码元/秒）\",\"理想带通道的最高码元传输速率 = W Baud = W（码元/秒）\",\"香农公式：\",\"c=W∗log2​(1+S/N)\",\"信噪比=10∗log10​(S/N)\",\"tip1：带通和低通\",\"在通信领域中，术语“理想带通信道”和“理想低通信道”中的“带通”和“低通”是关于信号频谱特性的描述。\",\"理想带通信道（Ideal Bandpass Channel）：\",\"带通（Bandpass）：这里的“带通”指的是通道只允许通过一定范围内的频率成分。换句话说，它只允许特定的频率范围通过，而剔除其他频率。\",\"理想带通信道是一个理想化的信道，它只允许特定的频率范围内的信号通过，并且不会引入干扰或失真。这种信道在频域上可以看作一个频率响应在一定范围内是非零的理想信道。\",\"应用：理想带通信道常用于模拟通信系统中，例如调制解调器通信系统。\",\"理想低通信道（Ideal Lowpass Channel）：\",\"低通（Lowpass）：这里的“低通”指的是通道允许低频成分通过，而剔除高频成分。\",\"理想低通信道是一个理想化的信道，它只允许低频信号通过，并在一定频率以上剔除所有的信号成分。\",\"应用：理想低通信道常用于数字通信系统中，例如数字传输系统和数据通信中。\",\"总的来说，带通和低通描述了信道允许通过的频率范围。理想带通信道只允许特定频率范围内的信号通过，而理想低通信道只允许低频信号通过。这两种理想信道在实际应用中很难实现，但它们提供了通信系统设计和理论分析的重要基础。\",\"tip2：常见物理层设备\",\"集线器（Hub）：用于将多个计算机连接到局域网上。\",\"网卡（Network Interface Card）：将计算机与网络物理连接起来。\",\"中继器（Repeater）：用于加强信号的传输距离。\",\"调制解调器（Modem）：将数字信号转化为模拟信号，方便在电话线上传输。\",\"光纤收发器（Optical Transceiver）：用于光纤的信号收发。\",\"传输介质： \",\"物理层还涉及各种传输介质，包括电缆、光纤、无线电波等。这些介质是用来传输信号的通道，不同的介质具有不同的特性和传输速度\"]},\"241\":{\"c\":[\"计算机基础\"]},\"242\":{\"c\":[\"计算机网络\"]},\"243\":{\"h\":\"前置知识\",\"t\":[\"计网前置知识扫盲\",\"计算机网络模型镇楼\",\"图例-计算机网络模型\"]},\"244\":{\"h\":\"一、名词解析\"},\"245\":{\"h\":\"1、各种网络\",\"t\":[\"图例-各种网络\"]},\"246\":{\"h\":\"（1）网络\",\"t\":[\"什么是网络：\",\"网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成\"]},\"247\":{\"h\":\"（2）互联网\",\"t\":[\"多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网（互连网）。\",\"因此，互联网是网络的网络（Network of Networks）\"]},\"248\":{\"h\":\"（3）因特网\",\"t\":[\"因特网（Internet）是世界上最大的互连网络【小写i的internet是通用名词，互连的网络都叫internet】\"]},\"249\":{\"h\":\"2、ISP\",\"t\":[\"ISP:\",\"ISP(Internet Service Provider)即因特网服务的提供者\",\"ISP的作用：\",\"普通用户通过ISP接入因特网。\",\"ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等连网设备，任何机构和个人只要向ISP交纳规定的费用，就可以从ISP得到所需要的IP地址。互联网上的主机都必须有IP地址才能通信\",\"如：中国移动、中国电信\",\"图例-ISP\"]},\"250\":{\"h\":\"3、实体和协议\",\"t\":[\"实体和对等实体：\",\"实体：任何可发送或接收信息的硬件或软件进程\",\"对等实体：收发双方相同层次中的实体\",\"图例-实体和对等实体\",\"协议：控制两个对等实体进行逻辑通信的规则的集合\",\"协议三要素：\",\"语法：定义所交换信息的格式\",\"语义：定义收发双方所要完成的操作\",\"同步：定义收发双发的时序关系\",\"图例-协议\"]},\"251\":{\"h\":\"3、服务\",\"t\":[\"详细图例：\",\"详细图例-服务\",\"服务\",\"在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。\",\"协议是 \\\"水平的\\\"，服务是 \\\"垂直的\\\"。\",\"实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是\\\"透明\\\"的。\",\"服务访问点\",\"在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。\",\"数据链路层的服务访问点为帧的 \\\"类型\\\" 字段。\",\"网络层的服务访问点为P数据报首部中的 \\\"协议字段\\\"。\",\"运输层的服务访问点为 \\\"端口号\\\"。\",\"服务原语\",\"上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。\",\"协议数据单元\",\"对等层次之间传送的数据包称为该层的协议数据单元。\",\"服务数据单元\",\"同一系统内，层与层之间交换的数据包称为服务数据单元。\"]},\"252\":{\"h\":\"二、数据交换方式\",\"t\":[\"图例-三种交换方式\"]},\"253\":{\"h\":\"1、电路交换\",\"t\":[\"电路交换怎么出现的？\",\"电话交换机接通电话线的方式称为电路交换\",\"从通信资源分配角度来看，交换(Switch)就是按照某种方式动态地分配传输线路的资源\",\"电路交换三个步骤：\",\"建立连接：例如在使用电路交换打电话前，必须先拨号请求建立连接，当被叫用户听到电话交换机送来的拨号音并拿起电话后，从主叫端到被叫端就建立了一条连接，也就是一条专用的物理通路。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信中不会被其他用户占用（分配通信资源）\",\"通话：分配的资源始终被占用（一直占用通信资源）\",\"释放连接：归还通信资源\",\"图例-电路交换\",\"优点和缺点：\",\"优点 \",\"通信时延小：通信线路为通信双方专用的，数据直达\",\"有序传输：通信双方只有一条专用通信线路，数据只在这一线路上传输，不存在失序问题\",\"没有冲突，控制简单：不同的通信双方拥有不同的信道，不会出现争用物理通道的问题\",\"适用范围广：适用于传输模拟信号，也适用于传输数字信号\",\"实时性强：时延小所以实时性强\",\"缺点 \",\"建立连接时间长\",\"线路独占，适用效率低\",\"灵活性差：只要连接所建立的物理通路中的任何一点出现了故障，就必须重新拨号建立新的连接\",\"难以规格化：不同类型、不同规格、不同速率的终端很难互相进行通信，也难以差错控制\"]},\"254\":{\"h\":\"2、分组交换\",\"t\":[\"分组交换组成和流程：\",\"发送方：①构建分组 ②发送分组\",\"路由器：①缓存分组 ②转发分组\",\"接收方：①接收分组 ②还原报文\",\"图例-分组交换\",\"优点和缺点：\",\"优点 \",\"无需建立连接 线路利用率高 简化存储管理：因为分组大小固定，管理起来就容易一些 加速传输：因为分组是逐个传输，这样前一个交换机的转发操作与后一个交换机的存储操作可同时进行 减少出错率和重复数据量：分组比报文小，因此出错概率也会比较小，即使出错也只需要重传出错的这一小部分即可\",\"缺点： \",\"引起了转发时延\",\"需要传输额外信息量(分组头部信息)\",\"当分组交换采用数据报服务时，可能会出现失序、丢失、重复分组。分组到达目的结点时，需要重新还原成原始报文，比较麻烦。\",\"若分组交换采用虚电路服务，虽然没有分组失序问题，但有呼叫建立，数据传输和虚电路释放三个过程\"]},\"255\":{\"h\":\"3、报文交换\",\"t\":[\"报文交换与分组交换类似，不过对报文没有限制大小，现如今多使用分组交换。\",\"优点和缺点：\",\"优点 \",\"无需建立连接\",\"动态分配线路\",\"提高线路可靠性：如果某条线路出现故障，会重新选择另一条线路\",\"提高线路利用率：通信双方在不同的时间分段占用物理线路\",\"提供多目标服务：一个报文可以同时发送给多个目的地址\",\"缺点 \",\"引起转发时延：报文在节点交换机上要经历存储转发的过程\",\"需要较大的存储转发空间：因为报文大小没有限制\",\"需要传输额外信息量：有头部等信息\"]},\"256\":{\"h\":\"三、计算机网络\"},\"257\":{\"h\":\"1、定义\",\"t\":[\"计算机网络的最简单的定义是：一些互相连接的、自治的计算机的集合。\",\"互连：是指计算机之间可以通过有线或无线的方式进行数据通信；\",\"自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；\",\"集合：是指至少需要两台计算机；\",\"白话 - 计算机网络的较好的定义是：\",\"计算机网络主要是由一些通用的，可编程的硬件（一定包含有中央处理机CPU）互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。\",\"计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。\",\"计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）\",\"自己的定义：\",\"计算机网络是指通过通信设备和通信线路，将分布在不同地理位置的计算机、外围设备及用户连接起来，以实现数据和信息的共享、传输和处理的一种技术体系。\",\"计算机网络是由多个计算机、服务器、网络设备和通信协议组成的互联网，它们通过网络传输协议来实现数据交换和通信。\"]},\"258\":{\"h\":\"2、分类\",\"t\":[\"计算机网络的分类：\"]},\"259\":{\"h\":\"3、性能指标\"},\"260\":{\"h\":\"（1）速率\",\"t\":[\"比特：\",\"计算机中数据量的单位，也是信息论中信息量的单位。一个比特就是二进制数字中的一个1或0。\",\"#常用数据量单位 8 bit = 1 Byte 1KB = 1024Byte = 2^10Byte 1MB = 2048Byte = 2^20Byte 1GB = 4096Byte = 2^30Byte 1TB = 8192Byte = 2^40Byte \",\"速率：\",\"速率是指连接在计算机网络上的主机在数字信道上传送比特的速率，也称为比特率或数据率。\",\"#常用数据率单位 bit/s (b/s,bps) 1kb/s = 10^3 b/s 1Mb/s = 10^6 b/s 1Gb/s = 10^9 b/s 1Tb/s = 10^12 b/s \",\"例题：\",\"例：有一个待发送的数据块，大小为100MB,网卡的发送速率为100MbPs,则网卡发送完该数据块需要多长时间？ t=100Mbps/100MB = 100 * 2^20 * 8 bit / (100*10^6 bit/s) = 2^20 * 8 bit / 10^6 bit/s = 8.388608s \"]},\"261\":{\"h\":\"（2）带宽\",\"t\":[\"一条通信线路的 \\\"频带宽度\\\" 越宽，其所传输数据的 \\\"最高数据率\\\" 也越高。\",\"带宽在摸拟信号系统中的意义：\",\"信号所包含的各种不同频率成分所占据的频率范围;\",\"单位：Hz (kHz，MHz，GHz)\",\"带宽在计算机网络中的意义\",\"用来表示网络的通信线路所能传送数据的能力\",\"网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的 \\\"最高数据率\\\"；\",\"单位：b/s (kb/s，Mb/s，Gb/s，Tb/s)\"]},\"262\":{\"h\":\"（3）吞吐量\",\"t\":[\"吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。\",\"吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。\",\"吞吐量受网络的带宽或额定速率的限制。\",\"图例-吞吐量\",\"带宽1 Gb/s的以太网，代表其额定速率是1 Gb/s，这个数值也是该以太网的吞吐量的绝对上限值。因此，对于带宽1 Gb/s的以太网，可能实际吞吐量只有 700 Mb/s，甚至更低。\",\"注意：吞吐量还可以用每秒传送的字节数或帧数表示。\"]},\"263\":{\"h\":\"（4）时延\",\"t\":[\"时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。\",\"网络时延由几部分组成：\",\"发送时延：主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。\",\"传播时延：电磁波在信道中传播一定的距离需要花费的时间。\",\"处理时延：主机或路由器在收到分组时要花费一定时间进行处理。\",\"排队时延：分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理，有时会把排队时延看成处理时延一部分。\",\"总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）\",\"图例-时延\"]},\"264\":{\"h\":\"（5）时延带宽积\",\"t\":[\"时延带宽积 = 传播时延 X 带宽 \",\"图例-时延带宽积\",\"若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特；\",\"链路的时延带宽积又称为以北比特为单位的链路长度。\"]},\"265\":{\"h\":\"（6）往返时间\",\"t\":[\"互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间(RTT)。\",\"图例-往返时间\"]},\"266\":{\"h\":\"（7）利用率\",\"t\":[\"图例-利用率\"]},\"267\":{\"h\":\"（8）丢包率\",\"t\":[\"图例-丢包率\"]},\"268\":{\"h\":\"4、体系结构\",\"t\":[\"体系结构如下：\",\"OSI 参考模型：由国际标准化组织（ISO）制定，共分为七层，包括物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。\",\"TCP/IP 参考模型：由美国国防部高级研究计划局（ARPA）制定，共分为四层，包括网络接口层、网络层、传输层和应用层。\",\"图例-体系结构\",\"分层的必要性和各层需要解决的问题：\",\"计算机网络采用分层结构的设计方式，主要是为了将复杂的网络系统分解成若干个相对独立、易于理解和设计的模块，从而简化设计和管理。每一层负责不同的功能和任务，通过接口的方式与上下层进行交互和通信，从而实现了网络协议的标准化和互操作性。\",\":::details下面是各层需要解决的问题：\",\"物理层：负责传输比特流，主要解决物理传输介质、传输速率、传输距离、接口类型等问题。\",\"数据链路层：负责将比特流组装成帧进行传输，主要解决帧的定界、差错检测、如何协调各主机争用总线（流量控制、访问控制）等问题： \",\"如何标识网络中的各主机（主机编址问题，例如MAC地址）\",\"如何从信号所表示的一连串比特流中区分出地址和数据\",\"网络层：负责实现不同网络之间的数据传输，主要解决数据路由（如何进行路由选择问题）、网络地址分配（网络和主机共同编址的问题，例如IP地址）\",\"运输层：负责端到端的数据传输，主要解决进程之间基于网络的通信问题，出现传输错误时，如何处理。\",\"应用层：负责为应用程序提供数据传输服务，主要解决应用程序与网络之间的交互问题。\",\":::\",\"每一层对应的任务\",\"分层举例\",\"解析：\",\"主机和Web服务器之间基于网络的通信，实际上是主机中的浏览器应用进程与Web服务器中的Web服务器应用进程之间基于网络的通信\",\"example1\",\"体系结构的各层在整个过程中起到怎样的作用？\",\"1、发送方发送\",\"发送方发送\",\"第一步：\",\"应用层按照HTTP协议的规定构建一个HTTP请求报文\",\"应用层将HTTP请求报文交付给运输层处理\",\"第一步\",\"第二步：\",\"运输层给HTTP请求报文添加一个TCP首部，使之成为TCP报文段\",\"TCP报文段的首部格式作用是区分应用进程以及实现可靠传输\",\"运输层将TCP报文段交付给网络层处理\",\"第二步\",\"第三步：\",\"网络层给TCP报文段添加一个IP首部，使之成为IP数据报\",\"IP数据报的首部格式作用是使IP数据报可以在互联网传输，也就是被路由器转发\",\"网络层将IP数据报交付给数据链路层处理\",\"第三步\",\"第四步：\",\"数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧 （图示右边为首部，左边为尾部）\",\"该首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收\",\"该尾部的作用是让目的主机检查所接收到的帧是否有误码\",\"数据链路层将帧交付给物理层\",\"第四步\",\"第五步：\",\"物理层先将帧看做是比特流，这里的网络N1假设是以太网，所以物理层还会给该比特流前面添加前导码\",\"前导码的作用是为了让目的主机做好接收帧的准备\",\"物理层将装有前导码的比特流变换成相应的信号发送给传输媒体\",\"第五步\",\"第六步：信号通过传输媒体到达路由器\",\"2、路由器转发\",\"存储-在路由器中\",\"物理层将信号变为比特流，然后去掉前导码后，将其交付给数据链路层\",\"数据链路层将帧的首部和尾部去掉后，将其交付给网络层，这实际交付的是IP数据报\",\"网络层解析IP数据报的首部，从中提取目的网络地址\",\"第六步\",\"转发-在路由器中\",\"提取目的网络地址后查找自身路由表。确定转发端口， 以便进行转发\",\"网络层将IP数据报交付给数据链路层\",\"数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧\",\"数据链路层将帧交付给物理层\",\"物理层先将帧看成比特流，这里的网络N2假设是以太网，所以物理层还会给该比特流前面添加前导码\",\"物理层将装有前导码的比特流变换成相应的信号发送给传输媒体，信号通过传输媒体到达Web服务器\",\"转发-在路由器中\",\"3、接收方接收\",\"和发送方（主机）发送过程的封装正好是反着来\",\"在Web 服务器上\",\"物理层将信号变换为比特流，然后去掉前导码后成为帧，交付给数据链路层\",\"数据链路层将帧的首部和尾部去掉后成为IP数据报，将其交付给网络层\",\"网络层将IP数据报的首部去掉后成为TCP报文段，将其交付给运输层\",\"运输层将TCP报文段的首部去掉后成为HTTP请求报文，将其交付给应用层\",\"应用层对HTTP请求报文进行解析，然后给主机发回响应报文\",\"发回响应报文的步骤和之前过程类似\",\"接收方接收\"]},\"269\":{\"c\":[\"计算机基础\"]},\"270\":{\"c\":[\"计算机网络\"]},\"271\":{\"h\":\"传输层\",\"t\":[\"传输层的主要任务为运行在不同主机上的上层应用进程提供直接的通信服务\"]},\"272\":{\"h\":\"一、简介\"},\"273\":{\"h\":\"1、主要任务\",\"t\":[\"传输层的任务是什么？\",\"传输层的主要任务是与下面的三层一起共同构建进行网络通信所需的线路和数据传输通道，为运行在不同主机上的上层应用进程提供直接的通信服务，向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就好像是在两个传输层实体之间有一条端到端的逻辑通信信道。\",\"根据应用需求的不同，因特网的传输层为应用层提供了两种不同的运输协议，用于解决进程之间基于网络的通信问题 \",\"面向连接的TCP、 无连接的UDP\",\"传输层的数据单元是数据段，这个名称显然太容易混淆，于是在OSI/RM体系结构的传输层中还是把其中传输的数据单元称为TPDU（不过，在TCP/IP体系结构中，TCP的协议数据单元仍然为数据段）。\"]},\"274\":{\"h\":\"2、为什么需要\",\"t\":[\"为什么需要传输层？\",\"因为仅靠网络层把数据传送到目的主机上还是不够的，还必须把它交给目的主机的应用进程，下面是详细解答：\",\"物理层为数据通信提供实际的物理线路和通信信道，这是任何数据通信的基础；\",\"数据链路层为同一网络中（数据链路层的通信限于同一局域网中）的数据通信提供了虚拟的通信通道，可以根据不同链路类型对物理层的比特流进行帧封装和传输；\",\"网络层为不同网络间的数据通信提供了数据包的路由、转发功能，把数据包从一个网络中的主机传送到位于另一网络中的目的主机上，其中需要选择传送的最佳路径。\",\"既然网络层已把源主机上发出的数据包传送给了目的主机，那么为什么还需要设置一个传输层呢？\",\"因为两台网络主机间的真正数据通信主体不是这两台主机，而是两台主机中的各种网络应用进程。因为在同一时刻，两主机间可以进行多个应用通信。\",\"而这里的应用进程识别就要依靠传输层了，它就是通过“端口”将不同应用进程进行对应的。\",\"传输层-简单工作流程\",\"在传输层内部，完成这项任务的硬件或软件称为传输实体（transport entity）。 \",\"传输实体可能位于操作系统的内核，或者在一个独立的用户进程中，或者以一个链接库的形式被绑定在具体的网络应用中。\"]},\"275\":{\"h\":\"3、端到端的服务\",\"t\":[\"传输层的主要作用就是为它的上层提供端到端的数据传输服务。\",\"为什么叫端到端服务呢？\",\"从物理的网络连接角度来讲的，即端到端是指网络通信的双方不是在同一链路上，不是点对点连接的；\",\"从虚拟的传输连接角度来讲的，即端到端是指在用户看来两端的连接是直接进行的（其实并不是这样的），屏蔽了核心网络结构和各种子网间的差异。\",\"点对点连接和端到端连接的区分？\",\"点对点连接就是通信双方直接通过电缆进行的连接，中间没有经过任何其他设备。 \",\"如上图的主机A与路由器1、主机B与路由器2\",\"点对点传输： \",\"源端可直接把数据传给与它直接相连的设备，在需要的时候又可把数据传给与之直接相连的下一台设备，通过一台台直接相连的设备，把数据传到接收端。很显然，这是一种接力传输方式，但是不可靠。\",\"端到端连接是两个终端系统之间的连接，体现在两个终端系统的连接中时要经过一个或多个设备。 \",\"如上图的主机A与主机B\",\"端到端传输： \",\"就是需要在两端所经过的线路上建立一条构建于网络层已搭建好的路由路径之上的虚拟传输连接（当然，这里仅是针对面向连接的传输层协议而讲的），以此来屏蔽所经网络类型或参数配置的不同，就像它们是直接相连的一样；链路建立后，源端就可以发送数据，直至数据发送完毕，接收端确认接收成功。\",\"直到目的端收到数据为止，源端的设备一直要参与传输，因为只有在传输完成后，从源端到目的端所建立的虚拟传输连接才能**“拆除”，否则会中途中断数据的传输，因此是可靠传输。\"]},\"276\":{\"h\":\"4、TSAP和TPDU\",\"t\":[\"在OSI/RM体系结构的传输层中，涉及两个非常重要的术语—TSAP（传输服务访问点）和TPDU（传输协议数据单元），它们贯穿整个传输层数据传输服务的始末。\"]},\"277\":{\"h\":\"（1）TSAP\",\"t\":[\"TSAP是什么？\",\"TSAP是上层调用传输层服务，以及传输层为它的上层提供服务的逻辑接口。\",\"同一时间、同一对网络实体间的用户应用进程可能有多个，不能仅靠网络实体地址（即NSAP）来标注通信双方（因为此时通信的实体是各个应用进程，而不是通信双方主机），而必须借助传输层地址进行标识。TSAP相当于传输层的地址，不同的TSAP标识不同的会话或应用进程。\",\"TSAP组成：\",\"为确保所有的传输地址在整个网络中是唯一的，因此将传输地址分成网络ID、主机ID、主机分配的端口三部分。\",\"端口是传输层特定的属性，用来与应用进程进行一一对应的，所以说真正的传输层地址其实就是具体应用所占用的端口。\"]},\"278\":{\"h\":\"（2）TPDU\",\"t\":[\"TPDU是什么？\",\"TPDU与前面几章中介绍的比特、帧、 分组是同类概念。\",\"OSI/RM体系结构的传输层中还是把其中传输的数据单元称为TPDU\",\"TCP/IP体系结构的传输层中还是把其中传输的数据单元称为数据段\",\"传输层数据 - 数据段 - 封装流程\"]},\"279\":{\"h\":\"5、寻址与端口号\",\"t\":[\"为什么要有端口号？\",\"运行在计算机上的进程使用进程标识符PID来标志，但是因特网上的计算机并不是使用统一的操作系统，不同的操作系统(windows,Linux,Mac OS)，又使用不同格式的进程标识符，为了使运行不同操作系统的计算机的应用进程之间能进行网络通信，必须使用统一的方法对TCP/IP体系的应用进程进行标识，即端口号。\",\"端口号的组成和含义：\",\"端口（逻辑端口/软件端口）：是传输层的SAP，唯一标识主机中的应用进程\",\"端口号只有本地意义（端口号只是为了标识本计算机应用层中的各进程），在因特网中不同计算机的相同端口是没有联系的\",\"端口号长度为16bit，能表示65536个不同的端口号 \",\"服务端使用的端口号\",\"熟知端口号（0~1023）：给TCP/IP最重要的一些应用程序/应用协议，所有用户都知道\",\"登记端口号（1024~49151）：为没有熟知端口号的应用程序使用的，使用时登记，如微软远程桌面使用的端口是3389\",\"客户端使用的端口号/短暂端口号（49152~65535）：仅在客户进程运行时才动态选择，当服务器进程收到客户进程的报文时，就知道了客户进程所使用的的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用\",\"常见端口号：\",\"应用程序\",\"端口号\",\"FTP\",\"21\",\"TELNET\",\"23\",\"SMTP\",\"25\",\"DNS\",\"53\",\"TFTP\",\"69\",\"HTTP\",\"80\",\"SNMP\",\"161\",\"套接字（Socket）：\",\"套接字就是：主机号+端口号\",\"在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机（主机号）和它上面的一个进程（端口号）。\"]},\"280\":{\"h\":\"6、复用和分用\",\"t\":[\"复用和分用：\",\"复用（Multiplexing）:\",\"应用层所有的应用进程都可以通过传输层再传输到网络层，也就是将多个上层应用程序的数据流合并为一个传输层数据流，以便在传输层和网络层之间传输。\",\"发送方的某些应用进程所发送的不同应用报文，在传输层使用UDP协议进行封装，这是UDP复用；若用TCP封装则称TCP复用\",\"传输层使用端口号区分不同进程，不管使用何种协议封装的报文，在网络层都需要使用IP协议封装成IP数据报，这是IP复用，数据报中协议字段的值用来表名封装的是何种协议数据单元\",\"实现方式：复用可以通过端口号来实现。每个应用程序会被分配一个唯一的端口号，这样在传输层就可以区分不同应用程序的数据流。\",\"目的：复用允许多个应用程序同时使用网络传输层服务，从而在网络上传输它们的数据。 :::\",\"分用（Demultiplexing）：\",\"传输层从网络层收到数据后交付指明的应用进程，指在接收主机的传输层将从网络上接收到的数据流分解成多个上层应用程序的数据流。\",\"分用是根据协议字段的值，将IP数据报封装的协议数据单元上交传输层的过程叫IP分用\",\"UDP根据端口号将数据交给应用进程叫做UDP分用，TCP根据端口号将数据交给应用进程叫做TCP分用\",\"实现方式：分用依赖于端口号，接收主机根据数据包中的目标端口号来将数据分发给相应的应用程序。\",\"目的：分用保证了数据能够正确地交付给目标应用程序，从而保持了端到端的通信。\",\"总的来说，复用和分用是在传输层中确保多个应用程序能够同时使用网络传输层服务的重要机制。复用允许多个应用程序的数据流合并为一个传输层数据流，而分用则确保接收主机能够将传输层数据流分解为多个上层应用程序的数据流。这两个机制共同保证了网络通信的有效进行。\"]},\"281\":{\"h\":\"二、TCP协议\"},\"282\":{\"h\":\"1、TCP协议的特性\",\"t\":[\"TCP的特点有哪些？\",\"TCP是面向连接（虚连接）的传输层协议\",\"只有建立了连接才能开始通信\",\"连接是逻辑连接，不是实际链路\",\"支持原因： TCP通过三次握手建立连接，确保通信双方的状态同步和连接的可靠性。这种连接导向的方式允许在数据传输前后进行数据完整性检查和确认，确保数据能够可靠地发送和接收。\",\"仅支持单播传输，无法用于多播、广播\",\"支持原因：每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的\",\"TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达\",\"支持原因： TCP的可靠性来自于序号、确认和重传机制。序号和确认保证了数据的有序传输，重传机制确保了即使出现丢失或损坏，数据也能被重新传输。\",\"TCP提供全双工通信\",\"发送缓存 \",\"准备发送的数据\",\"已发送但尚未收到确认的数据\",\"接收缓存 \",\"按序到达但尚未被接受应用程序读取的数据\",\"不按序到达的数据\",\"TCP面向字节流，而非报文流\",\"TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流\",\"TCP将要传输的数据分成多个字节，以字节为单位传送\",\"字节流传输使TCP更加灵活，可以处理不同大小的数据而不受消息边界的影响\",\"传输单位为数据段，每次发送的TCP数据段大小和数据段数都是可变的\",\"TCP能保证可靠传输、流量控制、拥塞控制\"]},\"283\":{\"h\":\"2、TCP的报文格式\",\"t\":[\"TCP的报文格式\",\"这是TCP协议头部的一些重要字段，它们承载了TCP通信过程中的关键信息。\",\"以下是这些字段的功能和作用：\"]},\"284\":{\"h\":\"3、TCP的连接管理\",\"t\":[\"TCP连接的建立采用客户服务器方式\",\"主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器\"]},\"285\":{\"h\":\"（1）TCP连接的建立\",\"t\":[\"TCP连接的建立采用的是三次握手方式.\",\"三次握手方式.流程描述：\",\"客户端发送连接请求报文段，无应用层数据 \",\"SYN=1\",\"seq=x（随机产生）\",\"ACK=0\",\"ack无效\",\"服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据 \",\"SYN=1\",\"seq=y（随机）\",\"ACK=1\",\"ack=x+1\",\"客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据 \",\"SYN=0\",\"seq=x+1\",\"ACK=1\",\"ack=y+1\",\"图例-三次握手\",\"chatgpt🤖：SYN洪泛攻击\",\"SYN洪泛攻击是一种常见的网络攻击方式，针对TCP协议中的三次握手过程。\",\"攻击者发送大量伪造的TCP连接请求（第一次握手的SYN数据包），但不完成后续的握手过程，导致服务器有大量挂起等待确认的TCP连接，消耗CPU和内存，进而导致死机。\",\"解决方法： \",\"SYN Cookie： 服务器可以启用SYN Cookie机制，它在握手阶段不会在连接表中保存信息，而是通过加密和计算检验和等方式临时存储信息。这样可以避免在握手阶段占用过多的资源。\",\"连接限制： 设置连接限制或阈值，当服务器达到一定的连接数时，暂时停止接受新的连接请求，或者采取其他限制措施。\",\"网络设备配置： 通过防火墙、负载均衡器等网络设备，配置规则来过滤恶意流量，识别和阻止大量伪造的连接请求。\"]},\"286\":{\"h\":\"（2）TCP连接释放\",\"t\":[\"TCP连接释放采用的是四次挥手方式.\",\"四次挥手过程消息描述：\",\"参与一条TCP连接的两个进程中的任何一个都能终止该连接\",\"客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接，转为FIN-WAIT-1状态 \",\"FIN=1\",\"seq=u\",\"服务器端回送一个确认报文段，并转为CLOSE-WAIT状态；客户到服务器这个方向的连接就释放了（半关闭状态），客户端收到这个确认段后转为FIN-WAIT-2状态 \",\"ACK=1\",\"seq=v\",\"ack=u+1\",\"服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接，转为LAST-ACK状态 \",\"FIN=1\",\"seq=w\",\"ACK=1\",\"ack=u+1\",\"客户端回送一个确认报文段，转为TIME-WAIT状态，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭 \",\"seq=u+1\",\"ACK=1\",\"ack=w+1\",\"图例-四次挥手\",\"2MSL的意义：防止服务器端因为未收到客户端的确认报文段导致无法关闭\"]},\"287\":{\"h\":\"4、TCP的可靠传输\",\"t\":[\"可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的\",\"可靠传输是TCP的主要目的，而校验和、序列号、确认号、超时重传等机制是TCP使用的手段，用于实现可靠传输。这些机制一起工作，确保了数据的完整性和可靠性，以及网络的稳定性。\"]},\"288\":{\"h\":\"（1）校验\",\"t\":[\"与UDP类似，通过伪首部进行检验和校验\",\"TCP报文段包含一个校验和字段，用于检测报文在传输过程中是否发生了错误。\"]},\"289\":{\"h\":\"（2）序号\",\"t\":[\"为传输流中的每一个字节进行编号，将缓冲区中的字节组成若干个TCP段（数据报），通过确认号和序号的机制进行发送\",\"发送方将数据分割成小的报文段，并为每个报文段分配一个唯一的序列号。\",\"接收方使用确认号来指示下一个期望接收的序列号。\"]},\"290\":{\"h\":\"（3）确认号\",\"t\":[\"接收方收到报文段后，返回确认字段，确认字段中的确认号为下一个期望收到的起始字节编号。\",\"捎带确认：接收方将确认字段捎带在自己要发送的数据中（ACK=1，使用相应的确认号即可）\",\"累计确认：只确认到第一个丢失为止的字节，而不需要一个一个地确认每个数据包。\",\"此时接收方返回的确认号为4\",\"7、8仍然正常接收\",\"发送方重新发送4、5、6\",\"接收方收到后返回的确认号为9\"]},\"291\":{\"h\":\"（4）重传\",\"t\":[\"超时重传：TCP的发送方在规定的时间（重传时间RTTs）内没有收到确认就要重传已发送的报文段，RTTs本质是加权平均往返时间\",\"重传时间过短：太长的数据报来不及发送完毕\",\"重传时间过长：增加网络空闲时间，降低传输效率\",\"TCP采用自适应算法，动态改变重传时间RTTs\",\"冗余ACK（冗余确认）\",\"每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号\",\"例题：\",\"发送方已发送1，2，3，4，5报文段\",\"接收方收到1，返回给1的确认（ACK=2）\",\"接收方收到3，返回给1的确认（ACK=2，冗余ACK）\",\"接收方收到4，返回给1的确认（ACK=2，冗余ACK）\",\"接收方收到5，返回给1的确认（ACK=2，冗余ACK）\",\"发送方收到3个对于报文段1的冗余ACK\",\"发送方认定2丢失，重传2\",\"可靠传输的特点：\",\"数据按序交付：TCP会根据序列号确保接收方按照正确的顺序接收到数据，即使数据包乱序到达，也会在接收方重新排序后交付给应用层。\",\"数据完整性保证：TCP使用校验和和序列号等机制来保证数据在传输过程中的完整性，接收方可以检测到任何丢失或损坏的数据。\",\"重传机制：如果发送方没有收到接收方的确认信息，它会定时重传数据，确保数据的可靠传输。\"]},\"292\":{\"h\":\"5、TCP的流量控制\"},\"293\":{\"h\":\"（1）概述\",\"t\":[\"流量控制就是让「发送方」根据「接收方」的实际接收能力控制发送的数据量，让发送方的发送速率不要太快，要让接收方来得及接收，以避免发送方发送速度过快导致接收方无法处理或缓存溢出的问题。\"]},\"294\":{\"h\":\"（2）实现方式\",\"t\":[\"TCP利用滑动窗口机制实现流量控制。\",\"接收方根据自己的缓冲区大小，动态的通过窗口字段调整发送方发送窗口的大小。\",\"发送方窗口大小取接收窗口rwnd和拥塞窗口cwnd的最小值。 \",\"拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量\",\"发送方发送完窗口内数据后需要等到确认报文才会滑动窗口并继续发送，若窗口内的某个值很久没有收到回答报文，则超时重传报文\",\"实时调整：窗口大小可以实时调整，当接收方通过确认重传机制进行字节编号确认时，会连带着修改发送方的允许发送窗口大小，可以根据网络状况和接收方的处理能力来动态控制数据的发送速度。\",\"例题：\",\"例：A向B发送数据，连接建立时，B的初始rwnd=400（B），设每一个报文段100B，报文段序号初始值为1\",\"图例-拥塞窗口\",\"若接收方发送的允许发送的确认信息丢包，则此时会出现“死锁”情况，即发送方窗口大小仍然为0，无法发送数据；接收方一直等待发送方发送新数据，没有新的确认信息。\",\"解决方法：TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。到时间则发送一个零窗口的探测报文段，并重置计时器时间。\",\"滑动窗口过小：产生太多ACK\",\"滑动窗口过大：路由器发生拥挤，主机可能丢失分组\",\"chatgpt🤖：零窗口探测报文\",\"零窗口探测报文的出现是为了解决TCP通信中可能出现的接收方窗口为零（Zero Window）的情况。\",\"接收方窗口为零表示接收方暂时无法接收更多的数据，这可能由以下几个原因导致：\",\"接收方处理能力不足：接收方的处理能力可能不足以及时处理收到的数据，导致其缓冲区满了。\",\"接收方应用程序忙碌：接收方的应用程序可能正在处理大量任务，无法及时处理新的数据，导致缓冲区满了。\",\"网络拥塞：在网络拥塞的情况下，数据包可能会丢失，接收方为了保证数据的完整性可能会将窗口大小设为零。\",\"接收方主动控制接收速率：接收方可能希望控制数据的接收速率，通过将窗口大小设为零来暂停数据的接收。\",\"死锁问题：在某些情况下，如果发送方一直等待接收方的窗口变为非零，可能会导致死锁。零窗口探测报文允许发送方主动探测接收方窗口的变化，避免了可能的死锁情况。\",\"零窗口探测报文的出现是为了及时解决这种情况，它的作用包括：\",\"主动探测接收方窗口变化：发送方可以通过发送零窗口探测报文来主动询问接收方的窗口是否已经变为非零，从而及时恢复数据的传输。\",\"保持连接状态：零窗口探测报文可以避免连接在窗口为零的情况下被错误地认为是不活跃的，从而保持连接的活跃状态。\",\"其次，零窗口探测报文也有超时重传机制\",\"总的来说，零窗口探测报文的出现是为了提升TCP通信的可靠性和效率，保证数据的及时传输，同时避免不必要的连接中断。\"]},\"295\":{\"h\":\"6、TCP的拥塞控制\"},\"296\":{\"h\":\"（1）概述\",\"t\":[\"拥塞控制是一种网络流量控制的机制，其主要目的是避免在网络中发生拥塞，以保证网络的稳定性和吞吐量的合理分配。\",\"拥塞控制：全局性的控制\",\"流量控制：端到端的控制\",\"拥塞控制的意义：防止过多的数据注入到网络中\",\"讨论前提：\",\"数据单方向传送，而另一个方向只传送确认\",\"接收方总是有足够大的缓存空间（rwnd -> ∞），因而发送窗口大小取决于拥塞程度\",\"拥塞控制的出现背景和原因：\",\"拥塞控制的背景：\",\"在计算机网络中，当网络中的路由器、交换机等网络设备的处理能力不足以处理大量的数据流时，就会导致网络拥塞。\",\"前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么，一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。\",\"在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....\",\"所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量，于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。为了在「发送方」调节所要发送数据的量，定义了一个叫做拥塞窗口 的概念。\",\"拥塞控制的原因：\",\"原因：\",\"不均衡的流量：可能有一些节点或链路的流量远远超过了其处理能力，导致拥塞。\",\"路由选择问题：不恰当的路由选择可能导致某些路径过于拥挤，造成拥塞。\",\"丢包和重传：在网络中丢失的数据包会导致重传，增加了网络的负担。\",\"缓冲区溢出：当网络设备的缓冲区已满时，新到达的数据包可能会被丢弃。\",\"网络拓扑变化：动态的网络拓扑变化可能导致数据包传输的不稳定性，可能引发拥塞。\",\"chatgpt🤖：拥塞控制可以解决以下问题\",\"避免网络拥塞：通过监测网络状态，控制数据的发送速率，避免在网络中发生拥塞。\",\"提高网络性能：通过动态调整传输速率，可以使网络资源得到合理利用，提高网络的吞吐量。\",\"保证公平性：拥塞控制机制可以确保网络中的各个流量源公平地共享网络资源。\",\"总的来说，拥塞控制是为了保证网络稳定运行，避免拥塞发生，以及在拥塞发生时能够有效地应对和解决问题。通过动态调整数据发送速率和监测网络状态，拥塞控制可以保证网络的稳定性和吞吐量的合理分配。\"]},\"297\":{\"h\":\"（2）实现方式\",\"t\":[\"什么是慢开始门限ssthresh？ 什么是拥塞窗口？和发送窗口有什么关系呢？\",\"慢开始门限ssthresh是TCP拥塞控制算法中的一个阈值，用于控制拥塞窗口（cwnd）的大小。\",\"拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的，表示在不收到确认信息的情况下可以发送的数据量。\",\"我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。\",\"拥塞窗口 cwnd 变化的规则：\",\"只要网络中没有出现拥塞，cwnd 就会增大；\",\"但网络中出现了拥塞，cwnd 就减少；\",\"那么怎么知道当前网络是否出现了拥塞呢？\",\"其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。\",\"拥塞控制有哪些控制算法？\",\"拥塞控制主要是四个算法：慢开始、拥塞避免、快重传、快恢复\"]},\"298\":{\"h\":\"（a）慢开始和拥塞避免\",\"t\":[\"慢开始：拥塞窗口从1开始，根据应答报文大小来扩大拥塞窗口，如发送方窗口2，应答大小2，则下次发送大小为4，是指数性的增长\",\"拥塞避免：拥塞窗口每次只扩大1，而不是向慢开始那样根据发送方的返回窗口进行增加。\",\"图例-慢开始和拥塞避免\"]},\"299\":{\"h\":\"（b）快重传和快恢复\",\"t\":[\"快重传：使发送方尽快进行重传，而不是等待超时重传计时器超时再重传 \",\"要求接收方不用等待自己发送数据时才进行捎带确认，而是要立即发送确认\",\"即使收到了失序的报文段(说明有一段丢失了)也要立即发出对已收到的报文段的重复确认\",\"发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传\",\"对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞。使用快重传可以使整个网络的吞吐量提高约20%\",\"快恢复：发送方一旦收到3个重复确认，就知道现在只是丢失了个别报文段。也是不启动慢开始算法，而执行快恢复算法 \",\"发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，开始执行拥塞避免算法\",\"也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3 \",\"既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络\",\"这三个报文段不再消耗网络资源而是停留在接收方的接收缓存中\",\"可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些\",\"图例-快重传和快恢复\",\"总结：\",\"当cwnd < ssthresh时，使用慢开始算法\",\"当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法\",\"当cwnd = ssthresh时，既可使用慢开始算法，也可以使用拥塞避免算法\"]},\"300\":{\"h\":\"三、UDP协议\"},\"301\":{\"h\":\"1、UDP协议的特性\",\"t\":[\"UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。\",\"UDP的主要特点\",\"UDP是无连接的：进行数据传输前是不需要建立专门的传输连接的，在数据发送结束时也无须释放连接了。\",\"UDP不保证可靠交付：不需要事先建立专门的传输连接的，所以它的传输是不可靠的（但会尽最大努力进行交付）\",\"分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文\",\"UDP是面向报文的：适合一次性传输少量数据的网络应用\",\"应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文，不做处理\",\"UDP直接对应用层提交的报文进行封装、传输，但不拆分，也不合并，保留原来报文的边界。因此，UDP是报文流，而TCP是字节流。因为UDP不拆分报文，自然也就没有报文段之说，但UDP报文传输到网络层后，在网络层仍然可以根据网络的MTU值进行分割。\",\"图例-UDP面向报文\",\"UDP无拥塞控制，适合很多实时应用：使用UDP进行数据传输时不能进行流量控制和拥塞控制，因为这类数据传输的连续性要比数据的完整性更重要，允许数据在传输过程中有部分丢失，如IP电话、流媒体通信等。\",\"支持各种交互通信方式：TCP不支持组播、广播通信方式，只支持一对一的单播方式，但UDP支持各种通信方式，即可以是一对一、一对多、多对一和多对多的方式。\",\"UDP首部开销小：只包含8个字节，分布是源端口和目的端口，以及UDP长度和校验和\",\"UDP的应用服务：\",\"计算机网络中有许多使用UDP的应用服务，如DNS、SNMP、DHCP和RIP等。\"]},\"302\":{\"h\":\"2、UDP的报文格式\",\"t\":[\"图例-UDP的报文格式\",\"这是UDP协议头部的一些重要字段，它们承载了UDP通信过程中的关键信息。\",\"以下是这些字段的功能和作用：\",\"首部字段\",\"源端口号（16位，2B）：可选填，当需要目的主机回应时使用\",\"目的端口号（16位，2B）：必要，目的进程的端口号\",\"UDP长度（16位，2B）：整个UDP数据报的长度（首部字段+数据字段）\",\"UDP检验和（16位，2B）：检测整个UDP数据报是否有错误\",\"数据字段\"]},\"303\":{\"h\":\"3、UDP的校验过程\"},\"304\":{\"h\":\"1、伪首部\",\"t\":[\"伪首部是用于计算UDP校验和的一个辅助数据结构，包含了一些关于IP头部的信息，只有在计算检验和时才出现， 不向下传送也不向上递交，用于确保UDP数据在传输过程中的完整性。\",\"图例-伪首部\",\"伪首部模仿的是IP数据报的首部，结构如下：\",\"源IP地址（32位）\",\"目标IP地址（32位）\",\"固定字段：0（8位）\",\"协议字段：标识上层协议，UDP的协议号为17（8位）\",\"UDP数据报长度（16位），包括UDP头部和数据部分的长度，不包括伪首部\"]},\"305\":{\"h\":\"2、校验过程\",\"t\":[\"若不使用校验，则将校验和字段全部置0\",\"校验过程\",\"UDP校验填充\",\"下列是一种关于UDP校验和填充的过程，是对UDP数据报在发送和接收过程中进行完整性检查的方法。\",\"这个过程包括了一些步骤，以保证数据在传输过程中的准确性和完整性：\"]},\"306\":{\"c\":[\"计算机基础\"]},\"307\":{\"c\":[\"计算机网络\"]},\"308\":{\"h\":\"学习数据结构前的必会知识\"},\"309\":{\"h\":\"一、前置扫盲\"},\"310\":{\"h\":\"1、数据结构分类\"},\"311\":{\"h\":\"1.1 逻辑结构：线性与非线性\",\"t\":[\"tip：逻辑结构揭示了数据元素之间的逻辑关系。\",\"线性数据结构：元素间存在明确的顺序关系。\",\"数据按照一定顺序排列，其中元素之间存在一个对应关系，使得它们按照线性顺序排列。\",\"每个元素都有且仅有一个前驱元素和一个后继元素，除了第一个和最后一个元素外。\",\"代表：数组、链表、栈、队列、哈希表。\",\"非线性数据结构：元素不是按照序列排列的\",\"元素之间存在多对多的关系，其组织方式不受固定顺序的限制。\",\"非线性数据结构中的元素不是按照序列排列的。\",\"代表：树、堆、图、哈希表。\",\"图例：\",\"常见线性数据结构和非线性数据结构\"]},\"312\":{\"h\":\"1.2 物理结构：顺序与链式\",\"t\":[\"tip：所有数据结构都是基于数组、链表或二者的组合实现的\",\"连续空间存储（顺序）： \",\"特点：数据元素存储在物理空间上是连续的，通过元素的物理地址和相对位置来访问数据。\",\"优缺点： \",\"优点： 随机访问速度快，存储效率高。\",\"缺点： 插入和删除操作可能涉及大量数据的移动，且需要预先分配连续的内存空间。\",\"代表：基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。\",\"分散空间存储（链式）： \",\"特点：数据元素存储在物理空间上是分散的，通过指针来连接各个元素。\",\"优缺点： \",\"优点： 插入和删除操作相对容易，不需要连续的内存空间。\",\"缺点： 不支持快速的随机访问，需要遍历才能找到特定位置的元素。\",\"代表：基于链表可实现：栈、队列、哈希表、树、堆、图等。\",\"图例：\",\"顺序存储和分散存储\"]},\"313\":{\"h\":\"2、算法效率评估\",\"t\":[\"tip：算法的效率主要评估的是时间和空间，名词称为-时间复杂度和空间复杂度，但是不是统计具体的算法运行时间和使用空间，而是统计算法运行时间和使用空间随着数据量变大时的增长趋势，使用大O计数法表示。\"]},\"314\":{\"h\":\"2.1 时间复杂度\",\"t\":[\"例子：下列一段代码，分别使用两种方式统计时间复杂度。\",\"void algorithm(int n) { int a = 2; a = a + 1; a = a * 2; for (int i = 0; i < n; i++) { System.out.println(0); } } \"]},\"315\":{\"h\":\"2.1.1 统计具体时间\",\"t\":[\"确定运行平台，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。\",\"评估各种计算操作所需的运行时间，假如加法操作 + 需要 1 ns ，乘法操作 * 需要 10 ns ，打印操作 print() 需要 5 ns 等。\",\"统计代码中所有的计算操作，并将所有操作的执行时间求和，从而得到运行时间。\",\"// 在某运行平台下 void algorithm(int n) { int a = 2; // 1 ns a = a + 1; // 1 ns a = a * 2; // 10 ns // 循环 n 次 for (int i = 0; i < n; i++) { // 1 ns ，每轮都要执行 i++ System.out.println(0); // 5 ns } } \",\"根据以上方法，可以得到算法的运行时间为 (6n+12) ns 。\",\"统计算法的运行时间既不合理也不现实\",\"预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。\",\"很难获知每种操作的运行时间，这给预估过程带来了极大的难度。\"]},\"316\":{\"h\":\"2.1.2 统计增长趋势\",\"t\":[\"“时间增长趋势(是算法运行时间随着数据量变大时的增长趋势)”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 n ，给定三个算法 A、B 和 C ：\",\"// 算法 A 的时间复杂度：常数阶 void algorithm_A(int n) { System.out.println(0); } // 算法 B 的时间复杂度：线性阶 void algorithm_B(int n) { for (int i = 0; i < n; i++) { System.out.println(0); } } // 算法 C 的时间复杂度：常数阶 void algorithm_C(int n) { for (int i = 0; i < 1000000; i++) { System.out.println(0); } } \",\"A、B、C的时间增长趋势图\",\"算法 A 只有 1 个打印操作，算法运行时间不随着 n增大而增长。我们称此算法的时间复杂度为“常数阶”。\",\"算法 B 中的打印操作需要循环 n 次，算法运行时间随着 n 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。\",\"算法 C 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小n 无关。因此 C 的时间复杂度和 A 相同，仍为“常数阶”\",\"相较于直接统计算法的运行时间，时间复杂度的特点：\",\"时间复杂度能够有效评估算法效率。例如，算法 B 的运行时间呈线性增长，在 n>1 时比算法 A 更慢，在n>1000000时比算法 C 更慢。事实上，只要输入数据大小 n 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。\",\"时间复杂度的推算方法更简便。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。\",\"时间复杂度也存在一定的局限性。例如，尽管算法 A 和 C 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 B 的时间复杂度比 C 高，但在输入数据大小 n 较小时，算法 B 明显优于算法 C 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。\",\"具体计算方式：使用函数T(n)演变为O(n)表示。\",\"void algorithm(int n) {//每次调用函数执行的次数 int a = 1; // +1 a = a + 1; // +1 a = a * 2; // +1 // 循环 n 次 for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++） System.out.println(0); // +1 } } \",\"设算法的操作数量是一个关于输入数据大小 n 的函数，记为T(n)，则以上函数的操作数量为\",\"T(n)=3+2n\",\"T(n)是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶，我们将线性阶的时间复杂度记为O(n)，这个数学符号称为「大O记号big-O notationJ,表示函数T(n)的「渐近上界asymptotic upper bound」。\",\"代码的时间复杂度：线性阶时间复杂度\",\"函数表示：T(n)=3+2n\",\"线性阶表示：O(3+2n) \",\"输入的n不受控制，可以为任意数，而时间复杂度是很难计算准确的，所以统计的为最差情况的时间复杂度。\",\"假如输入n的数趋近于∞（无穷），那么常数3可以忽略，同理系数2也可以忽略，无穷和2倍无穷不还是无穷吗\",\"所以最终时间复杂度表示为：O(n)\",\"总结：\",\"计数简化技巧：\",\"忽略T(n) 中的常数项。因为它们都与 n 无关，所以对时间复杂度不产生影响。\",\"省略所有系数。例如，循环 2n 次、5n+1 次等，都可以简化记为 n 次，因为 n前面的系数对时间复杂度没有影响。\",\"循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用第 1. 点和第 2. 点的技巧。\",\"最差情况判断：当输入数最差情况为n，趋近于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。\",\"void algorithm(int n) { int a = 1; // +1 a = a + n; // +1 // +5n for (int i = 0; i < 5 * n + 1; i++) { System.out.println(0); } // +2n for (int i = 0; i < 2 * n; i++) { //加n+1 for (int j = 0; j < n + 1; j++) { System.out.println(0); } } } \",\"函数表示：T(n)=2+5n+2n(n+1)=2n2+7n+3\",\"当n->∞，n2次方为主导，除去常数、系数、非主导项使用大O计数法表示：O(n2)\",\"拓展：常见大O类型和图例\",\"时间复杂度：O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(2n)<O(n!)\",\"时间复杂度：常数阶<对数阶<线性阶<线性对数阶<平方阶<指数阶<阶层阶\",\"常见大O类型和图例\",\"线性阶的操作数量相对于输入数据大小 n以线性级别增长。线性阶通常出现在单层循环中\",\"平方阶的操作数量相对于输入数据大小 n 以平方级别增长。平方阶通常出现在嵌套循环中\",\"生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 n 轮后有 2^n 个细胞，指数阶常出现于递归函数中。\",\"对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为 n ，由于每轮缩减到一半，因此循环次数是 log2⁡n ，即 2^n 的反函数。 \",\"time_complexity_logarithmic\",\"线性对数阶常出现于嵌套循环中\",\"阶乘阶对应数学上的“全排列”问题。给定 n 个互不重复的元素，求其所有可能的排列方案，方案数量为n!，常用于回溯。\"]},\"317\":{\"h\":\"2.2 空间复杂度\",\"t\":[\"tip：现在很发达了，内存没以前贵，直接跳过此处\",\"「空间复杂度 space complexity」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。\",\"算法在运行过程中使用的内存空间主要包括以下几种。\",\"输入空间：用于存储算法的输入数据。\",\"暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据。\",\"输出空间：用于存储算法的输出数据。\",\"一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。\",\"暂存空间可以进一步划分为三个部分。\",\"暂存数据：用于保存算法运行过程中的各种常量、变量、对象等。\",\"栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。\",\"指令空间：用于保存编译后的程序指令，在实际统计中通常忽略不计。\"]},\"318\":{\"c\":[\"计算机基础\"]},\"319\":{\"c\":[\"数据结构和算法\"]},\"320\":{\"h\":\"行为型设计模式\",\"t\":[\"行为型设计模式关注对象之间行为（通信和协作方式），以实现不同对象之间的交互和任务分配。这些模式涉及到对象之间的算法、责任分配和消息传递等行为。行为型设计模式的核心目的是提供一种灵活、可扩展和可维护的方式来管理对象之间的交互和行为。\",\"行为型设计模式关注对象之间行为（通信和协作方式），以实现不同对象之间的交互和任务分配。这些模式涉及到对象之间的算法、责任分配和消息传递等行为。行为型设计模式的核心目的是提供一种灵活、可扩展和可维护的方式来管理对象之间的交互和行为。\",\"总结：复用和拓展\"]},\"321\":{\"h\":\"一、观察者设计模式\"},\"322\":{\"h\":\"1、介绍\",\"t\":[\"观察者设计模式（Observer Pattern）是一种行为型设计模式，它建立了对象之间的一对多依赖关系，使得当一个对象的状态发生变化时，其相关依赖对象都能得到通知并自动更新。这种模式被广泛应用于事件驱动系统和发布-订阅系统中。\"]},\"323\":{\"h\":\"2、核心思想\",\"t\":[\"观察者设计模式的核心思想：\",\"将对象之间的依赖关系解耦，使得主题（被观察者）和观察者之间可以独立变化。\",\"主题维护一份观察者列表，并在状态变化时通知观察者，观察者接收到通知后进行相应的处理。\"]},\"324\":{\"h\":\"3、组成和基本流程\",\"t\":[\"观察者设计模式由以下几个关键组件组成：\",\"Subject（主题）：也称为被观察者或发布者，维护一份观察者列表，并提供方法用于添加(注册)、删除和通知观察者。\",\"Observer（观察者）：也称为订阅者，定义了接收和处理主题通知的方法。\",\"ConcreteSubject（具体主题）：具体主题是主题的具体实现类，负责维护具体的状态并在状态变化时通知观察者。\",\"ConcreteObserver（具体观察者）：具体观察者是观察者的具体实现类，实现了接收和处理主题通知的方法。\",\"观察者设计模式的使用基本流程：\",\"观察者通过将自身注册到主题中，成为主题的观察者。\",\"当主题的状态发生变化时，它会遍历观察者列表，并调用每个观察者的通知方法。\",\"每个观察者接收到通知后，执行相应的更新操作。\"]},\"325\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"观察者设计模式适用于以下场景：\",\"当一个对象的变化需要影响其他对象，但你又不希望这些对象紧密耦合在一起时。\",\"当一个对象的状态变化会导致其他对象的行为变化，而且你希望能够动态地将对象加入或移除。\",\"具体案例：\",\"一个常见的业务场景是网络聊天的群聊功能。假设我们有一个网络聊天室应用程序，用户可以加入聊天群，并与其他用户进行实时聊天。\",\"以下是一个简化的示例代码，展示了如何使用观察者设计模式实现网络聊天室：\",\"在下列示例中：\",\"我们创建了一个名为ChatGroup的主题接口，其中定义了加入聊天群、退出聊天群和通知所有用户的方法。\",\"具体主题类QQGroup实现了该接口，并维护了一个用户列表。\",\"观察者接口ChatUser定义了接收消息和发送消息的方法。\",\"具体观察者类QQUser实现了该接口，每个用户都可以接收消息并发送消息给聊天室中的其他用户。\",\"在主类中，我们创建了一个QQGroup实例作为聊天室。然后，创建了几个QQUser实例，代表聊天室中的用户。接着，将这些用户加入聊天室，并执行了一次消息发送操作。 \",\"当jack发送消息时，聊天室会调用notifyAllUser方法通知其他用户接收消息。每个用户收到消息后，会打印出相应的消息内容。\",\"这个例子演示了观察者设计模式在网络聊天室中的应用。通过使用观察者模式，网络聊天室实现了用户之间的解耦，聊天室中的用户可以实时接收和发送消息，实现了群聊的功能。\",\"// 主题接口 public interface ChatGroup { void joinChatGroup(ChatUser user); void exitChatGroup(ChatUser user); void notifyAllUser(String msg); } // 具体主题类 public class QQGroup implements ChatGroup { private List<ChatUser> users = new ArrayList<>(); @Override public void joinChatGroup(ChatUser user) { users.add(user); } @Override public void exitChatGroup(ChatUser user) { users.remove(user); } @Override public void notifyAllUser(String msg) { for (ChatUser user : users) { user.receiverMsg(msg); } } } // 观察者接口 public interface ChatUser { void receiverMsg(String msg); void sendMsg(String msg); } // 具体观察者类 class QQUser implements ChatUser { private String name; private ChatGroup chatRoom; public QQUser(String name, ChatGroup chatRoom) { this.name = name; this.chatRoom = chatRoom; } @Override public void receiverMsg(String msg) { System.out.println(name + \\\" 收到消息：\\\" + msg); } @Override public void sendMsg(String msg) { System.out.println(name + \\\" 发送消息：\\\" + msg); //通知其他人 chatRoom.notifyAllUser(msg); } } // 示例代码的主类 public class Main { public static void main(String[] args) { //创建QQ群 ChatGroup chatGroup = new QQGroup(); //宿舍四个室友创建qq ChatUser jack = new QQUser(\\\"jack\\\", chatGroup); ChatUser rose = new QQUser(\\\"rose\\\", chatGroup); ChatUser tom = new QQUser(\\\"tom\\\", chatGroup); ChatUser jerry = new QQUser(\\\"jerry\\\", chatGroup); //加入群聊 chatGroup.joinChatGroup(jack); chatGroup.joinChatGroup(rose); chatGroup.joinChatGroup(tom); chatGroup.joinChatGroup(jerry); //今天晚上打算出去吃饭,jack问了大家晚上吃什么 jack.sendMsg(\\\"今天晚上吃什么\\\"); } } \"]},\"326\":{\"h\":\"5、发布订阅模式\",\"t\":[\"发布-订阅模式是一种行为型设计模式，用于实现对象间的松耦合通信。在该模式中，存在一个消息总线或事件系统作为中介，发布者（Publisher）将消息发布到消息总线，而订阅者（Subscriber）订阅感兴趣的消息主题或事件类型。当有新的消息或事件发生时，消息总线会将消息传递给对应的订阅者。\",\"该模式的核心思想是解耦发布者和订阅者之间的直接依赖关系。发布者不需要知道订阅者的存在，而订阅者也不需要知道发布者的细节。通过引入消息总线或事件系统作为中介，发布者和订阅者之间的交互通过消息的发布和订阅来完成。\",\"发布-订阅模式广泛应用于各种场景，例如消息队列系统、事件驱动系统、日志记录系统等。它提供了一种灵活、可扩展的通信机制，有助于构建松耦合、可维护的软件系统。\",\"下列例子演示了一个简单的发布-订阅模式，明星发布消息，关注了明星的追星人可以接收到通过总线发送来的消息：\",\"代码说明介绍：\",\"上述代码是一个基于事件的发布-订阅模式的实现，以一个明星发布要开全球音乐巡演会的例子来说明。\",\"接口 Subscribe 定义了订阅者的行为，其中 onEvent() 方法用于处理收到的事件。\",\"JackSubscribe 和 RoseSubscribe 是具体的订阅者实现类，它们实现了 Subscribe 接口，并根据收到的事件进行相应的处理。\",\"EventBus 是事件总线类，用于维护事件和订阅者之间的关系。它包含了注册订阅者、移除订阅者和发布事件的方法。\",\"StartTopic 是发布者类，它拥有一个事件总线实例，并通过调用 worldConcert() 方法发布名为 \\\"worldConcert\\\" 的事件。\",\"代码解析：\",\"在 main() 方法中，创建了 JackSubscribe 和 RoseSubscribe 的实例，并创建了一个 EventBus 的实例。\",\"使用 EventBus 的 registerSubscribe() 方法注册了订阅者，将它们与事件类型 \\\"worldConcert\\\" 关联起来。\",\"创建了 StartTopic 的实例，并将 EventBus 实例传递给它。\",\"调用 startTopic 的 worldConcert() 方法发布了事件。\",\"EventBus 接收到事件后，根据事件类型找到相应的订阅者列表，并逐个调用订阅者的 onEvent() 方法处理事件。\",\"JackSubscribe 和 RoseSubscribe 分别接收到事件，并输出相应的消息。\",\"这个例子模拟了一个音乐演唱会的情景，当 StartTopic 的 worldConcert() 方法被调用时，会发布一个 \\\"worldConcert\\\" 的事件，然后 JackSubscribe 和 RoseSubscribe 作为订阅者接收到这个事件并进行处理，输出相应的消息。\",\"通过发布-订阅模式，发布者和订阅者之间的解耦，使得发布\",\"interface Subscribe { void onEvent(Map<String, Object> eventContext); } class JackSubscribe implements Subscribe { private String name; public JackSubscribe(String name) { this.name = name; } @Override public void onEvent(Map<String, Object> eventContext) { System.out.println(name + \\\"收到发布订阅的消息:\\\" + eventContext.get(\\\"tmp\\\")); } } class RoseSubscribe implements Subscribe { private String name; public RoseSubscribe(String name) { this.name = name; } @Override public void onEvent(Map<String, Object> eventContext) { System.out.println(name + \\\"收到发布订阅的消息:\\\" + eventContext.get(\\\"tmp\\\")); } } class EventBus { //维护事件和订阅者 private Map<String, List<Subscribe>> subscribes = new HashMap<>(8); public void registerSubscribe(String eventType, Subscribe subscribe) { List<Subscribe> subscribeList = subscribes.get(eventType); if (subscribeList == null) { List<Subscribe> list = new ArrayList<>(); //注册 list.add(subscribe); subscribes.put(eventType, list); } else { //注册 subscribeList.add(subscribe); } } public void removeSubscribe(String eventType, Subscribe subscribe) { List<Subscribe> subscribeList = subscribes.get(eventType); if (subscribeList != null) { subscribeList.remove(subscribe); } } public void publishEvent(String eventType, Map<String, Object> eventContext) { List<Subscribe> subscribeList = subscribes.get(eventType); for (Subscribe subscribe : subscribeList) { subscribe.onEvent(eventContext); } } } class StartTopic { private String name; private EventBus eventBus; public StartTopic(String name, EventBus eventBus) { this.name = name; this.eventBus = eventBus; } public void worldConcert(String name) { this.name = name; HashMap<String, Object> context = new HashMap<>(); context.put(\\\"tmp\\\", name + \\\"要开全球巡回演唱会了!!!\\\"); eventBus.publishEvent(\\\"worldConcert\\\", context); } } public class Main { public static void main(String[] args) { JackSubscribe jackSubscribe = new JackSubscribe(\\\"jack\\\"); RoseSubscribe roseSubscribe = new RoseSubscribe(\\\"rose\\\"); EventBus eventBus = new EventBus(); eventBus.registerSubscribe(\\\"worldConcert\\\", jackSubscribe); eventBus.registerSubscribe(\\\"worldConcert\\\", roseSubscribe); StartTopic startTopic = new StartTopic(\\\"redvelet\\\", eventBus); //发布事件 startTopic.worldConcert(\\\"redvelet\\\"); } } \"]},\"327\":{\"h\":\"6、观察者的进阶使用\",\"t\":[\"异步非阻塞型：\",\"前面例子的实现方式，是一种同步阻塞的实现方式。\",\"观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。\",\"当观察者模式需要在异步非阻塞的场景中使用时，可以通过使用线程池来实现异步通知。下面是一个经过格式化的示例代码：\",\"import java.util.ArrayList; import java.util.List; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; // 观察者接口 interface Observer { void update(String message); } // 被观察者接口 interface Observable { void addObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers(String message); } // 具体的被观察者类 class Subject implements Observable { private List<Observer> observers; private ExecutorService executorService; public Subject() { observers = new ArrayList<>(); executorService = Executors.newCachedThreadPool(); } @Override public void addObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { observers.remove(observer); } @Override public void notifyObservers(String message) { for (Observer observer : observers) { executorService.submit(() -> observer.update(message)); } } public void setMessage(String message) { notifyObservers(message); } } // 具体的观察者类 class ConcreteObserver implements Observer { private String name; public ConcreteObserver(String name) { this.name = name; } @Override public void update(String message) { System.out.println(name + \\\" received message: \\\" + message); } } public class Main { public static void main(String[] args) { Subject subject = new Subject(); ConcreteObserver observer1 = new ConcreteObserver(\\\"Observer 1\\\"); ConcreteObserver observer2 = new ConcreteObserver(\\\"Observer 2\\\"); ConcreteObserver observer3 = new ConcreteObserver(\\\"Observer 3\\\"); subject.addObserver(observer1); subject.addObserver(observer2); subject.addObserver(observer3); subject.setMessage(\\\"Hello, observers!\\\"); // 等待异步任务完成 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } \",\"在这个示例中，我们使用了线程池 ExecutorService 来实现异步非阻塞的通知。每个观察者的更新操作都将作为一个任务提交给线程池，并在不同的线程中异步执行。这样可以确保性能敏感的场景不会因为观察者的通知而阻塞。\",\"跨进程通信型：\",\"前面的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。\",\"如果用户注册成功之后，我们需要发送用户信息给大数据征信系统， 而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现 一个跨进程的观察者模式呢？\",\"如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前 的实现思路，在 notifyObservers() 函数中调用 RPC 接口来发送数据。\",\"另一种就是基于消息队列（Message Queue， 比如 ActiveMQ）来实现。 当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。\"]},\"328\":{\"h\":\"7、总结\",\"t\":[\"观察者设计模式的优点包括：\",\"解耦性：主题和观察者之间的松散耦合使得它们可以独立变化，增加了系统的灵活性和可扩展性。\",\"可维护性：通过使用观察者模式，可以更容易地维护和理解对象之间的关系。\",\"可重用性：主题和观察者可以在不同的场景中被重用，增加了代码的复用性。\",\"观察者设计模式的缺点包括：\",\"如果观察者较多或处理逻辑较复杂，可能导致性能问题。\",\"观察者之间的通信是单向的，观察者之间无法直接通信，需要通过主题进行中转。\",\"总的来说，观察者设计模式是一种非常有用的模式，它能够实现对象之间的松耦合、动态通信和状态同步，提高系统的可维护性和灵活性。通过合理的设计和使用，可以在事件驱动的系统中发挥重要作用。\"]},\"329\":{\"h\":\"二、模板设计模式\"},\"330\":{\"h\":\"1、介绍\",\"t\":[\"模板方法设计模式（Template Method Pattern），它定义了一个操作中的算法框架，将一些步骤的具体实现延迟到子类中。该模式允许在不改变算法结构的情况下，通过子类实现具体步骤，从而提供了一种代码复用和扩展的方法。\",\"重点内容：\",\"定义了一个模板方法，其中包含了算法的基本骨架，但某些步骤的具体实现由子类决定。\",\"子类可以根据需要重写父类中的方法，以提供特定的实现。 \",\"不变的放在模板里，变化的放在子类实现\"]},\"331\":{\"h\":\"2、核心思想\",\"t\":[\"模板方法设计模式的核心思想在于定义一个抽象类，其中包含了算法的模板（即模板方法）。模板方法中会调用多个抽象方法，这些方法由子类负责实现。通过这种方式，可以确保算法的结构稳定，同时在子类中提供具体步骤的灵活实现。\"]},\"332\":{\"h\":\"3、组成和基本流程\",\"t\":[\"模板方法设计模式主要由以下组成部分构成：\",\"AbstractClass（抽象类）：定义了一个模板方法，其中包含了算法的基本骨架，以及若干抽象方法，这些抽象方法由子类负责实现。\",\"ConcreteClass（具体类）：继承自抽象类，实现了在抽象类中定义的抽象方法，从而提供了对算法中特定步骤的具体实现。\",\"基本流程如下：\",\"定义抽象类，其中包含了一个模板方法和若干抽象方法。\",\"子类继承抽象类，并实现其中的抽象方法。\",\"在客户端中，通过实例化具体类对象，调用模板方法执行算法，具体步骤由子类实现。\",\"示例代码：\",\"public abstract class AbstractClass { // 模板方法，定义了算法的基本骨架 public final void templateMethod() { step1(); step2(); step3(); } // 抽象方法，由子类实现 protected abstract void step1(); protected abstract void step2(); protected abstract void step3(); } public class ConcreteClass extends AbstractClass { // 实现抽象方法 protected void step1() { // 具体步骤实现 } protected void step2() { // 具体步骤实现 } protected void step3() { // 具体步骤实现 } } \"]},\"333\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"模板方法设计模式适用于以下情况：\",\"当算法中的结构相对稳定，但其中某些步骤的具体实现可能会变化时，可以进行复用的功能。\",\"当希望在不改变算法整体结构的情况下，能够灵活地扩展和修改其中某些步骤的实现，可以进行拓展的功能。\",\"当结合具体业务场景时，模板方法设计模式可以应用于以下情况：\",\"数据导入处理：假设我们有一个数据导入系统，用于从不同来源（例如Excel文件、CSV文件、数据库等）导入数据，并将其存储到数据库中。整个导入过程有一定的稳定结构，如打开数据源、解析数据、数据校验、数据存储等。但不同的数据来源可能需要不同的数据解析和校验逻辑。我们可以将整个数据导入过程定义为一个模板方法，其中通用的处理步骤在抽象类中实现，而数据解析和校验的具体实现则由子类（不同数据来源对应的子类）来完成。\",\"订单处理：考虑一个电商平台的订单处理系统，其中订单的创建、支付、物流等过程有一些共性步骤，如生成订单号、验证支付、发货等。但不同类型的订单（普通订单、预定订单、退货订单）可能在这些共性步骤上有所不同，比如退货订单需要额外进行退款处理。我们可以将订单处理过程抽象为模板方法，将共性步骤放在抽象类中实现，然后每种订单类型对应一个具体子类，实现特定类型订单的处理逻辑。\",\"游戏关卡设计：在游戏开发中，不同关卡的设计可能有一些相似的元素，如敌人生成、任务目标、胜利条件等。但每个关卡的地图、敌人种类和数量、任务难度等可能会有所不同。我们可以将关卡设计抽象为模板方法，将共性的关卡元素放在抽象类中实现，然后每个具体关卡对应一个子类，实现特定关卡的设计。\",\"流程审批系统：在企业中，审批流程通常有一定的通用结构，如提交申请、审批处理、审核记录等。不同类型的申请（请假申请、报销申请、加班申请等）可能在审批处理上有所不同，比如请假申请需要额外的日期计算，报销申请需要金额核对。我们可以将审批流程抽象为模板方法，将通用的审批步骤放在抽象类中实现，然后每种申请类型对应一个具体子类，实现特定申请的审批逻辑。\",\"这些场景中，模板方法设计模式能够将稳定的处理流程与特定实现解耦，使得代码更加灵活、易于维护和扩展。同时，通过在抽象类中定义模板方法，可以促使开发人员在子类中实现特定步骤，提高代码的一致性和可读性。\"]},\"334\":{\"h\":\"4.1 复用\"},\"335\":{\"h\":\"具体案例1：InputStream\",\"t\":[\"在Java的标准库中，有一个经典的例子是java.io.InputStream类，它是所有输入流的抽象基类。这个类定义了一个模板方法read()，用于读取输入流中的数据。下面是一个简化的示例：\",\"import java.io.IOException; public abstract class InputStream { // 模板方法，定义了读取输入流中的数据的基本骨架 public final void readData() throws IOException { open(); while (!isEndOfStream()) { int data = readByte(); process(data); } close(); } // 抽象方法，由子类实现具体的输入流打开逻辑 protected abstract void open() throws IOException; // 抽象方法，由子类实现具体的数据读取逻辑 protected abstract int readByte() throws IOException; // 抽象方法，由子类实现具体的数据处理逻辑 protected abstract void process(int data); // 具体方法，判断是否达到输入流的末尾 protected boolean isEndOfStream() { // 具体判断逻辑 } // 具体方法，由子类实现具体的输入流关闭逻辑 protected void close() throws IOException { // 具体关闭逻辑 } } // 具体类：FileInputStream public class FileInputStream extends InputStream { // 实现抽象方法：打开文件输入流 protected void open() throws IOException { // 具体的文件打开逻辑 } // 实现抽象方法：读取文件中的字节数据 protected int readByte() throws IOException { // 具体的读取字节逻辑 } // 实现抽象方法：处理读取到的字节数据 protected void process(int data) { // 具体的处理逻辑 } // 重写父类方法：判断是否达到文件末尾 protected boolean isEndOfStream() { // 具体判断文件末尾的逻辑 } // 实现抽象方法：关闭文件输入流 protected void close() throws IOException { // 具体的文件关闭逻辑 } } \",\"在这个例子中，InputStream类是一个抽象类，它定义了一个模板方法readData()，该方法定义了读取输入流中数据的基本流程（打开流、读取数据、处理数据、关闭流）。具体的实现细节则交给子类去实现，子类必须提供具体的输入流的打开、读取、处理和关闭的逻辑。这样，我们可以通过继承抽象类并实现具体的方法，来创建不同类型的输入流，例如FileInputStream、ByteArrayInputStream等，实现了具体的数据读取逻辑。\",\"希望这个例子能够更好地展示模板方法设计模式的应用。再次向你表示抱歉，并感谢你的理解！\"]},\"336\":{\"h\":\"具体案例2：生成报告模板\",\"t\":[\"假设我们有一个报告生成系统，其中包含不同类型的报告，如PDF报告、Word报告等。这些报告的生成过程有一定的共性，比如首先需要进行数据查询，然后根据查询结果填充报告内容，并最终导出为指定格式的文件。\",\"使用模板方法设计模式，我们可以定义一个报告生成的抽象类，其中包含一个模板方法generateReport()，它定义了生成报告的基本骨架。然后，我们可以创建不同的具体报告类，如PDFReport和WordReport，它们继承自抽象类，并实现其中的抽象方法。\",\"// 抽象类：报告生成模板 public abstract class ReportTemplate { // 模板方法，定义报告生成的基本骨架 public final void generateReport() { fetchData(); fillContent(); exportReport(); } // 抽象方法，由子类实现具体的数据查询 protected abstract void fetchData(); // 抽象方法，由子类实现具体的报告内容填充 protected abstract void fillContent(); // 抽象方法，由子类实现具体的报告导出 protected abstract void exportReport(); } // 具体类：PDF报告 public class PDFReport extends ReportTemplate { protected void fetchData() { // 实现PDF报告的数据查询逻辑 } protected void fillContent() { // 实现PDF报告的内容填充逻辑 } protected void exportReport() { // 实现PDF报告的导出逻辑 } } // 具体类：Word报告 public class WordReport extends ReportTemplate { protected void fetchData() { // 实现Word报告的数据查询逻辑 } protected void fillContent() { // 实现Word报告的内容填充逻辑 } protected void exportReport() { // 实现Word报告的导出逻辑 } } \",\"通过这种方式，我们实现了报告生成过程的复用，因为不同类型的报告共用了相同的生成算法框架，但其中的具体步骤由子类实现，使得我们可以灵活地扩展和修改报告生成的某些步骤。\"]},\"337\":{\"h\":\"4.2 拓展\"},\"338\":{\"h\":\"具体案例1：Java Servelt\",\"t\":[\"当扩展到处理HTTP的GET、POST和PUT请求时，我们可以在抽象类MyServlet中增加对doPost()和doPut()方法的支持。这样，我们可以在模板方法中处理通用的逻辑，并在具体的子类中实现特定请求类型的处理。\",\"这段代码展示了一个简化的Java Servlet的示例。\",\"定义了一个抽象类MyServlet，它继承自HttpServlet，这是Java Servlet的基类。MyServlet中有三个模板方法：doGet()、doPost()和doPut()，它们分别处理HTTP的GET、POST和PUT请求，并调用相应的抽象方法处理具体的请求逻辑。\",\"抽象类中定义了三个抽象方法：handleGetRequest()、handlePostRequest()和handlePutRequest()，这些方法是由子类来实现的，用于处理特定类型的HTTP请求的逻辑。\",\"创建了一个具体子类MyServletImpl，它继承自抽象类MyServlet。在MyServletImpl中，我们实现了父类中定义的三个抽象方法，分别处理GET、POST和PUT请求的逻辑。\",\"这个示例中的MyServlet抽象类可以作为一个基类，用于处理不同类型的HTTP请求，而具体的子类如MyServletImpl则负责实现特定类型请求的处理逻辑。这种结构允许我们在一个抽象的框架中定义通用的请求处理流程，并在具体的子类中提供个性化的实现，实现了模板方法设计模式的思想：\",\"public abstract class MyServlet extends HttpServlet { // 模板方法，处理HTTP请求并生成响应 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { // 执行一些通用的处理逻辑 // 调用抽象方法，由子类实现特定的处理逻辑 handleGetRequest(request, response); // 执行一些通用的处理逻辑 } // 模板方法，处理HTTP POST请求并生成响应 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException { // 执行一些通用的处理逻辑 // 调用抽象方法，由子类实现特定的处理逻辑 handlePostRequest(request, response); // 执行一些通用的处理逻辑 } // 模板方法，处理HTTP PUT请求并生成响应 protected void doPut(HttpServletRequest request, HttpServletResponse response) throws IOException { // 执行一些通用的处理逻辑 // 调用抽象方法，由子类实现特定的处理逻辑 handlePutRequest(request, response); // 执行一些通用的处理逻辑 } // 抽象方法，由子类实现特定的GET请求处理逻辑 protected abstract void handleGetRequest(HttpServletRequest request, HttpServletResponse response) throws IOException; // 抽象方法，由子类实现特定的POST请求处理逻辑 protected abstract void handlePostRequest(HttpServletRequest request, HttpServletResponse response) throws IOException; // 抽象方法，由子类实现特定的PUT请求处理逻辑 protected abstract void handlePutRequest(HttpServletRequest request, HttpServletResponse response) throws IOException; } // 具体类：MyServletImpl public class MyServletImpl extends MyServlet { // 实现抽象方法：处理GET请求逻辑 protected void handleGetRequest(HttpServletRequest request, HttpServletResponse response) throws IOException { // 具体的GET请求处理逻辑 } // 实现抽象方法：处理POST请求逻辑 protected void handlePostRequest(HttpServletRequest request, HttpServletResponse response) throws IOException { // 具体的POST请求处理逻辑 } // 实现抽象方法：处理PUT请求逻辑 protected void handlePutRequest(HttpServletRequest request, HttpServletResponse response) throws IOException { // 具体的PUT请求处理逻辑 } } \",\"通过在抽象类中添加doPost()和doPut()的支持，我们使得MyServlet能够处理HTTP的GET、POST和PUT请求。在具体的子类中，我们分别实现了handleGetRequest()、handlePostRequest()和handlePutRequest()方法，来处理相应的请求逻辑。\",\"这个例子展示了模板方法设计模式在处理不同类型的HTTP请求时的应用。通过模板方法，我们可以复用通用的处理逻辑，同时为不同类型的请求提供灵活的特定处理实现。\"]},\"339\":{\"h\":\"5、总结\",\"t\":[\"优点：\",\"模板方法设计模式提高了代码复用性，通过将算法的公共部分抽象到父类中，确保了这些公共步骤在所有子类中的一致性实现，避免了重复代码的出现。\",\"可以灵活地扩展和修改算法的某些步骤，无需改变整体结构。子类可以通过实现抽象方法来覆盖或添加特定步骤，实现个性化的功能扩展。\",\"缺点：\",\"引入了抽象类和抽象方法，增加了代码的复杂性。在一些简单的场景下，使用模板方法可能会导致类的层次结构变得复杂，不利于代码的维护。\",\"如果算法的变化点过多，可能需要在抽象类中定义大量的抽象方法，增加了子类的实现复杂性和代码的理解难度。\",\"总体而言，模板方法设计模式在许多情况下都能很好地提高代码的复用性和灵活性。在设计和开发过程中，我们需要根据实际情况来判断是否适合使用模板方法，并平衡代码的复杂性和灵活性。合理地应用模板方法设计模式可以使代码更加清晰、易于维护，并且降低了修改代码时引入错误的风险。\"]},\"340\":{\"h\":\"三、策略设计模式\"},\"341\":{\"h\":\"1、介绍\",\"t\":[\"策略设计模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时选择算法的实现方式，从而使得算法的变化独立于使用算法的客户端。这种模式通过将不同的算法封装成独立的策略类，并在上下文类中持有一个策略对象，来实现灵活的算法替换和扩展。\"]},\"342\":{\"h\":\"2、核心思想\",\"t\":[\"策略设计模式的核心思想是把算法的定义和使用分开，将算法的具体实现封装在策略类中，然后在上下文类中持有一个策略对象，通过调用策略对象的方法来执行具体的算法。这样，当需要改变算法时，只需要替换相应的策略对象，而无需修改上下文类的代码，实现了算法和客户端的解耦。\",\"个人理解，不就是多态吗，传入的策略是一个接口，可以传入所有实现了该策略的具体实现，根据传入策略不同，选择不同算法实现。\"]},\"343\":{\"h\":\"3、组成和基本流程\",\"t\":[\"策略设计模式由以下几个关键组件组成：\",\"Strategy（策略接口）：策略接口定义了算法的统一接口，所有具体策略类都需要实现该接口。\",\"ConcreteStrategy（具体策略）：具体策略类是策略接口的实现类，每个具体策略类实现了一种具体的算法。\",\"Context（上下文）：上下文类持有一个策略对象，并在需要执行算法时调用策略对象的方法。\",\"策略设计模式的基本流程：\",\"上下文类持有一个策略接口对象。\",\"客户端根据需求选择具体的策略，并将其传递给上下文类。\",\"上下文类在需要执行算法时，调用策略接口的方法。\",\"具体的策略类根据实现方式执行算法。\",\"以下是一个使用策略设计模式的简单的示例：\",\"允许用户输入不同的符号来选择不同的策略进行计算，以下是用于接受用户输入并根据输入选择策略的代码：\",\"// 策略接口 interface Strategy { int execute(int m, int n); } // 具体策略-加法策略 class AddStrategy implements Strategy { @Override public int execute(int m, int n) { return m + n; } } // 具体策略-除法策略 class DivStrategy implements Strategy { @Override public int execute(int m, int n) { if (n == 0) { throw new IllegalArgumentException(\\\"除数不能为零！\\\"); } return m / n; } } class Computer { // 持有策略 private Strategy strategy; public void setStrategy(Strategy strategy) { // 设置策略 this.strategy = strategy; } public int calculator(int x, int y) { return strategy.execute(x, y); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建上下文 Computer computer = new Computer(); while (true) { System.out.println(\\\"请输入运算符号（+表示加法，/表示除法，q表示退出）:\\\"); String input = scanner.nextLine(); if (input.equalsIgnoreCase(\\\"q\\\")) { break; } Strategy strategy; if (input.equals(\\\"+\\\")) { strategy = new AddStrategy(); } else if (input.equals(\\\"/\\\")) { strategy = new DivStrategy(); } else { System.out.println(\\\"无效输入。请输入+、/或q。\\\"); continue; } // 设置策略 computer.setStrategy(strategy); // 获取运算数 System.out.println(\\\"请输入第一个数字:\\\"); int x = scanner.nextInt(); System.out.println(\\\"请输入第二个数字:\\\"); int y = scanner.nextInt(); scanner.nextLine(); // 使用 int result = computer.calculator(x, y); System.out.println(\\\"计算结果: \\\" + result); } System.out.println(\\\"再见！\\\"); scanner.close(); } } \",\"这个示例非常清晰地展示了策略设计模式的优势，通过策略模式，我们可以轻松地实现算法的替换，而不必修改 Computer 类的代码。这样的设计使得代码更加灵活、可扩展和易于维护。\"]},\"344\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"策略设计模式适用于以下场景：\",\"当一个类需要根据条件选择不同的算法时，可以使用策略模式来避免使用多个if-else语句。\",\"当一个类有多个相似的算法，并且客户端需要动态地选择其中一个时，可以使用策略模式来实现算法的灵活替换。\",\"业务场景\",\"我们的电商平台支持多种支付方式，包括支付宝支付、微信支付和信用卡支付。每种支付方式的支付逻辑不同，但是在用户提交订单时，我们并不知道用户会选择哪种支付方式。\",\"策略设计模式案例：\",\"首先，我们定义一个策略接口 PaymentStrategy，其中包含一个 pay 方法用于执行支付逻辑。然后，我们创建三个具体的支付策略类：AlipayStrategy、WeChatPayStrategy 和 CreditCardPayStrategy，分别实现了支付宝支付、微信支付和信用卡支付的具体逻辑。\",\"接下来，我们创建一个 PaymentContext 类作为上下文类，它持有一个支付策略对象，并提供了 setPaymentStrategy 方法用于设置支付策略。在 PaymentContext 类中，我们通过调用支付策略对象的 pay 方法来执行具体的支付逻辑。\",\"最后，在客户端代码中，我们可以根据用户选择的支付方式来设置不同的支付策略，并执行支付操作。\",\"示例代码如下：\",\"// 策略接口 interface PaymentStrategy { void pay(double amount); } // 具体策略-支付宝支付 class AlipayStrategy implements PaymentStrategy { @Override public void pay(double amount) { System.out.println(\\\"使用支付宝支付：\\\" + amount + \\\"元\\\"); // 具体的支付逻辑 } } // 具体策略-微信支付 class WeChatPayStrategy implements PaymentStrategy { @Override public void pay(double amount) { System.out.println(\\\"使用微信支付：\\\" + amount + \\\"元\\\"); // 具体的支付逻辑 } } // 具体策略-信用卡支付 class CreditCardPayStrategy implements PaymentStrategy { @Override public void pay(double amount) { System.out.println(\\\"使用信用卡支付：\\\" + amount + \\\"元\\\"); // 具体的支付逻辑 } } // 上下文类 class PaymentContext { // 持有策略 private PaymentStrategy paymentStrategy; public void setPaymentStrategy(PaymentStrategy paymentStrategy) { // 设置策略 this.paymentStrategy = paymentStrategy; } public void makePayment(double amount) { paymentStrategy.pay(amount); } } // 客户端代码 public class Main { public static void main(String[] args) { // 创建上下文 PaymentContext paymentContext = new PaymentContext(); // 用户选择支付宝支付 PaymentStrategy alipayStrategy = new AlipayStrategy(); paymentContext.setPaymentStrategy(alipayStrategy); paymentContext.makePayment(100.0); // 用户选择微信支付 PaymentStrategy weChatPayStrategy = new WeChatPayStrategy(); paymentContext.setPaymentStrategy(weChatPayStrategy); paymentContext.makePayment(200.0); // 用户选择信用卡支付 PaymentStrategy creditCardPayStrategy = new CreditCardPayStrategy(); paymentContext.setPaymentStrategy(creditCardPayStrategy); paymentContext.makePayment(300.0); } } \",\"在这个案例中，策略设计模式帮助我们实现了不同支付方式的逻辑隔离和动态替换。当用户选择不同的支付方式时，我们可以灵活地设置不同的支付策略，而不必修改 PaymentContext 类的代码。这样的设计使得代码更加灵活、可扩展和易于维护。\",\"在实际的电商平台中，支付逻辑可能更加复杂，涉及支付安全、订单状态管理等，使用策略设计模式能够更好地组织和管理这些复杂的支付流程。\"]},\"345\":{\"h\":\"6、总结\",\"t\":[\"策略设计模式的优点包括：\",\"算法可互换：可以在运行时动态地选择算法，实现算法的灵活替换。\",\"避免多重条件判断：避免使用大量的if-else语句，增加代码的可读性和可维护性。\",\"提高可扩展性：可以方便地增加新的策略类，扩展系统的功能。\",\"策略设计模式的缺点包括：\",\"增加类的数量：每个具体策略类都需要一个对应的类，如果策略较多，会增加类的数量。\",\"策略的选择逻辑：客户端需要选择合适的策略，如果策略选择逻辑复杂，会增加客户端的复杂性。\",\"总的来说，策略设计模式是一种非常有用的模式，它可以将算法的定义和使用分开，实现算法的灵活替换，提高系统的可扩展性和可\",\"维护性。在合适的场景下，使用策略设计模式可以使代码更加清晰、简洁、易于理解和维护。\"]},\"346\":{\"h\":\"7、结合工厂设计模式\",\"t\":[\"使用策略设计模式和工厂设计模式可以有效消除代码中的 if-else 语句，使代码更加清晰、可维护和易于扩展。\",\"首先，我们可以创建一个工厂类来根据用户输入返回相应的策略对象。然后，我们使用策略设计模式将不同的策略封装在不同的类中，从而实现算法的动态切换。\",\"下面是一个示例代码：\",\"// 策略接口 interface Strategy { int execute(int m, int n); } // 具体策略-加法策略 class AddStrategy implements Strategy { @Override public int execute(int m, int n) { return m + n; } } // 具体策略-除法策略 class DivStrategy implements Strategy { @Override public int execute(int m, int n) { if (n == 0) { throw new IllegalArgumentException(\\\"除数不能为零！\\\"); } return m / n; } } // 策略工厂 class StrategyFactory { public static Strategy createStrategy(String input) { if (input.equals(\\\"+\\\")) { return new AddStrategy(); } else if (input.equals(\\\"/\\\")) { return new DivStrategy(); } else { throw new IllegalArgumentException(\\\"无效输入。请输入+或/。\\\"); } } } class Computer { // 持有策略 private Strategy strategy; public void setStrategy(Strategy strategy) { // 设置策略 this.strategy = strategy; } public int calculator(int x, int y) { return strategy.execute(x, y); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建上下文 Computer computer = new Computer(); while (true) { System.out.println(\\\"请输入运算符号（+表示加法，/表示除法，q表示退出）:\\\"); String input = scanner.nextLine(); if (input.equalsIgnoreCase(\\\"q\\\")) { break; } try { // 创建策略 Strategy strategy = StrategyFactory.createStrategy(input); // 设置策略 computer.setStrategy(strategy); // 获取运算数 System.out.println(\\\"请输入第一个数字:\\\"); int x = scanner.nextInt(); System.out.println(\\\"请输入第二个数字:\\\"); int y = scanner.nextInt(); scanner.nextLine(); // 使用 int result = computer.calculator(x, y); System.out.println(\\\"计算结果: \\\" + result); } catch (IllegalArgumentException e) { System.out.println(e.getMessage()); } } System.out.println(\\\"再见！\\\"); scanner.close(); } } \",\"在这个示例中，我们使用了策略设计模式将加法和除法封装在不同的策略类中，并通过工厂设计模式根据用户的输入动态创建相应的策略对象。这样，在主程序中，就不再需要使用繁琐的 if-else 语句，代码更加简洁、易读、易于扩展和维护。\",\"您说得对，每个序列化器实现类中的判断确实会导致代码耦合，而且还会违反开闭原则（Open-Closed Principle），因为每次添加新的版本需要修改已有的实现类。 为了避免这种耦合，我们可以进一步优化设计。我们可以使用策略模式和工厂模式的组合来解耦代码并支持添加新的版本，而不需要修改现有的实现类。 首先，我们将序列化逻辑从序列化器实现类中分离出来，创建一个新的策略接口`DeserializationStrategy`用于处理反序列化逻辑。 ```java public interface DeserializationStrategy { <T> T deserialize(byte[] bytes, Class<T> clazz); } ``` 然后，我们为每个版本创建一个实现`DeserializationStrategy`的具体策略类。 ```java public class Version1DeserializationStrategy implements DeserializationStrategy { @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) { // 实现版本1的反序列化逻辑 } } public class Version2DeserializationStrategy implements DeserializationStrategy { @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) { // 实现版本2的反序列化逻辑 } } // 添加更多版本的策略类... ``` 接下来，我们更新`Serializer`接口，将策略模式引入其中： ```java public interface Serializer { byte[] serialize(Object object); <T> T deserialize(byte[] bytes, Class<T> clazz); void registerDeserializationStrategy(int version, DeserializationStrategy strategy); } ``` 我们将`registerDeserializationStrategy`方法用于注册不同版本对应的反序列化策略。 接着，我们修改每个序列化器实现类，让它们实现新的`Serializer`接口，并将策略模式的逻辑添加到其中。 ```java public class HessianSerializer implements Serializer { private Map<Integer, DeserializationStrategy> deserializationStrategies = new HashMap<>(); @Override public byte[] serialize(Object object) { // 实现Hessian的序列化方法 } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) { return deserialize(bytes, clazz, 1); // 默认版本1的反序列化方式 } @Override public void registerDeserializationStrategy(int version, DeserializationStrategy strategy) { deserializationStrategies.put(version, strategy); } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz, int version) { DeserializationStrategy strategy = deserializationStrategies.get(version); if (strategy != null) { return strategy.deserialize(bytes, clazz); } else { // 版本不兼容时，默认选择版本1的反序列化逻辑 return deserialize(bytes, clazz); } } } // 同样更新Fastjson2Serializer public class Fastjson2Serializer implements Serializer { // ... 其他代码 ... private Map<Integer, DeserializationStrategy> deserializationStrategies = new HashMap<>(); @Override public byte[] serialize(Object object) { // 实现Fastjson2的序列化方法 } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz) { return deserialize(bytes, clazz, 1); // 默认版本1的反序列化方式 } @Override public void registerDeserializationStrategy(int version, DeserializationStrategy strategy) { deserializationStrategies.put(version, strategy); } @Override public <T> T deserialize(byte[] bytes, Class<T> clazz, int version) { DeserializationStrategy strategy = deserializationStrategies.get(version); if (strategy != null) { return strategy.deserialize(bytes, clazz); } else { // 版本不兼容时，默认选择版本1的反序列化逻辑 return deserialize(bytes, clazz); } } } ``` 在上述实现中，我们将策略模式应用到序列化器实现类中，通过`registerDeserializationStrategy`方法注册不同版本的反序列化策略，并在`deserialize`方法中根据版本号选择对应的策略进行反序列化操作。如果版本不兼容，仍然可以选择默认的版本1的反序列化方式。 最后，在主程序中，您可以使用这些序列化器，并注册不同版本的反序列化策略。 ```java public class Main { public static void main(String[] args) { Serializer hessianSerializer = new HessianSerializer(); Serializer fastjsonSerializer = new Fastjson2Serializer(); int version = 2; // 假设报文传入的版本号为2 Serializer serializer = version == 2 ? fastjsonSerializer : hessianSerializer; // 注册不同版本的反序列化策略 serializer.registerDeserializationStrategy(1, new Version1DeserializationStrategy()); serializer.registerDeserializationStrategy(2, new Version2DeserializationStrategy()); // 可以继续注册更多版本的策略... // 假设bytes为序列化后的字节数组 byte[] bytes = // ...; // 假设clazz为目标类的Class对象 Class<?> clazz = // ...; // 反序列化 Message deserializedMessage = serializer.deserialize(bytes, clazz, version); System.out.println(\\\"Deserialized message: \\\" + deserializedMessage); } } ``` 通过使用策略模式和工厂模式的组合，我们成功解耦了代码，并可以根据版本号注册不同的反序列化策略，使得代码更加灵活和可扩展。新的版本也可以很方便地添加到现有系统中，而不需要修改已有的实现类。 \"]},\"347\":{\"h\":\"四、责任链设计模式\"},\"348\":{\"h\":\"1、介绍\",\"t\":[\"责任链设计模式（Chain of Responsibility Pattern）是一种行为型设计模式，它通过为请求创建一个接收者链，将多个处理器（或接收者）连接在一起，依次尝试处理请求。当一个请求进入责任链时，每个处理器将依次检查自己是否能够处理该请求，如果可以处理，则进行处理，如果不能处理，则将请求传递给下一个处理器。\",\"请求：不只是http请求，任何一个方法的调用也是请求\"]},\"349\":{\"h\":\"2、核心思想\",\"t\":[\"责任链设计模式的核心思想是解耦请求的发送者和接收者，将多个处理器组成一个链条，并在运行时动态决定请求的处理顺序。当一个请求进入责任链时，责任链上的每个处理器都有机会处理该请求，直到有一个处理器能够处理它为止。这样，每个处理器只需要关心自己能否处理该请求，而无需关心其他处理器的存在。\"]},\"350\":{\"h\":\"3、组成和基本流程\",\"t\":[\"责任链设计模式由以下几个要素组成：\",\"Handler（处理器）：定义一个处理请求的接口，并持有下一个处理器的引用。\",\"ConcreteHandler（具体处理器）：实现处理器接口，对请求进行实际处理。如果不能处理请求，则将请求传递给下一个处理器。\",\"Client（客户端）：创建责任链并将请求发送给责任链的头部。\",\"基本流程：\",\"客户端创建多个具体处理器，并将它们按照处理顺序连接成责任链。\",\"当一个请求进入责任链时，责任链上的第一个处理器开始检查是否能够处理该请求。\",\"如果能够处理，则进行处理并结束。\",\"如果不能处理，则将请求传递给下一个处理器，继续检查，直到有一个处理器能够处理该请求。\",\"以下是一个使用责任链设计模式的简单的示例：\",\"// Handler（处理器）接口 interface Handler { void handleRequest(int request); void setNextHandler(Handler nextHandler); } // ConcreteHandler（具体处理器）类 class ConcreteHandlerA implements Handler { private Handler nextHandler; @Override public void handleRequest(int request) { if (request >= 0 && request < 10) { System.out.println(\\\"ConcreteHandlerA 处理请求: \\\" + request); } else if (nextHandler != null) { nextHandler.handleRequest(request); } } @Override public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } } class ConcreteHandlerB implements Handler { private Handler nextHandler; @Override public void handleRequest(int request) { if (request >= 10 && request < 20) { System.out.println(\\\"ConcreteHandlerB 处理请求: \\\" + request); } else if (nextHandler != null) { nextHandler.handleRequest(request); } } @Override public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } } class ConcreteHandlerC implements Handler { @Override public void handleRequest(int request) { if (request >= 20 && request < 30) { System.out.println(\\\"ConcreteHandlerC 处理请求: \\\" + request); } else { System.out.println(\\\"没有处理器能够处理该请求: \\\" + request); } } @Override public void setNextHandler(Handler nextHandler) { // ConcreteHandlerC 是责任链的末端，不需要持有下一个处理器的引用 } } // Client（客户端）类 public class Main { public static void main(String[] args) { // 创建具体处理器 Handler handlerA = new ConcreteHandlerA(); Handler handlerB = new ConcreteHandlerB(); Handler handlerC = new ConcreteHandlerC(); // 构建责任链 handlerA.setNextHandler(handlerB); handlerB.setNextHandler(handlerC); // 客户端发送请求 int[] requests = {5, 15, 25, 35}; for (int request : requests) { handlerA.handleRequest(request); } } } \",\"在上述示例中，我们创建了三个具体处理器类（ConcreteHandlerA、ConcreteHandlerB、ConcreteHandlerC），它们分别能处理不同范围的请求。客户端（Main类）创建了这三个处理器，并按照处理顺序连接成了一个责任链。\",\"当客户端发送请求时，请求会从责任链的头部（handlerA）开始传递，每个处理器检查是否能够处理该请求，如果能够处理，则进行处理，否则将请求传递给下一个处理器。这样，只有能够处理该请求的处理器会进行处理，实现了请求的动态分发和处理。\",\"请注意，ConcreteHandlerC 是责任链的末端，并不需要持有下一个处理器的引用，因为它没有后继处理器。当请求到达末端后，如果没有任何处理器能够处理该请求，则会输出\\\"没有处理器能够处理该请求\\\"。\"]},\"351\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"责任链设计模式在以下情况下适用：\",\"当一个请求需要被多个对象处理，但具体的处理对象在运行时才能确定时。责任链模式允许在运行时动态地确定请求的处理顺序，从而实现灵活的处理流程。\",\"当希望避免请求发送者与接收者之间的耦合关系，或者希望动态地指定处理请求的对象时。责任链模式将请求发送者和接收者解耦，使得请求发送者无需知道是哪个接收者处理了请求，而接收者也无需知道请求的发送者是谁，从而增强了系统的灵活性和可扩展性。\"]},\"352\":{\"h\":\"具体案例\",\"t\":[\"责任链设计模式在实际应用中有许多场景，以下是一些具体案例：\",\"Servlet Filter：在Java Web开发中，Servlet Filter是一种典型的责任链模式的应用。Filter用于在Servlet请求被处理之前或之后对请求和响应进行预处理和后处理。可以通过配置多个Filter，并按照一定的顺序将它们连接成责任链，使得请求依次经过各个Filter进行处理。\",\"Spring Interceptor：在Spring框架中，Interceptor也是一种责任链模式的应用。Interceptor用于在请求被处理之前或之后进行一些公共的处理逻辑，如权限验证、日志记录等。可以通过配置多个Interceptor，并按照一定的顺序将它们连接成责任链，从而实现对请求的预处理和后处理。\",\"MyBatis中的插件：MyBatis是一个流行的Java持久化框架，它允许用户编写自定义的插件来扩展其功能。插件就是一种责任链模式的应用，可以通过插件在SQL执行前后进行拦截和处理，实现一些自定义的功能，如日志记录、缓存处理等，一层一层的代理包装。\",\"这些具体案例展示了责任链设计模式在实际项目中的灵活应用，通过将处理逻辑拆分成多个处理器，并将它们连接成责任链，可以实现更加灵活、可扩展和可维护的代码结构。\"]},\"353\":{\"h\":\"具体案例-链表实现\",\"t\":[\"这是一个简单的责任链设计模式示例代码，模拟了一个处理器链（HandlerChain）和两个具体处理器（LoggingHandler和ValidationHandler）。这些处理器按照添加的顺序依次处理请求。\",\"Handler 是抽象处理器类，定义了处理器的基本结构，并持有下一个处理器的引用。\",\"LoggingHandler 是具体处理器类，负责对请求进行日志处理。\",\"ValidationHandler 是具体处理器类，负责对请求进行数据校验。\",\"HandlerChain 是处理器链类，持有处理器链的头部和尾部，并提供添加处理器和执行处理器链的方法。\",\"在 Main 类中，创建了一个处理器链 chain，并向其添加了 LoggingHandler 和 ValidationHandler。然后，通过调用 chain.doChain(\\\"登录请求\\\") 来触发处理器链的执行，从而依次处理请求。\",\"调用输出：\",\"登录请求经过了日志处理器....打了进入日志 登录请求经过了日志处理器....进行的数据校验 \",\"public class Main { public static void main(String[] args) { HandlerChain chain = new HandlerChain(); chain.addHandler(new LoggingHandler()); chain.addHandler(new ValidationHandler()); chain.doChain(\\\"登录请求\\\"); } } abstract class Handler { protected Handler next; public Handler() { } public Handler(Handler next) { this.next = next; } public abstract void handle(String product); } class LoggingHandler extends Handler { @Override public void handle(String product) { System.out.println(product + \\\"经过了日志处理器....打了进入日志\\\"); } } class ValidationHandler extends Handler { @Override public void handle(String product) { System.out.println(product + \\\"经过了日志处理器....进行的数据校验\\\"); } } class HandlerChain { protected Handler head; protected Handler tail; public void addHandler(Handler handler) { if (head == null && tail == null) { head = handler; tail = handler; } tail.next = handler; tail = handler; } public void doChain(String msg) { if (head != null) { Handler p = head; while (p != null) { p.handle(msg); p = p.next; } } } } \",\"此示例代码演示了责任链设计模式的基本实现方式，它允许灵活地添加、移除和调整处理器的顺序，从而实现不同的处理逻辑和扩展。在实际应用中，可以根据业务需求定义更复杂的处理器链，并实现更多的具体处理器来满足不同的需求。\"]},\"354\":{\"h\":\"具体案例-数组实现\",\"t\":[\"在这个示例中，HandlerChain类持有一个List<Handler>，并提供了addHandler方法用于添加处理器到链中。doChain方法遍历链中的处理器，并依次调用它们的handle方法，从而实现责任链的执行。\",\"public class Main { public static void main(String[] args) { HandlerChain chain = new HandlerChain(); chain.addHandler(new LoggingHandler()); chain.addHandler(new ValidationHandler()); chain.doChain(\\\"登录请求\\\"); } } abstract class Handler { public Handler() { } public abstract void handle(String product); } class LoggingHandler extends Handler { @Override public void handle(String product) { System.out.println(product + \\\"经过了日志处理器....打了进入日志\\\"); } } class ValidationHandler extends Handler { @Override public void handle(String product) { System.out.println(product + \\\"经过了日志处理器....进行的数据校验\\\"); } } class HandlerChain { protected List<Handler> handlers; public HandlerChain() { this.handlers = new ArrayList<>(); } public void addHandler(Handler handler) { handlers.add(handler); } public void doChain(String msg) { for (Handler handler : handlers) { handler.handle(msg); } } } \"]},\"355\":{\"h\":\"5、总结\",\"t\":[\"责任链设计模式的优点：\",\"解耦请求发送者和接收者，增强了代码的灵活性和可扩展性。\",\"动态地组织和分配处理器，简化了代码的维护和扩展。\",\"责任链设计模式的缺点：\",\"可能会导致请求在责任链上无法被处理。\",\"需要遍历整个责任链，对性能有一定影响。\",\"总体而言，责任链设计模式在一些特定的场景下能够带来很大的便利，但也需要谨慎使用，避免责任链过长或者过于复杂，其次责任链模式在工作中的应用非常广泛，它可以在很多场景中帮助我们实现灵活的请求处理和任务分配。\",\"以下是一些常见的使用场景：\",\"日志记录器：在应用程序中，我们可能需要将日志记录到不同的位置，如控制台、文件、数据库等。我们可以创建一个日志记录器链，每个记录器处理特定级别的日志，然后将请求传递给下一个记录器。这样，可以根据日志级别灵活地记录日志信息。\",\"Web应用中的过滤器和拦截器：在Web应用程序中，我们经常需要对请求进行预处理和后处理，如身份验证、授权、编码转换、请求日志记录等。过滤器和拦截器就是典型的使用责任链模式的场景，请求和响应在过滤器或拦截器链中依次传递，每个过滤器或拦截器执行特定的任务。\",\"工作流引擎：在一个工作流引擎中，一个请求可能需要经过多个处理步骤，这些步骤可以看作是一个责任链。每个处理器处理请求的一个部分，然后将请求传递给下一个处理器，直到请求被完全处理。\",\"软件审批流程：在企业软件开发过程中，代码审查、需求审批、文档审查等流程可能需要多个审批者按顺序审批。这种场景下，责任链模式能够确保每个审批者只关注自己的审批职责，并将审批请求传递给下一个审批者。\",\"电子邮件处理：在一个电子邮件处理系统中，可能需要对不同类型的邮件进行不同的处理，如垃圾邮件过滤、自动回复、邮件归类等。在这种情况下，可以使用责任链模式来创建一个邮件处理链，每个处理器负责处理特定类型的邮件，然后将邮件传递给下一个处理器。\",\"事件处理系统：在一个事件驱动的系统中，可能需要对不同类型的事件进行不同的处理。责任链模式可以用于创建一个事件处理器链，每个处理器负责处理特定类型的事件，并将事件传递给下一个处理器。这样可以确保系统的可扩展性和灵活性。\",\"规则引擎：在某些业务场景下，可能需要按照一定的规则对数据进行处理。规则引擎是典型的使用责任链模式的场景。每个规则可以看作是一个处理器，对数据进行特定的处理，然后将数据传递给下一个规则，直至所有规则都被执行。\",\"任务调度系统：在任务调度系统中，根据任务的优先级、类型和资源需求，可能需要将任务分配给不同的执行器。责任链模式可以确保每个执行器只关注自己可以处理的任务，并将其他任务传递给下一个执行器。\",\"在这些场景中，责任链模式使得请求的处理和任务的分配变得灵活和可配置，同时保持了各个处理器之间的解耦，使得系统具有更好的扩展性和可维护性。因此，责任链模式是很多系统设计中常用的一种设计模式。\"]},\"356\":{\"h\":\"五、状态设计模式\"},\"357\":{\"h\":\"1、介绍\",\"t\":[\"状态设计模式（State Pattern），又称状态模式，是一种行为型设计模式。它允许一个对象在其内部状态发生改变时改变其行为，使得对象在不同状态下具有不同的行为。状态模式的关键在于将对象的状态封装成独立的类，并将请求委派给当前状态对象进行处理。这样可以避免在对象中使用大量的条件语句来判断状态，并将状态转换逻辑集中管理，使得代码更加清晰和易于维护。\"]},\"358\":{\"h\":\"2、核心思想\",\"t\":[\"状态设计模式的核心思想是将对象的状态抽象成独立的类，每个状态类都实现了相同的接口，表示对象在该状态下的行为。对象内部维护一个状态对象，根据不同的状态委派请求给对应的状态类处理。当对象的状态发生改变时，可以动态地切换状态对象，从而改变对象的行为。\"]},\"359\":{\"h\":\"3、组成和基本流程\",\"t\":[\"状态设计模式由以下几个要素组成：\",\"Context（上下文）：定义客户端感兴趣的接口，并持有一个具体状态的引用。\",\"State（状态）：定义一个接口来封装与Context的一个特定状态相关的行为。\",\"ConcreteState（具体状态）：实现State接口，每个具体状态类负责对应状态下的行为实现。\",\"Client（客户端）：通过Context类来与状态对象进行交互，实现状态切换。\",\"基本流程：\",\"客户端创建Context对象，并初始化为某个具体状态的对象。\",\"Context对象接收客户端的请求，并委派给当前具体状态对象处理。\",\"具体状态对象根据当前状态处理请求，可能会导致状态发生改变。\",\"如果状态发生改变，Context对象切换到新的具体状态对象进行处理。\",\"以下是一个简单的状态设计模式代码案例：\",\"// State（状态）接口 interface State { void handle(); } // ConcreteState（具体状态）类 class ConcreteStateA implements State { @Override public void handle() { System.out.println(\\\"当前是状态A，执行状态A的行为\\\"); } } class ConcreteStateB implements State { @Override public void handle() { System.out.println(\\\"当前是状态B，执行状态B的行为\\\"); } } // Context（上下文）类 class Context { private State currentState; public Context() { currentState = new ConcreteStateA(); // 初始状态为状态A } public void setCurrentState(State currentState) { this.currentState = currentState; } public void request() { currentState.handle(); } } // Client（客户端）类 public class Main { public static void main(String[] args) { Context context = new Context(); context.request(); context.setCurrentState(new ConcreteStateB()); context.request(); } } \",\"在上述示例中，我们定义了一个简单的状态设计模式。State接口定义了一个handle方法，表示当前状态下的行为；ConcreteStateA和ConcreteStateB是两个具体状态类，分别实现了State接口，表示状态A和状态B下的行为。Context类是上下文类，持有当前的状态对象，并根据当前状态委派请求给相应的状态对象处理。客户端（Main类）创建了Context对象，并初始状态为状态A，然后调用request方法来执行当前状态的行为。接着，客户端切换状态为状态B，再次调用request方法来执行状态B下的行为。\"]},\"360\":{\"h\":\"4、使用场景\",\"t\":[\"状态设计模式适用于以下场景：\",\"当一个对象的行为取决于它的状态，并且该对象需要根据状态改变行为时。\",\"当一个对象有许多状态且状态之间的转换频繁发生时，使用状态模式可以避免大量的条件语句。\",\"当一个对象的行为包含大量与状态相关的代码，状态模式可以将不同状态的行为拆分成独立的类，使代码更加清晰和易于维护。\",\"现在我们来看一个简单的Java示例。假设我们要模拟一个简易的电视遥控器，具有开启、关闭和调整音量的功能。如果我们不使用设计模式，编写出来的代码可能是这个样子的，我们需要针对电视机当前的状态为每一次操作编写判断逻辑：\",\"public class TV { private boolean isOn; private int volume; public TV() { isOn = false; volume = 0; } public void turnOn() { // 如果是开启状态 if (isOn) { System.out.println(\\\"TV is already on.\\\"); } else { isOn = true; System.out.println(\\\"Turning on the TV.\\\"); } } public void turnOff() { if (isOn) { isOn = false; System.out.println(\\\"Turning off the TV.\\\"); } else { System.out.println(\\\"TV is already off.\\\"); } } public void adjustVolume(int volume) { if (isOn) { this.volume = volume; System.out.println(\\\"Adjusting volume to: \\\" + volume); } else { System.out.println(\\\"Cannot adjust volume, TV is off.\\\"); } } } public class Main { public static void main(String[] args) { TV tv = new TV(); tv.turnOn(); tv.adjustVolume(10); tv.turnOff(); } } \",\"当然在该例子中我们的状态比较少，所以代码看起来也不是很复杂，但是状态如果变多了呢？比如加入换台、快捷键、静音等功能后呢？你会发现条件分支会急速膨胀，所以此时状态设计模式就要登场了：\",\"//首先，我们定义抽象状态接口TVState，将每一个修改状态的动作抽象成个接口： interface TVState { void turnOn(); void turnOff(); void adjustVolume(int volume); } //接下来，我们为每个具体状态创建类，实现 `TVState` 接口。例如，我们创建 `TVOnState` 和 `TVOffState` 类 // 在on状态下，去执行以下各种操作 class TVOnState implements TVState { @Override public void turnOn() { System.out.println(\\\"TV is already on.\\\"); } @Override public void turnOff() { System.out.println(\\\"Turning off the TV.\\\"); } @Override public void adjustVolume(int volume) { System.out.println(\\\"Adjusting volume to: \\\" + volume); } } // 在关机的状态下执行以下的操作 class TVOffState implements TVState { @Override public void turnOn() { System.out.println(\\\"Turning on the TV.\\\"); } @Override public void turnOff() { System.out.println(\\\"TV is already off.\\\"); } @Override public void adjustVolume(int volume) { System.out.println(\\\"Cannot adjust volume, TV is off.\\\"); } } //接下来，我们定义上下文类 `TV` class TV { // 当前状态 private TVState state; public TV() { state = new TVOffState(); } public void setState(TVState state) { this.state = state; } public void turnOn() { // 打开 state.turnOn(); // 设置为开机状态 setState(new TVOnState()); } public void turnOff() { // 关闭 state.turnOff(); // 设置为关机状态 setState(new TVOffState()); } public void adjustVolume(int volume) { state.adjustVolume(volume); } } //现在，我们可以在游戏中根据角色的状态来执行不同的行为，而不需要直接在 `Character` 类中进行大量的条件判断。 public class Main { public static void main(String[] args) { TV tv = new TV(); tv.turnOn(); tv.adjustVolume(10); tv.turnOff(); tv.adjustVolume(10); } } \",\"这个例子展示了状态模式的基本结构和用法：\",\"Turning on the TV. Adjusting volume to: 10 Turning off the TV. Cannot adjust volume, TV is off. \",\"通过使用状态模式，我们可以更好地组织和管理与特定状态相关的代码。当状态较多时，这种模式的优势就会凸显出来，同时我们在代码时，因为我们会对每个状态进行独立封装，所以也会简化代码编写。\"]},\"361\":{\"h\":\"5、总结\",\"t\":[\"状态设计模式通过将对象的状态封装成独立的类，并根据当前状态委派请求给相应的状态对象处理，实现了对象行为的动态改变。它可以消除大量的条件语句，使代码更加灵活和可维护。使用状态设计模式可以将复杂的对象行为拆分成独立的类，从而提高代码的可读性和可维护性。\",\"优点：\",\"将对象的状态抽象成独立的类，避免大量的条件语句，使代码更加清晰和易于维护。\",\"支持开闭原则，可以方便地添加新的状态类，而无需修改现有代码。\",\"当使用状态模式时，有以下几个具体的好处，让我用白话点来解释：\",\"清晰简洁的代码结构： 状态模式让我们将每种状态的处理逻辑封装在独立的类中，避免了大量的条件语句，让代码结构更加清晰、简洁，易于理解和维护。\",\"易于扩展和添加新功能： 通过将状态与上下文类分离，新增状态时只需添加新的状态类，不需要修改原有代码，符合开闭原则，使得扩展和添加新功能变得非常简单。\",\"状态切换更加灵活： 上下文类可以轻松地切换不同的状态，只需在运行时设置不同的状态类，状态之间的切换变得灵活可控。\",\"降低代码复杂度： 在处理复杂的状态逻辑时，状态模式能够将每个状态的处理逻辑独立起来，降低了代码的复杂度，让代码更易于维护和调试。\",\"增强可读性： 状态模式可以让每个状态类只包含特定状态下的逻辑，使得代码的含义更加明确，增强了代码的可读性。\",\"总之，状态模式为处理具有不同状态的对象提供了一种优雅的解决方案，通过封装状态的处理逻辑，简化了代码结构，使得代码更易于扩展和维护，降低了代码的复杂度，增强了代码的可读性。这让开发人员可以更加专注于业务逻辑的实现，而不需要过多地关心状态切换和状态处理的细节。\",\"缺点：\",\"状态模式会增加类的数量，增加代码复杂性。\",\"在某些情况下，状态的转换可能较为复杂，需要仔细设计状态之间的转换逻辑。\",\"总体而言，状态设计模式在一些需要根据状态改变行为的场景中是很有用的设计模式，它可以提高代码的可读性和可维护性，并支持系统的扩展。在使用状态模式时，应根据实际情况仔细设计状态之间的转换逻辑，避免状态的频繁转换导致性能问题。\"]},\"362\":{\"h\":\"六、迭代器设计模式\"},\"363\":{\"h\":\"1、介绍\",\"t\":[\"迭代器设计模式（Iterator Design Pattern）是一种行为型设计模式，它提供了一种顺序访问聚合对象（如列表、集合等）元素的方法，而无需暴露底层集合的表示方式。通过使用迭代器，可以遍历聚合对象，而不必了解其内部结构。\"]},\"364\":{\"h\":\"2、核心思想\",\"t\":[\"迭代器设计模式的核心思想是将迭代逻辑从聚合对象中抽离出来，使得聚合对象可以专注于管理元素，而迭代逻辑由迭代器来实现。这样做的好处是在不影响聚合对象结构的情况下，能够灵活地遍历聚合对象中的元素。\"]},\"365\":{\"h\":\"3、组成和基本流程\",\"t\":[\"组成：迭代器设计模式由以下两个主要组件组成：\",\"迭代器（Iterator）：定义访问和遍历元素的接口，通常包括hasNext()方法判断是否有下一个元素，以及next()方法获取下一个元素。\",\"具体迭代器（Concrete Iterator）：实现迭代器接口，负责具体的遍历逻辑，维护遍历时的状态信息。\",\"基本流程：迭代器设计模式的基本流程如下：\",\"定义聚合对象，并在聚合对象中实现一个方法用于返回迭代器对象。\",\"定义迭代器接口，包含用于遍历聚合对象的方法。\",\"在具体聚合对象中实现迭代器接口，定义具体迭代器类，实现遍历逻辑。\",\"在客户端中，通过聚合对象的迭代器方法获取迭代器对象，然后使用迭代器遍历聚合对象的元素。\",\"以下是一个按照组成和基本流程的代码案例：\",\"// 迭代器接口 interface Iterator { boolean hasNext(); Object next(); } // 具体聚合对象 class ConcreteAggregate { private Object[] elements; public Iterator createIterator() { return new ConcreteIterator(this); } } // 具体迭代器 class ConcreteIterator implements Iterator { private ConcreteAggregate aggregate; private int currentIndex; public ConcreteIterator(ConcreteAggregate aggregate) { this.aggregate = aggregate; this.currentIndex = 0; } public boolean hasNext() { return currentIndex < aggregate.elements.length; } public Object next() { if (hasNext()) { return aggregate.elements[currentIndex++]; } return null; } } // 客户端代码 public class Client { public static void main(String[] args) { ConcreteAggregate aggregate = new ConcreteAggregate(); Iterator iterator = aggregate.createIterator(); while (iterator.hasNext()) { Object element = iterator.next(); // 处理元素逻辑 } } } \"]},\"366\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"迭代器设计模式适用于以下场景：\",\"当需要遍历一个复杂对象结构，并且不希望暴露其内部表示时。\",\"当需要提供多种遍历方式，而又不希望在聚合对象中增加复杂的遍历逻辑时。\",\"当希望将遍历算法和遍历逻辑与聚合对象分离，使得代码更加清晰和易于维护。\",\"在下面例子中，我们实现了一个简单的类似ArrayList的集合SuperArray，并且实现了迭代器设计模式：\",\"SuperArray类表示一个简单的数组聚合对象，它封装了一个整型数组，并提供了添加元素、获取元素、获取长度和创建迭代器等方法。\",\"ArrayIterator类是具体的迭代器类，它实现了Iterator接口，负责遍历SuperArray对象中的元素。\",\"Main类的main()方法中，我们创建了一个SuperArray对象并添加了一些元素。然后，通过调用iterator()方法获取迭代器对象，使用迭代器遍历并输出SuperArray对象中的元素。\",\"// 迭代器接口 interface Iterator { boolean hasNext(); Object next(); } // 聚合对象 class SuperArray { private int[] array; private int curr = -1; public SuperArray() { this(5); } public SuperArray(int capacity) { this.array = new int[capacity]; } public int getLength() { return array.length; } public int add(int data) { // 判断容量、扩容 // ... array[++curr] = data; return curr; } public int get(int index) { return array[index]; } public Iterator iterator() { // 返回一个迭代器对象，迭代器持有当前对象实例 return new ArrayIterator(this); } } // 具体迭代器 class ArrayIterator implements Iterator { // 维护一个聚合对象 private SuperArray superArray; // 记录一个当前位置指针 private int currIndex; public ArrayIterator(SuperArray concreteObject) { this.superArray = concreteObject; this.currIndex = 0; } @Override public boolean hasNext() { // 判断是否有下一个 return currIndex < superArray.getLength(); } @Override public Object next() { int length = superArray.getLength(); if (currIndex < length) { // 返回当前元素，且指针下移 return superArray.get(currIndex++); } return null; } } public class Main { public static void main(String[] args) { SuperArray superArray = new SuperArray(); for (int i = 0; i < 5; i++) { superArray.add(i + 1); } // 创建并获得迭代器 // 隐藏了底层实现（没有方法获取到 superArray 内具体的实现 - array，只能通过公共的方法访问），所以我们只需要关注迭代器结合 Iterator iterator = superArray.iterator(); while (iterator.hasNext()) { System.out.println(\\\"iterator.next() = \\\" + iterator.next()); } } } \"]},\"367\":{\"h\":\"5、总结\",\"t\":[\"优点：\",\"将遍历算法与聚合对象分离，增加了代码的灵活性和可维护性。\",\"简化了聚合对象的接口，对外隐藏了内部表示，降低了对聚合对象的依赖。\",\"缺点：\",\"增加了迭代器类的数量，使得代码结构变得更加复杂。\",\"对于简单的聚合对象，使用迭代器模式可能会显得过于繁琐。\",\"总结： 迭代器设计模式提供了一种优雅的方式来遍历聚合对象，它将遍历算法与聚合对象解耦，使得代码更加灵活和易于维护。然而，在简单的情况下，使用迭代器模式可能会增加代码复杂性，因此在应用时需根据实际情况权衡利弊。\",\"其它：\",\"在使用迭代器内的remove()方法时，需要注意以下几点：\",\"调用位置：remove()方法只能在调用了next()方法之后再调用。例如，假设我们有一个迭代器iterator，如果在调用remove()之前没有调用iterator.next()，或者在同一个next()方法之后再次调用remove()，都将会抛出IllegalStateException异常。这是因为迭代器需要知道当前指针指向的元素，才能正确地执行删除操作。\",\"单次迭代：remove()方法在一次迭代中只能被调用一次。在每次调用next()方法后，我们只能调用一次remove()来移除上一个元素。如果在同一次迭代中多次调用remove()，将会导致IllegalStateException异常。这是为了避免迭代器状态的混乱，保持每次迭代操作的一致性。\",\"验证元素：在调用remove()方法之前，必须先调用hasNext()或next()方法来检查是否还有元素。如果在调用remove()之前没有检查元素，而迭代器已经遍历到了最后一个元素，将会导致remove()方法抛出NoSuchElementException异常。因此，在删除元素之前，我们应该先确保迭代器指针还没有到达最后一个元素。\",\"并发修改：在使用迭代器遍历集合的同时，通过其他方式修改了集合的结构（比如直接调用集合的add()、remove()等方法），会导致迭代器的状态不一致，进而可能引发ConcurrentModificationException异常。为了避免并发修改问题，建议在使用迭代器期间，不要使用集合的其他修改方法。如果需要在遍历过程中修改集合，应该使用迭代器的remove()方法来安全地删除元素。\",\"综上所述，使用迭代器的remove()方法需要遵循特定的调用顺序，确保在正确的时机调用并避免多次调用。同时，在调用remove()方法之前要进行元素的验证，确保迭代器指针没有到达最后一个元素。另外，需要注意避免在使用迭代器时并发修改集合的结构，以免引发ConcurrentModificationException异常。遵循这些注意事项，可以确保在使用迭代器的remove()方法时能够正常而安全地移除集合中的元素。\"]},\"368\":{\"h\":\"七、访问者设计模式\",\"t\":[\"说实话我也看不懂，理解不了，但是这个还是通过组合的方式实现的\"]},\"369\":{\"h\":\"1、介绍\",\"t\":[\"访问者设计模式（Visitor Pattern）是一种行为型设计模式，用于在不修改已有类的情况下，对现有类的对象结构进行操作或添加新的操作。它允许在不改变对象结构的前提下，定义作用于该结构中元素的新操作，从而实现对元素的新功能扩展。\"]},\"370\":{\"h\":\"2、核心思想\",\"t\":[\"访问者模式的核心思想是将数据结构与对数据的操作分离。\",\"通过引入访问者对象，使得数据结构中的元素可以接受不同类型的访问者对象，从而可以实现不同的操作。\"]},\"371\":{\"h\":\"3、组成和基本流程\",\"t\":[\"访问者模式主要包括以下组成：\",\"抽象访问者（Visitor）：定义访问元素对象的接口，通过这个接口，访问者可以访问所有具体元素。\",\"具体访问者（ConcreteVisitor）：实现抽象访问者定义的接口，为每种具体元素对象提供具体的访问操作。\",\"抽象元素（Element）：定义接受访问者对象的接口，通过这个接口，元素对象可以被访问者访问。\",\"具体元素（ConcreteElement）：实现抽象元素定义的接口，提供接受访问者访问的具体实现。\",\"对象结构（Object Structure）：包含元素对象的结构，可以是一个集合或其他数据结构。\",\"客户端（Client）：通过访问者来访问对象结构中的元素。\",\"基本流程如下：\",\"定义抽象访问者接口，声明访问具体元素对象的方法。\",\"定义抽象元素接口，声明接受访问者对象的方法。\",\"定义具体元素类，实现抽象元素接口，并提供具体的实现。\",\"定义具体访问者类，实现抽象访问者接口，并为每种具体元素对象提供具体的访问操作。\",\"定义对象结构，用于存储具体元素对象。\",\"在客户端中，创建具体元素对象并添加到对象结构中，然后创建具体访问者对象，调用访问者的访问方法对元素进行操作。\"]},\"372\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"当需要为一个对象结构中的元素添加新的操作，且不希望修改现有类的结构时，可以使用访问者模式。\",\"当需要对一个对象结构中的元素进行多种不相关的操作，且希望避免这些操作对元素类的污染时，可以使用访问者模式。\",\"当我们谈论访问者设计模式时，可以把它比作一个旅行团的场景。假设你要带领一个旅行团游览一个大城市，这个城市里有很多不同的景点，比如博物馆、公园、购物中心等等。\",\"在我们的旅行团场景中：\",\"可以将城市的景点看作是对象结构\",\"旅行团成员则是访问者。\",\"每个景点都可以接受访问者并提供一种或多种参观方式。\",\"这样，我们就可以实现旅行团成员在不同景点间游览的行为，同时不需要修改景点的结构。\",\"访问者设计模式示例\",\"创建访问者接口（Visitor Interface）：首先，我们需要定义一个访问者接口，它包含了旅行团成员可能会访问的不同景点的访问方法。例如，我们可以定义一个名为\\\"Visitor\\\"的接口，其中包含类似visitMuseum，visitPark，visitShoppingMall等方法。\",\"创建具体访问者（Concrete Visitors）：接下来，我们为旅行团成员的不同类型创建具体访问者类，实现访问者接口中的方法。例如，我们可以创建\\\"Tourist\\\"和\\\"Guide\\\"两个具体访问者类，它们分别表示普通旅游者和导游。\",\"创建元素接口（Element Interface）：定义一个元素接口，其中包含一个接受访问者的方法accept，该方法将具体的访问者作为参数。\",\"创建具体元素（Concrete Elements）：创建表示不同景点的具体元素类，这些类实现元素接口，并在accept方法中调用访问者的对应方法。例如，我们可以创建\\\"Museum\\\"、\\\"Park\\\"和\\\"ShoppingMall\\\"等具体元素类。\",\"建立对象结构（Object Structure）：创建一个对象结构，该结构存储所有景点的引用，并可以接受访问者。例如，我们可以创建一个\\\"City\\\"类，其中包含一个列表，存储所有景点（即具体元素）的引用。\",\"实现游览过程：最后，我们将旅行团成员引导到不同的景点上，并让他们按照一定顺序访问这些景点。旅行团成员可以依次访问每个景点，通过调用accept方法，将自己作为访问者传递给城市的对象结构。城市对象结构在接受访问者时，会调用具体元素的accept方法，从而实现访问者对景点的访问。\",\"当然，下面是用Java语言实现的示例代码，演示如何使用访问者设计模式来模拟旅行团游览大城市的场景：\",\"// 访问者接口 interface Visitor { void visitMuseum(Museum museum); void visitPark(Park park); void visitShoppingMall(ShoppingMall shoppingMall); } // 具体访问者 - 普通旅游者 class Tourist implements Visitor { @Override public void visitMuseum(Museum museum) { System.out.println(\\\"Tourist is visiting the museum\\\"); } @Override public void visitPark(Park park) { System.out.println(\\\"Tourist is enjoying the park\\\"); } @Override public void visitShoppingMall(ShoppingMall shoppingMall) { System.out.println(\\\"Tourist is shopping at the mall\\\"); } } // 具体访问者 - 导游 class Guide implements Visitor { @Override public void visitMuseum(Museum museum) { System.out.println(\\\"Guide is explaining the museum history\\\"); } @Override public void visitPark(Park park) { System.out.println(\\\"Guide is giving information about the park\\\"); } @Override public void visitShoppingMall(ShoppingMall shoppingMall) { System.out.println(\\\"Guide is showing the best shops at the mall\\\"); } } // 元素接口 interface CityElement { void accept(Visitor visitor); } // 具体元素 - 博物馆 class Museum implements CityElement { @Override public void accept(Visitor visitor) { visitor.visitMuseum(this); } } // 具体元素 - 公园 class Park implements CityElement { @Override public void accept(Visitor visitor) { visitor.visitPark(this); } } // 具体元素 - 购物中心 class ShoppingMall implements CityElement { @Override public void accept(Visitor visitor) { visitor.visitShoppingMall(this); } } // 对象结构 - 城市 class City { private List<CityElement> cityElements = new ArrayList<>(); public void addCityElement(CityElement cityElement) { cityElements.add(cityElement); } public void accept(Visitor visitor) { for (CityElement cityElement : cityElements) { cityElement.accept(visitor); } } } // 测试 public class Main { public static void main(String[] args) { City city = new City(); city.addCityElement(new Museum()); city.addCityElement(new Park()); city.addCityElement(new ShoppingMall()); Visitor tourist = new Tourist(); Visitor guide = new Guide(); System.out.println(\\\"Tourist's tour:\\\"); city.accept(tourist); System.out.println(\\\"\\\\nGuide's tour:\\\"); city.accept(guide); } } \",\"在上面的Java代码中，我们使用了访问者设计模式来实现旅行团游览大城市的场景。其中，游客（Tourist）和导游（Guide）是具体的访问者，博物馆（Museum）、公园（Park）、购物中心（ShoppingMall）是具体的元素。City是对象结构，用于存储所有景点，并接受访问者的访问。\",\"在测试部分，我们创建了一个City对象，并向其中添加了不同的景点。然后分别用游客和导游进行游览，观察他们在每个景点上执行的不同访问操作。\",\"这样，我们就成功地使用访问者设计模式来模拟了旅行团游览大城市的场景。该设计模式可以使得景点的结构保持稳定，同时旅行团成员可以根据自己的类型执行不同的访问行为，而无需改变景点的代码。\",\"访问者模式在现实世界中有很多应用场景，其中一个典型的例子是网站数据统计。假设我们有一个网站，网站上有不同类型的页面（例如首页、文章页、产品页等），而我们希望能够统计每种类型页面的访问量。\",\"下面是一个用Java语言实现网站数据统计的访问者模式示例代码：\",\"// 访问者接口 interface Visitor { void visit(HomePage homePage); void visit(ArticlePage articlePage); void visit(ProductPage productPage); } // 具体访问者 - 网站数据统计 class WebsiteStatsVisitor implements Visitor { private int homePageCount = 0; private int articlePageCount = 0; private int productPageCount = 0; @Override public void visit(HomePage homePage) { homePageCount++; } @Override public void visit(ArticlePage articlePage) { articlePageCount++; } @Override public void visit(ProductPage productPage) { productPageCount++; } public void displayStats() { System.out.println(\\\"Home Page Count: \\\" + homePageCount); System.out.println(\\\"Article Page Count: \\\" + articlePageCount); System.out.println(\\\"Product Page Count: \\\" + productPageCount); } } // 元素接口 interface Page { void accept(Visitor visitor); } // 具体元素 - 首页 class HomePage implements Page { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 具体元素 - 文章页 class ArticlePage implements Page { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 具体元素 - 产品页 class ProductPage implements Page { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 对象结构 - 网站 class Website { private List<Page> pages = new ArrayList<>(); public void addPage(Page page) { pages.add(page); } public void accept(Visitor visitor) { for (Page page : pages) { page.accept(visitor); } } } // 测试 public class Main { public static void main(String[] args) { Website website = new Website(); website.addPage(new HomePage()); website.addPage(new ArticlePage()); website.addPage(new ProductPage()); website.addPage(new ArticlePage()); website.addPage(new HomePage()); Visitor websiteStatsVisitor = new WebsiteStatsVisitor(); website.accept(websiteStatsVisitor); ((WebsiteStatsVisitor) websiteStatsVisitor).displayStats(); } } \",\"在上面的示例中，我们创建了一个网站，并向网站中添加了不同类型的页面（首页、文章页、产品页）。然后，我们创建了一个用于统计网站数据的访问者WebsiteStatsVisitor，它实现了访问者接口。当访问者访问各种页面时，会根据页面类型进行相应的计数。\",\"在测试部分，我们模拟了一些页面的访问，并最终显示了每种类型页面的访问次数。\",\"这个例子中，访问者模式将网站数据统计与网站的页面结构解耦，使得我们可以方便地新增其他的访问者来处理不同的操作，同时也能很容易地增加新的页面类型，而不需要修改已有的代码。这展示了访问者模式在真实业务场景中的应用。\"]},\"373\":{\"h\":\"6、总结\",\"t\":[\"优点：\",\"可以在不修改现有类的情况下，增加新的操作和功能。\",\"将数据结构和操作分离，使得扩展新功能更加灵活。\",\"缺点：\",\"增加了访问者类和元素类的数量，增加了系统复杂性。\",\"当元素类个数较少且变化不大时，访问者模式可能会显得过于繁琐。\",\"应用建议：\",\"访问者模式适用于需要在不改变数据结构的情况下，对数据结构中的元素进行操作的场景。它能够将不同的操作封装在具体的访问者中，从而实现对元素的功能扩展。但在使用时，应该根据具体情况权衡利弊，避免过度设计，保持代码的简洁和可维护性。\"]},\"374\":{\"h\":\"八、备忘录设计模式\"},\"375\":{\"h\":\"1、介绍\",\"t\":[\"备忘录设计模式（Memento Design Pattern）是一种行为型设计模式，它允许在不破坏封装性的前提下，捕获一个对象的内部状态，并在之后恢复该状态。这样，对象在后续的操作中可以回到之前的状态，提供了一种可撤销和恢复操作的机制。\",\"补充知识：\",\"\\\"undo\\\", \\\"redo\\\", 和 \\\"todo\\\" 是在软件开发中常见的术语，它们与备忘录设计模式有相关性。\",\"Undo（撤销）： 撤销是指在执行一个操作后，可以回到之前的状态。这意味着我们可以撤销前一步或多步操作，返回到过去的状态。例如，在文本编辑器中，当我们执行了一系列编辑操作，如果需要取消之前的某些操作，就可以使用撤销功能。\",\"Redo（重做）： 重做是指在执行了撤销操作后，可以再次执行这些被撤销的操作，恢复到之前的状态。例如，在文本编辑器中，如果我们执行了撤销操作，但之后发现撤销的部分是错误的，就可以使用重做功能重新执行之前的操作。\",\"Todo（待办事项）： \\\"Todo\\\" 是 \\\"to do\\\" 的缩写，指待办事项列表。在软件开发中，特别是在项目管理或任务追踪中，我们通常会创建一个待办事项列表，用于记录未完成的任务、功能或问题。这样的列表帮助团队成员了解尚未完成的工作，并能够跟踪进度。\",\"这些术语与备忘录设计模式的关系在于，\\\"undo\\\" 和 \\\"redo\\\" 是备忘录设计模式的实际应用场景。备忘录模式允许我们捕获对象的状态并在后续需要时恢复，从而实现了撤销和重做的功能。而 \\\"todo\\\" 列表则是一个待办事项列表，虽然与备忘录模式没有直接关联，但在软件开发中与项目管理密切相关。\"]},\"376\":{\"h\":\"2、核心思想\",\"t\":[\"备忘录设计模式的核心思想是：\",\"将对象的状态保存在一个备忘录对象中\",\"通过在原对象和备忘录对象之间建立关联\",\"可以在之后根据备忘录对象恢复原对象的状态。\",\"保存 ➡️ 恢复\"]},\"377\":{\"h\":\"3、组成和基本流程\",\"t\":[\"组成：\",\"Originator（发起人）：拥有需要保存和恢复状态的对象，并负责创建备忘录对象和从备忘录对象中恢复状态。\",\"Memento（备忘录）：用于存储Originator对象的内部状态，并提供给Originator进行恢复操作的接口。\",\"Caretaker（负责人）：负责保存备忘录对象，但不对备忘录对象的内容进行操作。主要作用是防止Originator以外的对象访问备忘录。\",\"基本流程：\",\"Originator通过创建备忘录对象将自身状态存储在备忘录中。\",\"Originator可以在后续的操作中根据备忘录对象来恢复自身状态。\",\"一个基本案例：\",\"// 备忘录类 class Memento { private String state; public Memento(String state) { this.state = state; } public String getState() { return state; } } // 发起人类 class Originator { private String state; public void setState(String state) { this.state = state; } public String getState() { return state; } public Memento saveStateToMemento() { return new Memento(state); } public void undo(Memento memento) { state = memento.getState(); } } // 负责人类 class Caretaker { private List<Memento> mementos = new ArrayList<>(); public void saveMemento(Memento memento) { mementos.add(memento); } public Memento getMemento(int index) { return mementos.get(index); } } public class Main { public static void main(String[] args) { Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); // 设置Originator的状态并保存到备忘录 originator.setState(\\\"State 1\\\"); caretaker.saveMemento(originator.saveStateToMemento()); // 修改Originator的状态并保存到备忘录 originator.setState(\\\"State 2\\\"); caretaker.saveMemento(originator.saveStateToMemento()); // 恢复Originator的状态到之前的备忘录 originator.undo(caretaker.getMemento(0)); System.out.println(\\\"Current State: \\\" + originator.getState()); // 再次恢复Originator的状态到之前的备忘录 originator.undo(caretaker.getMemento(1)); System.out.println(\\\"Current State: \\\" + originator.getState()); } } \",\"现在，我们使用了一个List来保存多个备忘录，然后通过指定备忘录的索引来恢复到相应的状态。运行这段代码将得到正确的输出：\",\"Current State: State 1 Current State: State 2 \"]},\"378\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"需要实现撤销和恢复功能，让对象能够回到之前的状态。\",\"需要保存对象状态的历史记录，以便可以在需要时进行查看或恢复。\",\"下面以一个文本编辑器为例来演示备忘录设计模式的应用。 假设我们有一个简单的文本编辑器，支持输入文本、撤销和重做操作。在这个场景中，我们可以使用备忘录设计模式来实现撤销和重做功能。\",\"// 备忘录类 - 文本状态 class TextMemento { private String text; public TextMemento(String text) { this.text = text; } public String getText() { return text; } } // 发起人类 - 文本编辑器 class TextEditor { private String text; private History history; public TextEditor(History history) { this.history = history; } public void setText(String text) { this.text = text; } public String getText() { return text; } public void save() { history.push(new TextMemento(text)); } public void undo() { TextMemento memento = history.popLast(); if (memento != null) { restore(memento); } } private void restore(TextMemento memento) { text = memento.getText(); } } // 负责人类 - 历史记录管理 class History { private Stack<TextMemento> mementos = new Stack<>(); public void push(TextMemento memento) { mementos.push(memento); } public TextMemento popLast() { if (mementos.isEmpty()) { return null; } return mementos.pop(); } } public class Main { public static void main(String[] args) { History history = new History(); TextEditor editor = new TextEditor(history); // 输入第一次文本并保存到历史记录 editor.setText(\\\"Hello, world!\\\"); System.out.println(\\\"1 input Current Text: \\\" + editor.getText()); editor.save(); // 修改文本并保存到历史记录 editor.setText(\\\"Hello, world! Have a nice day!\\\"); System.out.println(\\\"2 input Current Text: \\\" + editor.getText()); editor.save(); // 输入第二次文本并保存到历史记录 editor.setText(\\\"Goodbye, world!\\\"); System.out.println(\\\"3 input Current Text: \\\" + editor.getText()); editor.save(); // 撤销到之前的状态 editor.undo(); System.out.println(\\\"1 return input Current Text: \\\" + editor.getText()); // 再次撤销到之前的状态 editor.undo(); System.out.println(\\\"2 return Current Text: \\\" + editor.getText()); } } \",\"输出：\",\"1 input Current Text: Hello, world! 2 input Current Text: Hello, world! Have a nice day! 3 input Current Text: Goodbye, world! 1 return input Current Text: Goodbye, world! 2 return Current Text: Hello, world! Have a nice day! \"]},\"379\":{\"h\":\"5、总结\",\"t\":[\"优点：\",\"提供了可撤销和恢复状态的机制，增加了系统的灵活性和可维护性。\",\"将状态的保存和恢复逻辑封装在备忘录对象中，不影响Originator对象的封装性。\",\"缺点：\",\"如果备忘录对象过多或状态较大，可能会占用较大的内存空间。\",\"备忘录设计模式是一种功能强大的模式，适用于需要撤销和恢复操作的场景。合理地使用备忘录模式可以使系统更加灵活和可靠。\"]},\"380\":{\"h\":\"九、命令设计模式\"},\"381\":{\"h\":\"1、介绍\",\"t\":[\"命令设计模式是一种行为型设计模式，它允许将请求或操作封装为一个对象，从而使得我们可以将不同的请求参数化，延迟请求的执行，或者将请求放入队列中进行排队处理。通过使用命令模式，我们可以实现解耦请求的发送者和接收者，从而增加系统的灵活性和可扩展性。\"]},\"382\":{\"h\":\"2、核心思想\",\"t\":[\"命令设计模式的核心思想是通过将请求封装成一个对象，使得请求的发送者和接收者解耦。具体来说，它包含以下几个关键组件：\",\"Command（命令）：声明了执行操作的接口，通常包含一个execute方法，用于执行具体的命令。\",\"ConcreteCommand（具体命令）：实现了Command接口，持有一个接收者对象，并在execute方法中调用接收者的相应操作。\",\"Receiver（接收者）：负责执行具体操作的对象。\",\"Invoker（调用者）：持有一个命令对象，并在需要执行命令时调用命令的execute方法。\",\"Client（客户端）：创建具体命令对象并设置其接收者，将命令对象传递给调用者。\"]},\"383\":{\"h\":\"3、组成和基本流程\",\"t\":[\"组成： \",\"Command：定义命令接口，包含execute方法。\",\"ConcreteCommand：实现Command接口，持有Receiver对象，执行具体命令。\",\"Receiver：负责执行实际操作。\",\"Invoker：持有Command对象，在需要执行命令时调用Command的execute方法。\",\"Client：创建具体的Command对象并设置其接收者，传递给Invoker。\",\"基本流程： \",\"客户端创建具体的命令对象，并设置其接收者。\",\"客户端创建调用者对象，并将命令对象传递给调用者。\",\"调用者在需要执行命令时，调用命令对象的execute方法。\",\"命令对象调用接收者的具体操作来完成命令的执行。\",\"下面是一个简单的命令设计模式的例子，以一个遥控器控制电灯为例：\",\"// Command（命令）接口 interface Command { void execute(); } // ConcreteCommand（具体命令）：控制电灯开启的命令 class LightOnCommand implements Command { private Light light; public LightOnCommand(Light light) { this.light = light; } @Override public void execute() { light.turnOn(); } } // ConcreteCommand（具体命令）：控制电灯关闭的命令 class LightOffCommand implements Command { private Light light; public LightOffCommand(Light light) { this.light = light; } @Override public void execute() { light.turnOff(); } } // Receiver（接收者）：电灯类 class Light { public void turnOn() { System.out.println(\\\"Light is ON\\\"); } public void turnOff() { System.out.println(\\\"Light is OFF\\\"); } } // Invoker（调用者）：遥控器类 class RemoteControl { private Command command; public void setCommand(Command command) { this.command = command; } public void pressButton() { command.execute(); } } public class Main { public static void main(String[] args) { // 创建电灯和对应的命令对象 Light light = new Light(); Command lightOnCommand = new LightOnCommand(light); Command lightOffCommand = new LightOffCommand(light); // 创建遥控器并设置命令 RemoteControl remoteControl = new RemoteControl(); remoteControl.setCommand(lightOnCommand); // 按下按钮，执行命令 remoteControl.pressButton(); // 更改命令为关闭电灯，并再次按下按钮，执行命令 remoteControl.setCommand(lightOffCommand); remoteControl.pressButton(); } } \",\"在这个例子中，我们实现了一个简单的遥控器控制电灯的场景。其中，Command接口定义了执行命令的方法execute()，ConcreteCommand类LightOnCommand和LightOffCommand分别用于控制电灯开启和关闭。Receiver类Light表示电灯，它具体执行开启和关闭操作。而Invoker类RemoteControl持有Command对象，在需要执行命令时调用其execute方法。\",\"通过命令设计模式，我们可以轻松地添加新的命令和接收者，实现不同的功能，并且可以支持撤销和重做操作。这样，我们可以将请求的发送者和接收者解耦，增加系统的灵活性和可扩展性。\"]},\"384\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"命令设计模式适用于以下场景：\",\"需要将请求的发送者和接收者解耦，使得系统更加灵活和可扩展。\",\"需要支持请求的撤销、重做和排队等功能。\",\"需要将一系列操作参数化，以便在不同的上下文中执行相似的请求。\",\"当结合真实业务场景时，命令设计模式可以用于实现购物车系统中的\\\"添加商品到购物车\\\"和\\\"从购物车移除商品\\\"等功能。我们来看看如何在Java中实现这个例子：\",\"好的，我会将所有的代码整合到一个代码块内，只保留 Client 类为 public。\",\"// Command接口 interface Command { void execute(); } // 添加商品命令类 class AddItemCommand implements Command { private ShoppingCart cart; private String item; public AddItemCommand(ShoppingCart cart, String item) { this.cart = cart; this.item = item; } public void execute() { cart.addItem(item); } } // 移除商品命令类 class RemoveItemCommand implements Command { private ShoppingCart cart; private String item; public RemoveItemCommand(ShoppingCart cart, String item) { this.cart = cart; this.item = item; } public void execute() { cart.removeItem(item); } } // 购物车类 class ShoppingCart { private List<String> items; public ShoppingCart() { this.items = new ArrayList<>(); } public void addItem(String item) { items.add(item); System.out.println(item + \\\" 已添加到购物车\\\"); } public void removeItem(String item) { if (items.contains(item)) { items.remove(item); System.out.println(item + \\\" 已从购物车移除\\\"); } else { System.out.println(item + \\\" 不在购物车中\\\"); } } } // 客户端类 public class Client { public static void main(String[] args) { // 创建购物车对象 ShoppingCart cart = new ShoppingCart(); // 创建添加商品和移除商品的命令 Command addItemCommand = new AddItemCommand(cart, \\\"商品A\\\"); Command removeItemCommand = new RemoveItemCommand(cart, \\\"商品B\\\"); // 执行命令 addItemCommand.execute(); removeItemCommand.execute(); } } \",\"这个代码块完整地展示了如何使用命令设计模式来实现购物车系统的功能，并且保持了结构的清晰性。\"]},\"385\":{\"h\":\"5、总结\",\"t\":[\"命令设计模式是一种非常有用的设计模式，它可以帮助我们实现请求的封装和参数化，从而提高系统的灵活性和可扩展性。使用命令模式，我们可以将请求的发送者和接收者解耦，使得系统更加易于维护和扩展。虽然它增加了一些类的复杂性，但它带来的好处远远超过了这些额外的开销。\",\"优点：\",\"解耦请求的发送者和接收者，提高系统的灵活性和可扩展性。\",\"支持请求的撤销、重做和排队等功能，增加系统的功能性。\",\"可以将一系列操作参数化，实现更加灵活的命令组合。\",\"缺点：\",\"可能会引入过多的具体命令类，增加系统的复杂性。\",\"在设计和实现时，我们应该注意将命令设计模式与其他设计模式结合使用，以便在特定场景中获得更好的效果。同时，合理地使用继承和组合等技术，可以减少命令模式的复杂性，使得系统更加易于维护和扩展。\"]},\"386\":{\"h\":\"6、和策略设计模式比较\",\"t\":[\"命令设计模式（Command Pattern）关注的是将请求（命令）封装成一个对象，从而允许您参数化客户端与接收者之间的关系。它主要用于实现撤销/重做、队列请求、日志记录等功能。在命令模式中，客户端和接收者是解耦的，客户端不需要知道命令是如何被执行的，只需要调用命令对象的方法即可。\",\"策略设计模式（Strategy Pattern）关注的是定义一系列算法或行为，将它们封装成独立的策略类，并使这些策略类可以相互替换。这样可以让客户端在运行时动态选择算法，而不需要修改客户端代码。策略模式主要用于在不同算法或行为之间进行灵活切换，以实现不同的业务逻辑。\",\"主要区别如下：\",\"关注点不同：\",\"命令设计模式关注的是将请求封装成对象，以支持请求的参数化和解耦客户端与接收者。\",\"策略设计模式关注的是封装不同的算法或行为，并使得它们可以互相替换，从而动态地改变对象的行为。\",\"角色不同：\",\"命令模式的核心角色是命令（Command）对象、调用者（Invoker）和接收者（Receiver）。\",\"策略模式的核心角色是策略（Strategy）接口、具体策略（ConcreteStrategy）类和上下文（Context）。\",\"应用场景不同：\",\"命令模式适用于需要将请求封装为对象，支持撤销/重做、队列请求、日志记录等场景。\",\"策略模式适用于在运行时动态选择算法或行为的场景，以实现不同的业务逻辑。\",\"虽然它们有相似之处，但根据不同的需求和应用场景，选择使用命令模式或策略模式可以更好地组织和设计代码。\"]},\"387\":{\"h\":\"十、解释器设计模式\"},\"388\":{\"h\":\"1、介绍\",\"t\":[\"解释器设计模式（Interpreter Pattern）是一种行为型设计模式，属于GOF设计模式中的一员。它通过定义语言的文法表示，以及解释预定义的表达式，来实现对特定问题领域的解释和处理。\"]},\"389\":{\"h\":\"2、核心思想\",\"t\":[\"解释器设计模式的核心思想是创建一个解释器，用于解释特定问题领域的表达式和语句。它将每个文法规则表示为一个类，并定义解释方法，以便能够解释和处理特定的语法结构。\"]},\"390\":{\"h\":\"3、组成和基本流程\",\"t\":[\"解释器设计模式的组成主要包括以下几个元素：\",\"抽象表达式（Abstract Expression）：定义解释器的接口，包含一个解释方法 interpret()，所有具体表达式都必须实现该接口。\",\"终结符表达式（Terminal Expression）：表示语法规则中的终结符，即不再包含其他表达式的表达式。它实现了抽象表达式的解释方法，并处理表达式的终结符部分。\",\"非终结符表达式（Non-terminal Expression）：表示语法规则中的非终结符，即包含其他表达式的表达式。它实现了抽象表达式的解释方法，并处理表达式的非终结符部分。\",\"解释器设计模式的基本流程如下：\",\"客户端构建语法树（由多个终结符表达式和非终结符表达式组成）。\",\"客户端调用解释器的解释方法，对语法树进行解释。\",\"我们将实现一个简单的数学表达式求值器，以演示解释器设计模式的应用\",\"// 抽象表达式 interface Expression { int interpret(); } // 终结符表达式 class NumberExpression implements Expression { private int number; public NumberExpression(int number) { this.number = number; } @Override public int interpret() { return number; } } // 非终结符表达式 - 加法 class AddExpression implements Expression { private Expression left; private Expression right; public AddExpression(Expression left, Expression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() + right.interpret(); } } // 非终结符表达式 - 减法 class SubtractExpression implements Expression { private Expression left; private Expression right; public SubtractExpression(Expression left, Expression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() - right.interpret(); } } public class Main { public static void main(String[] args) { // 构建数学表达式： 7 + (10 - 3) Expression left = new NumberExpression(7); Expression right = new SubtractExpression(new NumberExpression(10), new NumberExpression(3)); Expression expression = new AddExpression(left, right); // 计算并输出结果 int result = expression.interpret(); System.out.println(\\\"计算结果: \\\" + result); // 输出：计算结果: 14 } } \"]},\"391\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"解释器设计模式适用于以下场景：\",\"当有一个语言需要解释执行，且该语言的文法规则相对稳定，可以使用解释器模式来解释和处理语法规则。\",\"当需要构建一个可以灵活配置的语法树，并且能够支持特定领域的解释和处理。\",\"当结合真实业务场景时，解释器设计模式可以用于处理自定义的查询语言或规则引擎，从而实现对特定领域的解释和处理。一个常见的例子是实现一个简单的规则引擎，用于根据一组规则对输入数据进行评估和决策。\",\"在这个例子中，我们将实现一个简单的规则引擎，用于根据用户输入的条件，对输入数据进行评估。我们将定义一些基本的规则，然后用户可以输入规则条件，规则引擎将根据这些条件对输入数据进行判断和处理。\"]},\"392\":{\"h\":\"1、介绍\",\"t\":[\"我们将实现一个简单的规则引擎，用于根据用户输入的规则条件，对输入数据进行评估和处理。该规则引擎将支持基本的比较操作，例如大于、小于、等于等。\"]},\"393\":{\"h\":\"2、实现步骤\",\"t\":[\"定义抽象表达式（Expression）接口：该接口定义了解释器的解释方法 interpret()。\",\"实现终结符表达式（TerminalExpression）类：该类表示规则引擎中的终结符，即用户输入的条件，它实现了抽象表达式接口，并根据输入条件进行解释和评估。\",\"实现非终结符表达式（NonTerminalExpression）类：该类表示规则引擎中的非终结符，即基于多个终结符条件的组合条件，它实现了抽象表达式接口，并根据组合条件进行解释和评估。\",\"使用客户端（Client）类：客户端代码创建规则引擎对象，并输入规则条件和待评估的数据，然后调用规则引擎进行解释和处理。\"]},\"394\":{\"h\":\"3、代码实现\",\"t\":[\"以下是Java实现的简单规则引擎：\",\"// 抽象表达式 interface Expression { boolean interpret(int data); } // 终结符表达式 - 大于 class GreaterExpression implements Expression { private int value; public GreaterExpression(int value) { this.value = value; } public boolean interpret(int data) { return data > value; } } // 终结符表达式 - 小于 class LessExpression implements Expression { private int value; public LessExpression(int value) { this.value = value; } public boolean interpret(int data) { return data < value; } } // 非终结符表达式 - And class AndExpression implements Expression { private Expression expr1; private Expression expr2; public AndExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } public boolean interpret(int data) { return expr1.interpret(data) && expr2.interpret(data); } } // 非终结符表达式 - Or class OrExpression implements Expression { private Expression expr1; private Expression expr2; public OrExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } public boolean interpret(int data) { return expr1.interpret(data) || expr2.interpret(data); } } // 客户端 public class Client { public static void main(String[] args) { // 创建规则引擎 Expression rule1 = new AndExpression(new GreaterExpression(10), new LessExpression(20)); Expression rule2 = new OrExpression(new GreaterExpression(30), new LessExpression(40)); // 输入数据 int data = 15; // 判断并输出结果 boolean result1 = rule1.interpret(data); boolean result2 = rule2.interpret(data); System.out.println(data + \\\" > 10 and \\\" + data + \\\" < 20: \\\" + result1); System.out.println(data + \\\" > 30 or \\\" + data + \\\" < 40: \\\" + result2); } } \"]},\"395\":{\"h\":\"4、解析和注释\",\"t\":[\"上述代码实现了一个简单的规则引擎，其中 Expression 接口为抽象表达式，GreaterExpression 和 LessExpression 类为终结符表达式，表示大于和小于条件。AndExpression 和 OrExpression 类为非终结符表达式，用于组合多个终结符条件。\",\"客户端代码创建了规则引擎对象 rule1 和 rule2，然后输入数据 data 进行条件判断，并输出结果。在这个例子中，我们对输入数据 15 进行了两个规则条件的判断，分别是大于10并且小于20的结果为 true，以及大于30或小于40的结果为 false。\",\"通过这个简单的案例，我们可以看到解释器设计模式在实现规则引擎等特定领域的应用。它通过定义语言的文法表示，并解释预定义的表达式，使得我们能够根据不同的规则条件进行灵活的评估和处理。\"]},\"396\":{\"h\":\"5、总结\",\"t\":[\"优点：\",\"灵活性：解释器设计模式可以动态地修改、扩展语法规则，因为每个文法规则都对应一个表达式类。\",\"可维护性：解释器模式将每个表达式规则封装在独立的类中，易于维护和理解。\",\"缺点：\",\"复杂性：对于复杂的文法规则，可能需要创建大量的表达式类，导致代码复杂化。\",\"总结：\",\"解释器设计模式提供了一种灵活的方式来处理特定领域的语法规则和表达式。它适用于特定领域的解释执行，但对于复杂的文法规则，可能会导致代码复杂性增加。在使用时需要权衡其优缺点，并结合实际情况选择是否使用解释器模式来解决问题。\"]},\"397\":{\"h\":\"十一、中介设计模式\"},\"398\":{\"h\":\"1、介绍\",\"t\":[\"中介设计模式（Mediator Pattern）是一种行为型设计模式，属于GOF设计模式中的一员。它通过引入中介者来降低多个对象之间的直接通信复杂性，从而提高对象之间的松耦合性。\"]},\"399\":{\"h\":\"2、核心思想\",\"t\":[\"中介设计模式的核心思想是引入一个中介者对象，用于协调多个相关对象之间的交互。多个对象不再直接相互通信，而是通过中介者对象进行消息传递，使得对象之间的通信更加灵活和可扩展。\"]},\"400\":{\"h\":\"3、组成和基本流程\",\"t\":[\"中介设计模式的组成主要包括以下几个元素：\",\"中介者（Mediator）：定义一个接口用于与各个相关对象通信，它可以是接口或抽象类。\",\"具体中介者（Concrete Mediator）：实现中介者接口，负责协调各个相关对象的交互关系。\",\"相关对象（Colleague）：每个相关对象都知道中介者对象，并通过中介者来与其他相关对象通信。\",\"中介设计模式的基本流程如下：\",\"客户端创建中介者对象。\",\"客户端创建相关对象，并将中介者对象传递给相关对象。\",\"相关对象在需要与其他对象通信时，通过中介者对象进行消息传递。\",\"在下面这个简单的案例中，我们将实现一个简单的飞机交通管制系统，演示中介者设计模式的应用。飞机交通管制系统将处理多个飞机之间的通信和交互，确保它们在空中安全地航行。\"]},\"401\":{\"h\":\"1、介绍\",\"t\":[\"在飞机交通管制系统中，我们将实现一个中介者（TrafficMediator）接口，用于处理飞机之间的通信。每个飞机（Aircraft）都将参与交通管制系统，并通过中介者来与其他飞机通信，以避免碰撞和确保安全航行。\"]},\"402\":{\"h\":\"2、实现步骤\",\"t\":[\"定义中介者（TrafficMediator）接口：该接口定义了飞机之间的通信方法。\",\"实现具体的中介者类（AirTrafficController）：该类实现了中介者接口，并负责处理飞机之间的通信和交互。\",\"定义参与者（Aircraft）接口：该接口定义了飞机参与交通管制系统的方法。\",\"实现具体的参与者类（ConcreteAircraft）：该类实现了参与者接口，表示实际的飞机，可以发送和接收通信。\"]},\"403\":{\"h\":\"3、代码实现\",\"t\":[\"以下是Java实现的简单飞机交通管制系统：\",\"// 中介者接口 interface TrafficMediator { void sendMessage(String message, Aircraft aircraft); } // 具体的中介者类 - 空中交通管制 class AirTrafficController implements TrafficMediator { public void sendMessage(String message, Aircraft aircraft) { System.out.println(\\\"ATC: \\\" + aircraft.getName() + \\\" 发送消息: \\\" + message); } } // 参与者接口 interface Aircraft { void send(String message); void receive(String message); String getName(); } // 具体的参与者类 - 飞机 class ConcreteAircraft implements Aircraft { private String name; private TrafficMediator mediator; public ConcreteAircraft(String name, TrafficMediator mediator) { this.name = name; this.mediator = mediator; } public void send(String message) { System.out.println(name + \\\" 发送消息: \\\" + message); mediator.sendMessage(message, this); } public void receive(String message) { System.out.println(name + \\\" 收到消息: \\\" + message); } public String getName() { return name; } } \",\"为了测试代码，我们需要创建客户端代码来创建中介者和飞机对象，并模拟它们之间的通信。以下是一个简单的客户端代码示例：\",\"public class Client { public static void main(String[] args) { // 创建空中交通管制作为中介者 TrafficMediator atc = new AirTrafficController(); // 创建飞机参与者 Aircraft aircraft1 = new ConcreteAircraft(\\\"Flight-001\\\", atc); Aircraft aircraft2 = new ConcreteAircraft(\\\"Flight-002\\\", atc); // 飞机发送和接收消息 aircraft1.send(\\\"请求降落许可。\\\"); aircraft2.send(\\\"已收到，准备降落。\\\"); } } \",\"运行上述客户端代码，输出结果如下：\",\"Flight-001 发送消息: 请求降落许可。 ATC: Flight-001 发送消息: 请求降落许可。 Flight-002 发送消息: 已收到，准备降落。 ATC: Flight-002 发送消息: 已收到，准备降落。 \",\"在输出结果中，我们可以看到飞机成功发送了消息，并且中介者（空中交通管制）也成功接收到了这些消息。中介者负责将消息传递给目标飞机，并打印相应的消息内容。\",\"这个例子是一个简单的模拟，它演示了中介者设计模式的应用。在实际应用中，中介者模式可以用于处理更复杂的对象间通信和交互，以实现更灵活和解耦的系统设计。\"]},\"404\":{\"h\":\"4、解析和注释\",\"t\":[\"上述代码实现了一个简单的飞机交通管制系统，其中 TrafficMediator 接口为中介者，AirTrafficController 类为具体的中介者类，Aircraft 接口为参与者，ConcreteAircraft 类为具体的参与者类。\",\"中介者模式的核心是 TrafficMediator 接口和 AirTrafficController 类。AirTrafficController 类实现了中介者接口的 sendMessage() 方法，用于接收消息并进行传递。ConcreteAircraft 类实现了参与者接口，表示飞机，可以发送消息并接收消息。\",\"在客户端代码中，我们创建了一个空中交通管制作为中介者，并创建了两个飞机作为参与者。飞机可以通过发送消息来进行通信，中介者负责将消息传递给目标飞机。\",\"通过这个简单的例子，我们可以看到中介者设计模式在实现飞机交通管制系统等复杂的对象间通信场景中的应用。它通过引入中介者来降低对象间的直接通信复杂性，从而提高系统的松耦合性和可扩展性。\"]},\"405\":{\"h\":\"4、使用场景和具体案例\",\"t\":[\"中介设计模式适用于以下场景：\",\"当多个对象之间存在复杂的关联关系，导致对象之间的通信和交互复杂且难以维护时，可以使用中介者模式来简化对象之间的通信。\",\"当一个对象的行为依赖于其他多个对象时，可以引入中介者来减少对象之间的直接依赖，提高系统的灵活性和可扩展性。 \",\"在 Spring MVC 框架中，DispatcherServlet 可以看作是一种中介者模式的中介。\",\"中介者设计模式在真实业务场景中经常用于处理复杂的对象间通信和交互关系。一个典型的例子是聊天应用程序，其中多个用户之间进行实时聊天，中介者设计模式可以用于管理用户之间的消息传递。\",\"在这个例子中，我们将实现一个简单的聊天应用程序，其中有多个用户参与聊天，每个用户可以发送消息给其他用户，中介者将负责将消息传递给目标用户。\"]},\"406\":{\"h\":\"1、介绍\",\"t\":[\"在这个聊天应用程序中，我们将实现一个中介者（Mediator）接口，其中包含消息传递的方法。然后，我们将实现具体的中介者类 ChatRoom，用于实现消息传递逻辑。\"]},\"407\":{\"h\":\"2、实现步骤\",\"t\":[\"定义中介者（Mediator）接口：该接口定义了消息传递的方法。\",\"实现具体的中介者类（ChatRoom）：该类实现了中介者接口，并负责实际处理用户之间的消息传递逻辑。\",\"定义参与者（Participant）接口：该接口定义了用户参与聊天的方法。\",\"实现具体的参与者类（User）：该类实现了参与者接口，表示聊天应用中的用户，可以发送和接收消息。\"]},\"408\":{\"h\":\"3、代码实现\",\"t\":[\"以下是Java实现的简单聊天应用程序：\",\"// 中介者接口 interface Mediator { void sendMessage(String message, Participant sender); } // 具体的中介者类 - 聊天室 class ChatRoom implements Mediator { public void sendMessage(String message, Participant sender) { System.out.println(sender.getName() + \\\" 发送消息: \\\" + message); } } // 参与者接口 interface Participant { void send(String message); void receive(String message); String getName(); } // 具体的参与者类 - 用户 class User implements Participant { private String name; private Mediator mediator; public User(String name, Mediator mediator) { this.name = name; this.mediator = mediator; } public void send(String message) { System.out.println(name + \\\" 发送消息: \\\" + message); mediator.sendMessage(message, this); } public void receive(String message) { System.out.println(name + \\\" 收到消息: \\\" + message); } public String getName() { return name; } } \",\"对于中介者设计模式的简单案例，我们无法实际运行测试，因为它是一个示例代码，不涉及实际的交互或外部依赖。这个例子主要用于说明中介者设计模式的结构和实现，而不是实际运行和交互。\",\"为了运行测试，我们需要创建客户端代码来创建中介者、参与者对象，并模拟它们之间的通信。以下是一个简单的客户端代码示例，用于展示中介者设计模式的运行测试：\",\"public class Client { public static void main(String[] args) { // 创建聊天室作为中介者 Mediator chatRoom = new ChatRoom(); // 创建用户参与者 Participant user1 = new User(\\\"User1\\\", chatRoom); Participant user2 = new User(\\\"User2\\\", chatRoom); Participant user3 = new User(\\\"User3\\\", chatRoom); // 用户发送和接收消息 user1.send(\\\"Hello, everyone!\\\"); user2.send(\\\"Hi, User1!\\\"); user3.send(\\\"Hey, there!\\\"); } } \",\"在这个客户端代码中，我们创建了一个聊天室作为中介者，然后创建了三个用户参与者。用户通过调用 send() 方法来发送消息，中介者将消息传递给其他用户，并调用 receive() 方法来接收消息。输出结果显示每个用户成功发送了消息，并且其他用户成功接收到了这些消息。\",\"User1 发送消息: Hello, everyone! User2 发送消息: Hi, User1! User3 发送消息: Hey, there! \",\"这个例子是一个简单的模拟，它演示了中介者设计模式的应用。在实际应用中，中介者模式可以用于处理更复杂的对象间通信和交互，以实现更灵活和解耦的系统设计。\"]},\"409\":{\"h\":\"4、解析和注释\",\"t\":[\"上述代码实现了一个简单的聊天应用程序，其中 Mediator 接口为中介者，ChatRoom 类为具体的中介者类，Participant 接口为参与者，User 类为具体的参与者类。\",\"中介者模式的核心是 Mediator 接口和 ChatRoom 类。ChatRoom 类实现了中介者接口的 sendMessage() 方法，用于接收消息并进行传递。User 类实现了参与者接口，表示聊天应用中的用户，可以发送消息并接收消息。\",\"在客户端代码中，我们创建了一个聊天室作为中介者，并创建了两个用户作为参与者。用户可以通过发送消息来进行聊天，中介者负责将消息传递给目标用户。\",\"通过这个简单的例子，我们可以看到中介者设计模式在实现聊天应用程序等复杂的对象间通信场景中的应用。它通过引入中介者来降低对象间的直接通信复杂性，从而提高系统的松耦合性和可扩展性。\"]},\"410\":{\"h\":\"5、总结\",\"t\":[\"优点：\",\"降低耦合：中介者设计模式通过引入中介者对象，将对象之间的直接通信转为通过中介者来进行，从而降低对象之间的耦合性。\",\"简化通信：中介者模式可以简化多个对象之间的通信和交互，使得系统的结构更加清晰。\",\"缺点：\",\"中介者对象可能会变得复杂：随着系统中对象之间关联关系的增多，中介者对象可能变得复杂，导致中介者对象本身难以维护。\",\"总结：\",\"中介设计模式是一种有助于降低对象之间直接通信复杂性的设计模式。它适用于需要简化对象之间通信关系的场景。在使用中介者模式时，需要注意中介者对象的复杂性，并权衡其优缺点，确保在特定场景下使用中介者模式能够带来实际的优势。\"]},\"411\":{\"h\":\"6、和观察者对比\",\"t\":[\"中介者设计模式和观察者设计模式是两种不同的设计模式，它们的关注点和应用场景有所不同。\",\"中介者设计模式：\",\"关注点：中介者设计模式关注的是将多个对象之间的通信和交互逻辑集中处理，通过引入一个中介者对象，使得对象之间不需要直接相互通信，而是通过中介者进行通信。中介者模式旨在降低对象之间的耦合性，使得对象之间的通信更加灵活和解耦。\",\"适用场景：中介者设计模式适用于对象之间存在复杂的交互和通信关系的场景，当对象之间的通信逻辑过于复杂且耦合性高时，可以引入一个中介者对象来简化和集中通信逻辑。\",\"观察者设计模式：\",\"关注点：观察者设计模式关注的是对象之间的一对多依赖关系。当一个对象的状态发生变化时，所有依赖它的观察者对象都会得到通知并更新自己的状态。观察者模式旨在建立对象之间的松耦合关系，使得一个对象的变化可以通知到多个观察者对象。\",\"适用场景：观察者设计模式适用于一个对象的状态变化需要通知多个观察者对象的场景。当一个对象的变化需要影响到多个其他对象时，可以使用观察者模式来建立对象之间的依赖关系。\",\"区别：\",\"目的不同：中介者设计模式的目的是简化对象之间的通信和交互，降低耦合性，而观察者设计模式的目的是建立对象之间的依赖关系，使得一个对象的变化可以通知到多个观察者对象。\",\"对象关系不同：中介者设计模式中，对象之间的通信是通过中介者对象进行的，对象之间不存在直接的关联。而观察者设计模式中，对象之间存在一对多的依赖关系，观察者对象直接订阅和监听被观察对象的状态变化。\",\"侧重点不同：中介者设计模式侧重于集中处理对象之间的通信和交互逻辑，使得对象之间的通信更加简单和灵活。观察者设计模式侧重于建立对象之间的松耦合关系，使得一个对象的状态变化可以通知到多个观察者对象。\",\"虽然中介者设计模式和观察者设计模式有不同的关注点和应用场景，但它们都是用于实现对象之间的解耦和通信，从而提高系统的灵活性和可维护性。根据具体的业务需求和设计目标，选择合适的设计模式来组织和管理对象之间的交互关系是很重要的。\"]},\"412\":{\"c\":[\"计算机基础\"]},\"413\":{\"c\":[\"设计模式\"]},\"414\":{\"h\":\"创建型设计模式\",\"t\":[\"创建型设计模式的核心就是给我们提供了一系列全新的创建对象的方式方法\",\"创建型设计模式：核心目的就是给我们提供了一系列全新的创建对象的方式方法\"]},\"415\":{\"h\":\"一、单例设计模式\"},\"416\":{\"h\":\"1、介绍\",\"t\":[\"单例设计模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点以供其他对象使用。单例模式常用于需要在整个系统中共享一个共享资源或管理共享状态的情况下。\"]},\"417\":{\"h\":\"2、核心思想\",\"t\":[\"单例设计模式的核心思想是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。通过使用单例模式，可以控制对象的创建过程，并确保在整个系统中只存在一个实例，提供对该实例的全局访问。\"]},\"418\":{\"h\":\"3、组成和基本流程\",\"t\":[\"单例设计模式通常由以下组成部分构成：\",\"单例类（Singleton Class）：表示只能有一个实例的类。该类负责创建自己的唯一实例，并提供对该实例的全局访问。\",\"全局访问点（Global Access Point）：提供对单例类实例的全局访问。其他对象可以通过该访问点获取单例类的实例。\",\"单例设计模式的基本流程如下：\",\"将类的构造函数设置为私有，以防止其他对象直接实例化该类。\",\"在类内部创建一个私有静态成员变量，用于保存类的唯一实例。\",\"提供一个公共的静态方法作为全局访问点，用于获取类的实例。在该方法内部，如果实例不存在，则创建一个新实例并返回；如果实例已存在，则直接返回现有实例。\"]},\"419\":{\"h\":\"4、使用场景\",\"t\":[\"单例设计模式适用于以下场景：\",\"当需要在整个系统中共享一个共享资源或管理共享状态时 ➡️ Spring容器的单例\",\"当某个对象只能有一个实例，而且需要对该实例进行严格的控制和管理时 ➡️ JDK中的Runtime类，该类封装了运行时的环境\",\"当需要对资源进行集中管理，以便于协调和控制时 ➡️ Mybaits中的org.apache.ibatis.io.VFS使用到了单例模式\",\"例如：\",\"jdk中有一个类的实现是一个标准单例模式->Runtime类，该类封装了运行时的环境。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。 一般不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前Runtime运行时对象的引用。\",\"Mybaits中的org.apache.ibatis.io.VFS使用到了单例模式。VFS就是Virtual File System的意思，mybatis通过VFS来查找指定路径下的资源。查看VFS以及它的实现类，不难发现，VFS的角色就是对更“底层”的查找指定资源的方法的封装，将复杂的 “底层”操作封装到易于使用的高层模块中，方便使用者使用。\"]},\"420\":{\"h\":\"5、具体案例\"},\"421\":{\"h\":\"6、总结\",\"t\":[\"单例设计模式通过确保一个类只有一个实例，提供了全局访问点来获取该实例。它在需要共享资源或管理共享状态的情况下非常有用。使用单例模式可以控制对象的创建和访问，提供对实例的全局访问，并确保在整个系统中只有一个实例存在。\",\"单例设计模式的优点和缺点：\",\"优点：\",\"提供了对唯一实例的全局访问点，方便其他对象使用。\",\"控制对象的创建过程，确保在整个系统中只存在一个实例。\",\"提供了对共享资源和共享状态的集中管理。\",\"缺点：\",\"可能引入全局状态和全局访问点，增加了对象之间的耦合性。\",\"可能导致单例类的职责过重，违反了单一职责原则。\",\"总体而言，单例设计模式在需要全局访问点和唯一实例的情况下非常有用。它提供了一种简单而有效的方式来管理共享资源和共享状态。然而，在使用单例模式时，需要权衡好全局状态的管理和对象职责的合理划分，以确保系统的可维护性和灵活性。\",\"单例存在的其它问题\",\"单例存在的其它问题：\",\"无法支持面向对象编程：单例模式的构造方法被私有化，这导致无法将单例类作为其他类的父类，限制了继承和多态的特性。这意味着在面对未来的需求变化时，扩展性受到限制。如果需要创建类似但略有差异的单例，就需要重新创建一个相似且大部分功能相同的单例类，造成代码冗余。\",\"极难的横向扩展：单例模式只允许存在一个实例对象，如果未来需要创建更多实例以满足不同需求，就必须修改源代码。这违反了开闭原则，增加新的实例需要对现有代码进行修改，导致扩展困难。例如，在数据库连接池中，可能从一个连接变成需要多个连接。\",\"不同作用范围的单例：\",\"线程级别的单例：每个线程都拥有自己的单例实例，线程之间互不干扰。\",\"容器范围的单例：在容器中管理单例实例，容器可以管理多个单例对象并控制其生命周期。\",\"日志中的多例：在日志记录中，可能需要根据不同的上下文创建多个实例来记录不同的日志信息。\",\"请注意，尽管单例模式存在一些缺点，但在某些情况下仍然是有用的设计模式。在使用单例模式时，需要仔细考虑其适用性和潜在的问题，并根据具体情况做出权衡决策。\"]},\"422\":{\"h\":\"二、工厂设计模式\",\"t\":[\"当没有使用工厂设计模式的情况下，代码可能会像下面这样实现：\",\"public class Resource { private String url; public Resource(String url) { this.url = url; } } public class ResourceLoader { private Resource load(String url) { // 根据前缀匹配 String prefix = getPrefix(url); if (prefix.equals(\\\"http\\\")) { // 很复杂的操作，可能此处会执行很久 return new Resource(url); } else if (prefix.equals(\\\"file\\\")) { // 很复杂的操作，可能此处会执行很久 return new Resource(url); } else if (prefix.equals(\\\"classpath\\\")) { // 很复杂的操作，可能此处会执行很久 return new Resource(url); } else { return new Resource(\\\"default\\\"); } } private String getPrefix(String url) { if (url == null || \\\"\\\".equals(url) || url.contains(\\\":\\\")) { throw new ResourceLoadException(\\\"url不合法\\\"); } String[] split = url.split(\\\":\\\"); return split[0]; } } \",\"代码详细解析：\",\"上述代码包含两个类：Resource 和 ResourceLoader。\",\"Resource 类表示资源对象，具有一个私有的 url 字段和一个公共的构造函数。它通过构造函数接收一个 url 参数，并将其赋值给 url 字段。\",\"ResourceLoader 类是一个资源加载器，它有一个私有的 load 方法用于加载资源。该方法接收一个 url 参数，根据其前缀进行匹配。根据前缀的不同，它执行不同的操作来创建并返回一个 Resource 对象。\",\"在 load 方法中，它通过调用私有的 getPrefix 方法来获取 url 的前缀。然后，使用条件语句判断前缀是什么，并在每个分支中执行复杂的操作（可能需要执行很久）来创建一个对应的 Resource 对象。如果前缀不匹配任何条件，则创建一个默认的 Resource 对象。\",\"getPrefix 方法用于从 url 中提取前缀。它首先检查 url 是否为空、空字符串或包含冒号。如果是，则抛出一个 ResourceLoadException 异常，表示 url 不合法。否则，它通过将 url 使用冒号进行分割，并返回分割后的第一个元素作为前缀。\",\"总结：以上代码展示了一个简单的资源加载器，根据给定的 url 和其前缀，创建并返回对应的 Resource 对象。它通过条件语句进行判断和创建，没有使用工厂设计模式。然而，这种实现方式存在代码冗余和可扩展性差的问题。工厂设计模式可以用来改善这些问题。\",\"在这个没有使用工厂设计模式的例子中，ResourceLoader 类负责根据 URL 的前缀来加载资源。根据不同的前缀，它执行不同的操作来创建 Resource 对象。这导致了以下问题：\",\"代码冗余：在每个分支中，都有相似的复杂操作用于创建 Resource 对象，这造成了代码的重复。\",\"可扩展性差：当需要添加新的资源类型时，需要修改 ResourceLoader 类的代码，并增加对应的分支。这违反了开闭原则，使代码难以扩展和维护。\",\"低内聚性：ResourceLoader 类的职责既包括根据前缀选择创建资源对象的逻辑，又包括资源对象的创建过程，导致职责不够单一。\",\"没有使用工厂设计模式的代码实现不够灵活，代码复用性较低，并且随着业务需求的变化，代码的维护和扩展会变得困难。相比之下，使用工厂设计模式可以将对象的创建逻辑封装到工厂类中，提高了代码的可扩展性和可维护性，同时使得代码更加清晰和易于理解。\"]},\"423\":{\"h\":\"1、简单工厂\"},\"424\":{\"h\":\"1.1 介绍\",\"t\":[\"简单工厂设计模式（Simple Factory Pattern）是一种创建型设计模式，它提供了一种统一的方式来创建对象，而无需直接实例化具体的产品类。简单工厂模式通过将对象的创建逻辑封装在一个工厂类中，根据不同的参数返回相应的对象实例。\"]},\"425\":{\"h\":\"1.2 核心思想\",\"t\":[\"简单工厂设计模式的核心思想是通过一个工厂类来封装对象的创建过程。客户端通过传递不同的参数给工厂类，工厂类根据参数的不同来创建对应的具体产品对象。这样可以将对象的创建和使用分离，降低了客户端代码的耦合性。\"]},\"426\":{\"h\":\"1.3 组成\",\"t\":[\"简单工厂设计模式由以下组成部分构成：\",\"工厂类（Factory Class）：负责创建具体产品对象的工厂类。它包含一个静态方法，根据传入的参数返回相应的产品对象。\"]},\"427\":{\"h\":\"1.4 基本流程\",\"t\":[\"简单工厂设计模式的基本流程如下：\",\"定义一个工厂类，包含一个静态方法用于创建产品对象。\",\"在工厂方法中根据不同的参数，实例化相应的具体产品对象。\",\"客户端通过调用工厂方法并传递参数，获取所需的产品对象。\"]},\"428\":{\"h\":\"1.5 使用场景\",\"t\":[\"简单工厂设计模式适用于以下场景：\",\"当需要根据不同参数创建不同的对象时。\",\"当需要将对象的创建和使用分离，降低客户端代码的耦合性时。\"]},\"429\":{\"h\":\"1.6 具体案例\",\"t\":[\"在下列案例中，ResourceLoader类是一个资源加载器，负责根据URL加载对应的资源。为了将资源的创建过程与资源加载器解耦，使用了简单工厂模式。ResourceLoadFactory类是工厂类，根据URL的前缀来创建不同类型的资源对象。在ResourceLoader类中，通过调用工厂类的静态方法create()来获取相应的资源实例，而不需要直接实例化具体的资源类。\",\"public class ResourceLoader { private Resource load(String url) { //1.根据前缀匹配 String prefix = getPrefix(url); //使用简单工厂模式,不将创建资源的过程耦合到此处代码 return ResourceLoadFactory.create(prefix, url); } private String getPrefix(String url) { if (url == null || \\\"\\\".equals(url) || url.contains(\\\":\\\")) { throw new ResourceLoadException(\\\"url不合法\\\"); } String[] split = url.split(\\\":\\\"); return split[0]; } } public class ResourceLoadFactory { public static Resource create(String type, String url) { if (type.equals(\\\"http\\\")) { //很复杂的操作,可能此处会执行很久 return new Resource(url); } else if (type.equals(\\\"file\\\")) { //很复杂的操作,可能此处会执行很久 return new Resource(url); } else if (type.equals(\\\"classpath\\\")) { //很复杂的操作,可能此处会执行很久 return new Resource(url); } else { return new Resource(\\\"default\\\"); } } } \"]},\"430\":{\"h\":\"1.7 总结\",\"t\":[\"简单工厂设计模式通过一个工厂类来封装对象的创建过程，根据不同的参数返回相应的产品对象。它提供了一种简单而统一的方式来创建对象，将对象的创建和使用分离，降低了客户端代码的耦合性。\",\"优点和缺点：\",\"优点：\",\"将对象的创建逻辑集中在一个工厂类中，方便维护和管理。\",\"客户端通过调用工厂方法获取所需的产品对象，无需直接实例化具体产品类。\",\"可以通过改变工厂方法的实现，轻松扩展新的产品类。\",\"缺点：\",\"工厂类的职责较重，可能随着产品种类的增加而变得臃肿。\",\"新增产品需要修改工厂类的代码，违背了开闭原则。\",\"总体而言，简单工厂设计模式提供了一种简单而统一的方式来创建对象，将对象的创建和使用分离。它适用于需要根据不同参数创建不同对象的场景，并可以提供一定程度的灵活性和扩展性。然而，在使用简单工厂模式时，需要注意工厂类的职责和代码的扩展性，以确保系统的可维护性和可扩展性。\",\"简单工厂设计模式（Simple Factory Pattern）是一种创建型设计模式，旨在通过一个工厂类来封装对象的创建过程。它属于最基本的工厂模式，虽然并不是一种正式的设计模式，但在实际开发中被广泛应用。\",\"在简单工厂模式中，存在一个具体的工厂类，负责根据客户端的需求创建不同类型的产品对象。客户端只需要提供一个参数或条件给工厂类，工厂类根据参数或条件的不同，返回相应类型的产品对象。这样，客户端与具体产品类之间解耦，不需要直接依赖具体产品的创建过程。\",\"总结就是：一个工厂负责生产多个产品\"]},\"431\":{\"h\":\"2、工厂方法\"},\"432\":{\"h\":\"2.1 介绍\",\"t\":[\"工厂方法设计模式（Factory Method Design Pattern）是一种创建型设计模式，旨在解决对象的创建过程。它定义了一个用于创建对象的接口，但将具体对象的创建延迟到子类中实现。工厂方法模式通过将对象的创建和使用分离，实现了开闭原则，使得系统更加灵活可扩展。\"]},\"433\":{\"h\":\"2.2 核心思想\",\"t\":[\"工厂方法设计模式的核心思想是将对象的创建委托给子类来实现。定义一个创建对象的接口，具体的对象创建由子类来完成。这样可以在不修改客户端代码的情况下，通过切换具体工厂类来创建不同的产品对象。\"]},\"434\":{\"h\":\"2.3 组成和基本流程\",\"t\":[\"工厂方法设计模式通常由以下组成部分构成：\",\"抽象工厂类（Abstract Factory Class）：定义了创建对象的接口，包含一个抽象的工厂方法。\",\"具体工厂类（Concrete Factory Class）：实现了抽象工厂类，负责创建具体的产品对象。\",\"抽象产品类（Abstract Product Class）：定义了产品对象的接口，描述了产品的公共方法。\",\"具体产品类（Concrete Product Class）：实现了抽象产品类，表示具体的产品对象。\",\"工厂方法设计模式的基本流程如下：\",\"定义抽象工厂类，包含一个抽象的工厂方法。\",\"定义抽象产品类，描述产品对象的公共接口。\",\"创建具体产品类，实现抽象产品类的接口。\",\"创建具体工厂类，实现抽象工厂类，负责创建具体的产品对象。\",\"在客户端中，通过抽象工厂类创建产品对象，而无需直接实例化具体的产品类。\"]},\"435\":{\"h\":\"2.4 使用场景\",\"t\":[\"工厂方法设计模式适用于以下场景：\",\"当需要创建一组相关的对象时，可以使用工厂方法模式来统一创建这些对象。\",\"当对象的创建逻辑比较复杂，或者需要根据不同的条件创建不同的对象时，可以使用工厂方法模式。\"]},\"436\":{\"h\":\"2.5 具体案例\",\"t\":[\"下列这段代码展示了使用抽象工厂设计模式的资源加载器实现。\",\"// 抽象产品和具体产品 @Data public abstract class AbstractResource { private String url; public AbstractResource() { } public AbstractResource(String url) { this.url = url; } // 子类都要实现的方法 public abstract InputStream getInputStream(); } public class FileResource extends AbstractResource { public FileResource() { super(); } public FileResource(String url) { super(url); } @Override public InputStream getInputStream() { return null; } } // 抽象工厂和具体工厂 public interface IResourceFactory { public AbstractResource create(String url); } public class FileResourceFactory implements IResourceFactory { @Override public AbstractResource create(String url) { // 很复杂的逻辑... // 很复杂的逻辑... // 很复杂的逻辑... // 很复杂的逻辑... // 很复杂的逻辑... return new FileResource(url); } } // 测试 @Slf4j public class ResourceLoaderMethod { private IResourceFactory resourceFactory; private static Map<String, IResourceFactory> resourceFactoryCache = new HashMap<>(8); static { // 在类加载的时候/起一个定时器,定时读取配置文件 InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\\\"resourceFactory.properties\\\"); Properties properties = null; try { properties = new Properties(); properties.load(inputStream); } catch (IOException e) { throw new RuntimeException(e); } Set<Map.Entry<Object, Object>> entries = properties.entrySet(); Iterator<Map.Entry<Object, Object>> iterator = entries.iterator(); while (iterator.hasNext()) { Map.Entry<Object, Object> next = iterator.next(); String prefixKey = next.getKey().toString(); String className = next.getValue().toString(); Class<?> clazz = null; try { clazz = Class.forName(className); IResourceFactory instance = (IResourceFactory) clazz.getConstructor().newInstance(); resourceFactoryCache.put(prefixKey, instance); } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) { throw new RuntimeException(e); } } } private AbstractResource load(String url) { String prefix = getPrefix(url); return resourceFactoryCache.get(prefix).create(url); } private String getPrefix(String url) { if (url == null || \\\"\\\".equals(url) || url.contains(\\\":\\\")) { return \\\"default\\\"; } String[] split = url.split(\\\":\\\"); return split[0]; } public static void main(String[] args) { ResourceLoaderMethod rlm = new ResourceLoaderMethod(); AbstractResource load = rlm.load(\\\"file:user/inter\\\"); System.out.println(\\\"load.getUrl() = \\\" + load.getUrl()); } } \",\"代码详细解析：\",\"抽象产品和具体产品部分：\",\"AbstractResource 是抽象产品类，它包含了一个 url 字段，并定义了一个抽象方法 getInputStream()。\",\"FileResource 是具体产品类，它继承自 AbstractResource，实现了抽象方法 getInputStream()。\",\"抽象工厂和具体工厂部分：\",\"IResourceFactory 是抽象工厂接口，它定义了一个方法 create()，用于创建抽象产品 AbstractResource 对象。\",\"FileResourceFactory 是具体工厂类，实现了 IResourceFactory 接口。在 create() 方法中，它通过复杂的逻辑创建一个 FileResource 对象，并将其返回。\",\"测试部分：\",\"ResourceLoaderMethod 类中包含了一个静态的 resourceFactoryCache 缓存，用于存储不同前缀对应的具体工厂对象。\",\"在静态代码块中，通过读取配置文件 resourceFactory.properties，获取了具体工厂类的映射关系，并将其实例化放入缓存中。\",\"load() 方法根据传入的 URL 获取前缀，并从 resourceFactoryCache 缓存中获取对应的具体工厂对象，然后调用其 create() 方法创建抽象产品对象。\",\"getPrefix() 方法用于从 URL 中提取前缀，如果 URL 为空、空字符串或包含冒号，则返回默认前缀。\",\"在 main() 方法中，创建 ResourceLoaderMethod 对象，并通过调用 load() 方法加载资源。最后打印出加载的资源的 URL。\",\"通过这段代码，资源加载器实现了抽象工厂设计模式。客户端只需与抽象工厂接口 IResourceFactory 进行交互，通过调用其 create() 方法，由具体工厂类根据传入的 URL 创建相应的具体产品对象。这样可以实现客户端与具体产品类的解耦，提高了代码的灵活性和可维护性。\"]},\"437\":{\"h\":\"2.6 总结\",\"t\":[\"工厂方法设计模式的优点包括：\",\"实现了对象的创建和使用的解耦，客户端只需要与抽象工厂接口交互。\",\"提供了可扩展性，可以通过添加新的具体工厂类和产品类来创建新的产品对象。\",\"代码结构清晰，各个对象的职责明确。\",\"然而，工厂方法设计模式也存在一些缺点：\",\"需要定义抽象工厂和抽象产品接口，增加了代码的复杂度。\",\"每新增一个具体产品，都需要新增相应的具体产品类和具体工厂类，导致类的数量增加。\",\"总的来说，工厂方法设计模式是一种非常常用和灵活的设计模式，可以帮助我们实现对象的创建和使用的解耦，提高代码的可扩展性和维护性。\",\"总结就是：一个工厂生产一个产品\"]},\"438\":{\"h\":\"3、抽象工厂\"},\"439\":{\"h\":\"3.1 介绍\",\"t\":[\"抽象工厂设计模式（Abstract Factory Pattern）是一种创建型设计模式，旨在提供一个接口来创建一系列相关或依赖对象的家族，而无需指定具体实现类。它将对象的创建与使用相分离，使得客户端代码与具体产品的实现解耦，提供了一种灵活的方式来创建对象。\"]},\"440\":{\"h\":\"3.2 核心思想\",\"t\":[\"抽象工厂设计模式的核心思想是通过提供一个抽象工厂接口，定义一系列创建产品的方法，每个具体的工厂实现该接口，并负责创建特定的产品家族。客户端只与抽象工厂和抽象产品进行交互，而不直接依赖具体产品的实现。\"]},\"441\":{\"h\":\"3.3 组成和基本流程\",\"t\":[\"抽象工厂设计模式包含以下组成：\",\"抽象工厂（Abstract Factory）：定义用于创建产品家族的接口，声明了一系列创建产品的方法。\",\"具体工厂（Concrete Factory）：实现抽象工厂接口，具体实现了创建产品的方法，每个具体工厂对应一个具体产品家族。\",\"抽象产品（Abstract Product）：定义产品的接口，声明产品的共性方法。\",\"具体产品（Concrete Product）：实现抽象产品接口，具体定义产品的具体实现。\",\"抽象工厂设计模式的基本流程：\",\"定义抽象工厂接口，声明一系列创建产品的方法。\",\"创建具体产品类，实现抽象产品接口。\",\"创建具体工厂类，实现抽象工厂接口，实现产品的创建方法。\",\"在客户端中使用抽象工厂接口声明工厂对象，通过工厂对象创建具体产品。\"]},\"442\":{\"h\":\"3.4 使用场景\",\"t\":[\"抽象工厂设计模式适用于以下情景：\",\"系统需要创建一系列相关或依赖的产品家族。\",\"客户端不关心或不知道如何创建产品的具体实现。\",\"需要解耦客户端和具体产品的实现。\"]},\"443\":{\"h\":\"3.5 具体案例\",\"t\":[\"代码详细解析：\",\"下列代码实现了抽象工厂设计模式。抽象工厂设计模式旨在提供一个接口（抽象工厂），用于创建一系列相关或依赖的产品（抽象产品）的家族，而无需指定具体实现类。它将产品的创建与使用相分离，使得客户端代码与具体产品的实现解耦，提供了一种灵活的方式来创建对象。\",\"在这段代码中：\",\"抽象产品由接口 IResource 和具体实现类 AbstractVideoResource、AbstractTextResource、AbstractPictureResource 组成。每个具体产品都实现了 IResource 接口，并包含一些特定的方法。\",\"抽象工厂由接口 IResourceFactory 和具体工厂类 AbstractResourceFactory、FileResourceFactory、HttpResourceFactory 组成。抽象工厂接口定义了创建产品的抽象方法和加载具体产品的工厂方法。具体工厂类实现了抽象工厂接口，并负责实现具体产品的创建和加载。\",\"在 ResourceLoaderMethod 类中，通过静态缓存 resourceFactoryCache 存储不同前缀对应的具体工厂对象。在类加载时，通过读取配置文件，动态创建具体工厂对象，并将其放入缓存中。load() 方法根据传入的 URL 获取前缀，然后通过具体工厂对象调用 create() 方法创建抽象产品对象。这样，客户端代码只需要与抽象工厂进行交互，而无需关心具体产品的创建和加载过程。\",\"以下是整合后的代码，展示了抽象工厂设计模式的实现：\",\"public interface IResource {//抽象产品 InputStream getInputStream(); } //抽象产品 @Data public abstract class AbstractVideoResource implements IResource { private String url; public AbstractVideoResource() { } public AbstractVideoResource(String url) { this.url = url; } public void transformMp4() { System.out.println(\\\"视频资源组共有方法-transformMp4()\\\"); } } //抽象产品 @Data public abstract class AbstractTextResource implements IResource { private String url; public AbstractTextResource() { } public AbstractTextResource(String url) { this.url = url; } public void transformUtf8() { System.out.println(\\\"文本资源组共有方法-transformUtf8()\\\"); } } //抽象产品 @Data public abstract class AbstractPictureResource implements IResource { private String url; public AbstractPictureResource() { } public AbstractPictureResource(String url) { this.url = url; } public void transformJpg() { System.out.println(\\\"图片资源组共有方法-transformJpg()\\\"); } } //具体产品 public class FileTextResource extends AbstractTextResource { @Override public InputStream getInputStream() { return null; } } //具体产品 public class FileVideoResource extends AbstractVideoResource { @Override public InputStream getInputStream() { return null; } } //具体产品 public class FilePictureResource extends AbstractPictureResource { public FilePictureResource() { super(); } public FilePictureResource(String url) { super(url); } @Override public InputStream getInputStream() { return null; } } //具体产品 public class HttpPictureResource extends AbstractPictureResource { public HttpPictureResource() { super(); } public HttpPictureResource(String url) { super(url); } @Override public InputStream getInputStream() { return null; } } //具体产品 public class HttpTextResource extends AbstractPictureResource { public HttpTextResource() { super(); } public HttpTextResource(String url) { super(url); } @Override public InputStream getInputStream() { return null; } } //具体产品 public class HttpVideoResource extends AbstractPictureResource { public HttpVideoResource() { super(); } public HttpVideoResource(String url) { super(url); } @Override public InputStream getInputStream() { return null; } } //抽象工厂 public interface IResourceFactory { AbstractPictureResource create(String url); AbstractPictureResource loadPicture(String url); AbstractVideoResource loadVideo(String url); AbstractTextResource loadText(String url); } //抽象工厂 public abstract class AbstractResourceFactory implements IResourceFactory { } //具体工厂 public class FileResourceFactory extends AbstractResourceFactory { @Override public AbstractPictureResource create(String url) { return new FilePictureResource(url); } @Override public AbstractPictureResource loadPicture(String url) { return null; } @Override public AbstractVideoResource loadVideo(String url) { return null; } @Override public AbstractTextResource loadText(String url) { return null; } } //抽象工厂 public class HttpResourceFactory extends AbstractResourceFactory { @Override public AbstractPictureResource create(String url) { return new HttpPictureResource(url); } @Override public AbstractPictureResource loadPicture(String url) { return null; } @Override public AbstractVideoResource loadVideo(String url) { return null; } @Override public AbstractTextResource loadText(String url) { return null; } } //客户端测试 @Slf4j public class ResourceLoaderMethod { private IResourceFactory resourceFactory; private static Map<String, IResourceFactory> resourceFactoryCache = new HashMap<>(8); static { InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\\\"resourceFactory.properties\\\"); Properties properties = null; try { properties = new Properties(); properties.load(inputStream); } catch (IOException e) { throw new RuntimeException(e); } Set<Map.Entry<Object, Object>> entries = properties.entrySet(); Iterator<Map.Entry<Object, Object>> iterator = entries.iterator(); while (iterator.hasNext()) { Map.Entry<Object, Object> next = iterator.next(); String prefixKey = next.getKey().toString(); String className = next.getValue().toString(); Class<?> clazz = null; try { clazz = Class.forName(className); IResourceFactory instance = (IResourceFactory) clazz.getConstructor().newInstance(); resourceFactoryCache.put(prefixKey, instance); } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) { throw new RuntimeException(e); } } } private AbstractPictureResource load(String url) { String prefix = getPrefix(url); return resourceFactoryCache.get(prefix).create(url); } private String getPrefix(String url) { if (url == null || \\\"\\\".equals(url) || url.contains(\\\":\\\")) { return \\\"default\\\"; } String[] split = url.split(\\\":\\\"); return split[0]; } public static void main(String[] args) { ResourceLoaderMethod rlm = new ResourceLoaderMethod(); AbstractPictureResource load = rlm.load(\\\"file:user/inter\\\"); System.out.println(\\\"load.getUrl() = \\\" + load.getUrl()); } } \"]},\"444\":{\"h\":\"3.6 总结\",\"t\":[\"优点：\",\"提供了一种灵活的方式来创建一系列相关或依赖的产品家族。\",\"客户端与具体产品的实现解耦，可以方便地替换具体工厂和产品。\",\"符合开闭原则，容易扩展新的产品家族。\",\"缺点：\",\"添加新的产品家族可能需要修改抽象工厂的接口和所有的具体工厂。\",\"抽象工厂设计模式通过将产品的创建与使用相分离，提供了一种创建对象的灵活方式，同时也增加了系统的复杂度。在设计时需要权衡灵活性和复杂性之间的平衡。\",\"总结就是：一个工厂生产一组产品线\"]},\"445\":{\"h\":\"三、建造者设计模式\"},\"446\":{\"h\":\"1、简介\",\"t\":[\"建造者设计模式（Builder Pattern）是一种创建型设计模式，它专注于逐步构建复杂对象。它将对象的构建过程与其表示分离，允许相同的构建过程创建不同的表示形式。该模式的目标是简化对象的构建过程，并提供灵活性和可扩展性。\"]},\"447\":{\"h\":\"2、核心思想\",\"t\":[\"Builder设计模式的核心思想是将对象的构建过程从其实际表示中解耦。通常情况下，一个对象的构建过程是复杂且多步骤的，使用Builder模式可以将这些步骤分解为独立的方法，从而使得构建过程更加灵活和可控。\"]},\"448\":{\"h\":\"3、组成和基本流程\",\"t\":[\"Builder设计模式包含以下几个主要组成部分：\",\"Director（指导者）：负责控制对象的构建过程，按照一定的顺序调用Builder的方法来构建对象。\",\"Builder（构建者）：定义构建对象的接口，包含各个构建步骤的方法。\",\"ConcreteBuilder（具体构建者）：实现Builder接口，负责具体的构建逻辑，并返回构建完成的对象。\",\"Product（产品）：表示最终构建完成的对象，通常具有复杂的内部结构。\",\"详情\",\"Builder设计模式的基本流程和简单示例如下：\",\"定义一个Builder接口，其中包含各个构建步骤的方法。\",\"创建具体的Builder类，实现Builder接口，并实现各个构建步骤的具体逻辑。\",\"创建一个Director类，它包含一个Builder对象作为成员变量。通过调用Builder的方法，按照特定的顺序构建对象。\",\"最终调用Builder的一个方法返回构建完成的对象。\",\"下列是一个简单的建造者设计模式的例子，这段代码演示了如何使用建造者设计模式创建一个电脑对象。\",\"首先，我们定义了一个Computer类，它具有一些属性（processor、memory、hardDisk、monitor）以及对应的设置方法。\",\"然后，我们定义了一个ComputerBuilder接口，其中包含了构建电脑对象所需的方法（buildProcessor、buildMemory、buildHardDisk、buildMonitor）以及获取构建完成的电脑对象的方法getComputer()。\",\"接着，我们实现了一个BasicComputerBuilder类，它是ComputerBuilder接口的具体实现。在BasicComputerBuilder类中，我们实例化了一个Computer对象，并实现了构建电脑各个部件的方法。\",\"之后，我们创建了一个ComputerDirector类，它负责指导建造过程。通过调用ComputerBuilder的方法，按照一定的顺序构建电脑对象，并返回构建完成的对象。\",\"最后，在Main类中，我们创建了一个BasicComputerBuilder对象作为建造者，创建了一个ComputerDirector对象作为指导者，然后通过指导者来构建电脑对象。最后，我们输出了构建完成的电脑对象的各个属性。\",\"class Computer { private String processor; private String memory; private String hardDisk; private String monitor; public void setProcessor(String processor) { this.processor = processor; } public void setMemory(String memory) { this.memory = memory; } public void setHardDisk(String hardDisk) { this.hardDisk = hardDisk; } public void setMonitor(String monitor) { this.monitor = monitor; } // 省略其他方法和属性的访问器 } interface ComputerBuilder { void buildProcessor(); void buildMemory(); void buildHardDisk(); void buildMonitor(); Computer getComputer(); } class BasicComputerBuilder implements ComputerBuilder { private Computer computer; public BasicComputerBuilder() { this.computer = new Computer(); } public void buildProcessor() { computer.setProcessor(\\\"Basic Processor\\\"); } public void buildMemory() { computer.setMemory(\\\"4GB\\\"); } public void buildHardDisk() { computer.setHardDisk(\\\"500GB\\\"); } public void buildMonitor() { computer.setMonitor(\\\"15-inch\\\"); } public Computer getComputer() { return computer; } } class ComputerDirector { public Computer buildComputer(ComputerBuilder builder) { builder.buildProcessor(); builder.buildMemory(); builder.buildHardDisk(); builder.buildMonitor(); return builder.getComputer(); } } public class Main { public static void main(String[] args) { ComputerBuilder builder = new BasicComputerBuilder(); ComputerDirector director = new ComputerDirector(); Computer computer = director.buildComputer(builder); System.out.println(\\\"Processor: \\\" + computer.getProcessor()); System.out.println(\\\"Memory: \\\" + computer.getMemory()); System.out.println(\\\"Hard Disk: \\\" + computer.getHardDisk()); System.out.println(\\\"Monitor: \\\" + computer.getMonitor()); } } \",\"在这个示例中，我们通过建造者模式逐步构建了一个电脑对象。指导者类控制了建造过程，而具体的建造者类负责实际构建对象。最终，我们可以获取到一个完整的电脑对象，并对其进行进一步操作。\"]},\"449\":{\"h\":\"4、使用场景\",\"t\":[\"Builder设计模式适用于以下情况：\",\"当需要创建具有复杂内部结构的对象时，可以使用Builder模式将构建过程分解为多个简单步骤。\",\"当需要构建的对象存在不同的表示形式时，可以使用Builder模式来创建不同的表示。\",\"当需要在构建过程中灵活地添加或修改构建步骤时，可以使用Builder模式。\",\"实现不可变对象，可以使用Builder模式创建不可变对象。通过将建造者的构建方法设置为私有，并将需要的属性通过构造函数进行初始化，可以确保对象在构建后不可再修改。这样的对象可以提供更好的线程安全性和代码健壮性。\"]},\"450\":{\"h\":\"5、具体案例\",\"t\":[\"在这个示例中，我们使用建造者设计模式创建了一个名为 ImmutablePerson 的不可变对象类。\",\"在 ImmutablePerson 类中，属性 name、age 和 address 被声明为 final，并且没有提供任何修改它们的方法。这样可以确保这些属性在对象创建后不可变。\",\"通过私有的构造方法 ImmutablePerson(Builder builder)，我们将属性的值从 Builder 对象传递给了 ImmutablePerson 对象，并在构造方法内进行了赋值操作。这样，我们可以在构造对象时保证对象的属性值一致和不可变。\",\"Builder 类是一个嵌套类，它提供了链式调用的方法来设置 ImmutablePerson 的属性值。每个方法都返回 Builder 对象本身，以便可以连续调用多个方法。最后，通过调用 build() 方法，我们可以创建并返回一个不可变的 ImmutablePerson 对象。\",\"使用该示例，我们可以这样创建一个不可变的 ImmutablePerson 对象：\",\"public final class ImmutablePerson { private final String name; private final int age; private final String address; private ImmutablePerson(Builder builder) { this.name = builder.name; this.age = builder.age; this.address = builder.address; } public String getName() { return name; } public int getAge() { return age; } public String getAddress() { return address; } public static class Builder { private String name; private int age; private String address; public Builder() { } public Builder setName(String name) { this.name = name; return this; } public Builder setAge(int age) { this.age = age; return this; } public Builder setAddress(String address) { this.address = address; return this; } public ImmutablePerson build() { return new ImmutablePerson(this); } } public static void main(String[] args) { // Usage example: ImmutablePerson person = new ImmutablePerson.Builder() .setName(\\\"John\\\") .setAge(30) .setAddress(\\\"123 Street\\\") .build(); } } \",\"在这个示例中，我们通过链式调用 Builder 的方法设置属性的值，并最后调用 build() 方法来创建 ImmutablePerson 对象。一旦对象创建完成，它的属性就是不可变的，无法再修改。\",\"这种方式提供了不可变对象的安全性和线程安全性，因为对象的状态无法在创建后被修改。不可变对象还可以更容易地进行缓存、共享和使用。\",\"lombok例子：\",\"在lombok中，我们使用@Builder注解会自动生成一个建造者模式的构建者类。下面是一个使用Lombok的@Builder注解的示例代码：\",\"非常抱歉前面的回答中有些遗漏，确实是多了一些代码。以下是编译前和编译后的代码：\",\"编译前的代码：\",\"@Builder @Getter @ToString public class User { private String name; private Integer age; private String bobby; public static void main(String[] args) { User.UserBuilder builder = new UserBuilder(); User user = builder.name(\\\"jack\\\").age(18).bobby(\\\"rap\\\").build(); System.out.println(\\\"user = \\\" + user); } } \",\"编译后的代码：\",\"public class User { private String name; private Integer age; private String bobby; public static void main(String[] args) { UserBuilder builder = new UserBuilder(); User user = builder.name(\\\"jack\\\").age(18).bobby(\\\"rap\\\").build(); System.out.println(\\\"user = \\\" + user); } User(String name, Integer age, String bobby) { this.name = name; this.age = age; this.bobby = bobby; } public static UserBuilder builder() { return new UserBuilder(); } public String getName() { return this.name; } public Integer getAge() { return this.age; } public String getBobby() { return this.bobby; } public String toString() { return \\\"User(name=\\\" + this.getName() + \\\", age=\\\" + this.getAge() + \\\", bobby=\\\" + this.getBobby() + \\\")\\\"; } public static class UserBuilder { private String name; private Integer age; private String bobby; UserBuilder() { } public UserBuilder name(String name) { this.name = name; return this; } public UserBuilder age(Integer age) { this.age = age; return this; } public UserBuilder bobby(String bobby) { this.bobby = bobby; return this; } public User build() { return new User(this.name, this.age, this.bobby); } public String toString() { return \\\"User.UserBuilder(name=\\\" + this.name + \\\", age=\\\" + this.age + \\\", bobby=\\\" + this.bobby + \\\")\\\"; } } } \",\"请注意，编译后的代码中添加了一些内容，其中包括：\",\"在User类中，添加了私有构造函数以及对应的属性赋值操作。\",\"在User类中，添加了getter方法和toString()方法的具体实现。\",\"在User类中，添加了静态的builder()方法，用于创建UserBuilder对象。\",\"在UserBuilder类中，添加了构造函数、链式调用方法以及build()方法的具体实现。\",\"这些额外的代码是Lombok库根据注解自动生成的，它们帮助简化了建造者模式的使用，减少了手动编写重复代码的工作量。这样，您可以更方便地创建和操作User对象。\"]},\"451\":{\"h\":\"6、总结\",\"t\":[\"Builder设计模式的优点包括：\",\"可以分步骤构建复杂对象，使构建过程更加灵活和可控。\",\"可以创建不同的表示形式，根据复杂的配置项进行定制化构建，提供了更多对象构建的可能性。\",\"隔离了构建过程和表示，使得扩展和修改更加方便。\",\"然而，Builder设计模式也存在一些缺点：\",\"会增加代码量，因为需要定义和实现多个类。\",\"对于简单对象的构建，使用Builder模式可能会显得过于复杂。\",\"总的来说，Builder设计模式在构建复杂对象时非常有用，并提供了灵活性和可扩展性。但在简单情况下，使用该模式可能会带来一定的开销。\"]},\"452\":{\"h\":\"7、和工厂设计模式的区别\",\"t\":[\"建造者设计模式和工厂设计模式是两种常见的创建型设计模式，它们都用于创建对象，但在目的和使用方式上存在一些区别。\",\"工厂设计模式旨在通过一个工厂类来创建对象，隐藏了具体对象的创建细节，并将客户端与具体对象的实例化过程解耦。客户端只需要通过工厂类来请求所需的对象，而不需要直接实例化对象。工厂模式通常适用于创建不同类型对象的场景，通过使用不同的工厂方法或参数，可以创建不同类型的对象。\",\"与之不同，建造者设计模式关注的是逐步构建复杂对象，将对象的构建过程与其表示分离。它允许按照特定的步骤或顺序构建对象，并允许在构建过程中配置对象的各个部分。建造者模式通常适用于创建具有复杂结构或多个可选组件的对象，以及构建过程中涉及多个步骤或变化的对象。\",\"现在，让我们结合生活中的一个例子来说明这两种设计模式的区别。\",\"假设你要制作一份披萨。使用工厂模式，你可以有一个披萨工厂，通过向工厂提供披萨的类型（例如，奶酪披萨、素食披萨等），工厂将返回相应类型的披萨对象。这种情况下，你只需要告诉工厂你想要的披萨类型，而不需要知道具体如何制作披萨。\",\"现在，假设你要定制一份复杂的披萨，它有多个可选组件，如酱料、配料和尺寸等。这时，建造者模式更适合。你可以有一个披萨建造者，它提供了设置酱料、配料和尺寸等属性的方法。你可以逐步调用这些方法来构建披萨对象，并在构建过程中根据你的喜好进行定制。\",\"总结一下，工厂设计模式适用于创建不同类型的对象，而建造者设计模式适用于逐步构建复杂对象。工厂模式隐藏了对象的创建细节，而建造者模式允许按照特定的步骤或顺序构建对象，并允许在构建过程中进行配置和定制。\"]},\"453\":{\"h\":\"四、原型设计模式\",\"t\":[\"原型设计模式（Prototype Design Pattern）是一种创建型设计模式，旨在通过复制现有对象来创建新对象，而不是通过使用构造函数进行创建。它允许我们通过克隆（复制）现有对象的实例来创建新的对象，而无需显式地依赖于特定类的构造函数。\",\"主要分为：浅拷贝和深拷贝\"]},\"454\":{\"h\":\"1、浅拷贝\",\"t\":[\"浅拷贝是原型设计模式中的一种复制方式，它复制对象内的所有基本数据类型和引用数据类型的地址。这意味着在浅拷贝中，原始对象和复制对象将共享相同的引用数据类型的实例。\",\"当执行浅拷贝时，如果对象内有引用类型的成员变量，那么复制的对象将包含对原始对象引用数据类型成员变量的引用。这意味着两个对象的引用类型成员变量指向相同的对象，任何对引用类型的修改将会影响到两个对象。\",\"好的！让我们使用Java来举一个例子，使用浅拷贝来创建歌曲和歌单对象。\",\"首先，我们定义一个歌曲（Song）类：\",\"public class Song { private String title; private String artist; public Song(String title, String artist) { this.title = title; this.artist = artist; } public String getTitle() { return title; } public String getArtist() { return artist; } public void setTitle(String title) { this.title = title; } public void setArtist(String artist) { this.artist = artist; } @Override public String toString() { return \\\"Song: \\\" + title + \\\" - \\\" + artist; } } \",\"接下来，我们定义一个歌单（Playlist）类，它包含了多个歌曲对象：\",\"public class PlayList { private String name; private List<Song> songs; public PlayList(String name) { this.name = name; this.songs = new ArrayList<>(); } public String getName() { return name; } public List<Song> getSongs() { return songs; } public void addSong(Song song) { songs.add(song); } public void removeSong(Song song) { songs.remove(song); } public PlayList shallowCopy(String newName) { PlayList copy = new PlayList(newName); copy.songs = new ArrayList<>(songs); return copy; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\\\"PlayList: \\\").append(name).append(\\\"\\\\n\\\"); for (Song song : songs) { sb.append(\\\"- \\\").append(song).append(\\\"\\\\n\\\"); } return sb.toString(); } public static void main(String[] args) { PlayList playList = new PlayList(\\\"歌单-全是redvelet的歌\\\"); playList.addSong(new Song(\\\"feel my rhythm\\\", \\\"redvelet\\\")); playList.addSong(new Song(\\\"psycho\\\", \\\"redvelet\\\")); playList.addSong(new Song(\\\"bad boy\\\", \\\"redvelet\\\")); //创建一个新歌单,歌单包含原歌单playList1的所有歌曲,自己在新增歌曲 PlayList newPlayList = playList.shallowCopy(\\\"歌单-kpop\\\"); System.out.println(\\\"playList = \\\" + playList); System.out.println(\\\"newPlayList = \\\" + newPlayList); //修改新歌单内的歌曲bad boy为人员为wendy,旧歌单的原信息会改变吗? Song song = newPlayList.getSongs().get(2); song.setArtist(\\\"wendy\\\"); System.out.println(\\\"修改新歌单内的歌曲bad boy\\\"); System.out.println(\\\"playList = \\\" + playList); System.out.println(\\\"newPlayList = \\\" + newPlayList); } } \",\"在Playlist类中，我们添加了一个shallowCopy()方法来执行浅拷贝。该方法会创建一个新的Playlist对象，并复制歌单中的歌曲列表。注意，我们使用了new ArrayList<>(songs)来复制歌曲列表的引用。\",\"浅拷贝输出示例\",\"通过实现cloneable接口实现浅拷贝：\",\"public class PlayListByCloneableInterface implements Cloneable, Serializable { private String name; private List<Song> songs; public PlayListByCloneableInterface(String name) { this.name = name; this.songs = new ArrayList<>(); } public void setName(String name) { this.name = name; } public String getName() { return name; } public List<Song> getSongs() { return songs; } public void addSong(Song song) { songs.add(song); } public void removeSong(Song song) { songs.remove(song); } public PlayListByCloneableInterface shallowCopy(String newName) { PlayListByCloneableInterface copy = new PlayListByCloneableInterface(newName); copy.songs = new ArrayList<>(songs); return copy; } @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\\\"PlayList: \\\").append(name).append(\\\"\\\\n\\\"); for (Song song : songs) { sb.append(\\\"- \\\").append(song).append(\\\"\\\\n\\\"); } return sb.toString(); } public static void main(String[] args) throws CloneNotSupportedException { PlayListByCloneableInterface playList = new PlayListByCloneableInterface(\\\"歌单-全是redvelet的歌\\\"); playList.addSong(new Song(\\\"feel my rhythm\\\", \\\"redvelet\\\")); playList.addSong(new Song(\\\"psycho\\\", \\\"redvelet\\\")); playList.addSong(new Song(\\\"bad boy\\\", \\\"redvelet\\\")); //创建一个新歌单,歌单包含原歌单playList1的所有歌曲,自己在新增歌曲 PlayListByCloneableInterface newPlayList = (PlayListByCloneableInterface) playList.clone(); newPlayList.setName(\\\"歌单-全是kpop的歌\\\"); System.out.println(\\\"playList = \\\" + playList); System.out.println(\\\"newPlayList = \\\" + newPlayList); //修改新歌单内的歌曲bad boy为人员为wendy,旧歌单的原信息会改变吗? Song song = newPlayList.getSongs().get(2); song.setArtist(\\\"wendy\\\"); System.out.println(\\\"修改新歌单内的歌曲bad boy\\\"); System.out.println(\\\"playList = \\\" + playList); System.out.println(\\\"newPlayList = \\\" + newPlayList); } } \"]},\"455\":{\"h\":\"2、深拷贝\",\"t\":[\"深拷贝是指在复制对象时，不仅复制对象本身，还复制对象所引用的所有子对象，使得复制后的对象与原始对象完全独立，互不影响。\",\"在进行深拷贝时，需要递归地复制对象及其子对象，确保每个子对象都是独立的副本，而不是共享引用。\",\"深拷贝可以解决对象拷贝过程中可能出现的共享引用和副作用问题。它确保了复制对象与原始对象之间的数据隔离，使得修改复制后的对象不会影响原始对象，从而提高代码的可靠性和安全性。\",\"在Java中，可以通过几种方式实现深拷贝：\",\"递归复制：对于复杂对象，通过递归遍历对象的每个属性，并针对引用类型的属性进行深度复制。\",\"序列化和反序列化：将对象序列化为字节流，然后再反序列化为新的对象。这种方式需要确保对象及其所有子对象都实现了 Serializable 接口。\",\"递归复制：\",\"class Product implements Cloneable { private String name; private double price; private int stock; // 省略构造函数、getter和setter方法 @Override public Product clone() { try { return (Product) super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } // 促销规则 class PromotionRule implements Cloneable { private String type; private double discount; private Product product; // 省略构造函数、getter和setter方法 @Override protected PromotionRule clone() { try { PromotionRule promotionRule = (PromotionRule) super.clone() Product product = (Product)product.clone();promotionRule.setProduct(product); return promotionRule; } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } // 促销活动 class PromotionEvent implements Cloneable { private String name; private Date startDate; private Date endDate; private List<PromotionRule> rules; // 省略构造函数、getter和setter方法 // 在促销活动中的clone方法需要克隆里边所有的非基础数据类型 @Override protected PromotionEvent clone() { try { PromotionEvent clonedEvent = (PromotionEvent) super.clone(); clonedEvent.startDate = (Date) startDate.clone(); clonedEvent.endDate = (Date) endDate.clone(); clonedEvent.rules = new ArrayList<>(); for (PromotionRule rule : rules) { clonedEvent.rules.add(rule.clone()); } return clonedEvent; } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } \",\"现在，我们已经为每个实体类实现了深拷贝方法。假设我们需要为不同的商品创建相似的促销活动，我们可以使用深拷贝来实现：\",\"public class Main { public static void main(String[] args) { // 创建原始促销活动 PromotionEvent originalEvent = createSamplePromotionEvent(); // 创建新的促销活动 PromotionEvent newEvent = originalEvent.clone(); newEvent.setName(\\\"新的促销活动\\\"); // 现在newEvent是originalEvent的一个深拷贝副本，我们可以对它进行修改而不会影响originalEvent // 修改新促销活动的日期 newEvent.setStartDate(addDays(newEvent.getStartDate(), 7)); newEvent.setEndDate(addDays(newEvent.getEndDate(), 7)); // 修改新促销活动的部分规则 List<PromotionRule> newRules = newEvent.getRules(); newRules.get(0).setDiscount(newRules.get(0).getDiscount() * 1.1); // 现在，我们已经成功地复制了一个与原始活动相似但具有不同日期和部分规则的新促销活动。 // 可以将新活动应用于其他商品，而原始活动保持不变。 } private static PromotionEvent createSamplePromotionEvent() { // 创建示例促销活动 List<PromotionRule> rules = Arrays.asList( new PromotionRule(\\\"折扣\\\", 0.9), new PromotionRule(\\\"满减\\\", 50) ); PromotionEvent event = new PromotionEvent( \\\"原始促销活动\\\", new Date(), addDays(new Date(), 7), rules ); return event; } private static Date addDays(Date date, int days) { Calendar calendar = Calendar.getInstance(); calendar.setTime(date);calendar.add(Calendar.DATE, days); return calendar.getTime(); } } \",\"序列化方式：前提需要实现Serializable接口\",\"深拷贝的通用做法就是使用对象想对原型对象进行序列化，再对序列化后的二进制流 执行反序列化操作，就可以得到一个完完全全相同的对象，这种序列化的方式有很多，比如先转为json，在转成内存模型的对象，也是可以的。\",\"@Test public void deepCopyTest() throws Exception{ User user = new User(12, \\\"zhangsan\\\"); user.setDog(new Dog(2)); // 将对象写到字节数组当中 ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(user); // 获取字节数组 byte[] bytes = outputStream.toByteArray(); // 用输入流读出来 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object object = objectInputStream.readObject(); User user1 = (User) object; user.setAge(44); user.getDog().setAge(11); System.out.println(user); System.out.println(user1); } \",\"应用场景：\",\"在订单管理系统中，深拷贝可以用于创建新订单并复制现有订单的商品和客户信息。假设我们有一个名为 Order 的类，其中包含订单信息和关联的商品和客户对象。我们可以通过深拷贝来创建新订单，并复制原始订单中的商品和客户信息，但需要重新填写新订单的其他信息。这样，新订单和原始订单是相互独立的对象，对新订单的修改不会影响原始订单。就比如每个月需要进一批货，但是大部分货的信息都一样，只是日期不一样，就可以使用深拷贝。\",\"在前端开发中，重置按钮通常用于将表单或页面恢复到初始状态。当加载表单或页面时，可以进行深拷贝，复制一份初始内容作为参考。当用户点击重置按钮时，可以将深拷贝的对象作为引用，重新将其内容设置到表单或页面中，从而实现重置操作。通过深拷贝并使用引用转换，可以避免对原始对象的修改，确保每次重置都回到初始状态。\"]},\"456\":{\"c\":[\"计算机基础\"]},\"457\":{\"c\":[\"设计模式\"]},\"458\":{\"h\":\"前言\",\"t\":[\"设计不是一个固定的技术，每个人写出的代码可能都不一样，他都有自己的设计方案和设计理念，设计模式只是提供了一套别人总结好的解决方案，我们写出来的代码可能并不是完全符合设计模式本身，但是只要它的思想和理念和某个设计模式相同，那么你就是对的，所以说我们只要写出优雅的、拓展性强的、可阅读的、测试性强的代码即可。\",\"当涉及到软件设计和开发原则时，有一些常见的原则和准则可以帮助我们编写高质量、可维护和可扩展的代码。以下是其中一些重要的原则和准则：\",\"软件设计原则-思维导图\",\"这些原则和准则的目标是提高软件系统的质量、可维护性和可扩展性。它们强调了良好的设计实践和规范，使得代码更具可读性、可测试性和可维护性。\"]},\"459\":{\"h\":\"一、单一原则\"},\"460\":{\"h\":\"1、简介\",\"t\":[\"单一职责原则（Single Responsibility Principle，简称SRP），它要求一个类或模块应该只负责一个特定的功能。\",\"这有助于降低类之间的耦合度，提高代码的可读性和可维护性。\",\"我们可以把模块看作比类更加抽象的概念，类也可以看作模块。或者把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。\"]},\"461\":{\"h\":\"2、例子\",\"t\":[\"案例：\",\"当应用单一责任原则时，我们可以看到代码的模块化和职责分离，每个类或模块专注于一个单一的职责。以下是一个示例，展示了一个简单的订单处理系统，其中有两个类：Order 和 EmailSender。\",\"// 使用单一责任原则的代码示例 public class Order { private int orderId; private String customerName; private double totalAmount; public Order(int orderId, String customerName, double totalAmount) { this.orderId = orderId; this.customerName = customerName; this.totalAmount = totalAmount; } public void processOrder() { // 处理订单的逻辑 // ... sendConfirmationEmail(); } private void sendConfirmationEmail() { EmailSender emailSender = new EmailSender(); String message = \\\"Dear \\\" + customerName + \\\", your order with ID \\\" + orderId + \\\" has been processed.\\\"; emailSender.sendEmail(customerName, \\\"Order Confirmation\\\", message); } } public class EmailSender { public void sendEmail(String recipient, String subject, String message) { // 发送电子邮件的逻辑 // ... } } \",\"在上述代码中，Order 类负责表示订单，并包含订单的处理逻辑。它的职责是处理订单和发送确认电子邮件。EmailSender 类专门负责发送电子邮件。\",\"这样设计的好处是，Order 类只关注订单的处理逻辑，不涉及与电子邮件发送相关的代码。这遵循了单一责任原则，使得代码更加模块化、可维护和可测试。\",\"现在，让我们看一下如果不遵循单一责任原则会发生什么：\",\"// 没有使用单一责任原则的代码示例 public class Order { private int orderId; private String customerName; private double totalAmount; public Order(int orderId, String customerName, double totalAmount) { this.orderId = orderId; this.customerName = customerName; this.totalAmount = totalAmount; } public void processOrder() { // 处理订单的逻辑 // ... sendConfirmationEmail(); } private void sendConfirmationEmail() { // 发送电子邮件的逻辑 // ... } } \",\"在上述代码中，Order 类不仅负责订单的处理逻辑，还包含了发送电子邮件的逻辑。这违反了单一责任原则，导致一个类承担了多个职责。\",\"这种设计的问题在于，如果以后需要更改或替换发送电子邮件的方式，需要修改 Order 类中的代码，这可能导致不必要的变更风险，并增加了代码的复杂性。\",\"通过对比这两个示例，我们可以清晰地看到应用单一责任原则的代码更加清晰、可维护和可扩展，每个类或模块只关注一个单一的职责，避免了不必要的耦合。\",\"好处解析：\",\"当使用单一责任原则的代码需要进行维护时，其好处主要体现在以下几个方面：\",\"修改订单处理逻辑：假设我们需要修改订单处理逻辑，例如添加一些额外的验证或处理步骤。在使用单一责任原则的代码中，我们只需关注 Order 类中与订单处理逻辑相关的代码，而不必担心影响到与电子邮件发送相关的代码。这样的职责分离使得修改订单处理逻辑变得更加简单和直观。\",\"替换邮件发送方式：如果我们需要更改或替换邮件发送方式，例如从使用SMTP协议改为使用API调用发送邮件，或者使用不同的邮件服务提供商。在使用单一责任原则的代码中，我们只需关注 EmailSender 类中的邮件发送逻辑，而不必修改 Order 类。这样的职责分离使得替换邮件发送方式变得更加容易和安全。\",\"测试的简化：由于单一责任原则使得代码更加模块化和职责清晰，因此测试变得更加简单。在使用单一责任原则的代码中，我们可以轻松地针对不同的职责编写独立的单元测试，而不必处理与其他职责相关的复杂逻辑。这样的测试可分离性使得测试更加可靠和可维护。\",\"降低风险：当需要对代码进行修改时，使用单一责任原则的代码降低了引入错误的风险。因为每个类或模块只关注一个职责，修改其中一个部分不会影响到其他部分，减少了不必要的依赖和耦合。这使得维护过程更加可控和安全。\",\"总之，使用单一责任原则的代码在维护时具有更高的可维护性、可测试性和可扩展性。代码的职责分离使得维护过程更加简化和安全，降低了风险，并促进了代码的模块化和解耦。这使得开发者能够更加轻松地修改、扩展和测试代码，以满足系统的变化需求。\"]},\"462\":{\"h\":\"3、总结\",\"t\":[\"一个类只负责完成一个职责或者功能。但是也要结合具体的业务。\",\"也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。\",\"换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。\"]},\"463\":{\"h\":\"二、开闭原则\"},\"464\":{\"h\":\"1、简介\",\"t\":[\"开闭原则（pen Closed Principle，简写为 OCP）。它要求应该对扩展开放、对修改关闭。\",\"说人话就是，当我们需要添加一个新的功能时，应该在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。\"]},\"465\":{\"h\":\"2、例子\",\"t\":[\"案例：\",\"如果没有遵循开闭原则，代码可能会如下所示：\",\"class Order { private double totalAmount; public Order(double totalAmount) { this.totalAmount = totalAmount; } // 计算折扣后的金额 public double getDiscountedAmount(String discountType) { double discountedAmount = totalAmount; if (discountType.equals(\\\"FESTIVAL\\\")) { discountedAmount = totalAmount * 0.9; // 节日折扣，9折 } else if (discountType.equals(\\\"SEASONAL\\\")) { discountedAmount = totalAmount * 0.8; // 季节折扣，8折 } return discountedAmount; } } \",\"在这个例子中，订单类 Order 中的 getDiscountedAmount 方法根据不同的折扣类型应用相应的折扣。当需要添加新的折扣类型时，我们不得不修改 getDiscountedAmount 方法的代码，增加新的判断逻辑。\",\"这种设计违反了开闭原则，具有以下不利影响：\",\"代码的脆弱性：每次添加新的折扣类型时，我们需要修改现有的代码。这增加了代码的脆弱性，因为任何错误的修改都可能导致现有功能的破坏。\",\"可维护性下降：在没有遵循开闭原则的情况下，代码中的条件逻辑会不断增加，使得代码变得复杂和难以维护。当折扣类型增多时，代码会变得冗长且难以阅读，降低了可维护性。\",\"扩展困难：由于没有使用抽象和多态来定义折扣策略，我们无法轻松地扩展和添加新的折扣类型。每次需要添加新的折扣类型时，都需要修改现有的代码，这增加了开发的复杂性和风险。\",\"测试困难：代码中的条件逻辑使得测试变得困难，因为需要编写多个测试用例来覆盖不同的分支。同时，每次修改现有的条件逻辑时，还需要更新相关的测试代码，增加了测试的工作量。\",\"综上所述，如果不遵循开闭原则，代码将变得脆弱、难以维护和扩展。通过引入抽象和多态的设计方式，可以改善代码的可扩展性、可维护性和测试性，使代码更具弹性和适应性。\",\"遵循开闭原则的案例：\",\"在上述代码中，我们可以使用开闭原则对其进行改进。我们可以引入一个抽象的折扣策略接口，每种折扣类型都实现该接口，然后在订单类中使用策略模式来计算折扣金额。\",\"以下是使用开闭原则改进后的代码示例：\",\"// 折扣策略接口 public interface DiscountStrategy { double applyDiscount(double totalAmount); } // 节日折扣策略 public class FestivalDiscountStrategy implements DiscountStrategy { @Override public double applyDiscount(double totalAmount) { return totalAmount * 0.9; // 节日折扣，9折 } } // 季节折扣策略 public class SeasonalDiscountStrategy implements DiscountStrategy { @Override public double applyDiscount(double totalAmount) { return totalAmount * 0.8; // 季节折扣，8折 } } // 订单类 public class Order { private double totalAmount; private DiscountStrategy discountStrategy; public Order(double totalAmount) { this.totalAmount = totalAmount; } // 设置折扣策略 public void setDiscountStrategy(DiscountStrategy discountStrategy) { this.discountStrategy = discountStrategy; } // 计算折扣后的金额 public double getDiscountedAmount() { if (discountStrategy != null) { return discountStrategy.applyDiscount(totalAmount); } return totalAmount; } } \",\"在改进后的代码中，我们定义了一个折扣策略接口 DiscountStrategy，并创建了两个具体的折扣策略类 FestivalDiscountStrategy 和 SeasonalDiscountStrategy。订单类 Order 中引入了折扣策略，并使用策略模式在 getDiscountedAmount 方法中计算折扣金额。\",\"通过这种方式，当需要添加新的折扣类型时，我们只需要创建一个新的实现了 DiscountStrategy 接口的具体折扣策略类，而不需要修改订单类的代码。我们可以通过设置不同的折扣策略来应用不同的折扣类型。\",\"这样的设计遵循了开闭原则，使得代码更加可扩展和可维护。每个折扣类型都是独立的策略类，可以方便地扩展和修改，而不会对订单类产生影响。这提高了代码的灵活性，并符合开闭原则的设计理念。\"]},\"466\":{\"h\":\"3、总结\",\"t\":[\"开闭原则是面向对象设计中的重要原则之一：\",\"它要求软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。\",\"简单来说，就是在设计中要尽量避免修改已有的代码，而是通过扩展来实现新功能或适应变化的需求。\"]},\"467\":{\"h\":\"三、里氏替换原则\"},\"468\":{\"h\":\"1、简介\",\"t\":[\"里氏替换原则（Liskov Substitution Principle，简写为 LSP）：它强调子类型必须能够替换其基类型而不影响程序的正确性。\",\"说人话就是，当我们使用继承关系创建派生类（子类）时，这个派生类应该能够无缝替换其基类（父类）的实例，而程序的行为不会出现意外。\",\"这意味着派生类在行为上应该保持与基类的一致性，并且不应该破坏基类的约定，包括输入输出的约束、异常的约束，以及前置条件和后置条件 。 \",\"如：尽量不要重写父类的方法。\"]},\"469\":{\"h\":\"2、例子\",\"t\":[\"案例：\",\"好的，让我们以动物类的例子来说明里氏替换原则的好处和坏处。\",\"假设我们有一个基类 Animal 表示动物，它有一个方法 makeSound() 用于发出声音。然后我们派生出两个子类 Dog 和 Cat 分别表示狗和猫，它们都继承自 Animal。\",\"》调用方法时：\",\"public class Main { public static void makeAnimalSound(Animal animal) { animal.makeSound(); } public static void main(String[] args) { Animal animal1 = new Dog(); Animal animal2 = new Cat(); makeAnimalSound(animal1); // Output: \\\"Dog barks\\\" makeAnimalSound(animal2); // Output: \\\"Cat meows\\\" } } \",\"当调用 makeAnimalSound 方法时，如果遵循里氏替换原则，输出结果将符合预期，即分别输出 \\\"Dog barks\\\" 和 \\\"Cat meows\\\"。\",\"符合里氏替换原则的情况下：\",\"符合里氏替换原则的情况下：\",\"在 makeAnimalSound 方法中，我们将 Animal 类型的参数传递进去，并调用其 makeSound() 方法。由于 Dog 和 Cat 类都是 Animal 类的子类，且它们都重写了 makeSound() 方法，所以在运行时，根据对象的实际类型，会调用相应子类的 makeSound() 方法。\",\"这样做的好处是，我们可以使用统一的方法 makeAnimalSound 来处理不同类型的动物对象，而不需要针对每个具体的子类编写特定的代码。这增加了代码的灵活性和可扩展性，使得我们可以轻松地添加新的动物子类，而不需要修改现有的方法。\",\"不符合里氏替换原则的情况下：\",\"不符合里氏替换原则的情况下：\",\"在不遵循里氏替换原则的情况下，当调用 makeAnimalSound 方法时，输出结果可能不符合预期。\",\"在不符合里氏替换原则的示例中，Cat 类重写了 makeSound() 方法，并抛出了一个不支持的操作异常。如果我们将一个 Cat 对象传递给 makeAnimalSound 方法，它将抛出异常而不是输出 \\\"Cat meows\\\"。\",\"这个问题的根本原因是 Cat 类违反了基类 Animal 的行为约定，即 makeSound() 方法应该输出相应动物的声音。这导致代码在处理 Cat 对象时出现了不一致和不可预测的行为。\",\"因此，遵循里氏替换原则可以确保代码在处理父类对象时，不依赖于具体子类的实现细节，而是按照基类的行为约定进行操作。这增加了代码的可靠性、可维护性和可扩展性。相反，违反里氏替换原则可能导致代码的不稳定和不可靠，增加了代码的复杂性和维护成本。\"]},\"470\":{\"h\":\"3、总结\",\"t\":[\"当遵循里氏替换原则时，子类对象可以完全替换父类对象，并且程序的行为保持一致。这种设计方式具有以下优势：\",\"可复用性和可扩展性：代码中的父类可以作为通用的抽象接口或基类使用，而子类可以根据需要进行扩展和定制。这样，我们可以使用基类的对象来处理一系列子类对象，而不需要对每个子类编写特定的代码，提高了代码的复用性和可扩展性。\",\"统一的行为约定：遵循里氏替换原则，子类必须遵循父类的行为约定，确保在任何使用父类对象的地方，都能正确地处理子类对象。这样可以增加代码的可靠性和稳定性，减少意外行为的发生。\",\"降低代码的耦合性：通过将代码依赖于抽象的父类而不是具体的子类，实现了代码的松耦合。这使得系统更容易理解、修改和扩展，减少了代码之间的依赖关系，提高了代码的可维护性和灵活性。\",\"符合多态性原则：里氏替换原则是多态性的基础之一。通过将子类对象视为父类对象，实现了多态的特性，可以在运行时根据对象的实际类型来调用相应的方法，增加了代码的灵活性和可扩展性。\",\"总之，里氏替换原则是面向对象设计中的一个重要原则，它强调子类对象必须能够替换其父类对象并且保持系统行为的一致性。遵循该原则可以提高代码的可复用性、可扩展性和可维护性，降低代码的耦合性，并保持多态性的特性。\"]},\"471\":{\"h\":\"四、接口隔离原则\"},\"472\":{\"h\":\"1、简介\",\"t\":[\"接口隔离原则（Interface Segregation Principle，简称ISP），它强调客户端不应该强迫依赖于它们不需要的接口,其中的“客户端”，可以理解为接口的调用者或者使用者。\",\"说人话就是，当我们设计接口时，应该将其拆分成更小、更具体的接口，以满足客户端的实际需求，而不是设计一个庞大而臃肿的接口。\",\"这样做的好处是，可以提高代码的内聚性，使得类或模块只需实现与其业务相关的接口，而不需要依赖于不相关的接口。同时也降低了类之间的耦合性，提高了代码的灵活性、可维护性和可测试性。\"]},\"473\":{\"h\":\"2、例子\",\"t\":[\"假设我们正在开发一个机器人程序，机器人具有多种功能，如行走、飞行和工作。我们可以为这些功能创建一个统一的接口：\",\"public interface Robot { void walk(); void fly(); void work(); } \",\"然而，这个接口并不符合接口隔离原则，因为它将多个功能聚合在了一个接口中。\",\"对于那些只需要实现部分功能的客户端来说，这个接口会导致不必要的依赖（如机器人分为：扫地机器人、飞行机器人等）。为了遵循接口隔离原则，我们应该将这个接口拆分成多个更小、更专注的接口：\",\"public interface Walkable { void walk(); } public interface Flyable { void fly(); } public interface Workable { void work(); } \",\"现在，我们可以根据需要为不同类型的机器人实现不同的接口。例如，对于一个只能行走和工作的机器人，我们只需要实现 Walkable 和 Workable 接口：\",\"public class WalkingWorkerRobot implements Walkable, Workable { @Override public void walk() { // 实现行走功能 } @Override public void work() { // 实现工作功能 } } \",\"通过遵循接口隔离原则，我们将功能拆分成更小的接口，避免了不必要的依赖关系。现在，客户端只需要依赖于它们真正需要的接口，使得代码更加清晰、可维护和可扩展。如果我们需要新的功能，只需要针对相应的接口进行扩展即可，而不会影响其他接口的实现。这样，我们可以根据需求和场景来选择实现相应的接口，而不需要强制实现不需要的方法。\",\"在实际项目中，应用接口隔离原则可以带来以下好处：\",\"提高代码的内聚性：每个接口只关注特定的功能，使得代码更加专注和可理解。\",\"降低代码的耦合性：客户端只依赖于所需的接口，不受其他不相关接口的影响。\",\"提升代码的灵活性：根据需求选择合适的接口实现，使得系统更加灵活和可扩展。\"]},\"474\":{\"h\":\"3、总结\",\"t\":[\"接口隔离原则（Interface Segregation Principle，简写为 ISP）强调将大型、笼统的接口拆分成小而精确的接口，以符合客户端的实际需求，避免不必要的依赖和复杂性。\",\"以下是接口隔离原则的总结：\",\"接口应该精确地定义只与特定功能相关的方法，而不是将所有功能都聚合在一个接口中。\",\"将大型接口拆分成多个小接口，每个接口关注特定的功能领域。\",\"客户端应该只依赖于它们真正需要的接口，而不是依赖于不相关的方法。\",\"避免将不需要的方法强加给实现类，防止出现空实现或抛出不支持的操作异常。\",\"接口隔离原则提高了代码的内聚性，使得每个接口和实现类都专注于特定的任务。\",\"通过减少接口之间的依赖，接口隔离原则降低了代码的耦合性，提高了系统的灵活性和可维护性。\",\"合理应用接口隔离原则可以简化系统的设计和维护工作，提升团队的开发效率和协作效果。\",\"总之，接口隔离原则通过细化接口的设计，使得代码更加模块化、可扩展和易于理解。它促进了单一职责原则的实现，提高了代码质量和可维护性。在实际项目中，我们应该根据需求和场景合理应用接口隔离原则，避免过度依赖和冗余代码，构建更灵活、可扩展的系统。\",\"ISP 和 SRP 的区别：\",\"单一职责原则（SRP）要求一个类或模块只负责一项职责或功能。它强调类的内聚性，即一个类应该只有一个引起它变化的原因。SRP的目标是将功能划分清晰，避免一个类承担过多的责任，从而提高代码的可维护性、可测试性和可理解性。\",\"接口隔离原则（ISP）则侧重于接口的设计。它提倡将大型、笼统的接口拆分成小而精确的接口，以符合客户端的实际需求。ISP的目标是避免客户端依赖不需要的方法，减少不相关功能的耦合。通过接口的细化和分离，ISP提高了代码的内聚性，促进了代码模块化、可扩展性和可理解性。\",\"简而言之，**SRP关注类或模块的职责和功能的划分，强调类的单一职责。而ISP关注接口的设计，强调接口的精确性和客户端的需求。**它们共同为代码的可维护性、可测试性和可理解性提供了指导原则，但侧重点和应用场景略有不同。在实际设计中，我们可以同时考虑和应用这两个原则来构建高质量的软件系统。\"]},\"475\":{\"h\":\"五、依赖倒置原则\"},\"476\":{\"h\":\"1、简介\",\"t\":[\"依赖倒置原则（Dependency Inversion Principle，简称DIP）：它强调高层模块不应该依赖于低层模块的具体实现方式，而是应该依赖于抽象。\",\"说人话就是，当我们设计代码时，应该通过抽象来定义模块之间的关系，而不是直接依赖于具体的实现细节。\",\"这样做的好处是，提高了代码的灵活性和可维护性。高层模块不需要知道低层模块的具体实现，只需依赖于抽象接口。这样，当低层模块的实现发生变化时，高层模块不受影响。\",\"另外，依赖倒置原则也鼓励通过依赖注入等方式来实现模块之间的解耦，提高了代码的可测试性和可扩展性。\"]},\"477\":{\"h\":\"2、例子\",\"t\":[\"总结起来，依赖倒置原则与 Spring 的 IOC 容器相辅相成。通过将接口作为抽象的约定，将实现类的选择和创建交给容器管理，我们实现了高层模块和低\",\"层模块之间的解耦和灵活性。无论是使用 AImpl 还是 AnotherAImpl，MyClass 类只需依赖于接口 A，从而提高了代码的可维护性和可扩展性。\"]},\"478\":{\"h\":\"3、总结\",\"t\":[\"依赖倒置原则（DIP）是面向对象设计中的一条重要原则。它的核心思想是高层模块不应该依赖于低层模块，而应该依赖于抽象接口或抽象类。这样可以降低模块之间的耦合性，提高代码的灵活性和可维护性。通过依赖注入等方式实现依赖倒置原则可以使代码更易于扩展和修改，同时也能提升代码的可测试性和可复用性。\"]},\"479\":{\"h\":\"六、KISS原则\"},\"480\":{\"h\":\"1、简介\",\"t\":[\"KISS原则（Keep It Simple, Stupid），它强调保持代码简单易懂的重要性。在编写代码时，应避免过度设计和复杂化，而是以简洁的方式解决问题。KISS原则鼓励我们使用简单直接的方法来实现功能，避免过多的复杂性和不必要的抽象。\",\"说人话就是，写代码的时候要保持简单，不要过度设计和增加复杂性，不要花里胡哨。要选择简洁直接的方法来解决问题，避免不必要的复杂性和抽象。这样做的好处是，代码更易于理解、调试和维护，降低出错的概率，并且提高开发效率。\"]},\"481\":{\"h\":\"2、例子\",\"t\":[\"当我们设计一个用户管理系统时，假设有以下需求：\",\"用户可以注册账号。\",\"用户可以登录账号。\",\"用户可以查看自己的个人信息。\",\"用户可以修改个人信息。\",\"以下是一个违反KISS原则的示例代码：\",\"public class UserManagementSystem { private UserRepository userRepository; private EmailService emailService; public UserManagementSystem() { userRepository = new UserRepository(); emailService = new EmailService(); } public void registerUser(String username, String password) { // 一些注册逻辑 userRepository.saveUser(username, password); emailService.sendEmail(username, \\\"Welcome to our system!\\\"); } public void loginUser(String username, String password) { // 一些登录逻辑 // ... } public void displayUserInfo(String username) { // 一些显示用户信息的逻辑 // ... } public void updateUserProfile(String username, String newEmail) { // 一些更新用户信息的逻辑 userRepository.updateEmail(username, newEmail); emailService.sendEmail(username, \\\"Your profile has been updated.\\\"); } } \",\"在上述代码中，UserManagementSystem类承担了太多的责任，既包含了用户管理逻辑，又包含了与用户相关的邮件服务逻辑。这导致类的职责过重，代码复杂度高，并且增加了对UserRepository和EmailService的直接依赖。\",\"下面是符合KISS原则的重构后的示例代码：\",\"public class UserManagementSystem { private UserRepository userRepository; private EmailService emailService; public UserManagementSystem(UserRepository userRepository, EmailService emailService) { this.userRepository = userRepository; this.emailService = emailService; } public void registerUser(String username, String password) { userRepository.saveUser(username, password); emailService.sendWelcomeEmail(username); } // 其他方法的实现省略... } \",\"在重构后的代码中，我们将与用户相关的逻辑拆分成了两个独立的类：UserRepository负责用户数据的持久化，EmailService负责发送邮件。UserManagementSystem类只关注用户管理的核心逻辑，并通过构造函数依赖注入的方式获取UserRepository和EmailService实例。\",\"通过拆分职责，每个类的责任更加清晰，代码也更加简洁和可维护。同时，减少了类之间的直接依赖关系，提高了代码的灵活性和可测试性。\"]},\"482\":{\"h\":\"3、总结\",\"t\":[\"KISS原则（Keep It Simple, Stupid）是一种设计原则，强调保持代码简单易懂的重要性。以下是对KISS原则的总结：\",\"KISS原则建议在编写代码时避免过度设计和复杂化，以简洁的方式解决问题。\",\"简单的代码更易于理解、调试和维护，降低了引入错误和bug的风险。\",\"通过避免不必要的复杂性，可以提高代码的可读性，使其更容易被团队成员理解和使用。\",\"简单的代码更容易进行扩展和重构，使系统更具灵活性和可维护性。\",\"遵循KISS原则可以减少代码的冗余和复杂度，提高开发效率，并降低项目的成本和风险。\",\"总而言之，KISS原则是一种鼓励简洁和直观代码的设计原则，它强调避免过度复杂化（代码多不是复杂），以简单的方式解决问题。通过遵循KISS原则，我们可以提高代码的可读性、可维护性和可扩展性，从而为项目的成功和可持续发展奠定坚实基础。\"]},\"483\":{\"h\":\"七、DRY原则\"},\"484\":{\"h\":\"1、简介\",\"t\":[\"DRY原则（Don't Repeat Yourself），它强调避免重复代码的产生。\"]},\"485\":{\"h\":\"2、例子\",\"t\":[\"在 Java 编程中，我们可以通过以下方法遵循 DRY 原则：\",\"（1）使用方法（functions）：当你发现自己在多处重复相同的代码时，可以将其抽取为一个方法，并在需要的地方调用该方法。\",\"public class DryExample { public static void main(String[] args) { printHello(\\\"张三\\\"); printHello(\\\"李四\\\"); } public static void printHello(String name) { System.out.println(\\\"你好，\\\" + name + \\\"!\\\"); } } \",\"在这个例子中，我们使用 printHello 方法避免了重复的 System.out.println 语句。\",\"（2）使用继承和接口：当多个类具有相似的行为时，可以使用继承和接口来抽象共享的功能，从而减少重复代码。\",\"public abstract class Animal { public abstract void makeSound(); public void eat() { System.out.println(\\\"动物在吃东西\\\"); } } public class Dog extends Animal { public void makeSound() { System.out.println(\\\"汪汪\\\"); } } public class Cat extends Animal { public void makeSound() { System.out.println(\\\"喵喵\\\"); } } \",\"在这个例子中，我们使用抽象类 Animal 和继承来避免在 Dog 和 Cat 类中重复 eat 方法的代码。\",\"（3）重用代码库和框架：使用成熟的代码库和框架可以避免从零开始编写一些通用功能。例如，使用 Java 标准库、Apache Commons 或 Google Guava 等库。\",\"遵循 DRY 原则可以帮助我们编写更高质量的代码，并更容易进行维护和扩展。同时，要注意不要过度优化，以免影响代码的可读性和理解性。\"]},\"486\":{\"h\":\"3、总结\",\"t\":[\"DRY原则（Don't Repeat Yourself）是一种软件设计原则，强调避免重复代码的重要性。它鼓励开发人员在编写代码时避免重复的逻辑、功能或信息。\",\"首先，它提高了代码的可维护性和可读性。通过将重复的代码抽取到单独的方法、函数或模块中，我们可以避免在多个地方修改相同的代码，降低了出错的风险，并使代码更易于理解和修改。\",\"其次，DRY原则促进了代码的重用和模块化。通过将通用的逻辑抽象为可复用的组件，我们可以在不同的地方调用它们，避免了重复编写相同的代码。这样可以减少代码量，提高开发效率，并增加系统的灵活性和可扩展性。\",\"同时，DRY原则还有助于降低代码的耦合性。通过将重复的代码抽象为单一的实现，我们可以减少代码之间的依赖关系，使系统的各个部分更加独立和解耦。这样可以提高代码的可测试性，降低修改一个功能对其他部分造成的影响。\",\"需要注意的是，DRY原则并不意味着完全消除重复代码。重复的代码只有在处理相同逻辑和功能时才被认为是违反DRY原则的。在评估重复代码时，我们需要考虑业务差异和上下文变化。如果代码的相似之处只是因为业务上的差异或上下文的变化，那么这种重复可能是合理的。\"]},\"487\":{\"h\":\"八、迪米特原则\"},\"488\":{\"h\":\"1、简介\",\"t\":[\"迪米特原则（Law of Demeter，简称LoD），也被称为最少知识原则（Principle of Least Knowledge），它强调对象之间的松耦合和信息隐藏。\",\"说人话就是，当我们设计软件时，对象之间的交互应该尽量简单，避免直接访问其他对象的内部细节，而是通过调用公共方法来间接进行通信。\",\"迪米特原则的核心思想是将对象设计为尽可能少地依赖其他对象，只与自己的直接朋友对象进行交互。这样做的好处是：\",\"减少耦合：对象之间的直接依赖越少，耦合度越低。当一个对象只与少数几个朋友对象进行交互时，修改一个对象的内部结构或实现不会对其他对象产生太大的影响。\",\"提高灵活性：由于对象之间的关系简单明确，系统更容易进行扩展和修改。当需要修改系统时，我们只需关注与当前对象直接相关的部分，而不需要了解其他对象的内部细节。\",\"提升可维护性：迪米特原则使得系统中的对象独立性更强，易于单独测试和调试。当一个对象的实现发生变化时，不会对其他对象产生连锁影响，减少了代码的藕合度。\",\"遵循迪米特原则可以帮助我们设计出更加松耦合、可维护和可扩展的软件系统。同时，要注意避免过度设计，遵循适度原则，不要违背其他设计原则或增加不必要的复杂性。\"]},\"489\":{\"h\":\"2、例子\",\"t\":[\"假设我们有一个订单处理系统，其中包括订单(Order)、用户(User)和库存(Inventory)三个核心概念：\",\"public class Order { private User user; private Inventory inventory; public Order(User user, Inventory inventory) { this.user = user; this.inventory = inventory; } public void processOrder() { String userName = user.getName(); int availableQuantity = inventory.getAvailableQuantity(); // 处理订单逻辑 // ... } } public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } } public class Inventory { private int availableQuantity; public Inventory(int availableQuantity) { this.availableQuantity = availableQuantity; } public int getAvailableQuantity() { return availableQuantity; } } \",\"在这个例子中，Order 类直接依赖于 User 和 Inventory 类，通过调用它们的方法来获取用户信息和库存信息。这种直接依赖关系导致了较高的耦合性，当 User 或 Inventory 类发生变化时，需要修改 Order 类的代码。\",\"现在，让我们看看遵循迪米特法则的情况下的代码：\",\"public class Order { private OrderService orderService; public Order(OrderService orderService) { this.orderService = orderService; } public void processOrder() { String userName = orderService.getUserName(); int availableQuantity = orderService.getAvailableQuantity(); // 处理订单逻辑 // ... } } public interface OrderService { String getUserName(); int getAvailableQuantity(); } public class UserService implements OrderService { private User user; public UserService(User user) { this.user = user; } public String getUserName() { return user.getName(); } public int getAvailableQuantity() { // 调用库存服务获取库存信息 // ... return availableQuantity; } } public class InventoryService implements OrderService { private Inventory inventory; public InventoryService(Inventory inventory) { this.inventory = inventory; } public String getUserName() { // 调用用户服务获取用户信息 // ... return userName; } public int getAvailableQuantity() { return inventory.getAvailableQuantity(); } } public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } } public class Inventory { private int availableQuantity; public Inventory(int availableQuantity) { this.availableQuantity = availableQuantity; } public int getAvailableQuantity() { return availableQuantity; } } \",\"在这个例子中，我们引入了一个中间层接口 OrderService，并有两个实现类 UserService 和 InventoryService。Order 类通过依赖 OrderService 接口来获取用户信息和库存信息，而不直接依赖于具体的 User 和 Inventory 类。这种间接的依赖关系降低了耦合性，当 User 或 Inventory 类发生变化时，只需修改对应的实现类，而不需要修改 Order 类的代码。\",\"通过遵循迪米特法则，我们实现了类之间的解耦，提高了代码的灵活性和可维护性。中间层的引入使得系统的模块职责更加清晰，提升了代码的可读性和可测试性。\"]},\"490\":{\"h\":\"3、总结\",\"t\":[\"迪米特法则在设计和编写代码时，强调对象之间的松耦合，通过减少对象之间的直接依赖关系来提高代码的质量。它带来的优势包括降低耦合性、提高代码的灵活性、可维护性、模块化和封装性，同时也有助于代码的可读性和可测试性：\",\"迪米特法则的核心思想是减少对象之间的直接依赖关系。一个对象应该尽可能少地了解其他对象的细节和内部结构。\",\"迪米特法则鼓励使用中间层或接口来实现对象之间的通信，而不是直接依赖具体的对象。这样做可以降低耦合性，提高代码的灵活性和可维护性。\",\"迪米特法则能够促进代码的模块化和封装性。对象只需关注与其密切相关的对象，不需要了解其他对象的具体实现细节。这样可以提高代码的可读性和可理解性。\",\"遵循迪米特法则可以降低代码的脆弱性。当一个对象发生变化时，只有直接依赖它的对象需要进行相应的修改，而其他无关的对象不会受到影响。\",\"迪米特法则有助于提高代码的可测试性。由于对象之间的依赖关系更加简化和清晰，测试对象的行为变得更加容易，可以更好地进行单元测试和模块测试。\",\"GoF（Gang of Four）是指四位著名的计算机科学家：Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides。他们合作编写了一本具有里程碑意义的著作《Design Patterns: Elements of Reusable Object-Oriented Software》（设计模式：可复用的面向对象软件元素）。这本书对软件开发领域产生了深远影响。\",\"GoF提出了23种设计模式，分为三大类：\",\"创建型模式（Creational Patterns）关注对象的创建过程，包括：\",\"单例模式（Singleton）\",\"工厂方法模式（Factory Method）\",\"抽象工厂模式（Abstract Factory）\",\"建造者模式（Builder）\",\"原型模式（Prototype）\",\"结构型模式（Structural Patterns）关注类和对象之间的组合，包括：\",\"适配器模式（Adapter）\",\"桥接模式（Bridge）\",\"组合模式（Composite）\",\"装饰模式（Decorator）\",\"外观模式（Facade）\",\"享元模式（Flyweight）\",\"代理模式（Proxy）\",\"行为型模式（Behavioral Patterns）关注对象之间的通信，包括：\",\"职责链模式（Chain of Responsibility）\",\"命令模式（Command）\",\"解释器模式（Interpreter）\",\"迭代器模式（Iterator）\",\"中介者模式（Mediator）\",\"备忘录模式（Memento）\",\"观察者模式（Observer）\",\"状态模式（State）\",\"策略模式（Strategy）\",\"模板方法模式（Template Method）\",\"访问者模式（Visitor）\",\"这些设计模式提供了在软件开发中常见问题的解决方案，并促进了可\"]},\"491\":{\"c\":[\"计算机基础\"]},\"492\":{\"c\":[\"设计模式\"]},\"493\":{\"h\":\"结构型设计模式\",\"t\":[\"结构型设计模式就是利用类与类之间的关系（继承、组合），形成一种类与类之间的结构，通过这种结构提高代码的可拓展性、可维护性和可重用性\",\"结构型设计模式：利用类与类之间的关系（继承、组合），形成一种类与类之间的结构，通过这种结构提高代码的可拓展性、可维护性和可重用性。\"]},\"494\":{\"h\":\"一、代理设计模式\",\"t\":[\"代理设计模式（Proxy Design Pattern）是一种结构型设计模式，它为其他对象提供一个代理，以控制对这个对象的访问。根据不同时期生成的代理对象，分为：\",\"静态代理：指代理类在编译时就已经确定。\",\"动态代理：指代理类在运行时动态生成。\",\"代理模式可以用于实现懒加载、安全访问控制、日志记录等功能，其核心就是：屏蔽掉对原始对象的直接访问，为原始对象的能力提高增强。\",\"其大致流程如下：\",\"创建一个接口，定义代理类和被代理类共同实现的方法。\",\"创建被代理类，实现这个接口，并且在其中定义实现方法。\",\"创建代理类，也要实现这个接口，同时在其中定义一个被代理类的对象作为成员变量。\",\"在代理类中实现接口中的方法，方法中调用被代理类中的对应方法。\",\"通过创建代理对象，并调用其方法，方法增强。 这样，被代理类的方法就会被代理类所覆盖，实现了对被代理类的增强或修改。\"]},\"495\":{\"h\":\"1、静态代理\",\"t\":[\"简介：\",\"在静态代理中，需要手动创建代理类和被代理类，并且它们实现相同的接口或继承相同的父类。\",\"基本流程：\",\"创建一个接口 / 抽象父类 / 父类：定义代理类和被代理类共同实现的方法。\",\"创建被代理类：实现上述接口，并在其中定义实现方法。\",\"创建代理类：同样实现上述接口，并在其中定义一个被代理类的对象作为成员变量。\",\"在代理类中实现接口中的方法：在这些方法中，调用被代理类对象的对应方法。\",\"通过创建代理对象并调用其方法，实现对被代理类方法的增强或修改。\",\"当涉及到继承关系时，我们可以使用静态代理来实现对继承类的功能增强。\",\"继承实现代理设计模式示例代码：\",\"以下是一个示例代码，演示了如何使用静态代理来实现继承类的功能增强：\",\"首先，我们有一个基础类 BaseClass，它定义了一些基本的操作：\",\"// 基础类 class BaseClass { public void performOperation() { System.out.println(\\\"Performing base operation...\\\"); } } \",\"接下来，我们创建一个代理类 ProxyClass，它继承自基础类，并在其方法中添加额外的逻辑：\",\"// 代理类，继承自基础类 class ProxyClass extends BaseClass { @Override public void performOperation() { // 在调用父类方法之前添加额外的逻辑 System.out.println(\\\"Before performing operation...\\\"); // 调用父类方法 super.performOperation(); // 在调用父类方法之后添加额外的逻辑 System.out.println(\\\"After performing operation...\\\"); } } \",\"在代理类中，我们重写了基础类的 performOperation() 方法，并在方法中通过调用 super.performOperation() 来执行基础类的功能。同时，在调用父类方法之前和之后，我们添加了额外的逻辑。\",\"最后，我们可以使用代理类来执行操作，并观察功能增强的效果：\",\"public class Main { public static void main(String[] args) { ProxyClass proxy = new ProxyClass(); proxy.performOperation(); } } \",\"在上述示例中，我们创建了 ProxyClass 的实例，并调用其 performOperation() 方法。在执行该方法时，代理类将在调用父类方法之前和之后添加额外的逻辑。这样，我们就实现了对继承类功能的增强，而不需要修改基础类的代码。\",\"通过静态代理，我们可以在继承关系中对基础类的功能进行增强，而不影响基础类的原有实现。这样，我们可以通过代理类在调用父类方法之前或之后添加额外的逻辑，实现功能的灵活扩展。\",\"接口实现代理设计模式示例代码：\",\"下面是一个使用接口实现静态代理的示例代码：\",\"首先，我们定义一个共同的接口 Image，它包含一个方法 display()：\",\"// 共同的接口 interface Image { void display(); } \",\"接下来，我们创建一个具体的接口实现类 RealImage，实现了 Image 接口：\",\"// 接口实现类 class RealImage implements Image { private String filename; public RealImage(String filename) { this.filename = filename; } @Override public void display() { System.out.println(\\\"Displaying image: \\\" + filename); } } \",\"然后，我们创建一个代理类 ImageProxy，它同时实现了 Image 接口，并拥有一个 RealImage 对象作为成员变量：\",\"// 代理类 class ImageProxy implements Image { private RealImage realImage; public ImageProxy(String filename) { this.realImage = new RealImage(filename); } @Override public void display() { System.out.println(\\\"Loading image: \\\" + realImage.getFilename()); realImage.display(); } } \",\"在代理类中，我们在 display() 方法中先输出加载图片的信息，然后调用 RealImage 对象的 display() 方法来显示图片。\",\"最后，我们可以使用代理类来显示图片，并观察输出结果：\",\"public class Main { public static void main(String[] args) { Image image = new ImageProxy(\\\"example.jpg\\\"); image.display(); } } \",\"在上述示例中，我们创建了 ImageProxy 的实例，并调用其 display() 方法来显示图片。在执行该方法时，代理类会输出加载图片的信息，并通过调用 RealImage 对象的 display() 方法来实际显示图片。\",\"通过使用接口实现静态代理，我们可以在代理类中控制对实现接口的对象的访问，并在调用其方法前后添加额外的逻辑。这样，我们可以对接口实现对象的方法进行增强、修改或限制，以满足特定的需求。\",\"优点和缺点：\",\"优点：\",\"可以在不修改原始代码的情况下，通过代理对象对被代理对象进行功能增强、安全访问控制、日志记录等操作；也可以在代理对象中进行一些额外的操作，如记录日志、缓存等，以增强被代理对象的功能。\",\"代理对象可以隐藏被代理对象的具体实现，实现了客户端和被代理对象的解耦。\",\"缺点：\",\"静态代理在编译时就已经确定代理类，后续维护可能修改源代码\",\"每个被代理类都需要手动创建一个代理类，当代理类较多或变动频繁时，会增加代码量和维护成本。\",\"**使用场景：**下列是使用chatgpt学习中回答的使用场景和代码示例\",\"访问控制和安全性：静态代理可以用于控制对被代理对象的访问权限，确保只有具有合适权限的客户端可以访问被代理对象。\",\"日志记录：静态代理可以用于记录对被代理对象的操作日志，方便后续的分析和监控。\",\"性能监控：静态代理可以用于监控被代理对象的性能，统计方法的执行时间、调用次数等指标。\",\"缓存：静态代理可以用于实现对被代理对象的结果进行缓存，提高系统响应速度。\",\"事务管理：静态代理可以用于实现对被代理对象的事务管理，保证操作的原子性和一致性。\",\"远程代理：静态代理可以用于实现远程对象的访问，隐藏底层的网络通信细节。\",\"缓存代理示例代码：\",\"示例-缓存代理当涉及到数据库查询时，可以使用静态代理来实现查询缓存的功能。下面是一个简单的示例代码，演示了如何使用静态代理来实现数据库查询缓存的功能：\",\"首先，我们需要定义一个共同的接口，代表数据库操作：\",\"// 定义数据库操作的接口 interface Database { String queryData(String query); } \",\"然后，我们创建一个具体的数据库操作类，实现上述接口，用于执行实际的数据库查询：\",\"// 实现数据库操作的具体类 class DatabaseImpl implements Database { @Override public String queryData(String query) { // 模拟执行数据库查询 System.out.println(\\\"Executing database query: \\\" + query); // 返回查询结果 return \\\"Result for query: \\\" + query; } } \",\"接下来，我们创建一个代理类，用于添加查询缓存的逻辑：\",\"// 创建代理类，添加查询缓存的逻辑 class DatabaseProxy implements Database { private Database database; private Map<String, String> cache; // 查询缓存 public DatabaseProxy() { this.database = new DatabaseImpl(); this.cache = new HashMap<>(); } @Override public String queryData(String query) { // 先检查缓存中是否存在查询结果 if (cache.containsKey(query)) { System.out.println(\\\"Retrieving cached result for query: \\\" + query); return cache.get(query); } // 如果缓存中不存在查询结果，则执行实际的数据库查询 String result = database.queryData(query); // 将查询结果存入缓存 cache.put(query, result); return result; } } \",\"在代理类中，我们在queryData()方法中先检查缓存中是否存在查询结果。如果存在，直接从缓存中返回结果；如果不存在，代理类会调用实际的数据库操作类执行查询，并将查询结果存入缓存中。\",\"最后，我们可以使用代理类来执行数据库查询，并观察缓存的效果：\",\"public class Main { public static void main(String[] args) { Database database = new DatabaseProxy(); // 第一次执行查询，将结果存入缓存 String result1 = database.queryData(\\\"SELECT * FROM table1\\\"); System.out.println(\\\"Result 1: \\\" + result1); // 第二次执行相同的查询，从缓存中获取结果 String result2 = database.queryData(\\\"SELECT * FROM table1\\\"); System.out.println(\\\"Result 2: \\\" + result2); } } \",\"在上述示例中，第一次执行查询时，会调用实际的数据库操作类执行查询，并将结果存入缓存。第二次执行相同的查询时，直接从缓存中获取结果，而不会再次执行数据库查询。\",\"缓存代理-示例-输出结果展示\",\"通过静态代理，我们实现了数据库查询缓存的功能，可以提高查询性能，减少对数据库的访问。这样，在相同的查询被频繁执行时，可以直接从缓存中获取结果，避免了重复的数据库查询操作。\",\"安全代理示例代码：\",\"示例-安全代理当涉及到安全性验证时，可以使用静态代理来实现安全代理的功能。下面是一个简单的示例代码，演示了如何使用静态代理来实现安全代理：\",\"首先，我们需要定义一个共同的接口，代表敏感操作：\",\"// 定义敏感操作的接口 interface SensitiveOperation { void performOperation(); } \",\"然后，我们创建一个具体的敏感操作类，实现上述接口，用于执行实际的敏感操作：\",\"// 实现敏感操作的具体类 class SensitiveOperationImpl implements SensitiveOperation { @Override public void performOperation() { System.out.println(\\\"Performing sensitive operation...\\\"); } } \",\"接下来，我们创建一个代理类，用于添加安全验证的逻辑：\",\"// 创建代理类，添加安全验证的逻辑 class SecurityProxy implements SensitiveOperation { private SensitiveOperation sensitiveOperation; private String password; // 安全验证密码 public SecurityProxy(String password) { this.sensitiveOperation = new SensitiveOperationImpl(); this.password = password; } @Override public void performOperation() { // 进行安全验证 if (authenticate()) { sensitiveOperation.performOperation(); } else { System.out.println(\\\"Access denied! Invalid password.\\\"); } } private boolean authenticate() { // 进行安全验证的逻辑，比较输入密码和预设密码是否匹配 String inputPassword = getPasswordFromUser(); return inputPassword.equals(password); } private String getPasswordFromUser() { // 模拟从用户输入获取密码的逻辑 Scanner scanner = new Scanner(System.in); System.out.print(\\\"Enter password: \\\"); return scanner.nextLine(); } } \",\"在代理类中，我们在performOperation()方法中进行安全验证。首先，用户需要输入密码进行验证；如果验证通过，则调用实际的敏感操作类执行敏感操作；如果验证失败，则拒绝访问。\",\"最后，我们可以使用代理类来执行敏感操作，并观察安全验证的效果：\",\"public class Main { public static void main(String[] args) { String password = \\\"password123\\\"; // 设置安全验证密码 SensitiveOperation operation = new SecurityProxy(password); // 执行敏感操作，需要通过密码验证 operation.performOperation(); } } \",\"在上述示例中，执行敏感操作时，用户需要输入密码进行安全验证。只有当输入的密码与预设密码匹配时，才能执行实际的敏感操作。否则，将拒绝访问。\",\"通过静态代理，我们实现了安全代理的功能，可以在执行敏感操作前进行安全验证，保护敏感操作的安全性。这样，在需要对敏感操作进行访问控制和验证的场景下，可以使用安全代理来确保只有经过验证的用户才能执行敏感操作。\",\"远程代理示例代码：\",\"示例-远程代理 当涉及到远程对象的访问时，可以使用静态代理来实现远程代理的功能。下面是一个简单的示例代码，演示了如何使用静态代理来实现远程代理：\",\"首先，我们需要定义一个共同的接口，代表远程服务：\",\"// 定义远程服务的接口 interface RemoteService { void performTask(); } \",\"然后，我们创建一个具体的远程服务类，实现上述接口，用于执行实际的远程任务：\",\"// 实现远程服务的具体类 class RemoteServiceImpl implements RemoteService { @Override public void performTask() { System.out.println(\\\"Performing remote task...\\\"); } } \",\"接下来，我们创建一个代理类，用于封装远程通信的逻辑：\",\"// 创建代理类，封装远程通信的逻辑 class RemoteProxy implements RemoteService { private RemoteService remoteService; public RemoteProxy() { // 在代理类中创建远程服务对象 this.remoteService = new RemoteServiceImpl(); } @Override public void performTask() { // 在代理类中添加远程通信的逻辑，模拟网络请求 System.out.println(\\\"Sending request to remote server...\\\"); // 调用远程服务对象的方法 remoteService.performTask(); // 在代理类中添加远程通信的逻辑，模拟网络响应 System.out.println(\\\"Received response from remote server...\\\"); } } \",\"在代理类中，我们在performTask()方法中添加远程通信的逻辑，模拟网络请求和响应的过程。首先，发送请求到远程服务器；然后，调用远程服务对象的方法执行远程任务；最后，接收远程服务器的响应。\",\"最后，我们可以使用代理类来执行远程任务，并观察远程通信的效果：\",\"public class Main { public static void main(String[] args) { RemoteService remoteService = new RemoteProxy(); // 执行远程任务 remoteService.performTask(); } } \",\"在上述示例中，执行远程任务时，代理类将负责封装远程通信的逻辑。在调用远程服务对象的方法之前和之后，代理类会进行网络请求和响应的模拟操作。\",\"通过静态代理，我们实现了远程代理的功能，可以封装远程通信的逻辑，隐藏底层的网络细节。这样，在需要访问远程对象时，可以使用远程代理来进行网络请求和响应的处理，简化了远程通信的操作。\"]},\"496\":{\"h\":\"2、动态代理\",\"t\":[\"简介：\",\"动态代理（Dynamic Proxy）是一种在运行时动态生成代理类的设计模式。与静态代理不同，动态代理不需要手动编写代理类，而是通过Java的反射机制在运行时动态生成代理类，从而实现对被代理对象的代理。\",\"基于JDK实现的动态代理，基于接口实现。\",\"基于CGLIB使用的动态代理，基于继承实现。\",\"基本流程：\",\"定义一个接口，该接口是被代理类和代理类共同实现的接口。\",\"创建一个实现了InvocationHandler接口的代理处理器类，该类中包含对方法的增强逻辑。\",\"使用Proxy类的静态方法newProxyInstance()来创建代理对象，该方法接收三个参数：类加载器、被代理类实现的接口数组、代理处理器对象。\",\"通过代理对象调用方法，代理处理器中的invoke()方法会被触发，并执行相应的增强逻辑。\",\"优点和缺点：\",\"优点：\",\"动态代理可以在运行时动态地创建代理对象，适用于不同的接口和被代理类。\",\"它允许在不修改现有代码的情况下，对方法进行统一的增强或拦截，比如性能监控、事务管理、缓存等。\",\"动态代理可以减少代码量，避免手动编写大量的代理类。\",\"缺点：\",\"动态代理的性能相对较低，因为在运行时需要使用反射机制来生成代理类和调用方法。\",\"动态代理只能代理接口，无法代理具体类，因为Java的单继承限制。\",\"使用场景：\",\"动态代理常用于AOP（面向切面编程）领域，可以通过动态代理在运行时动态地为目标对象添加横切逻辑，如日志记录、事务管理等。\",\"动态代理还可以用于远程方法调用（RMI）、缓存代理、延迟加载等场景，以实现更灵活、可扩展的系统架构。\"]},\"497\":{\"h\":\"基于 JDK 实现的动态代理\",\"t\":[\"这个例子是基于 JDK 实现的动态代理示例。它演示了如何使用动态代理在运行时为目标对象添加额外的逻辑处理，而无需修改目标对象的代码：\",\"/** * Author: shawn * Description: 定义一个共同的接口，代表数据库操作 */ public interface DataBase { /** * 执行数据库查询操作 * * @param query 查询语句 * @return 查询结果 */ String query(String query); /** * 执行数据库删除操作 * * @param delete 删除语句 * @return 删除结果 */ String delete(String delete); } /** * Author: shawn * Description: 数据库操作的具体实现类 */ public class DataBaseImpl implements DataBase { @Override public String query(String query) { // 模拟执行数据库查询 System.out.println(\\\"Executing database query: \\\" + query); // 返回查询结果 return \\\"Result for query: \\\" + query; } @Override public String delete(String delete) { // 模拟执行数据库删除 System.out.println(\\\"Executing database delete: \\\" + delete); // 返回删除结果 return \\\"Result for delete: \\\" + delete; } } /** * Author: shawn * Description: 该代理处理器类负责处理代理对象的方法调用，并在方法调用前后执行额外的逻辑操作。 */ public class DatabaseInvocationHandler implements InvocationHandler { private Object target; public DatabaseInvocationHandler(Object target) { this.target = target; } /** * invoke()方法用于处理代理对象的方法调用。 * * @param proxy 代理对象本身 * @param method 被调用的方法对象 * @param args 方法的参数数组 * @return 方法的返回结果 * @throws Throwable 异常信息 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 在方法调用前的逻辑处理 // 如:判断方法名,查看是否需要做记录日志 String methodName = method.getName(); if (\\\"delete\\\".equals(methodName)) { //是删除操作才做增强,不然还是调用原方法 System.out.println(\\\"Recording deletion operation log\\\"); } System.out.println(\\\"Before method: \\\" + methodName); System.out.println(\\\"Arguments: \\\" + args[0]); // 调用被代理对象的方法 Object result = method.invoke(target, args); // 在方法调用后的逻辑处理 System.out.println(\\\"Result: \\\" + result); System.out.println(\\\"After method: \\\" + method); // 返回方法的返回结果 return result; } } public class Main { public static void main(String[] args) { // 创建目标对象 DataBase target = new DataBaseImpl(); // 创建代理处理器 DatabaseInvocationHandler handler = new DatabaseInvocationHandler(); // 创建代理对象 DataBase proxy = (DataBase) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler ); // 调用代理对象的方法 String queryResult = proxy.query(\\\"SELECT * FROM table\\\"); System.out.println(\\\"------------------------\\\"); String deleteResult = proxy.delete(\\\"DELETE FROM table WHERE id = 1\\\"); System.out.println(\\\"------------------------\\\"); // 输出方法的返回结果 System.out.println(\\\"Query Result: \\\" + queryResult); System.out.println(\\\"------------------------\\\"); System.out.println(\\\"Delete Result: \\\" + deleteResult); } } \",\"在上面的代码中，我们使用了动态代理来为 DataBase 接口生成了一个代理类，并在代理类中增加了日志记录的功能。\",\"具体地说，在 DatabaseInvocationHandler 类中的 invoke 方法中，我们根据方法名进行判断，只有当方法名是 \\\"delete\\\" 时才会进行日志记录。这样，在调用代理对象的 delete 方法时，会先输出 \\\"Recording deletion operation log\\\" 的提示信息，表示进行了删除操作的日志记录。\",\"其他方法（比如 query 方法）没有满足条件，所以不会进行日志记录，只会输出方法调用前的提示信息和参数信息。\",\"通过这种方式，我们实现了对原有接口的增强，根据不同的方法名来决定是否进行日志记录，从而实现了按需添加日志记录功能的动态代理类。这样的设计使得我们可以在不修改原有接口和实现类的情况下，为特定方法或特定场景添加额外的功能。\",\"【下列是运行输出】：\",\"Before method: query Arguments: SELECT * FROM table Executing database query: SELECT * FROM table Result: Result for query: SELECT * FROM table After method: public abstract java.lang.String structuralDesignPattern.proxy.dynamicProxy.DataBase.query(java.lang.String) ------------------------ Recording deletion operation log Before method: delete Arguments: DELETE FROM table WHERE id = 1 Executing database delete: DELETE FROM table WHERE id = 1 Result: Result for delete: DELETE FROM table WHERE id = 1 After method: public abstract java.lang.String structuralDesignPattern.proxy.dynamicProxy.DataBase.delete(java.lang.String) ------------------------ Query Result: Result for query: SELECT * FROM table ------------------------ Delete Result: Result for delete: DELETE FROM table WHERE id = 1 \"]},\"498\":{\"h\":\"基于 CGLIB 实现的动态代理\",\"t\":[\"这是一个基于CGLIB实现的动态代理示例。下面是代码的解析：\",\"public class DataBaseImpl { public String query(String query) { // 模拟执行数据库查询 System.out.println(\\\"Executing database query: \\\" + query); // 返回查询结果 return \\\"Result for query: \\\" + query; } public String delete(String delete) { // 模拟执行数据库删除 System.out.println(\\\"Executing database delete: \\\" + delete); // 返回删除结果 return \\\"Result for delete: \\\" + delete; } } \",\"上述代码定义了一个数据库操作的具体实现类 DataBaseImpl，包含了 query 和 delete 两个方法。\",\"public class DatabaseMethodInterceptor implements MethodInterceptor { private DataBaseImpl dataBase; public DatabaseMethodInterceptor() { this.dataBase = new DataBaseImpl(); } public DatabaseMethodInterceptor(DataBaseImpl dataBase) { this.dataBase = dataBase; } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { // 在方法调用前的逻辑处理 // 如:判断方法名,查看是否需要做记录日志 String methodName = method.getName(); if (\\\"delete\\\".equals(methodName)) { //是删除操作才做增强,不然还是调用原方法 System.out.println(\\\"Recording deletion operation log\\\"); } System.out.println(\\\"Before method: \\\" + methodName); System.out.println(\\\"Arguments: \\\" + objects[0]); // 调用被代理对象的方法 Object result = method.invoke(dataBase, objects); // 在方法调用后的逻辑处理 System.out.println(\\\"Result: \\\" + result); System.out.println(\\\"After method: \\\" + method); // 返回方法的返回结果 return result; } } \",\"上述代码是基于CGLIB的方法拦截器 DatabaseMethodInterceptor，实现了 MethodInterceptor 接口。拦截器中的 intercept 方法用于在方法调用前后进行逻辑处理，包括记录日志和调用被代理对象的方法。\",\"public class Main { public static void main(String[] args) { //cglib通过enhancer Enhancer enhancer = new Enhancer(); //设置他的父类-要继承谁,给谁做代理 enhancer.setSuperclass(DataBaseImpl.class); //设置方法拦截器,用于拦截方法,对方法做增强 enhancer.setCallback(new DatabaseMethodInterceptor()); // 创建代理对象 DataBaseImpl proxy = (DataBaseImpl) enhancer.create(); // 调用代理对象的方法 String queryResult = proxy.query(\\\"SELECT * FROM table\\\"); System.out.println(\\\"--------cglib----------------\\\"); String deleteResult = proxy.delete(\\\"DELETE FROM table WHERE id = 1\\\"); System.out.println(\\\"--------cglib----------------\\\"); // 输出方法的返回结果 System.out.println(\\\"Query Result: \\\" + queryResult); System.out.println(\\\"--------cglib----------------\\\"); System.out.println(\\\"Delete Result: \\\" + deleteResult); } } \",\"上述代码是 Main 类，包含了代理对象的创建和方法调用的示例。使用 Enhancer 创建代理对象，并设置父类和方法拦截器，最终通过 create 方法创建代理对象。然后，通过代理对象调用方法。\",\"在运行该示例代码时，会输出方法调用的前后日志和结果。\",\"请注意，为了使该示例代码正常运行，你需要在项目的依赖中添加 CGLIB 的相关依赖，或者将项目修改为spring boot项目。你可以将以下依赖添加到你的 pom.xml 文件中：\",\"在运行代码时，你将看到方法调用的输出结果和日志记录，以及代理对象的增强效果。\",\"Before method: query Arguments: SELECT * FROM table Executing database query: SELECT * FROM table Result: Result for query: SELECT * FROM table After method: public java.lang.String structuralDesignPattern.proxy.dynamicProxy.cglib.DataBaseImpl.query(java.lang.String) --------cglib---------------- Recording deletion operation log Before method: delete Arguments: DELETE FROM table WHERE id = 1 Executing database delete: DELETE FROM table WHERE id = 1 Result: Result for delete: DELETE FROM table WHERE id = 1 After method: public java.lang.String structuralDesignPattern.proxy.dynamicProxy.cglib.DataBaseImpl.delete(java.lang.String) --------cglib---------------- Query Result: Result for query: SELECT * FROM table --------cglib---------------- Delete Result: Result for delete: DELETE FROM table WHERE id = 1 \"]},\"499\":{\"h\":\"二、装饰器设计模式\"},\"500\":{\"h\":\"1、简介\",\"t\":[\"装饰器设计模式（Decorator Design Pattern）是一种结构型设计模式，它允许你在不改变已有对象的情况下，使用组合替代继承对某些原生对象的方法做增强，添加新的能力\",\"代理设计模式：主要倾向于控制对对象的访问 \",\"在代理设计模式中，代理类附加的是跟原始类无关的功能 \",\"代理会屏蔽原始对象的访问 （即增加缓存功能），而并不是\",\"如我们要给所有的service层添加日志/事务，日志/事务和我们的业务不强相关，代理类附加的是跟原始类无关的功能\",\"装饰器设计模式：主要倾向于增强对象的功能 \",\"在装饰器模式（增强对象的功能）中，装饰器类附加的是跟原始类相关的增强功能 \",\"装饰器不会屏蔽原始对象的访问，既可以访问原始对象，还能访问包装后的对象\",\"如我们有一个缓存结构，这个结构功能不够强大，我们需要给这个结构包装一下增加一个淘汰策略，再包装一下添加一个刷新机制，对原始功能并不够强大的能力让他变得更加强大，装饰器类附加的是跟原始类相关的增强功能\",\"案例：为什么不用继承实现呢 ？\",\"IO库提供了一组用于处理输入和输出的类和接口，例如InputStream、OutputStream、Reader、Writer等。这些类和接口通过组合关系，可以以各种方式组合和包装，实现各种输入和输出操作。\",\"如InputStream有很多子类，如ByteInputStream、FileInputStream等，如我们想要给FileInputStream添加一个新的能力时，如添加缓存的功能，我们可以通过继承的方式实现，创建一个类继承自FileInputStream再对其做增强，但是假如我们要给每一个InputStream的的子类做增强呢，InputStream那么多子类，那我们要为每一个子类创建类进行继承，会让类结构爆炸，所以它是通过装饰器设计模式来解决的，里面维护一个原生对象，通过组合关系和包装，对原生对象的某些方法做增强，这样我们只需要为新的功能创建装饰器类，而不需要修改现有的类继承结构，使得代码更加灵活、可扩展和可维护。\",\"优点：\",\"可以在不修改现有代码的情况下扩展对象的功能。\",\"允许多个装饰器嵌套使用，以实现更复杂的功能组合。\",\"遵循开闭原则，即对扩展开放，对修改关闭。\"]},\"501\":{\"h\":\"2、基本流程\",\"t\":[\"​ 该模式通过创建一个包装器（装饰器），将对象放入该包装器中，并在保持对象接口不变的情况下，增加了额外的功能或责任。装饰器包装了原始对象，从而允许你在执行原始对象的操作之前或之后添加自定义的行为。\",\"抽象组件（Component）：定义了装饰器和具体组件的共同接口，可以是抽象类或接口。\",\"具体组件（Concrete Component）：实现了抽象组件接口，即被装饰的原始对象。\",\"抽象装饰器（Decorator）：继承了抽象组件接口，并持有一个抽象组件对象的引用，可以是抽象类或接口。\",\"具体装饰器（Concrete Decorator）：继承了抽象装饰器，实现了额外的功能，并调用被装饰对象的方法。\"]},\"502\":{\"h\":\"3、案例\",\"t\":[\"下面是一个简单的示例代码，展示了装饰器模式的应用：\",\"public interface Component { void operation(); } \",\"这是一个接口Component，定义了一个operation方法。\",\"public class ConcreteComponent implements Component { @Override public void operation() { System.out.println(\\\"这是具体的对象\\\"); } } \",\"ConcreteComponent是一个实现了Component接口的具体类。它实现了operation方法，并打印出\\\"这是具体的对象\\\"。\",\"public abstract class Decorator implements Component { private Component component; public Decorator(Component component) { this.component = component; } @Override public void operation() { component.operation(); } } \",\"Decorator是一个抽象类，实现了Component接口。它包含一个Component类型的私有成员变量component，并通过构造器接收一个Component对象进行初始化。它还实现了operation方法，调用了component对象的operation方法。\",\"public class DecoratorA extends Decorator { public DecoratorA(Component component) { super(component); } @Override public void operation() { System.out.println(\\\"包装了一下，添加了背景颜色\\\"); super.operation(); } } \",\"DecoratorA是一个继承自Decorator的具体装饰类。它接收一个Component对象，并通过构造器调用父类的构造器进行初始化。它重写了operation方法，在打印\\\"包装了一下，添加了背景颜色\\\"之后，再调用父类的operation方法。\",\"public class DecoratorB extends Decorator { public DecoratorB(Component component) { super(component); } @Override public void operation() { System.out.println(\\\"包装了一下，打了个合格标签\\\"); super.operation(); } } \",\"DecoratorB是另一个继承自Decorator的具体装饰类。它也接收一个Component对象，并通过构造器调用父类的构造器进行初始化。它同样重写了operation方法，在打印\\\"包装了一下，打了个合格标签\\\"之后，再调用父类的operation方法。\",\"public class Main { public static void main(String[] args) { // 创建一个原始对象 Component component = new ConcreteComponent(); // 没有包装，调用原始方法 component.operation(); System.out.println(\\\"----------分-----------界------------线--------------\\\"); // 同A包装一下 DecoratorA decoratorA = new DecoratorA(component); decoratorA.operation(); System.out.println(\\\"----------分-----------界------------线--------------\\\"); // 同B再包装一层 DecoratorB decoratorB = new DecoratorB(decoratorA); decoratorB.operation(); System.out.println(\\\"----------分-----------界------------线--------------\\\"); // 再次调用原有对象，并没有发生改变 component.operation(); } //更加直观 public static void main(String[] args) { //创建一个原始对象 Component component = new ConcreteComponent(); //没有包装，调用原始方法 component.operation(); System.out.println(\\\"----------分-----------界------------线--------------\\\"); //同A包装一下 Decorator decorator = new DecoratorA(component); decorator.operation(); System.out.println(\\\"----------分-----------界------------线--------------\\\"); //同B再包装一层 decorator = new DecoratorB(decorator); decorator.operation(); System.out.println(\\\"----------分-----------界------------线--------------\\\"); //再次调用原有对象，并没有发生改变 component.operation(); } } \",\"在Main类的main方法中，首先创建了一个ConcreteComponent对象作为原始对象。然后，通过component.operation()调用原始对象的operation方法，打印出\\\"这是具体的对象\\\"。\",\"接下来，创建了一个DecoratorA对象decoratorA，并将原始对象component作为参数传递给它的构造器。通过decoratorA.operation()调用DecoratorA对象的operation方法。在打印\\\"包装了一下，添加了背景颜色\\\"之后，它调用父类Decorator的operation方法，这会再次调用原始对象的operation方法。\",\"然后，创建了一个DecoratorB对象decoratorB，并将decoratorA对象作为参数传递给它的构造器。通过decoratorB.operation()调用DecoratorB对象的operation方法。在打印\\\"包装了一下，打了个合格标签\\\"之后，它同样调用父类Decorator的operation方法，这会再次调用原始对象的operation方法。\",\"最后，再次调用原始对象component的operation方法，输出结果仍然是\\\"这是具体的对象\\\"，即原始对象并没有发生改变。\",\"这是具体的对象 ----------分-----------界------------线-------------- 包装了一下,添加了背景颜色 这是具体的对象 ----------分-----------界------------线-------------- 包装了一下,打了个合格标签 包装了一下,添加了背景颜色 这是具体的对象 ----------分-----------界------------线-------------- 这是具体的对象 \",\"总结起来，装饰器模式允许通过包装对象来动态地为对象添加额外的行为。抽象类Decorator作为装饰器的基类，通过组合和继承的方式实现了装饰功能。在示例中，DecoratorA和DecoratorB是具体的装饰器类，它们分别在原始对象的行为前后添加了特定的功能。通过层层装饰，可以灵活地组合各种装饰器，实现对对象功能的动态扩展。\"]},\"503\":{\"h\":\"三、桥接设计模式\"},\"504\":{\"h\":\"1、简介\",\"t\":[\"桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象和实现分离，使它们可以独立地变化。\",\"桥接模式的核心思想：通过组合关系而不是继承关系来连接抽象和实现。\",\"核心使用场景：当需要抽象和实现，一对多、多对多的场景。\",\"在桥接模式中，抽象部分和实现部分分别由两个独立的类层次结构组成。抽象部分包含高层的抽象接口和方法，实现部分包含低层的具体实现。通过桥接模式，抽象部分和实现部分可以独立地扩展和变化，而不会相互影响。\",\"以下是桥接模式的几个关键角色：\",\"抽象部分（Abstraction）：定义了抽象接口，并包含一个指向实现部分的引用。\",\"扩展的抽象部分（Refined Abstraction）：对抽象部分进行扩展，提供更多的功能或特性。\",\"实现部分（Implementor）：定义了实现部分的接口，供抽象部分调用。\",\"具体实现部分（Concrete Implementor）：实现实现部分的具体逻辑。\",\"通过桥接模式，我们可以通过修改或添加新的抽象部分或实现部分，来实现更灵活的变化和扩展。它可以避免类爆炸问题，提高系统的可维护性和可扩展性。\"]},\"505\":{\"h\":\"2、基本流程\",\"t\":[\"桥接模式是一种结构型设计模式，它的主要目的是将抽象部分与实现部分分离，使它们可以独立地变化。下面是桥接模式的基本流程：\",\"定义抽象部分接口（Abstraction）：抽象部分是桥接模式的核心，它定义了抽象部分的接口和功能。通常，抽象部分接口中会包含对实现部分对象的引用，以及一些抽象的操作方法。\",\"定义实现部分接口（Implementor）：实现部分接口定义了实现部分的接口和功能。实现部分接口通常是与抽象部分接口相对应的，但可以独立地变化。\",\"创建具体抽象部分类（RefinedAbstraction）：具体抽象部分类是抽象部分接口的具体实现，它扩展了抽象部分接口，并实现了相关的操作方法。具体抽象部分类通常会持有一个实现部分对象的引用。\",\"创建具体实现部分类（ConcreteImplementor）：具体实现部分类是实现部分接口的具体实现，它实现了实现部分接口定义的功能。\",\"在具体抽象部分类中使用实现部分对象：具体抽象部分类通过调用实现部分对象的方法来实现自己的操作。抽象部分和实现部分通过组合关系连接在一起，而不是继承关系。\",\"通过桥接模式，抽象部分和实现部分可以独立地变化，它们的变化不会相互影响。这样可以使系统更加灵活，方便扩展和维护。\"]},\"506\":{\"h\":\"3、案例\",\"t\":[\"假如我们正在开发一个电子商务系统，该系统涉及不同类型的商品（如服装、电子产品、家居用品等），并且可以在不同的销售渠道上进行销售（如在线商店、移动应用、实体店等）。为了处理商品和销售渠道之间的关系，我们可以使用桥接设计模式。\",\"首先，我们定义了一个名为 Product 的接口，其中包含一些通用的商品属性和方法。然后，我们创建了具体的商品类，例如 ClothingProduct（服装商品）、ElectronicsProduct（电子产品商品）和 HomeProduct（家居用品商品）。这些具体商品类都实现了 Product 接口，并实现了 sell() 方法。\",\"接下来，我们定义了一个名为 SalesChannel 的接口，其中包含一些通用的销售渠道属性和方法，例如渠道名称、销售方式等。然后，我们创建了多个具体的销售渠道类，例如 OnlineStoreChannel（在线商店渠道）、MobileAppChannel（移动应用渠道）和 PhysicalStoreChannel（实体店渠道）。这些具体销售渠道类都继承自 SalesChannel 接口，并提供了各自特定的属性和方法。\",\"现在，通过桥接模式，我们将商品和销售渠道分离开来，使它们可以独立地变化。我们创建了一个桥接类 ProductSales，该类包含一个指向商品和销售渠道的引用，并提供一个方法来在特定销售渠道上销售商品。这样，我们可以根据需要组合不同的商品和销售渠道，实现灵活的销售策略。\",\"通过桥接设计模式，我们可以实现商品和销售渠道之间的解耦，并且可以方便地扩展和修改系统，以适应不同的需求和变化。\",\"// 商品接口 interface Product { void sell(SalesChannel channel); } // 具体商品类 class ClothingProduct implements Product { private String name; private double price; public ClothingProduct(String name, double price) { this.name = name; this.price = price; } public void sell(SalesChannel channel) { System.out.println(\\\"Selling \\\" + name + \\\" clothing product on \\\" + channel.getName()); // 实现具体的销售逻辑 } } // 具体商品类 class DigitalProduct implements Product { private String name; private double price; public DigitalProduct(String name, double price) { this.name = name; this.price = price; } public void sell(SalesChannel channel) { System.out.println(\\\"Selling \\\" + name + \\\" digital product on \\\" + channel.getName()); // 实现具体的销售逻辑 } } // 销售渠道接口 interface SalesChannel { String getName(); } // 具体销售渠道类 class OnlineStoreChannel implements SalesChannel { public String getName() { return \\\"Online Store\\\"; } } class MobileAppChannel implements SalesChannel { public String getName() { return \\\"Mobile App\\\"; } } class PhysicalStoreChannel implements SalesChannel { public String getName() { return \\\"Physical Store\\\"; } } // 桥接类 class ProductSales { private Product product; private SalesChannel channel; public ProductSales(Product product, SalesChannel channel) { this.product = product; this.channel = channel; } public void sell() { product.sell(channel); } } // 使用示例 public class Main { public static void main(String[] args) { Product clothingProduct = new ClothingProduct(\\\"T-Shirt\\\", 29.99); SalesChannel onlineStoreChannel = new OnlineStoreChannel(); ProductSales productSales = new ProductSales(clothingProduct, onlineStoreChannel); productSales.sell(); } } \",\"通过使用桥接模式，我们可以轻松地添加新的商品类型和销售渠道，而不需要修改现有的类。例如，我们可以创建新的 ElectronicsProduct 类和 MobileAppChannel 类，并根据需要进行组合。这样，我们可以实现不同商品在不同销售渠道上的灵活销售。同时，它也提供了更高的代码可读性和可维护性，使得系统更加灵活和易于扩展。\"]},\"507\":{\"h\":\"四、适配器设计模式\"},\"508\":{\"h\":\"1、简介\",\"t\":[\"适配器设计模式（Adapter Design Pattern）是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一个接口，主要用于解决不兼容接口之间的问题，使得原本由于接口不匹配而无法合作的类可以一起工作。\",\"适配器模式涉及三个主要角色：\",\"目标（Target）：目标是客户端所期望的接口。它定义了客户端代码可以使用的方法。\",\"适配器（Adapter）：适配器是将原本不兼容的接口转换成目标接口的类。它实现了目标接口，并通过包装或转换来适应被适配者。\",\"被适配者（Adaptee）：被适配者是需要被适配的类或接口。它定义了适配器需要适配的方法。\"]},\"509\":{\"h\":\"2、基本流程\",\"t\":[\"适配器模式的工作原理如下：\",\"客户端通过调用目标接口中的方法来使用适配器。\",\"适配器接收客户端的请求，并将其转发给被适配者。\",\"被适配者执行相应的操作，并将结果返回给适配器。\",\"适配器将结果转换为客户端所期望的格式，并将其返回给客户端。\"]},\"510\":{\"h\":\"3、使用场景和案例\",\"t\":[\"适配器模式在软件开发中经常用于以下场景：\",\"将旧的接口适配成新的接口，以便与新的系统集成。\",\"在使用第三方库或组件时，适配器可以帮助将其接口转换为符合项目需求的接口。\",\"在系统演进中，适配器模式可以用于平滑迁移旧的接口到新的接口。\",\"总结起来，适配器设计模式允许不兼容的接口之间进行协同工作，提供了一种解决接口不匹配问题的灵活方案。\",\"将旧的接口迁移成新的接口：\",\"当面对新老支付接口替换的场景时，适配器设计模式可以帮助我们平滑过渡并确保系统的兼容性。假设我们有一个电商平台，目前正在使用老的支付接口2022进行支付操作。由于接口2022已过时或者有其他限制，我们需要将支付接口替换为新的支付接口2023。下面是一个示例代码，演示如何使用适配器设计模式来实现支付接口的替换：\",\"// 老的支付接口 public interface Payment2022Interface { void processPayment(double amount); // ... } // 老的支付接口实现 public class Payment2022Implementation implements Payment2022Interface { @Override public void processPayment(double amount) { // 使用老的支付接口进行支付 // ... System.out.println(\\\"使用老的支付接口支付的: \\\" + amount + \\\"元\\\"); } } // 新的支付接口 public interface PaymentInterfaceB { void initiatePayment(double amount); // ... } // 新的支付接口实现 public class Payment2023Implementation implements Payment2023Interface { @Override public void initiatePayment(double amount) { // 使用新的支付接口进行支付 // ... System.out.println(\\\"使用新的支付接口支付的: \\\" + amount + \\\"元\\\"); } } // 适配器类，将新的支付接口适配到老的支付接口上 public class PaymentAdapter implements Payment2022Interface { private Payment2023Interface payment2023; public PaymentAdapter(Payment2023Interface payment2023) { this.payment2023 = payment2023; } @Override public void processPayment(double amount) { // 将老的支付接口2022的调用转换为新的支付接口2023的调用 payment2023.initiatePayment(amount); } } // 电商平台订单类 public class Order { private final double amount; private final Payment2022Interface payment2022; public Order(double amount, Payment2022Interface payment2022) { this.amount = amount; this.payment2022 = payment2022; } public void processOrderPayment() { // 调用支付接口进行支付 payment2022.processPayment(amount); } // ... } // 使用示例 public class Main { public static void main(String[] args) { // 创建新的支付接口实现 Payment2023Interface payment2023 = new Payment2023Implementation(); // 创建适配器，将新的支付接口适配到老的支付接口上 Payment2022Interface payment2022 = new PaymentAdapter(payment2023); // 创建订单，并传入适配器 Order order = new Order(100.0, payment2022); // 处理订单支付 //表面调用的是老的支付接口,但是内部实现确实调用新的支付接口 order.processOrderPayment(); } } \",\"运行输出：\",\"使用新的支付接口支付的: 100.0元 \",\"以上代码展示了一个适配器模式的示例，用于将新的支付接口适配到旧的支付接口上。\",\"在示例中，有以下关键部分：\",\"Payment2022Interface 是旧的支付接口，定义了 processPayment 方法用于处理支付操作。\",\"Payment2022Implementation 是旧的支付接口的实现类，实现了 Payment2022Interface 接口的方法。\",\"PaymentInterfaceB 是新的支付接口，定义了 initiatePayment 方法用于发起支付操作。\",\"Payment2023Implementation 是新的支付接口的实现类，实现了 PaymentInterfaceB 接口的方法。\",\"PaymentAdapter 是适配器类，实现了旧的支付接口 Payment2022Interface，并在内部使用新的支付接口 Payment2023Interface 进行支付操作的适配。\",\"Order 是电商平台的订单类，接收一个支付接口对象，在 processOrderPayment 方法中调用支付接口的支付方法。\",\"Main 是使用示例，创建了新的支付接口实现对象 Payment2023Implementation，然后使用适配器 PaymentAdapter 将新的支付接口适配到旧的支付接口上，并将适配后的接口对象传递给订单对象进行支付处理。\",\"在示例中，通过适配器模式，可以在保留原有代码和接口的情况下，使用新的支付接口实现进行支付操作。即使订单类中使用的是旧的支付接口对象，实际上在内部调用的是新的支付接口实现的方法。这样就实现了旧接口和新接口的兼容性和平滑过渡。\"]},\"511\":{\"h\":\"4、实际案例\",\"t\":[\"如在我的项目经历中有这样一条描述：\",\"整合银行不同接口发来的不同格式的报文，使用适配器设计模式进行适配，统一转换为我司可用的短信数据格式。\",\"接收第三方发送的报文：\",\"@WebService public class SmsService { @WebMethod public void receiveSms(@WebParam(name = \\\"message\\\") String message, @WebParam(name = \\\"format\\\") String format) { //根据类型获取对应获取适配器 SmsAdapter smsAdapter = SmsAdapterFactory.createAdapter(format); //解析 SmsParamsDTO smsParamsDTO = smsAdapter.parse(message); } } \",\"适配器：\",\"//适配器定义行为 public interface SmsAdapter { SmsParamsDTO parse(String msg); } //解析json的 public class JsonSmsAdapter implements SmsAdapter { @Override public SmsParamsDTO parse(String msg) { //解析json格式 return null; } } //解析xml的 public class XmlSmsAdapter implements SmsAdapter { @Override public SmsParamsDTO parse(String msg) { //解析xml格式 return null; } } \",\"根据类型获取适配器：\",\"public class SmsAdapterFactory { public static SmsAdapter createAdapter(String format) { //判断报文格式获取不同的适配器对象 if (\\\"xml\\\".equals(format)) { return new XmlSmsAdapter(); } else if (\\\"json\\\".equals(format)) { return new JsonSmsAdapter(); } else { //return default return null; } } } \"]},\"512\":{\"h\":\"5、总结\",\"t\":[\"适配器设计模式它允许不兼容的接口或类之间进行协同工作。\",\"适配器充当两个不兼容实体之间的桥梁，将一个接口转换为另一个接口，以便它们可以无缝地协同工作。\",\"在不修改现有代码的情况下实现接口之间的互操作性和交互。\",\"适配器通过包装或转换一个类，将其接口转换为客户端所期望的接口形式。\",\"适配器设计模式的优点包括：\",\"解决接口不匹配问题：适配器允许不兼容的接口或类之间进行协同工作，提供了一种无缝的接口转换机制。\",\"可重用性和灵活性：适配器可以重复使用，用于适配多个不同的接口或类，提供了灵活性和可扩展性。\",\"保护现有代码：适配器可以包装现有的类或接口，而无需修改其源代码，从而保护现有代码的稳定性和完整性。\",\"提高代码复用：适配器将适配逻辑封装在一个单独的类中，可以在不同的系统和项目中重复使用。\",\"适配器设计模式适用于以下情况：\",\"需要将一个已存在的类或接口适配到另一个接口，以满足客户端的需求。\",\"需要在不修改现有代码的情况下与已有类或接口进行协同工作。\",\"需要在系统中引入新的功能，但又不希望破坏现有的代码结构。\",\"总而言之，适配器设计模式提供了一种解决接口不匹配问题的灵活而可扩展的方式，使得不兼容的类或接口可以协同工作。它帮助我们保护现有代码，提高代码复用性，并提供了系统的可扩展性和灵活性。\"]},\"513\":{\"h\":\"五、门面设计模式\"},\"514\":{\"h\":\"1、介绍\",\"t\":[\"门面设计模式（Facade Pattern）是一种结构性设计模式，它为子系统提供了一个统一的接口，以简化客户端与子系统之间的交互。通过使用门面模式，客户端可以通过与门面对象进行交互，而无需直接与子系统的组件进行通信。\"]},\"515\":{\"h\":\"2、核心思想\",\"t\":[\"门面设计模式的核心思想是提供一个高层接口（门面），将复杂的子系统封装起来，以简化客户端与子系统之间的交互。门面对象充当了客户端与子系统之间的中介，它隐藏了子系统的复杂性，提供了一个简单且统一的接口供客户端使用。\"]},\"516\":{\"h\":\"3、组成和基本流程\",\"t\":[\"门面设计模式由以下几个主要组成部分组成：\",\"门面（Facade）：提供了一个统一的接口，封装了对子系统的访问。客户端只需与门面对象进行交互，无需直接与子系统的组件进行通信。\",\"子系统组件（Subsystems）：表示实际执行工作的各个组件或类。子系统可以包含多个组件，每个组件负责一部分具体的功能。\",\"门面设计模式的基本流程如下：\",\"定义子系统组件：确定子系统中的各个组件或类，并实现它们的具体功能。\",\"创建门面类：创建一个门面类，它提供了一个简单的接口来封装子系统的复杂性。门面类可以调用子系统组件来完成客户端请求的处理。\",\"客户端与门面交互：客户端通过与门面对象进行交互来使用子系统。客户端只需调用门面提供的接口，无需直接与子系统组件进行交互。\"]},\"517\":{\"h\":\"4、使用场景\",\"t\":[\"门面设计模式通常在以下情况下使用：\",\"当存在一个复杂的子系统，需要简化客户端与子系统之间的交互时。\",\"当需要将子系统的接口与实现解耦，以提高系统的可维护性和灵活性时。\",\"当希望向客户端隐藏子系统的复杂性，提供一个简单而统一的接口时。\",\"门面设计模式在许多场景中都有应用，例如：\",\"在电商系统中，门面模式可以用于封装与库存管理、订单处理和支付系统等子系统的交互，提供一个统一的接口给客户端进行商品购买操作。\",\"在酒店预订系统中，门面模式可以将与客房管理、价格计算和订单生成等子系统的交互封装起来，为客户端提供一个简单的接口来预订酒店房间。\",\"通过使用门面设计模式，我们可以简化复杂系统的使用，并提供一个统一的接口给客户端，使得客户端更加方便地与子系统进行交互。\"]},\"518\":{\"h\":\"5、具体案例\",\"t\":[\"一个具体的业务场景，结合门面设计模式的案例是一个在线购物平台的订单处理系统。订单处理系统涉及多个子系统，包括库存管理、支付服务、物流管理等。在这种情况下，可以使用门面设计模式来提供一个简化的接口，将订单处理系统的复杂性隐藏起来。\",\"下面是一个简化的示例代码，展示如何使用门面设计模式来简化订单处理系统：\",\"// 子系统：库存管理 class InventorySystem { public void updateInventory(String productId, int quantity) { // 更新库存 // ... System.out.println(\\\"更新库存,库存-1\\\"); } } // 子系统：支付服务 class PaymentService { public void processPayment(double amount, String paymentMethod) { // 处理支付 // ... System.out.println(\\\"付款成功\\\"); } } // 子系统：物流管理 class LogisticsService { public void shipOrder(String orderId, String shippingAddress) { // 发货处理 // ... System.out.println(\\\"开始发货,揽件\\\"); } } // 门面：订单处理门面 class OrderProcessingFacade { private InventorySystem inventorySystem; private PaymentService paymentService; private LogisticsService logisticsService; public OrderProcessingFacade() { this.inventorySystem = new InventorySystem(); this.paymentService = new PaymentService(); this.logisticsService = new LogisticsService(); } public void processOrder(String productId, int quantity, double amount, String paymentMethod, String shippingAddress) { // 更新库存 inventorySystem.updateInventory(productId, quantity); // 处理支付 paymentService.processPayment(amount, paymentMethod); // 物流处理 logisticsService.shipOrder(generateOrderId(), shippingAddress); // 其他订单处理逻辑 // ... } private String generateOrderId() { // 生成订单号 // ... String orderId = UUID.randomUUID().toString(); return orderId; } } // 客户端代码 public class Main { public static void main(String[] args) { OrderProcessingFacade orderProcessingFacade = new OrderProcessingFacade(); // 处理订单 orderProcessingFacade.processOrder(\\\"12345\\\", 2, 100.0, \\\"Credit Card\\\", \\\"Shipping Address\\\"); } } \",\"运行输出：\",\"更新库存,库存-1 付款成功 开始发货,揽件 \",\"在这个示例中，我们构建了一个在线购物平台的订单处理系统。订单处理涉及多个子系统，包括库存管理、支付服务和物流管理。为了简化订单处理系统的复杂性，我们使用了门面设计模式。\",\"在这个示例中，我们有以下几个类：\",\"InventorySystem：库存管理子系统，负责更新库存。\",\"PaymentService：支付服务子系统，负责处理支付。\",\"LogisticsService：物流管理子系统，负责处理物流。\",\"OrderProcessingFacade：订单处理门面，提供一个简化的接口来处理订单。它内部持有库存管理、支付服务和物流管理子系统的实例，并在processOrder方法中调用它们的相应方法来处理订单。\",\"客户端代码中，我们创建了一个OrderProcessingFacade实例，并使用它来处理订单。通过调用processOrder方法，我们将订单的相关信息传递给门面，然后门面负责协调并调用库存管理、支付服务和物流管理子系统的方法来处理订单。客户端无需直接与子系统交互，而是通过门面来完成订单处理。\",\"通过使用门面设计模式，我们将订单处理系统的复杂性封装起来，客户端只需要与门面进行交互，不需要了解和管理子系统的细节。这样可以提高代码的可维护性和可扩展性，同时降低了客户端与子系统的耦合度。\"]},\"519\":{\"h\":\"6、总结\",\"t\":[\"门面设计模式是一种有用的设计模式，它提供了许多优点和一些潜在的缺点。\",\"优点：\",\"简化客户端与复杂子系统之间的交互，客户端只需与门面对象进行通信，无需了解子系统的内部结构和组件。\",\"将子系统与客户端解耦，子系统的变更不会影响到客户端的代码。\",\"提供了一个清晰的界面和高层次的接口，提高了系统的可维护性和可读性。\",\"缺点：\",\"可能会导致门面对象变得庞大，承担过多的责任，违反单一职责原则。\",\"如果需要对子系统进行更细粒度的控制或定制化操作，可能需要修改门面类，导致修改范围较大。\",\"总体而言，门面设计模式是一种有助于简化复杂系统的交互和提高系统可维护性的设计模式。它在许多应用场景中都有着广泛的应用，尤其是在需要隐藏复杂性并提供统一接口的情况下。然而，在使用该模式时，需要权衡好门面对象的责任和灵活性之间的平衡，以确保设计的合理性和可扩展性。\"]},\"520\":{\"h\":\"7、与适配器设计模式的区别\",\"t\":[\"适配器设计模式：用于将一个类的接口转换为另一个类的接口，以便它们可以协同工作。\",\"门面设计模式：提供一个统一的接口，隐藏了底层子系统的复杂性，使客户端与子系统之间的交互更加简单和直观。\"]},\"521\":{\"h\":\"六、组合设计模式\"},\"522\":{\"h\":\"1、介绍\",\"t\":[\"组合设计模式是一种结构性设计模式，它允许将对象组织成树形结构，以表示“部分-整体”的层次结构。组合模式使得客户端能够以一致的方式处理单个对象以及对象的组合。\"]},\"523\":{\"h\":\"2、核心思想\",\"t\":[\"组合设计模式的核心思想是将对象组织成树形结构，并对叶子节点和组合节点提供一致的操作接口。通过这种方式，客户端可以将单个对象和组合对象一视同仁，无需关心处理的是单个对象还是对象的组合。\"]},\"524\":{\"h\":\"3、组成和基本流程\",\"t\":[\"组合设计模式由以下几个主要角色组成：\",\"Component（组件）: 定义组合中对象的共有接口，可以是接口或抽象类。该接口声明了对于组合对象和叶子对象的通用操作。\",\"Leaf（叶子）: 表示组合中的叶子对象，它没有子节点。实现了Component接口的操作。\",\"Composite（组合）: 表示组合中的组合对象，它拥有子节点。实现了Component接口的操作，并且通常存储子节点。\",\"组合设计模式的基本流程如下：\",\"创建组件接口（Component），声明通用的操作方法。\",\"创建叶子类（Leaf），实现组件接口。叶子类表示组合中的叶子节点。\",\"创建组合类（Composite），实现组件接口。组合类表示组合中的组合节点，并且通常存储子节点。\",\"在组合类中实现对子节点的管理操作，例如添加子节点、删除子节点等。\",\"在客户端中使用组合类来构建组合对象的树形结构，并通过组件接口操作对象。\",\"以下是一个示例代码片段，演示了组合设计模式的基本流程：\",\"// 定义组件接口 interface Component { void operation(); } // 叶子类 class Leaf implements Component { public void operation() { // 实现叶子对象的操作 } } // 组合类 class Composite implements Component { private List<Component> components = new ArrayList<>(); public void addComponent(Component component) { // 添加子节点 components.add(component); } public void removeComponent(Component component) { // 删除子节点 components.remove(component); } public void operation() { // 实现组合对象的操作 // 可以通过循环调用子节点的操作方法来实现对子节点的操作 for (Component component : components) { component.operation(); } } } // 客户端代码 public class Client { public static void main(String[] args) { Component leaf1 = new Leaf(); Component leaf2 = new Leaf(); Composite composite1 = new Composite(); composite1.addComponent(leaf1); composite1.addComponent(leaf2); Component leaf3 = new Leaf(); Composite composite2 = new Composite(); composite2.addComponent(leaf3); composite2.addComponent(composite1); composite2.operation(); } } \",\"在这个示例中，我们有以下几个类：\",\"Component：组件接口，定义了组合模式中的叶子节点和组合节点的共同操作方法。\",\"Leaf：叶子节点，实现了Component接口，并定义了叶子节点的操作方法。\",\"Composite：组合节点，实现了Component接口，并持有一个子组件列表。它提供了添加子组件和移除子组件的方法，并在operation方法中递归调用子组件的操作方法。\",\"在客户端代码中，我们创建了一个叶子节点和一个组合节点，并将叶子节点添加到组合节点中。然后，我们调用组合节点的操作方法，它会递归调用叶子节点的操作方法。\",\"通过使用组合模式，我们可以以统一的方式处理单个对象和组合对象，客户端无需关心当前处理的是叶子节点还是组合节点，从而简化了客户端的代码。组合模式适用于需要处理树状结构的情况，例如文件系统、UI组件、菜单栏等。\"]},\"525\":{\"h\":\"4、案例\",\"t\":[\"例子1：业务场景 - 文件夹\",\"好的，再举一个例子，以文件和文件夹为对象来说明组合设计模式的应用。\",\"在这个例子中，我们使用组合模式来表示文件系统的层次结构。\",\"文件和文件夹都实现了FileSystemComponent接口，表示树状结构中的叶子节点和组合节点。\",\"Folder类表示树状结构中的组合节点，它可以包含文件和其他文件夹。\",\"客户端代码中，我们创建了文件和文件夹对象，并将它们组织起来形成文件系统的层次结构。\",\"最后，我们调用根文件夹的display方法来显示整个文件系统。\",\"interface FileSystemComponent { void display(); } // 文件类，实现组件接口 class File implements FileSystemComponent { private String name; public File(String name) { this.name = name; } @Override public void display() { System.out.println(\\\"文件：\\\" + name); } } // 文件夹类，实现组件接口 class Folder implements FileSystemComponent { private String name; private List<FileSystemComponent> components = new ArrayList<>(); public Folder(String name) { this.name = name; } public void addComponent(FileSystemComponent component) { components.add(component); } public void removeComponent(FileSystemComponent component) { components.remove(component); } public List<FileSystemComponent> getComponents() { return components; } @Override public void display() { System.out.println(\\\"文件夹：\\\" + name); } } // 客户端代码 public class Main { public static void main(String[] args) { // 创建文件和文件夹对象 FileSystemComponent song1 = new File(\\\"redflavor.mp3\\\"); FileSystemComponent song2 = new File(\\\"psycho.mp3\\\"); FileSystemComponent song3 = new File(\\\"birthday.mp3\\\"); Folder lyricsFolder = new Folder(\\\"歌词\\\"); FileSystemComponent lyric1 = new File(\\\"redflavor.txt\\\"); FileSystemComponent lyric2 = new File(\\\"psycho.txt\\\"); FileSystemComponent lyric3 = new File(\\\"birthday.txt\\\"); Folder musicFolder = new Folder(\\\"音乐\\\"); musicFolder.addComponent(song1); musicFolder.addComponent(song2); musicFolder.addComponent(song3); lyricsFolder.addComponent(lyric1); lyricsFolder.addComponent(lyric2); lyricsFolder.addComponent(lyric3); musicFolder.addComponent(lyricsFolder); FileSystemComponent movie1 = new File(\\\"疾速追杀.mp4\\\"); FileSystemComponent movie2 = new File(\\\"疾速备战.mp4\\\"); Folder movieFolder = new Folder(\\\"电影\\\"); movieFolder.addComponent(movie1); movieFolder.addComponent(movie2); Folder rootFolder = new Folder(\\\"D\\\"); rootFolder.addComponent(musicFolder); rootFolder.addComponent(movieFolder); // 遍历文件系统 rootFolder.display(); traverseFileSystem(rootFolder); } public static void traverseFileSystem(FileSystemComponent component) { if (component instanceof Folder) { for (FileSystemComponent subComponent : ((Folder) component).getComponents()) { subComponent.display(); traverseFileSystem(subComponent); } } } } \",\"在上述示例中：\",\"我们创建了文件和文件夹对象，并按照要求构建了文件夹的层次结构。\",\"音乐文件夹包含三首歌和一个歌词文件夹 \",\"歌词文件夹中包含三个歌词文件。\",\"电影文件夹中包含两部电影。\",\"所有这些文件和文件夹都被组织在根文件夹 D 中。\",\"以下是使用Markdown格式绘制上述文件夹和文件的树形结构：\",\"- D (文件夹) - 音乐 (文件夹) - reflavor.mp3 (文件) - psycho.mp3 (文件) - birthday.mp3 (文件) - 歌词 (文件夹) - reflavor.txt (文件) - psycho.txt (文件) - birthday.txt (文件) - 电影 (文件夹) - 疾速追杀.mp4 (文件) - 疾速备战.mp4 (文件) \",\"这个树形结构表示了根文件夹 \\\"D\\\" 下的音乐文件夹和电影文件夹，以及它们的子文件和子文件夹。其中，音乐文件夹下包含了三个音乐文件和一个歌词文件夹，歌词文件夹中包含了三个歌词文件。电影文件夹中包含了两部电影文件。\",\"请注意，上述树形结构只是一种可视化的表示方式，并非真正的文件系统结构。它提供了一个直观的展示方式，以更清晰地理解文件夹和文件之间的层次关系。\",\"在 traverseFileSystem 方法中，我们使用递归方式遍历文件系统的层次结构，并调用每个文件和文件夹的 display 方法进行展示。\",\"通过运行该代码，您将会看到文件夹结构被递归地打印出来，包括每个文件和文件夹的名称。\",\"文件夹：D 文件夹：音乐 文件：redflavor.mp3 文件：psycho.mp3 文件：birthday.mp3 文件夹：歌词 文件：redflavor.txt 文件：psycho.txt 文件：birthday.txt 文件夹：电影 文件：疾速追杀.mp4 文件：疾速备战.mp4 \",\"通过使用组合模式，我们可以方便地管理和操作复杂的文件系统结构。组合模式统一了叶子节点和组合节点的处理方式，客户端无需关心当前处理的是文件还是文件夹，可以以相同的方式对待它们。这种设计模式简化了代码，并提供了一种灵活的方式来处理树状结构。\",\"例子2：业务场景 - 组织架构管理\",\"假设我们有一个组织架构管理系统，用于管理公司的组织结构。组织结构包括部门和员工，每个部门可以包含其他部门或员工，形成一个树状结构。在这种情况下，可以使用组合设计模式来表示组织架构。\",\"// 组件接口 interface Component { void display(); } // 部门类，实现组件接口 class Department implements Component { private String name; public Department(String name) { this.name = name; } public void display() { System.out.println(\\\"部门：\\\" + name); } } // 员工类，实现组件接口 class Employee implements Component { private String name; public Employee(String name) { this.name = name; } public void display() { System.out.println(\\\"员工：\\\" + name); } } // 组合类，包含子组件 class Composite implements Component { private List<Component> components = new ArrayList<>(); public void add(Component component) { components.add(component); } public void remove(Component component) { components.remove(component); } public void display() { for (Component component : components) { component.display(); } } } // 客户端代码 public class Main { public static void main(String[] args) { // 创建部门和员工对象 Component hrDepartment = new Department(\\\"人力资源部\\\"); Component financeDepartment = new Department(\\\"财务部\\\"); Component employee1 = new Employee(\\\"张三\\\"); Component employee2 = new Employee(\\\"李四\\\"); // 创建组合对象 Composite organization = new Composite(); organization.add(hrDepartment); organization.add(financeDepartment); organization.add(employee1); organization.add(employee2); // 显示组织架构 organization.display(); } } \",\"在这个例子中，我们使用组合模式来管理组织架构。部门和员工都实现了Component接口，表示树状结构中的叶子节点。Composite类表示树状结构中的组合节点，它可以包含部门和员工。客户端代码中，我们创建了部门、员工和组合对象，并将它们组织起来形成组织架构。最后，我们调用组合对象的display方法来显示组织架构。\"]},\"526\":{\"h\":\"5、总结\",\"t\":[\"组合模式是一种结构型设计模式，旨在以树状结构组织对象，使得单个对象和组合对象能够以一致的方式进行处理。该模式允许我们将对象组合成树状结构，从而形成层次关系，并且可以递归地处理整个层次结构。\",\"通过使用组合模式，我们可以将单个对象和组合对象都视为相同的抽象组件，从而使得客户端代码无需区分处理单个对象还是组合对象，而是统一使用组件接口进行操作。\",\"以下是组合模式的一些关键点和总结：\",\"角色：\",\"组件（Component）：定义组合对象和叶子对象的共同接口。它可以是接口或抽象类，提供了默认的行为和管理子组件的方法。\",\"叶子对象（Leaf）：表示组合中的叶子节点，它没有子组件。\",\"组合对象（Composite）：表示组合中的容器节点，它可以包含子组件。它实现了组件接口，并提供了添加、删除和获取子组件的方法。\",\"优点：\",\"简化客户端代码：客户端无需区分处理单个对象和组合对象，可以统一通过组件接口进行操作，从而简化了客户端代码。\",\"易于扩展：可以通过添加新的叶子对象或组合对象来扩展层次结构，而无需修改现有代码。\",\"递归处理：可以递归地处理整个层次结构，无论是遍历、搜索还是执行操作，都能够方便地应用于整个组合对象。\",\"注意事项：\",\"组件接口的设计：组件接口应该定义一组合适的方法，以满足组合和叶子对象的需要，并提供默认实现（如果有的话）。\",\"叶子对象的限制：叶子对象不能有子组件，它们应该是组合结构的最小单位。\",\"递归遍历：递归遍历组合结构时，需要适当处理组件和叶子对象的差异，以避免出现不必要的操作或错误。\",\"组合模式在许多场景中都有应用，特别是当需要处理树状结构的对象时，它能够提供一种灵活且统一的方式来处理对象的层次关系。\",\"总的来说，组合模式通过统一处理单个对象和组合对象，提供了一种方便的方式来管理和操作树状结构的对象。它帮助我们简化了客户端代码，同时也提供了一种灵活的方式来扩展和处理组合对象的层次结构。\",\"希望这个总结对您有帮助！如果您还有其他问题，请随时提问。\"]},\"527\":{\"h\":\"七、享元设计模式\"},\"528\":{\"h\":\"1、介绍\",\"t\":[\"享元设计模式（Flyweight Pattern）是一种结构性设计模式，它通过共享对象来有效地支持大量细粒度的对象。享元模式旨在减少内存使用和提高性能，特别适用于需要创建大量相似对象的情况。\"]},\"529\":{\"h\":\"2、核心思想\",\"t\":[\"享元设计模式的核心思想是共享对象。它通过将对象的共享部分提取出来，并将不同对象之间的变化部分外部化，以实现对相似对象的共享和复用。这样可以减少对象的创建和内存占用，并提高系统的性能。\"]},\"530\":{\"h\":\"3、组成和基本流程\",\"t\":[\"享元设计模式由以下组成部分构成：\",\"享元工厂（Flyweight Factory）：负责创建和管理享元对象，维护一个享元池用于存储和管理共享对象。\",\"享元对象（Flyweight）：表示需要被共享的对象，包含内部状态和外部状态两部分。内部状态可被共享，而外部状态则由客户端提供。\",\"享元设计模式的基本流程如下：\",\"创建享元工厂，用于创建和管理享元对象。\",\"定义享元对象接口，包含对内部状态和外部状态的操作方法。\",\"客户端通过享元工厂获取或创建享元对象。\",\"客户端设置享元对象的外部状态。\",\"客户端使用享元对象进行操作，享元对象根据内部状态和外部状态的组合来执行具体操作。\"]},\"531\":{\"h\":\"4、使用场景\",\"t\":[\"享元设计模式适用于以下场景：\",\"当系统需要大量相似对象，并且创建和管理这些对象会消耗大量资源时。\",\"当对象的大部分状态可以外部化，并且可以在不同对象之间共享时。\",\"当需要缓存和复用对象以提高系统性能时。\"]},\"532\":{\"h\":\"6、具体案例（仅标题）\",\"t\":[\"游戏中的棋子对象\",\"文字编辑器中的字符对象（字体、样式）\",\"考试系统里面的试卷、学生\"]},\"533\":{\"h\":\"7、总结\",\"t\":[\"享元设计模式通过共享对象来减少内存使用和提高性能。它适用于需要大量相似对象的情况，并将对象的共享部分提取出来以实现复用。使用享元设计模式可以有效地减少系统资源的消耗，提高系统的性能和可扩展性。\",\"优点：\",\"减少内存使用：通过共享对象的方式减少相似对象的创建，降低了内存占用。\",\"提高性能：共享对象减少了对象的创建和销毁过程，提高了系统的性能。\",\"支持大量对象：可以有效地支持大量细粒度的对象，提供了更好的扩展性。\",\"缺点：\",\"共享外部状态：外部状态的共享需要注意线程安全性和正确性。\",\"复杂性增加：享元模式会引入共享对象的管理逻辑，增加了代码的复杂性。\",\"总体而言，享元设计模式在需要创建大量相似对象并且关注内存和性能优化的情况下非常有用。它提供了一种有效地共享和复用对象的机制，以提高系统的效率和可扩展性。然而，在使用该模式时需要注意外部状态的处理和线程安全性，以确保系统的正确性和可靠性。\"]},\"534\":{\"c\":[\"计算机基础\"]},\"535\":{\"c\":[\"设计模式\"]},\"536\":{\"h\":\"Android前置知识\",\"t\":[\" Android学习前应该具备的前置知识 \",\" 包括软件的安装、环境的配置、第一个应用、调试方法等 \"]},\"537\":{\"h\":\"1、发展历程\",\"t\":[\"介绍：\",\"Android之父：Andy Rubin\",\"Android起源：基于Linux内核\",\"所属公司：Google\",\"第一部安卓手机：HTC\",\"所属设备：手机、平板、车载等\",\"Android开发语言：JVM语言（Java、Kotlin）\"]},\"538\":{\"h\":\"2、配置环境\",\"t\":[\"安装Android Studio：\",\"记得勾选Android Virtual Device，然后一直next即可\",\"默认安装C盘，如果需要安卓其他盘，请自行更改目录\",\"配置Android Studio：\",\"首次打开，选择自定义安装Customer Installer，可以自定义安装目录\",\"其他点Next即可，碰到License Agreement，需要手动点击每个license，手动选择Accept\",\"然后一直Next，等待下载完成\",\"创建第一个项目：\",\"New Project —> Phone and Tablet —> Empty Activity（默认kotlin） / Empty Views Activity（默认kotlin，可以修改为Java）\",\"根据需要自行修改：\",\"项目名、包名、保存位置、SDK版本（API版本-安卓系统版本）、编译配置\",\"创建项目-Empty Activity\",\"创建项目-Empty Views Activity\",\"创建安卓虚拟机：\",\"右侧Device Manager创建虚拟机，选择机器和版本，创建完成点击运行即可\",\"创建安卓虚拟机\",\"启动过程中，出现下列问题：\",\"显示Sync Connect Time Out\",\"项目目录结构没有图标显示，且代码文件也没有显示\",\"💬 gradle的问题：需要下载对应的gradle，然后点击Try Again：\",\"打开项目的gradle目录：gradle-wrapper.properties\",\"查看distributionUrl的gradle版本： \",\"例如-distributionUrl=https\\\\://services.gradle.org/distributions/gradle-8.2-bin.zip\",\"去下载gradle-8.2-bin.zip ，然后将文件移动至：\",\"C:\\\\Users\\\\96946\\\\.gradle\\\\wrapper\\\\dists\\\\gradle-8.2-bin\\\\bbg7u40eoinfdyxsxr3z4i7ta\\\\\",\"下载地址：https://services.gradle.org/distributions/\",\"更新完后，点击运行的按钮运行，显示Hello World：\",\"程序成功启动在创建的安卓虚拟机上\",\"目录结构有颜色了，代码有提示了\",\"调试日志成功打印了\",\"依赖下载成功、运行成功\",\"真机调试：PC与Android OS通过Android Debug Bridge进行通信\",\"打开手机：开发者选项 —> USB调试\",\"插上数据线连接手机和电脑：选择传输类型 - 传输文件/Android Auto\",\"根据提示，点击确定允许USB调试\",\"Android Auto选择真机，点击运行，手机安卓发布的app，即可\",\"真机调试\",\"真机应用内容显示\"]},\"539\":{\"h\":\"3、项目结构\",\"t\":[\"app目录：\",\"java目录：存放Java源代码\",\"res目录：存放静态资源（常量定义文件、应用名、布局、图标、主题）\",\"manifests子目录：存放XML-清单文件，AndroidManifest.xml，是App的运行配置文件\",\"Gradle目录：\",\"proguard-rues.pro：该文件用于描述Java代码的混淆规则，防止源代码被反编译篡改泄漏\",\"build.gradle：该文件分为项目级与模块级两种，用于描述App工程的编译规则，引用了哪些插件、依赖，打包时，去哪个仓库下载对应的依赖。\",\"settings.gradle：该文件配置了需要编译哪些模块。初始内容为include':app' ，表示只编译app模块，\",\"gradle.properties：该文件用于配置编译工程的命令行参数，一般无须改动。\",\"local.properties：项目的本地配置文件，它在工程编译时自动生成，用于描述开发者电脑的环境配置，包括SDK的本地路径、NDK的本地路径等。\",\"build.gradle配置文件注释：\",\"// 应用插件声明，指定项目类型为 Android 应用 plugins { id 'com.android.application' } // Android 配置块，用于配置 Android 项目的构建和属性 android { // 定义项目的命名空间 namespace 'com.example.myapplication' // 指定编译的 Android SDK 版本 compileSdk 34 // 默认配置块，包含应用程序的基本设置 defaultConfig { // 应用程序的唯一标识符 applicationId \\\"com.example.myapplication\\\" // 最小支持的 Android 版本 minSdk 33 // 目标 Android 版本 targetSdk 34 // 应用程序的版本代码，用于区分不同的应用程序版本 versionCode 1 // 应用程序的版本名称，显示在应用商店等地方 versionName \\\"1.0\\\" // 指定测试运行器 testInstrumentationRunner \\\"androidx.test.runner.AndroidJUnitRunner\\\" } // 构建类型配置块，定义不同构建类型的设置 buildTypes { release { // 是否启用代码缩小（minification） minifyEnabled false // 指定 Proguard 配置文件，用于代码混淆和优化 proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } // 编译选项配置块，指定源代码和目标代码的兼容性 compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } // 依赖声明块，指定项目所需的外部库和依赖关系 dependencies { // AndroidX AppCompat 库，提供向后兼容性支持 implementation 'androidx.appcompat:appcompat:1.6.1' // Material Design 库，提供现代的 UI 设计元素 implementation 'com.google.android.material:material:1.9.0' // ConstraintLayout 库，用于灵活而复杂的布局 implementation 'androidx.constraintlayout:constraintlayout:2.1.4' // 单元测试 JUnit 库，用于编写和运行单元测试 testImplementation 'junit:junit:4.13.2' // Android 测试扩展库，提供额外的测试功能 androidTestImplementation 'androidx.test.ext:junit:1.1.5' // Espresso UI 测试库，用于编写可读性强的 UI 测试 androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1' } \",\"AndroidManifest.xml清单文件注释：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <!-- Android 清单文件，定义应用程序的基本信息和配置 --> <manifest xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" xmlns:tools=\\\"http://schemas.android.com/tools\\\"> <!-- 应用程序的主体部分 --> <application <!-- 允许备份应用数据 --> android:allowBackup=\\\"true\\\" <!-- 指定数据提取规则 --> android:dataExtractionRules=\\\"@xml/data_extraction_rules\\\" <!-- 指定全备份规则 --> android:fullBackupContent=\\\"@xml/backup_rules\\\" <!-- 应用程序的图标 --> android:icon=\\\"@mipmap/ic_launcher\\\" <!-- 应用程序的名称 --> android:label=\\\"@string/app_name\\\" <!-- 圆形图标 --> android:roundIcon=\\\"@mipmap/ic_launcher_round\\\" <!-- 支持 RTL（Right To Left）文字排列顺序布局 --> android:supportsRtl=\\\"true\\\" <!-- 应用程序的主题 --> android:theme=\\\"@style/Theme.MyApplication\\\" <!-- 工具属性，指定目标 API 版本为 31 --> tools:targetApi=\\\"31\\\"> <!-- Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互完成任务--> <activity <!-- 活动的类名 --> android:name=\\\".MainActivity\\\" <!-- 是否允许其他应用启动该活动 --> android:exported=\\\"true\\\"> <!-- 活动的意图过滤器 --> <intent-filter> <!-- 指定活动为主要入口点 --> <action android:name=\\\"android.intent.action.MAIN\\\" /> <!-- 指定活动为启动器 --> <category android:name=\\\"android.intent.category.LAUNCHER\\\" /> </intent-filter> </activity> </application> </manifest> \"]},\"540\":{\"h\":\"4、界面显示和逻辑处理\",\"t\":[\"Android使用：XML描绘应用界面，Java代码书写程序逻辑\",\"XML类似于HTML，Java类型与JS\",\"好处：把App的界面设计与代码逻辑分开，进行解耦\",\"使用XML文件描述APP界面，可以很方便地在Android Studio上预览界面效果。\",\"一个界面布局可以被多处代码复用，反过来，一个Java代码也可能适配多个界面布局。\",\"默认：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" xmlns:app=\\\"http://schemas.android.com/apk/res-auto\\\" xmlns:tools=\\\"http://schemas.android.com/tools\\\" android:layout_width=\\\"match_parent\\\" android:layout_height=\\\"match_parent\\\" tools:context=\\\".MainActivity\\\"> <TextView android:layout_width=\\\"wrap_content\\\" android:layout_height=\\\"wrap_content\\\" android:text=\\\"Hello World!\\\" app:layout_constraintBottom_toBottomOf=\\\"parent\\\" app:layout_constraintEnd_toEndOf=\\\"parent\\\" app:layout_constraintStart_toStartOf=\\\"parent\\\" app:layout_constraintTop_toTopOf=\\\"parent\\\" /> </androidx.constraintlayout.widget.ConstraintLayout> \"]},\"541\":{\"c\":[\"Android开发\"]},\"542\":{\"c\":[\"android\"]},\"543\":{\"h\":\"关系型数据库mysql\",\"t\":[\"Github | CSDN\",\"图床图片：\"]},\"544\":{\"h\":\"非关系型数据库 - 键值数据库 - redis\",\"t\":[\"Github | CSDN\",\"图床图片：\"]},\"545\":{\"h\":\"首页\",\"t\":[\"Github | CSDN\",\"图床图片：\"]},\"546\":{\"h\":\"计算机网络应用层-面试题\"},\"547\":{\"h\":\"1、应用层的主要功能是什么？可以列举一些常见的应用层协议\"},\"548\":{\"h\":\"2、什么是HTTP，HTTP的报文格式\"},\"549\":{\"h\":\"3、什么是HTTPS，为什么要使用它\"},\"550\":{\"h\":\"4、它的工作流程是怎么样的\"},\"551\":{\"h\":\"5、客户端怎么去校验证书的合法性\"},\"552\":{\"h\":\"6、HTTP和HTTPS的区别是什么\"},\"553\":{\"h\":\"7、HTTP 有哪些请求方式\"},\"554\":{\"h\":\"8、什么是RESTful API？它的特点是什么？可以举例说明一个符合RESTful设计风格的API吗？\"},\"555\":{\"h\":\"9、GET 请求和 POST 请求的区别是什么\"},\"556\":{\"h\":\"10、GET 的长度限制是多少\"},\"557\":{\"h\":\"11、HTTP 请求的过程与原理\"},\"558\":{\"h\":\"12、URI和URL的区别是什么\"},\"559\":{\"h\":\"13、常用的HTTP 状态码有哪些，介绍一下\"},\"560\":{\"h\":\"14、HTTP 协议是无状态的，你是怎么理解的\"},\"561\":{\"h\":\"15、Session 和 Cookie 有什么联系和区别\"},\"562\":{\"h\":\"16、HTTP/1.0，1.1，2.0 的区别有哪些\"},\"563\":{\"h\":\"17、什么是HTTP/3\"},\"564\":{\"h\":\"18、HTTP 如何实现长连接？在什么时候会超时\"},\"565\":{\"h\":\"19、什么是WebSocket？它相对于HTTP有哪些优势？\"},\"566\":{\"h\":\"20、说说 WebSocket 与 Socket 的区别？\"},\"567\":{\"h\":\"21、什么是DNS？它的作用是什么？\"},\"568\":{\"h\":\"22、SMTP和POP3是什么协议？它们分别用于什么？\"},\"569\":{\"h\":\"23、什么是FTP？它是用来做什么的？\"},\"570\":{\"h\":\"24、应用层常用端口有哪些\"},\"571\":{\"c\":[\"面经收藏\"]},\"572\":{\"h\":\"计算机网络数据链路层-面试题\"},\"573\":{\"h\":\"1、数据链路层的主要功能是什么？\",\"t\":[\"数据链路层的主要功能是什么？\",\"是什么：\",\"数据链路层是OSI模型中的第二层，它位于物理层之上，网络层之下。\",\"数据链路层是实现这些规程或协议的硬件和软件加上物理线路。\",\"主要功能：\",\"它的主要功能也是由它的位置衍生而来：\",\"对于下层的物理层，因为物理层解决了在不同物理机之间传输比特流的问题，而且物理层是真正的实体的物理线路，但是这里就有问题：①这里就会出现不同传输介质、设备和协议的差异 ②不同物理机之间当然可以传输比特流，插个线就行，但是如果线多了呢？不知道目的地，是个瞎子 \",\"所以就抽离出了一条用于数据传输的逻辑通道，屏蔽下层不同设备、介质和协议的差异，在此层制定统一协议，让设备完成，从而让上层感知不到下层差异，这就和我们的接口和子类的关系，接口指定规范，子类有不同的实现，但是使用时会进行动态的选择，是多态的体现。\",\"在数据传输过程中，上层的数据被封装成数据链路层的帧，添加必要的控制信息（如地址、校验和等），使得数据可以在物理介质上传输。\",\"数据链路层使用物理地址（比如MAC地址）来标识网络设备，确保数据帧被正确发送到目标设备，而不是广播到整个网络。\",\"对于上层的网络层而言，数据链路层将来自网络层的数据包封装成数据帧，在发送端添加帧头和帧尾等控制信息，以便在物理介质上传输。在接收端，它负责解封装数据帧，提取数据包，然后传递给网络层。\",\"对于不同设备间的数据链路层而言，数据链路层通过流量控制机制，确保发送方和接收方之间的数据传输速率匹配，防止过载或丢失数据的情况发生，其次通过校验和、CRC（循环冗余校验）等技术来检测和纠正在传输过程中产生的错误，保证数据的完整性。\"]},\"574\":{\"h\":\"2、什么是MAC地址？它与IP地址有何区别？\",\"t\":[\"什么是MAC地址？它与IP地址有何区别？\",\"MAC地址（Media Access Control Address）是数据链路层（OSI模型中的第二层）中使用的硬件地址，用于唯一标识网络设备（如网卡、路由器、交换机等）在局域网中的身份。它是由厂商预先分配给网络设备的，通常由48位二进制数（通常表示为十六进制）组成，被编码在网络接口卡上。\",\"MAC地址是一个全球唯一的标识符，用于识别网络设备。它通常以6个十六进制数对的形式表示，例如：00:1A:2B:3C:4D:5E。\",\"而IP地址（Internet Protocol Address）是网络层（OSI模型中的第三层）中使用的逻辑地址，用于标识网络上的设备或主机。IP地址是在网络通信中用来识别和定位设备的数字标签。IP地址通常分为IPv4和IPv6两种格式。IPv4地址是一个32位二进制数，通常以点分十进制的形式表示，例如：192.168.0.1。而IPv6地址则采用128位地址，通常表示为一系列的十六进制数字和字母。\",\"主要区别在于：MAC地址用于局域网内部设备之间的通信，而IP地址则用于在全球范围内定位和连接设备。\",\"因为我们的网络比较大，不再是拘于物理层和数据链路层的局域网了，而是更大的广域网、互联网。而在这个更大的网络中，如果我们要是信息送达给对方，单靠数据链路层的mac地址寻址是不够的，因为：\",\"数据是在不同设备间进行传输的，一直经历帧的封装的解封，这个过程中，帧的mac地址是不断变化的，例如A –> D，要经过B、C两个路由器，那么最后达到D的数据中的mac地址就是C的mac地址，所以说当源端和目的端位于不同网络的时候，直接通信是不可行的（找不到对方），此时就需要由网络层解决。\",\"所以我们需要一个不变的地址，那就是本层网络层的IP地址。\"]},\"575\":{\"h\":\"3、数据帧的结构是怎样的？\",\"t\":[\"数据帧的结构是怎样的？\",\"数据帧是在数据链路层中用于封装和传输数据的基本单位。不同的数据链路层协议有不同的帧结构，其中一些常见的数据帧包括：\",\"以太网数据帧：\",\"前导码（Preamble）： 7字节的前导码，用于同步时钟和准备接收帧。\",\"帧起始标志（Start Frame Delimiter）： 1字节，标志帧的开始。\",\"目标 MAC 地址（Destination MAC Address）： 6字节，指示接收方的MAC地址。\",\"源 MAC 地址（Source MAC Address）： 6字节，表示发送方的MAC地址。\",\"类型/长度字段（Type/Length Field）： 2字节，指示数据的类型或长度。\",\"数据部分（Data）： 46-1500字节，实际要传输的数据。\",\"帧校验序列（Frame Check Sequence，FCS）： 4字节，使用CRC校验算法计算的校验值，用于检测数据传输过程中是否发生错误。\",\"PPP 帧：点对点连接的协议\",\"帧起始标志（Flag）： 1字节，标志帧的开始。\",\"地址字段（Address）： 1字节，通常为0xFF。\",\"控制字段（Control）： 1字节，指定控制信息。\",\"协议字段（Protocol）： 2字节，表示数据的类型。\",\"数据部分（Data）： 实际传输的数据。\",\"帧校验序列（Frame Check Sequence，FCS）： 4字节，校验数据帧是否有误。\",\"802.1Q VLAN 帧：在局域网中实现虚拟局域网（VLAN），其结构在以太网帧的基础上增加了VLAN标签\",\"VLAN标签： 4字节，包括标签协议标识、优先级、C标志、S标志、VLAN ID等字段。\",\"其余部分保持以太网帧的结构，包括目标MAC地址、源MAC地址、类型/长度字段、数据和FCS。\"]},\"576\":{\"h\":\"4、流控制和差错控制是什么？你能列举一些常见的流控制和差错控制协议吗？\",\"t\":[\"流量控制和差错控制是什么？你能列举一些常见的流控制和差错控制协议吗？\",\"流量控制并不是数据链路层所特有的功能，许多高层协议中也提供流量控功能，只不过流量控制的对象不同而已。\",\"流量控制是什么？\",\"对发送端数据传输速率的控制，使其数据发送速率不超过接收端所能承受的数据接收能力。\",\"流量控制考虑什么方面？\",\"发送端的数据发送速度与接收端的数据接收速度要匹配，否则接收端来不及接收就会造成数据在传输过程中的丢失。\",\"发送端的数据发送速度要与线路上的承载速率（与线路信道带宽有关）相匹配，否则也会造成数据在传输过程中的丢失。\",\"流量控制常见实现？\",\"（Ⅰ）基于反馈的流量控制方案\",\"差错控制中的“自动重发请求”，停止-等待协议/自动请求重传，就是基于反馈的流量控制。\",\"XON/XOFF（继续/停止）：\",\"接收端认为不能继续接收数据时（也就是接收端的缓存空间满了或者接近满时），接收端会向发送端发送一个XOFF控制字符\",\"当发送端收到对应的XOFF控制字符时就停止数据的继续发送；\",\"当接收端可以继续接收数据时，接收端会再向发送端发送一个XON控制字符\",\"发送端收到这个控制字符后就知道可以恢复数据发送了，继续发送数据，一直这么循环下去。\",\"（Ⅱ）基于速率的流量控制方案\",\"基于窗口滑动机制的速率控制方，差错控制中的回退N帧协议和选择重传协议就是基于速率的流量控制\",\"收发双方维持收发窗口N：\",\"假设发送端缓存空间大小为3个帧，那么发送端连着发了3个帧后，缓存空间满了，就要停止，等待接收端的确认，当发送端收到接收端对前两个帧的确认后，发送端将前两个帧从缓存空间中删去，再发送两个帧，此时缓存空间又满了，又要等待确认.....如此循环下去。\",\"差错控制是什么？\",\"因为帧在传输过程中可能出现错误，而差错控制是一种机制，用于检测和纠正数据传输中可能产生的错误（损坏或丢失），以确保数据的完整性和正确性。\",\"差错控制常见实现？\",\"循环冗余校验（CRC，Cyclic Redundancy Check）： 根据帧内的FCS来进行校验的，用于检测数据传输过程中的错误。接收方使用CRC校验算法验证接收到的数据是否存在损坏,。\",\"收发双方：约定好一个生成多项式G(x)= 用来作为除数的二进制比特串（或多项式）\",\"发送方： \",\"基于待发送的数据（原始帧）和生成多项式(上面选定的除)*进行计算(**二进制除法运算**)得到差错检测码*【冗余码FCS】\",\"将其添加到待传输数据的后面一起传输\",\"接收方：通过生成多项式(上面选定的除) 和【冗余码FCS】来计算收到的数据是否产生了误码\",\"假设比特串为n位，那么在原始帧后面加上n-1个0，并用二进制除法除以该比特串，最后的余数就是FCS校验码，将FCS校验码放在原始帧最后，接收端拿到数据后，用二进制除法除以比特串，若余数为0，则没有差错，反之有差错。\",\"奇偶校验（Parity Check）：\",\"实现：\",\"发送端：在待发送的传输的二进制代码最后专门设置1个奇偶校验位，用它控制这组代码中1的个数为奇数或偶数（具体是偶数还是奇数，要视所采用的是偶校验还是奇校验）\",\"接收端：看里面的“1”的个数是否仍与原来一样的奇数或偶数，来确定数据传输的正确性。\",\"问题：\",\"如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码；如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码(漏检)\",\"所以奇偶校验方法只可以用来检查单个码元错误，检错能力较差，所以一般只用于本身误码率较低的环境\"]},\"577\":{\"h\":\"5、数据链路层中的封装、透明传输和可靠传输是什么？\",\"t\":[\"数据链路层中的封装、透明传输和可靠传输是什么？\",\"封装：\",\"封装是指将来自更高层的数据添加到数据链路层的帧中的过程。在数据传输过程中，上层的数据被封装成数据链路层的帧，添加必要的控制信息（如地址、校验和等），使得数据可以在物理介质上传输。每个数据链路层协议都有其特定的帧格式和封装规则，以确保在网络中正确传输数据。\",\"透明传输：\",\"透明传输指的是数据链路层对于传输的数据是透明的，不会对数据内容进行修改或解释，你给我一块我就传一块，但是实现这就要保证：\",\"我的理解就是数据链路层要对上层数据是透明的，它就要识别上层数据，不能误读，因为在帧的有效数据当中，可能出现和帧定界的控制字符一样的字符，为了防止将这些字符当中帧定界的字符，错误的处理帧，所以我们采方法使得数据当中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符\",\"在数据链路层传输数据时，它应该是透明的，无论传输的是文本、图像、音频还是其他类型的数据，数据链路层都不对其内容进行解释或处理。这种透明性确保了在传输过程中不会损坏或改变数据的含义。\",\"可靠传输：\",\"可靠传输指的是数据链路层确保数据在传输过程中能够可靠地到达目的地的能力。数据链路层实现可靠传输的方式包括错误检测和纠正、流控制、重传机制等。它能够检测并纠正可能出现的传输错误，并且确保数据按顺序到达目的地，以保证传输的完整性和正确性。\"]},\"578\":{\"h\":\"6、以太网协议是怎样运作的？\",\"t\":[\"以太网协议是怎样运作的？\",\"以太网/以太网协议是一种计算机局域网技术。执行IEEE 802.3技术标准，它规定了物理层的连线、电子信号和介质访问层协议。它采用CSMA/CD（带冲突检测的载波侦听多路访问）来实现多个设备在同一信道上进行数据传输。其工作流程包括四个步骤：\",\"先听后发： 发送设备在发送数据前先侦听信道，若空闲则发送数据，否则等待。\",\"边听边发： 发送设备在发送数据的同时持续侦听信道，若有冲突则停止发送。\",\"冲突停止： 发送设备若检测到信道上有冲突，则立即停止发送并发送干扰信号通知其他设备。\",\"延迟重发： 发送设备在停止发送后，等待一段随机时间后再次尝试发送数据，直至成功或达到最大重试次数。\",\"以太网协议简单、灵活、高效，但在信道负载较高时容易发生冲突，影响传输效率。其发展历史分为经典以太网和交换式以太网两个阶段。交换式以太网通过交换机等设备提高了信道利用率和传输速率，已成为主流的以太网技术。\"]},\"579\":{\"h\":\"7、什么是虚拟局域网（VLAN）？它的作用是什么？\",\"t\":[\"什么是虚拟局域网（VLAN）？它的作用是什么？\",\"什么是VLAN：\",\"VLAN是通过软件的方式实现的，把局域网进行流量隔离，将一个局域网划分成多个虚拟的、逻辑上独立的子网络，即使这些子网络可能跨越不同的物理位置、交换机或路由器，因为传统的网络设置中，它们都连接到同一个物理的网络交换机上，共享相同的网络资源和广播域。\",\"广播流量会跨越整个机构网络（ARP、RIP、DHCP协议）一个单位的不同部门共享一个局域网，对安全不利，所以引入了VLAN。\",\"想象一栋大楼里的不同办公室和部门组成了一个大的局域网。现在，通过VLAN技术，可以将这个大的局域网划分成多个虚拟的、逻辑上独立的子网，就像是这栋大楼中的各个部门实际上在逻辑上组成了各自独立的小区域。\",\"比方说，这栋大楼有财务部门、市场部门和技术部门。在传统的网络设置中，它们都连接到同一个物理的网络交换机上，共享相同的网络资源和广播域。但通过VLAN，可以将它们划分为三个不同的虚拟网络（VLAN）：\",\"财务部门VLAN： 财务部门的计算机、打印机和其他设备连接到同一个VLAN中，这个VLAN只允许财务部门内部的设备相互通信，对其他VLAN的设备不可见。\",\"市场部门VLAN： 同样地，市场部门的设备被划分到一个独立的VLAN中，让市场部门内部的设备可以相互通信，与其他VLAN隔离开来。\",\"技术部门VLAN： 技术部门也有自己的VLAN，其中的设备可以相互通信，但与其他VLAN中的设备隔离。\",\"VLAN原理：\",\"基于端口： 交换机中除了转发表，还存在一张VLAN表，记录了各个端口号和它对应的VLAN号\",\"VLAN 可以基于交换机的端口进行划分。每个交换机端口都被指派到一个特定的 VLAN 上。当数据流经某个端口时，交换机知道该数据属于哪个 VLAN，并且只转发到同一 VLAN 的其他端口。\",\"**基于 MAC 地址：**VALN表中记录的是各个MAC地址和它对应的VLAN号\",\"VLAN 也可以根据设备的 MAC 地址进行划分。在交换机的 VLAN 表中，记录了不同 MAC 地址对应的 VLAN 号。这种方法可以让同一 VLAN 下的设备即使连接到不同的端口，也能够彼此通信。\",\"基于 IP 地址： 可以进行跨路由器扩展\",\"VLAN 也能够基于 IP 地址进行扩展。通常在更高层次的网络设备（如路由器）上实现，允许不同的 VLAN 跨越不同的网络设备。这样，即使 VLAN 跨越了路由器等设备，仍然可以实现不同 VLAN 下设备之间的通信。\"]},\"580\":{\"h\":\"8、交换机和集线器有哪些区别？交换机与路由器的区别又是什么？\",\"t\":[\"交换机和集线器有哪些区别？交换机与路由器的区别又是什么？\",\"交换机（Switch）和集线器（Hub）的区别：\",\"工作原理：\",\"集线器（Hub）： 将所有连接到它的设备组成一个广播域，收到的数据包会广播给所有端口，所有设备都能看到并处理这些数据包。\",\"交换机（Switch）： 它有智能的转发能力，能够学习设备的 MAC 地址，并根据目的地 MAC 地址将数据包只转发到目标设备所在的端口，从而减少了网络中不必要的广播和冲突。\",\"数据处理：\",\"集线器： 不具备数据过滤能力，所有数据包都会被广播到所有端口，增加了网络中的冲突和干扰。\",\"交换机： 有存储转发功能，能够在不同端口之间建立直接连接，只将数据包发送到目标设备，减少了网络中的冲突，提高了效率。\",\"性能和速度：\",\"集线器： 在网络中传输速度相对较慢，因为所有设备共享带宽，且无法同时进行数据传输。\",\"交换机： 具有更高的性能，因为它能够在不同端口之间直接连接，实现了数据的并行传输，每个端口之间的数据传输不会相互影响。\",\"交换机（Switch）和路由器（Router）的区别：\",\"作用：\",\"交换机： 主要用于局域网内部的数据交换和转发，通过 MAC 地址实现设备间的通信。\",\"路由器： 用于连接不同网络，并在这些网络间转发数据，根据 IP 地址进行数据包的传输，实现不同网络之间的通信。\",\"工作层次：\",\"交换机： 在数据链路层（第二层）操作，主要处理 MAC 地址。\",\"路由器： 在网络层（第三层）操作，主要处理 IP 地址。\",\"广播域和隔离性：\",\"交换机： 在同一 VLAN 内部广播域是连通的，设备可直接通信；不同 VLAN 间需要路由器才能通信。\",\"路由器： 能够分隔不同的广播域（不同的子网），只有经过它才能在不同的子网之间进行通信。\",\"总体来说，交换机更适用于局域网内部设备的连接和数据交换，而路由器则连接不同的网络，并能控制不同网络之间的数据流向。集线器在现代网络中已经很少使用，因为交换机的性能和功能更优。\"]},\"581\":{\"h\":\"9、在数据链路层中，CSMA/CD是什么？在哪种网络中使用？\",\"t\":[\"在数据链路层中，CSMA/CD是什么？在哪种网络中使用？\",\"CSMA/CD 是“载波监听多点接入/碰撞检测”（Carrier Sense Multiple Access with Collision Detection）的缩写，是一种用于控制多个设备在共享传输介质上进行数据传输的协议。\",\"工作原理：\",\"载波监听（Carrier Sense）： 设备在发送数据之前会监听传输介质（例如，电缆或光纤），以检测是否有其他设备正在发送数据。如果传输介质闲置，设备就可以开始发送数据。\",\"多点接入（Multiple Access）： 多个设备共享同一个传输介质。因此，如果多个设备同时尝试发送数据，可能会发生数据碰撞。\",\"碰撞检测（Collision Detection）： 如果两个设备同时发送数据，它们的信号会在传输介质上发生碰撞。CSMA/CD协议允许设备检测到这种碰撞并立即停止发送，然后执行一种退避算法，以减少冲突再次发生的可能性。\",\"使用场景：\",\"CSMA/CD 主要用于以太网局域网中。在传统的以太网中，所有设备连接到同一个共享传输介质（例如集线器），它们通过CSMA/CD协议来协调数据的发送，避免碰撞并处理任何发生的碰撞情况。然而，现代的以太网通常使用交换机，而不是集线器，因为交换机能够提供更好的性能和碰撞的避免，所以CSMA/CD在现代网络中的使用已经减少。\"]},\"582\":{\"h\":\"10、解释一下半双工与全双工通信的区别\",\"t\":[\"解释一下半双工与全双工通信的区别是什么？\",\"半双工和全双工是两种不同的通信模式，它们的区别在于设备进行通信时能否同时发送和接收数据：\",\"半双工通信：\",\"定义： 在半双工通信中，设备可以在不同时间段内进行发送和接收数据，但不能同时进行发送和接收。\",\"工作原理： 当设备发送数据时，它不能立即接收来自同一通信链路的响应数据。只有当设备停止发送并切换到接收模式时，才能接收来自其他设备的数据。这种通信方式就像单行道交通，一边通行时另一边必须等待。\",\"示例： 对讲机就是典型的半双工设备。当一个人在说话时，其他人必须等待，无法同时说话。\",\"半双工通信只能单向进行数据传输，设备需要在发送和接收之间切换；\",\"全双工通信：\",\"定义： 在全双工通信中，设备能够同时进行发送和接收数据，即设备能够在同一时间内进行双向通信。\",\"工作原理： 设备可以同时发送和接收数据，允许实时的双向通信。这种通信方式就像是双向的双车道，两个方向的车辆可以同时行驶而不会相互干扰。\",\"示例： 典型的全双工设备包括大多数现代网络设备，例如双向无线电通信、以太网交换机和路由器等。在这些设备中，可以同时进行双向通信而不会出现冲突。\",\"而全双工通信允许设备同时进行双向数据传输，提供了更高效的通信能力。\"]},\"583\":{\"h\":\"11、ARP协议是用来做什么的？它的作用是什么？\",\"t\":[\"ARP协议是用来做什么的？它的作用是什么？\",\"ARP（地址解析协议）是一个位于网络层和数据链路层之间的协议，是用于解析IP地址与MAC地址之间对应关系的协议。它的主要作用是在局域网中根据已知的IP地址查找对应的MAC地址。\",\"作用：\",\"IP地址到MAC地址的映射： ARP协议用于在局域网中确定一个IP地址对应的MAC地址。当一台设备需要发送数据到另一台设备时，它需要知道目标设备的MAC地址才能将数据帧发送到正确的位置。\",\"动态获取MAC地址： ARP协议允许设备在需要通信时动态地获取目标设备的MAC地址。当设备知道目标设备的IP地址但不知道其MAC地址时，会发送ARP请求广播以获取对应的MAC地址。\",\"缓存机制提高效率： 为了避免在每次通信时都进行ARP请求，设备通常会在本地维护一个ARP缓存表，将已知的IP地址和MAC地址对应关系存储一段时间。这样可以提高通信效率，避免多次ARP请求。\",\"局域网内部通信： ARP协议主要用于在同一局域网内解析IP地址到MAC地址的映射关系，而不涉及跨越路由器等设备的通信。\",\"地址解析协议ARP属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址，ARP协议只能在一段链路或一个网络上使用，不能全链路，只能跨链路\",\"数据的发送需要经过链路，仅仅知道IP地址是无法在数据链路层实现传输的，因此我们需要得到IP地址与MAC地址的对应关系，即地址解析。\",\"每台主机都会有一个ARP高速缓存表，记录有IP地址与MAC地址的对应关系\",\"初始ARP高速缓存表为空，假设此时B知道C的IP地址，准备发送信息，但是由于不知道C的MAC地址，因此无法封装数据帧，所以此时会广播一个ARP请求报文(封装在MAC帧中，目的地址为广播地址FF-FF-FF-FF-FF-FF)， \",\"内容如下： \",\"我的IP地址是：xxx ；我的MAC地址是：XXX；我想知道C主机的MAC地址是多少？这个广播帧会被该广播域的所有主机收到\",\"A主机收到后交由上层处理，发现B问的不是他，所以不予理会，C收到后交由上层处理，发现这个IP地址正是自己，因此首先将B的MAC地址和IP地址的对应关系记录到自己的高速缓存表中，接着返回给ARP响应报文(封装在MAC帧中，目的地址为B的MAC地址)，其中包含自己的MAC地址\",\"ARP高速缓存条目有静态与动态两种类型\",\"动态：代表是通过广播自动获取的条目，生命周期默认为两分钟\",\"静态：是手工设置的条目，不同操作系统下的生命周期不同。\"]},\"584\":{\"h\":\"13、HDLC协议在数据链路层中有什么作用？\",\"t\":[\"HDLC协议在数据链路层中有什么作用？\",\"常见的两种广域网数据链路层协议是 PPP 协议和 HDLC 协议\",\"HDLC（High-Level Data Link Control，高级数据链路控制）协议是一种在数据链路层中常见的通信协议，它具有以下作用和功能：\",\"数据封装： HDLC协议能够将上层数据封装为数据帧，添加必要的控制信息，如帧起始和结束标志、地址、控制字段以及帧校验序列等，以便在数据链路上传输。\",\"数据传输和同步： HDLC协议负责在物理介质上传输数据帧，并确保发送和接收双方的数据同步和正确传输。它通过帧的同步字段来确保帧的边界以及数据的准确接收。\",\"流量控制： HDLC支持基本的流量控制机制，允许发送方根据接收方的能力来控制数据的发送速率，以避免接收方无法处理过多的数据而发生数据丢失。\",\"错误检测和纠错： HDLC在数据帧中使用循环冗余检验（CRC）等技术来检测数据传输过程中可能发生的错误，并在需要时进行纠正。\",\"连接管理： 它提供了连接管理功能，可以建立、维护和终止数据链路连接，确保通信的可靠性和有效性。\",\"总的来说，HDLC协议在数据链路层中起到了数据封装、传输、同步、流量控制、错误检测与纠正以及连接管理等多种作用，帮助确保数据的可靠传输和通信的稳定性。\"]},\"585\":{\"c\":[\"面经收藏\"]},\"586\":{\"h\":\"计算机网络网络层-面试题\"},\"587\":{\"h\":\"1、网络层的主要作用是什么\",\"t\":[\"网络层的主要作用是什么？\",\"网络层的主要任务是实现不同网络之间的互连，为不同主机提供通信服务，允许数据包在这些网络之间传输，就是把数据分组从源端传到目的端。\",\"网络层传输单位是数据报。\",\"当数据报过大时，还是会进行分组之后再发送。\",\"因为我们的网络比较大，不再是拘于物理层和数据链路层的局域网了，而是更大的广域网、互联网。而在这个更大的网络中，如果我们要是信息送达给对方，单靠数据链路层的mac地址寻址是不够的，因为：\",\"数据是在不同设备间进行传输的，一直经历帧的封装的解封，这个过程中，帧的mac地址是不断变化的，例如A –> D，要经过B、C两个路由器，那么最后达到D的数据中的mac地址就是C的mac地址，所以说当源端和目的端位于不同网络的时候，直接通信是不可行的（找不到对方），此时就需要由网络层解决。\",\"所以我们需要一个不变的地址，那就是本层网络层的IP地址。\"]},\"588\":{\"h\":\"2、网络层提供了哪些服务\",\"t\":[\"网络层提供了哪些服务？\"]},\"589\":{\"h\":\"（Ⅰ）屏蔽网络差异，提供透明传输\",\"t\":[\"网络层能够为上层传输层解决不同网络的规范要求差异，寻找一个不同网络间能共同遵守的网络通信规范，以便不同网络间能相互识别，并接受对方的访问请求，这样传输层就可以在不同网络间进行透明（也就是不管不同网络间的差异，就像通信双方是直接互连一样）数据传输了。\",\"网络层向传输层提供的服务：\",\"①面向连接的网络服务：虚电路服务\",\"②无连接的网络服务：数据报服务\"]},\"590\":{\"h\":\"（Ⅱ）为网络间通信提供路由选择\",\"t\":[\"能根据一定的原则和路由选择算法在多个结点的通信子网中选择一条到达目的节点的最佳路径\"]},\"591\":{\"h\":\"（Ⅲ）数据包封装和解封装\",\"t\":[\"对来自传输层的报文：为其报文头部添加一些网络层协议控制信息封装成数据包。数据包的头部包含源节点和目标节点的网络层地址（例如IP地址）。\",\"对从低层到达网络层的报文：去掉在数据链路层加上的数据链路层协议控制信息（也就是帧头和帧尾），还原出原来的数据包格式，这就是包的解封装过程\"]},\"592\":{\"h\":\"（Ⅳ）拥塞控制\",\"t\":[\"避免网络传输路径中数据的传输延迟或死锁\",\"在数据链路层提到了流量控制功能，那是针对数据链路中点对点传输速率的控制\",\"而这里的拥塞控制是针对在网络传输路径中的端到端传输效率的控制（如避免路由器缓存空间爆满而造成丢包的情况）。\"]},\"593\":{\"h\":\"2、IP协议的定义和作用\",\"t\":[\"IP协议的定义和作用？\",\"IP（Internet Protocol，互联网协议）是互联网中最基本的协议之一，负责在网络中定位和传递数据包。\",\"IP协议是一种网络层协议，用于在计算机网络中标识和定位设备，以及在不同网络之间传输数据。它为数据包添加了源地址和目标地址信息，使得数据能够正确地从源设备传输到目标设备。\",\"数据定位和传输： IP协议为数据包提供了地址信息，使得数据能够在网络中准确地路由到目标设备。它定义了数据包的格式和结构，包括源IP地址和目标IP地址，确保数据正确地传输到目标地址。\",\"地址分配和唯一性： IP地址是在网络中唯一标识设备的地址，通过IP地址，设备可以彼此识别并进行通信。IP地址的分配和管理是网络运行的基础。\",\"跨网络通信： IP协议允许在不同的物理网络之间进行通信，通过路由器等设备将数据包从一个网络传输到另一个网络，实现跨网络的数据传输。\",\"分组和路由： IP协议将数据拆分为多个分组（数据包），每个分组带有目标地址信息。这些分组可以通过不同的路径传输，经过不同的路由器和网络设备，最终到达目标地址。\",\"总的来说，IP协议是互联网中的基础协议之一，负责设备的定位、数据包的传输和网络间的通信。它定义了数据包的结构和传输规则，为互联网上的各种网络和设备提供了连接和通信的能力。\"]},\"594\":{\"h\":\"2、域名和 IP 的关系？一个 IP 可以对应多个域名吗\",\"t\":[\"域名和 IP 的关系？一个 IP 可以对应多个域名吗？\",\"域名和IP地址之间存在映射关系。在互联网中，域名是人类可读的网址，而IP地址是计算机在网络中的标识。\",\"域名和IP的关系：\",\"域名解析： 域名系统（DNS）负责将域名转换为相应的IP地址。当你在浏览器中输入一个域名时，DNS服务器会将这个域名解析成对应的IP地址，以便计算机能够定位要访问的服务器。\",\"IP地址标识计算机： 每台连接到互联网的设备都有唯一的IP地址，用于在网络中定位和标识这台设备。IP地址是网络通信的基础，它类似于计算机的“街道地址”。\",\"多个域名对应同一个IP： 是的，一个IP地址可以对应多个域名。这种情况通常出现在共享服务器或负载均衡的情形下。多个域名指向同一个IP地址的服务器，在服务器上设置不同的虚拟主机或网站，从而让多个域名可以访问同一台服务器上的不同网站或服务。\",\"IP是身份证号，域名是别人喊你的名字，比如我叫张阿三，老师可能喊我张阿三，同学可能喊阿三，家人可能喊二字，这也很像一级域名、二级域名的样子\"]},\"595\":{\"h\":\"3、什么是子网掩码？它的作用是什么\",\"t\":[\"什么是子网掩码？它的作用是什么？\",\"子网掩码是一种用于指示一个IP地址的哪部分用于网络标识，哪部分用于主机标识的32位二进制数字。它与IP地址结合使用，用于划分网络中的主机和子网。\",\"作用：\",\"确定网络和主机部分： 子网掩码通过在IP地址中指示哪些位用于网络标识和哪些位用于主机标识，帮助计算机识别一个IP地址所属的网络和主机。\",\"网络划分： 子网掩码允许网络管理员将一个网络划分为多个子网，每个子网可以容纳一定数量的主机。这种划分提高了网络的安全性和管理性。\",\"IP地址分类： 在IPv4中，子网掩码也与IP地址的分类相关。它与IP地址一起确定了地址的类别（A、B、C等），并影响了可用的网络和主机数量。\",\"路由和数据包传输： 子网掩码用于确定数据包的目标网络和主机，帮助路由器决定如何将数据包传输到正确的目的地。\",\"总体来说，子网掩码是用于划分网络中的主机和子网的重要工具，它确定了IP地址中哪些位用于网络标识，哪些位用于主机标识，帮助网络设备正确地定位和传输数据。\"]},\"596\":{\"h\":\"4、如何进行子网划分\",\"t\":[\"如何进行子网划分？\",\"这个我不清楚，但是可以反推，子网的作用是指示IP地址中哪些位用于网络标识和哪些位用于主机标识，帮助计算机识别一个IP地址所属的网络和主机，所以：\",\"确定所需的子网数量： 确定网络中需要多少个子网。这取决于网络的规模、主机数量以及对网络管理和安全性的需求。\",\"选择合适的子网掩码： 子网掩码决定了网络部分和主机部分的划分。根据所需的子网数量和主机数量选择合适的子网掩码。常见的子网掩码有 /24（255.255.255.0）、/25（255.255.255.128）等。\",\"确定子网的大小： 子网的大小取决于所需的主机数量。确定每个子网可以容纳的主机数量，确保能够满足每个子网的需求。\",\"分配子网： 将原始网络划分为多个子网，确保每个子网拥有足够的IP地址空间来容纳所需的主机数量。\",\"分配子网的地址范围： 确定每个子网的起始地址和结束地址，用于分配给子网中的设备。确保每个子网的地址范围不会与其他子网重叠。\",\"更新网络设备配置： 更新网络设备（如路由器、交换机）的配置，以识别和路由到新划分的子网。\",\"实施和测试： 实施子网划分并进行测试，确保网络设备正确地识别和处理新的子网，确保网络通信正常。\"]},\"597\":{\"h\":\"5、什么是默认网关\",\"t\":[\"什么是默认网关？\",\"默认网关是计算机或网络设备用于发送非本地数据包的IP地址。\",\"它通常是本地网络中的路由器或网关设备，负责将发往其他网络或互联网的数据包转发到正确的目标网络。\",\"当设备需要发送数据包到另一个网络或互联网时，它首先检查目标IP地址是否属于本地网络。\",\"如果不是，设备会将数据包发送给默认网关，由默认网关将数据包路由到目标网络。\",\"默认网关通常是本地网络中一个指定的IP地址，它对于设备来说是发送数据包到其他网络的出口。\",\"在计算机或网络配置中设置默认网关是很重要的，因为它允许设备在需要时将数据包发送到非本地网络，实现网络间的通信。默认网关的设置通常是在设备的网络设置中配置的，确保设备能够正确地路由数据包到其他网络或互联网上。\"]},\"598\":{\"h\":\"6、什么是路由器？它在网络中的作用是什么\",\"t\":[\"详情\"]},\"599\":{\"h\":\"7、什么是IP地址？IPv4和IPv6的区别是什么\",\"t\":[\"详情\"]},\"600\":{\"h\":\"8、IP地址的分类有哪些？A类、B类和C类地址的范围是多少\",\"t\":[\"详情\"]},\"601\":{\"h\":\"9、为什么有了 IP 地址，还要 MAC 地址\",\"t\":[\"详情\"]},\"602\":{\"h\":\"10、IPV4 地址不够如何解决\",\"t\":[\"详情\"]},\"603\":{\"h\":\"11、常见的路由协议有哪些\",\"t\":[\"详情\"]},\"604\":{\"h\":\"12、什么是CIDR\",\"t\":[\"详情\"]},\"605\":{\"h\":\"13、什么是NAT？它的作用是什么\",\"t\":[\"详情\"]},\"606\":{\"h\":\"14、什么是静态路由和动态路由？它们之间有什么区别\",\"t\":[\"详情\"]},\"607\":{\"h\":\"15、什么是ARP？说说它的工作流程和作用？\",\"t\":[\"详情\"]},\"608\":{\"h\":\"16、什么是OSPF协议？它的工作原理是什么\",\"t\":[\"详情\"]},\"609\":{\"h\":\"17、什么是BGP协议？它的作用是什么\",\"t\":[\"详情\"]},\"610\":{\"h\":\"18、 什么是防火墙？它的作用是什么\",\"t\":[\"详情\"]},\"611\":{\"h\":\"19、解释一下ICMP协议的作用。\",\"t\":[\"详情\"]},\"612\":{\"h\":\"20、什么是DHCP？它的作用是什么\",\"t\":[\"详情\"]},\"613\":{\"h\":\"21、什么是IP地址分配方式（静态分配和动态分配）\",\"t\":[\"详情\"]},\"614\":{\"h\":\"22、ping的工作原理是什么\",\"t\":[\"详情\"]},\"615\":{\"c\":[\"面经收藏\"]},\"616\":{\"h\":\"计算机网络物理层-面试题\"},\"617\":{\"h\":\"1、物理层的主要功能是什么？\",\"t\":[\"物理层的主要功能是什么？\",\"在计算机网络中，物理层是网络体系结构的基础也就是第一层，负责处理数据传输和物理媒介的连接。\",\"物理层的主要任务是在计算机网络中负责在不同的物理机之间通过物理媒介传输原始比特流而进行通信。\",\"它实现了将数字数据转换成适合在物理媒介上传输的信号，并负责控制数据传输的物理特性，比如电压、频率、光强等。\",\"这样的处理确保了数据的可靠传输，保证了数据在不同设备之间的传输的正确性和可靠性，同时与上层的数据链路层建立了桥梁，使数据能够通过物理媒介进行传输。\"]},\"618\":{\"h\":\"2、介绍一下常见工作在物理层的设备有哪些？\",\"t\":[\"介绍一下常见工作在物理层的设备有哪些？\",\"常见工作在物理层的设备包括连接设备和传输媒体介质：\",\"连接设备： \",\"集线器（Hub）：在物理层工作，用于将网络中的设备连接在一起，通过广播方式将数据传输到网络中的所有设备。然而，随着交换机的普及，集线器的使用逐渐减少。\",\"物理层接口卡/网卡（NIC）：也称为网络适配器，是安装在计算机或设备上的硬件，连接计算机与网络介质（如以太网、Wi-Fi），负责将数据转换为适合在物理媒介上传输的形式。\",\"中继器（Repeater）：用于放大信号并延长信号传输的距离。它能够增强信号质量，使得数据能够在长距离传输时更可靠。\",\"调制解调器（Modem）：用于将数字数据转换成模拟信号以在电话线等模拟介质上传输，同时将模拟信号还原为数字数据。它在物理层连接数字设备与模拟介质。\",\"传输媒体介质：物理层工作的关键部分是介质，比如电缆（如双绞线、同轴电缆）、光纤等。这些介质负责承载数据传输的物理信号，如光、电等，并确保信号在传输过程中的稳定性和可靠性。\"]},\"619\":{\"h\":\"3、什么是调制和解调？能列举一些常见的调制技术吗？\",\"t\":[\"什么是调制和解调？能列举一些常见的调制技术吗？\",\"调制和解调是什么？为什么要有？\",\"调制：是指在通信中将数字信号转换为模拟信号的过程，以便在特定传输介质中（如电缆、光纤、空气等）中传输。\",\"解调：则是将模拟信号转换回数字信号的过程，以便接收设备能够理解和处理。\",\"为什么要有调制？\",\"因此，调制过程允许数据能够更有效地通过传输介质传输，并提高了传输的可靠性和适应性。不进行调制可能导致数据传输过程中的信号衰减、噪声干扰和传输距离限制，从而影响数据的完整性和可靠性。\",\"如果不进行调制，直接使用数字信号传输可能会面临以下问题： \",\"传输距离限制： 数字信号在长距离传输时受到噪声和衰减的影响更大。模拟信号在传输过程中的衰减相对较小，因此更适合长距离传输。\",\"抗干扰能力： 模拟信号在某些情况下具有更好的抗干扰能力，能够更好地应对传输中的干扰或噪声。\",\"传输介质兼容性： 模拟信号在某些传输介质中的传输更为可靠和高效，比如在某些类型的电缆或光纤中，模拟信号的传输损耗相对较低。\",\"多路复用： 一些模拟调制技术（比如QAM）允许在同一传输介质中传输多个信号，提高了传输效率和带宽利用率。\",\"所以调制是为了在传输过程中将数字信号转换成适合在特定传输介质中传输的模拟信号，因为在某些传输介质中（比如光纤、电缆、无线信道），模拟信号的传输更为可靠，例如电缆就传输电信号，而光纤传输光信号，调制就是将数字信号适配不同的传输介质。\",\"常见的调制技术包括：\",\"基本调制：\",\"调幅（AM）：利用信号的振幅变化来表示不同的数字信号\",\"调频（FM）：利用信号的频率变化来表示不同的数字信号\",\"调相（PM）：利用信号的相位变化来表示不同的数字信号。\",\"混合调制：QAM-16（ 正交振幅调制 – 同时利用振幅和相位来表示多个数字信号）\",\"这些调制技术都有各自的优势和应用场景，根据不同的通信需求和传输介质特性，选择合适的调制方式可以有效地进行数据传输。\"]},\"620\":{\"h\":\"5、解释一下带宽和频谱，它们之间有何区别？\",\"t\":[\"解释一下带宽和频谱，它们之间有何区别？\",\"带宽（Bandwidth）和频谱（Spectrum）是通信和信号处理中常用的两个概念，它们关联但表示不同的概念。\",\"带宽（Bandwidth）：信号所占用的频率范围或单位时间内传输的数据量，它是指定频率范围的宽度。\",\"带宽指的是信号传输过程中所占用的频率范围或信号所能传输的最大频率范围。在数字通信中，带宽也可指代在单位时间内传输的数据量或信息量。\",\"带宽关注的是频率范围的宽度\",\"频谱（Spectrum）：指频谱是指信号在频率上的分布情况，它描述了信号中各个频率成分的强度或能量分布。\",\"频谱指的是信号或波形在频率上的分布情况，信号的频谱可以是连续的，也可以是离散的，它展示了信号中各个频率成分的强度或能量分布。\"]},\"621\":{\"h\":\"频谱则关注信号中各个频率成分的分布情况\",\"t\":[\"简而言之，带宽关注的是频率范围的宽度，而频谱则关注信号中各个频率成分的分布情况。频谱展示了信号的频率特征，而带宽则是描述信号在频域中所占用的范围。\"]},\"622\":{\"h\":\"6、奈氏准则和香农公式在通信中扮演着什么样的角色？\",\"t\":[\"奈氏准则和香农公式在通信中扮演着什么样的角色？\",\"奈氏准用于确保信号采样的正确性，避免混叠，而香农公式则给出了信息传输的理论上限，指导着我们在给定的条件下设计更有效的通信系统，以最大化数据传输的可靠性和效率。\",\"奈氏准则（Nyquist Criterion）： \",\"奈氏准则用于确定最低的采样率，确保数字化的信号能够被有效地还原和解码，避免信息丢失或损坏。\",\"指出在理想条件下，为了正确地恢复出信号，采样频率必须至少是信号带宽的两倍。即采样速率应大于信号带宽的两倍，以避免混叠（aliasing）现象，确保能够准确地重建原始信号。\",\"香农公式（Shannon's Theorem）： \",\"规定了在理想条件下，数字通信中的信息传输速率的上限。公式表达了在受限的带宽内，最大可靠地传输信息的极限。\",\"公式描述了信道的容量与带宽、信噪比等因素之间的关系。它指出在理想情况下，一个受限带宽的通道能够以一定的信噪比下最大限度地传输信息，这个极限被称为香农容量。\"]},\"623\":{\"h\":\"7、未完待续\"},\"624\":{\"c\":[\"面经收藏\"]},\"625\":{\"h\":\"计算机网络场景题\"},\"626\":{\"h\":\"一、基础题\"},\"627\":{\"h\":\"1、说说计算机网络体系结构\"},\"628\":{\"h\":\"2、每一层对应的网络协议有哪些\"},\"629\":{\"h\":\"3、数据在各层之间是怎么传输的呢？数据是如何变化的\"},\"630\":{\"h\":\"二、场景题\"},\"631\":{\"h\":\"1、从浏览器地址栏输入 url 到显示主页的过程\"},\"632\":{\"h\":\"2、说说 DNS 的解析过程\"},\"633\":{\"c\":[\"面经收藏\"]},\"634\":{\"h\":\"计算机网络传输层-面试题\"},\"635\":{\"h\":\"1、传输层的主要功能是什么？\"},\"636\":{\"h\":\"2、传输层提供了哪两种主要的协议？\"},\"637\":{\"h\":\"3、TCP和UDP的区别是什么？在什么情况下会选择使用TCP或UDP？\"},\"638\":{\"h\":\"4、说说什么是三次握手和工作流程\"},\"639\":{\"h\":\"5、为什么不能是两次握手？不能是四次握手\"},\"640\":{\"h\":\"6、三次握手中每一次没收到报文会发生什么情况\"},\"641\":{\"h\":\"7、第二次握手传回了 ACK，为什么还要传回 SYN\"},\"642\":{\"h\":\"8、第 3 次握手可以携带数据吗\"},\"643\":{\"h\":\"9、什么是半连接队列和 SYN Flood 攻击有什么关系\"},\"644\":{\"h\":\"10、详细说说 TCP 四次挥手的过程\"},\"645\":{\"h\":\"11、TCP 挥手为什么需要四次呢\"},\"646\":{\"h\":\"12、TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态\"},\"647\":{\"h\":\"13、保活计时器有什么用\"},\"648\":{\"h\":\"14、CLOSE-WAIT 和 TIME-WAIT 的状态和意义\"},\"649\":{\"h\":\"15、TIME_WAIT 状态过多会导致什么问题？怎么解决\"},\"650\":{\"h\":\"16、说说 TCP 报文首部格式\"},\"651\":{\"h\":\"17、TCP 是如何保证可靠性的\"},\"652\":{\"h\":\"18、什么是拥塞控制？TCP如何进行拥塞控制\"},\"653\":{\"h\":\"19、什么是流量控制？TCP如何进行流量控制\"},\"654\":{\"h\":\"20、什么是滑动窗口协议？它在传输层中的作用是什么\"},\"655\":{\"h\":\"21、TCP的滑动窗口大小如何动态调整\"},\"656\":{\"h\":\"22、什么是TCP的粘包和拆包问题？如何解决\"},\"657\":{\"h\":\"23、什么是TCP的超时重传机制？它是如何工作的\"},\"658\":{\"h\":\"24、什么是快速重传和快速恢复\"},\"659\":{\"h\":\"25、什么是Nagle算法？它的作用是什么\"},\"660\":{\"h\":\"26、什么是延迟确认机制（Delayed ACK）\"},\"661\":{\"h\":\"27、什么是UDP协议？它适用于哪些场景\"},\"662\":{\"h\":\"28、说说 TCP 报文首部格式\"},\"663\":{\"h\":\"29、为什么 xx 采用 UDP 协议\"},\"664\":{\"h\":\"30、UDP 协议为什么不可靠\"},\"665\":{\"h\":\"31、DNS 为什么要用 UDP\"},\"666\":{\"h\":\"32、运输层常用端口有哪些\"},\"667\":{\"c\":[\"面经收藏\"]},\"668\":{\"h\":\"Java集合框架-面试题\"},\"669\":{\"h\":\"一、基础\"},\"670\":{\"h\":\"1、Java集合框架体系\",\"t\":[\"说说Java集合的框架体系？\",\"集合相关类和接口都在java.util中，主要和两家接口相关：Collection、Map，而集合可以分为4种：Collection接口下面的基于单值集合的List（列表）接口、Set(集)接口、Queue（队列），另一种就是Map（映射）接口、。\"]},\"671\":{\"h\":\"2、那这几个父类接口有什么区别\",\"t\":[\"那这几个父类接口有什么区别？\",\"说说 List, Set, Queue, Map 四者的区别？\",\"List列表（对付顺序的好帮手）：存储的元素是有序的、可重复的。\",\"Set集（注重独一无二的性质）：存储的元素不可重复的。\",\"Queue队列（实现排队功能的叫号机）： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。\",\"Map映射（用 key 来搜索的专家）：使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，\\\"x\\\" 代表 key，\\\"y\\\" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\"]},\"672\":{\"h\":\"3、无序性和不可重复性\",\"t\":[\"无序性和不可重复性的含义是什么？\",\"无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的，无序性不等于随机性 。\",\"不可重复性是指添加的元素按照 equals() 判断时，返回 false，需要同时重写 equals() 方法和 hashCode() 方法。\"]},\"673\":{\"h\":\"4、为什么要使用集合，如何挑选合适的集合\",\"t\":[\"为什么要使用集合，如何挑选合适的集合？\",\"数组存储对象存在一些不足之处不能动态扩容，Java 集合底层是基于Obejct动态数组实现，还是使用了反向，Java 集合更灵活、更有效的方法来存储多个数据对象\",\"Java 集合封装了一些了对数据操作的常用方法，减少了工作量，其次关于操作过程中的一些问题，如线程安全，也提供对应符合要求的集合\",\"集合种类多样，可以根据业务情况进行挑选\"]},\"674\":{\"h\":\"5、Comparable 和 Comparator\",\"t\":[\"Comparable 和 Comparator 的区别？\",\"两个接口都是 Java 中用于排序的接口，用于实例对象之间比较大小、排序等方面发挥了重要作用：\",\"Comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序 \",\"Comparable 接口定义了对象自身的排序方式，是对象固有的排序方法\",\"比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话\",\"Comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序 \",\"Comparator 接口则是在外部独立定义的排序方式，可以创建多个不同的比较器，并在需要时选择使用。\",\"可以为两个 Comparator 来实现歌名排序和歌星名排序\"]},\"675\":{\"h\":\"6、Java里线程安全的集合\",\"t\":[\"那有Java集合里面有哪些是线程安全的集合？\"]},\"676\":{\"h\":\"二、单值集合\"},\"677\":{\"h\":\"1、说说你对ArrayList的理解\",\"t\":[\"说说你对ArrayList的理解？\",\"ArrayList是Java基于数组实现的一种动态数组的数据结构。\",\"底层实现是基于一个Object数组，会根据实际存储的元素动态地扩容或缩容\",\"创建时的大小可以传入创建大小，如何是无参构造则默认大小为10，扩容是满了才会扩容，按原大小的1.5倍扩容，扩容方式是创建一个新数组，然后copy赋值，改变引用指向\",\"由于是一种动态数组的数据结构，且被RandomAccess 接口标记了，表明实现该接口的类支持随机访问，可以通过索引进行访问，查询的时间复杂度是O(1)\",\"插入可以头部插入、尾部插入、指定位置插入：时间复杂度是 O(n)、时间复杂度是 O(1)、时间复杂度是 O(n)\",\"删除可以头部删除、尾部删除、指定位置删除：时间复杂度是 O(n)、时间复杂度是 O(1)、时间复杂度是 O(n)\"]},\"678\":{\"h\":\"2、说说你对LinkedList的理解\",\"t\":[\"说说ArrayList的添加元素的过程和扩容过程?\",\"LinkedList是Java基于数组实现的一种动态数组的数据结构。\",\"底层实现是基于链表实现，是一个个的Node节点，节点包括pre、next指针和data数据\",\"由于是一种链表的数据结构，不可以通过索引进行访问，访问指定节点只能遍历链表，查询的时间复杂度是O(n)\",\"插入可以头部插入、尾部插入、指定位置插入：时间复杂度是 O(1)、时间复杂度是 O(1)、时间复杂度是 O(1)\",\"删除可以头部删除、尾部删除、指定位置删除：时间复杂度是 O(1)、时间复杂度是 O(1)、时间复杂度是 O(1)\"]},\"679\":{\"h\":\"3、ArrayList和LinkedList的区别\",\"t\":[\"说说ArrayList和LinkedList的区别？\",\"底层实现、查询效率、增加/删除效率、扩容方式、遍历方式\"]},\"680\":{\"h\":\"4、ArrayList序列化\",\"t\":[\"ArrayList怎么序列化的知道吗？\",\"ArrayList的序列化不太一样，它使用transient修饰存储元素的elementData的数组，transient关键字的作用是让被修饰的成员属性不被序列化。\",\"为什么最ArrayList不直接序列化元素数组呢？\",\"出于效率的考虑，数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。\",\"那ArrayList怎么序列化呢？\",\"ArrayList通过两个方法readObject、writeObject自定义序列化和反序列化策略，实际直接使用两个流ObjectOutputStream和ObjectInputStream来进行序列化和反序列化。\"]},\"681\":{\"h\":\"5、ArrayList是不是线程安全的\",\"t\":[\"ArrayList是线程安全的吗？有哪几种实现ArrayList线程安全的方法？\",\"ArrayList是线程不安全的，保证ArrayList的线程安全可以通过这些方案：\",\"使用 Vector 代替 ArrayList。（不推荐，Vector是一个历史遗留类）\",\"使用 Collections.synchronizedList 包装 ArrayList，然后操作包装后的 list。\",\"使用 CopyOnWriteArrayList 代替 ArrayList。\",\"在使用 ArrayList 时，应用程序通过同步机制去控制 ArrayList 的读写。\"]},\"682\":{\"h\":\"6、你是否了解CopyOnWriteArrayList\",\"t\":[\"CopyOnWriteArrayList了解多少？\",\"CopyOnWriteArrayList就是线程安全版本的ArrayList。\",\"它的名字叫CopyOnWrite——写时复制，采用了一种读写分离的并发策略。\",\"允许并发读，读操作是无锁的，性能较高。\",\"至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。 \",\"将原数组拷贝一份\",\"写操作在副本上，加锁；此时读操作在原数组上\",\"写完将元素数组指向副本\"]},\"683\":{\"h\":\"7、HashSet实现原理\",\"t\":[\"HashSet实现原理？\",\"HashSet实现就是基于 HashMap 实现的，当你向 HashSet 中添加元素时，实际上是将这些元素作为 HashMap 中的 key，而对应的 value 则是一个固定的 Object 对象， private static final Object PRESENT = new Object()。\",\"因此，HashSet 的实现本质上就是通过 HashMap 来模拟一个只有 key 没有 value 的集合。这也解释了为什么 HashSet 中不能存储重复元素，因为 HashMap 中的 key 是唯一的。\"]},\"684\":{\"h\":\"二、双值集合\"},\"685\":{\"h\":\"1、说说你对HashMap的理解\",\"t\":[\"说说你对HashMap的理解？\",\"HashMap是Map接口下的一个实现类，存储方式是键值对存储，是Java对Hash表的一种实现，具体是使用数组做Hash容器。\",\"底层实现是在jdk1.7是基于一个数组+链表形式，数组做Hash容器，数组存储每个元素对应一个链表，用于解决哈希冲突。\",\"底层实现是在jdk1.8是基于一个数组+链表+红黑树形式，引入了红黑树，数组做Hash容器，数组存储每个元素对应一个链表，用于解决哈希冲突，红黑树用于以提高查询效率，优化 HashMap 的性能。\",\"引入红黑树主要是为hashmap集合分布的元素更均匀，如果没有红黑树，可能会出现元素集中分布，某一个部位的链表特别长，其他部位特别短，\",\"初始化HashMap，默认大小是16，也可以传参，如果传一个值不是2的倍数，则会HashMap会向上寻找离得最近的2的倍数\",\"HashMap 在元素数量超过负载因子（默认为 0.75）与容量的乘积时，HashMap 将自动进行扩容操作，扩容长度为原来的两倍\",\"这个过程可能会比较耗时，尤其是当元素数量巨大时，因为需要重新计算所有元素的哈希值并重新分配到新的位置。为了避免频繁扩容带来的性能开销，通常在创建 HashMap 时指定一个合适的初始容量，以及根据实际情况调整负载因子。\",\"数据元素通过hash算法也就是散列函数进行定位，映射到Hash表（桶数组）对应索引的位置，在大多数情况下，已知键，对应查询、删除、修改的效率是O(1)，如果链表非常长，最差情况是O(n)\"]},\"686\":{\"h\":\"2、HashMap的实现原理\",\"t\":[\"HashMap的实现原理？\",\"底层实现是在jdk1.7是基于一个数组+链表形式，数组做Hash容器，数组存储每个元素对应一个链表，用于解决哈希冲突。 \",\"HashMap 通过 key 的 hashcode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度）\",\"如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话-是同一个元素，直接覆盖，不相同就通过拉链法解决冲突。\",\"底层实现是在jdk1.8是基于一个数组+链表+红黑树形式，引入了红黑树，数组做Hash容器，数组存储每个元素对应一个链表，用于解决哈希冲突，红黑树用于以提高查询效率，优化 HashMap 的性能。 \",\"引入红黑树主要是为hashmap集合分布的元素更均匀，如果没有红黑树，可能会出现元素集中分布，某一个部位的链表特别长，其他部位特别短\",\"当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\"]},\"687\":{\"h\":\"3、HashMap可以添加null，元素可以重复吗\",\"t\":[\"HashMap可以添加null，元素可以重复吗？\",\"在 HashMap 中：\",\"允许添加 null： 是的，HashMap 中的键和值都可以为 null。在键值对中，键和值都可以是 null。\",\"元素不允许重复： 在 HashMap 中，键是唯一的，不允许重复。如果添加相同的键（即相同的 hashCode 和 equals 结果），后添加的值会覆盖先前的值。但是值可以重复，即多个键可以对应相同的值，不会影响 HashMap 的数据结构。\"]},\"688\":{\"h\":\"4、为什么HashMap 的长度是 2 的幂次方/倍数\",\"t\":[\"为什么HashMap 的长度是 2 的幂次方/倍数？\",\"为了方便哈希取余：\",\"HashMap是用hash值&(数组大小-1)代替了hash值%数组定位位置，这就得益于HashMap的大小是2的倍数.\",\"2的倍数意味着该数的二进制位只有一位为1，而该数-1就可以得到二进制位上1变成0，后面的0变成1，再通过&运算，就可以得到和%一样的效果，并且位运算比%的效率高得多\",\"HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。\",\"在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去\",\"进行与运算时，只是多了一个1参与运算（例如从 16 扩容到 32，n-1二进制分别为 01111 和 011111），保持与运算 (hash & (newCapacity - 1)) 在扩容后的效果，仍然能够有效且均匀地分布元素到新的数组中。\",\"低位在进行位运算时能够更均匀地分布元素到新的数组中，虽然只有低位参与了运算，但这足以保持元素的均匀性，有助于减少哈希冲突，提高 HashMap 的性能。\"]},\"689\":{\"h\":\"5、如果初始化HashMap，传入的值不是2的倍数，它会怎么处理\",\"t\":[\"如果初始化HashMap，传入的值不是2的倍数，它会怎么处理？\",\"简单来说，就是初始化时，传的不是2的倍数时，HashMap会向上寻找离得最近的2的倍数，所以传入17，但HashMap的实际容量是32。\",\"我们来看看详情，在HashMap的初始化中，有这样⼀段⽅法；\",\"public HashMap(int initialCapacity, float loadFactor) { ... this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } \",\"阀值 threshold ，通过⽅法 tableSizeFor 进⾏计算，是根据初始化传的参数来计算的。\",\"同时，这个⽅法也要要寻找⽐初始值⼤的，最⼩的那个2进制数值。⽐如传了17，我应该找到的是32。\",\"static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } \",\"MAXIMUM_CAPACITY = 1 << 30，这个是临界范围，也就是最⼤的Map集合。\",\"计算过程是向右移位1、2、4、8、16，和原来的数做|运算，这主要是为了把⼆进制的各个位置都填上1，当⼆进制的各个位置都是1以后，就是⼀个标准的2的倍数减1了，最后把结果加1再返回即可。\"]},\"690\":{\"h\":\"6、你和我简单的说一说hash算法\",\"t\":[\"你和我简单的说一说hash算法？\",\"hash算法是一种散列算法，可以将几个任意长度的二进制数据散列计算成一个定长的二进制数据，常见的hash算法有md5，sha256等，当然我们也可以自定义实现一些简单的hash算法，比如java中有取余、内存地址等。\",\"hash算法通常是要结合数组来实现hash表。\",\"1、hash表是一种数据结构，通常要结合数组和hash算法来实现，我们利用hash算法可以定位一个元素的位置，并利用数据的随机访问特性快速的元素进行增删查改，他的最优时间复杂度可以达到O(1)。\",\"2、但是，他也存在一些问题，比如hash碰撞，如果数组的元素过少，或者hash算法不太优秀或者存入的元素太多，可能会经常发生hash碰撞，导致时间复杂度进行退化，最差可能是O(n)。\",\"3、通常情况下，我们可以使用线性探测法、链表法等来解决hash碰撞的问题，同时提供一个负载因子，在必要的时候进行扩容，来保持一个相对较稳定的时间复杂度，比如java中的hashmap的实现。\",\"那你继续说说hashmap（O(1) —》 数据总量和查询次数的关系）\",\"1、基础数据结构，负载因子0.75（泊松分布）\",\"2、hash算法，只要我们的hash算法不垃圾，一般情况都不会树化\",\"3、扩缩容的条件: >0.75 链表节点 > 8 （优先扩容）\",\"4、treeify的条件: 链表的节点 > 8 && 数组长度 > 64\",\"5、线程安全的问题.\"]},\"691\":{\"h\":\"7、你还知道哪些哈希函数的构造方法呢？\",\"t\":[\"你还知道哪些哈希函数的构造方法呢？\",\"HashMap里哈希构造函数的方法叫：\",\"除留取余法：H（key)=key%p（p<=N）,关键字除以一个不大于哈希表长度的正整数p，所得余数为地址，当然HashMap里进行了优化改造，效率更高，散列也更均衡。\",\"直接定址法：直接根据key来映射到对应的数组位置，例如1232放到下标1232的位置。\",\"数字分析法：取key的某些数字（例如十位和百位）作为映射的位置\",\"平方取中法：取key平方的中间几位作为映射的位置\",\"折叠法：将key分割成位数相同的几段，然后把它们的叠加和作为映射的位置\"]},\"692\":{\"h\":\"8、解决哈希冲突有哪些方法呢\",\"t\":[\"解决哈希冲突有哪些方法呢？\",\"我们到现在已经知道，HashMap使用链表的原因为了处理哈希冲突，这种方法就是所谓的：\",\"链地址法：在冲突的位置拉一个链表，把冲突的元素放进去。\",\"开放定址法：开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位。\",\"找到空闲位置的方法也有很多种：\",\"线行探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置\",\"平方探查法: 从冲突的位置x开始，第一次增加1^2个位置，第二次增加2^2…，直至找到空闲的位置\",\"再哈希法：换种哈希函数，重新计算冲突元素的地址。\",\"建立公共溢出区：再建一个数组，把冲突的元素放进去。\"]},\"693\":{\"h\":\"9、HashMap的哈希/扰动函数是怎么设计的?\",\"t\":[\"详情\",\"HashMap的哈希函数是先拿到 key 的hashcode，是一个32位的int类型的数值，然后让hashcode的高16位和低16位进行异或操作。\",\"static final int hash(Object key) { int h; // key的hashCode和key的hashCode右移16位做异或运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \"]},\"694\":{\"h\":\"10、为什么哈希/扰动函数能降hash碰撞？\",\"t\":[\"为什么哈希/扰动函数能降hash碰撞？\",\"因为 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。int 值范围为 -2147483648~2147483647，加起来大概 40 亿的映射空间。\",\"只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。\",\"假如 HashMap 数组的初始大小才 16，就需要用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。\",\"源码中模运算就是把散列值和数组长度 - 1 做一个 \\\"与&\\\" 操作，位运算比取余 % 运算要快。\",\"bucketIndex = indexFor(hash, table.length); static int indexFor(int h, int length) { return h & (length-1); } \",\"顺便说一下，这也正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。因为这样（数组长度 - 1）正好相当于一个 “低位掩码”。与 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是 0000 0000 0000 0000 0000 0000 0000 1111。和某个散列值做 与 操作如下，结果就是截取了最低的四位值。\",\"这样是要快捷一些，但是新的问题来了，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，那就更难搞了。\",\"这时候 扰动函数 的价值就体现出来了：\",\"key的hashCode右移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。\"]},\"695\":{\"h\":\"11、HashMap的put()流程\",\"t\":[\"HashMap的put()流程知道吗？\",\"首先进行哈希值的扰动，获取一个新的哈希值。(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\",\"判断tab是否位空或者长度为0，如果是则进行扩容操作。\",\"if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; \",\"根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆盖。tab[i = (n - 1) & hash])\",\"判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。\",\"如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。treeifyBin(tab, hash);\",\"最后所有元素处理完成后，判断是否超过阈值；threshold，超过则扩容。\"]},\"696\":{\"h\":\"12、扩容在什么时候呢？为什么扩容因子是0.75\",\"t\":[\"扩容在什么时候呢？为什么扩容因子是0.75？\",\"那就是大于容量 * 负载因子(0.75)如：16x0.75=12时，就会触发扩容操作。\",\"那么为什么选择了0.75作为HashMap的默认加载因子呢？\",\"简单来说，这是对空间成本和时间成本平衡的考虑\",\"HashMap 中的加载因子（即扩容因子）通常设置为 0.75。这个值的选择考虑了几个方面：\",\"太大了分布不均匀，太小了容易hash冲突，基于他们一次次的尝试，参考下列的因素试出来的。\",\"减少哈希冲突和提高性能： 较低的加载因子可以减少哈希碰撞，也就是减少了链表或红黑树的长度，使得哈希表的性能更高效。过高的加载因子会导致哈希碰撞增多，链表长度变长，使得哈希表的性能下降。\",\"空间利用和内存效率： 较高的加载因子意味着哈希表需要更少的空间来存储相同数量的元素。但过高的加载因子可能导致哈希表过度填充，增加了哈希冲突的概率，影响了性能。\",\"泊松分布： 在一些情况下，0.75 这个值选择可能考虑到了键的插入和查询操作符合泊松分布的假设。泊松分布是一种描述在一定时间或空间区域内随机事件发生次数的概率分布，HashMap 中键的插入和查询操作可能在一定程度上符合这种分布。选择加载因子为 0.75 可能是在尽可能平衡哈希表的空间利用率和性能之间做出的折中。\",\"总的来说，0.75 这个值的选择是为了在空间利用和哈希表性能之间取得一个较好的平衡，并不仅仅是基于泊松分布考虑的。这个值可能会因不同的情况和需求而有所调整。\"]},\"697\":{\"h\":\"13、为什么HashMap链表转红黑树的阈值为8呢\",\"t\":[\"为什么HashMap链表转红黑树的阈值为8呢？\",\"树化发生在table数组的长度大于64，且链表的长度大于8的时候。\",\"我记得源码的注释给了解答：\",\"红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。\",\"阈值为什么要选8呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为0.00000006。\",\"至于红黑树转回链表的阈值为什么是6，而不是8？是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费。\"]},\"698\":{\"h\":\"14、你对红黑树了解多少？为什么不用二叉树/平衡树呢？\",\"t\":[\"你对红黑树了解多少？为什么不用二叉树/平衡树呢？\",\"红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：\",\"每个节点要么是红色，要么是黑色；\",\"根节点永远是黑色的；\",\"所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；\",\"每个红色节点的两个子节点一定都是黑色；\",\"从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；\",\"之所以不用二叉树：\",\"二叉树不平衡，可能出现树枝不均匀情况，一边长一边短。\",\"红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。\",\"之所以不用平衡二叉树：\",\"平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。\"]},\"699\":{\"h\":\"15、红黑树怎么保持平衡的知道吗？\",\"t\":[\"红黑树怎么保持平衡的知道吗？\",\"红黑树有两种方式保持平衡：旋转和染色。\",\"旋转：旋转分为两种，左旋和右旋\"]},\"700\":{\"h\":\"16、HashMap怎么查找元素的呢？\",\"t\":[\"HashMap怎么查找元素的呢？\",\"HashMap的查找就简单很多：\",\"使用扰动函数，获取新的哈希值\",\"计算数组下标，获取节点\",\"当前节点和key匹配，直接返回\",\"否则，当前节点是否为树节点，查找红黑树\",\"否则，遍历链表查找\"]},\"701\":{\"h\":\"17、jdk1.8对HashMap主要做了哪些优化呢\",\"t\":[\"jdk1.8对HashMap主要做了哪些优化呢？\",\"jdk1.8 的HashMap主要有五点优化：\",\"数据结构：数组 + 链表改成了数组 + 链表或红黑树\",\"原因：发生 hash 冲突，元素会存入链表，链表过长转为红黑树，将时间复杂度由O(n)降为O(logn)\",\"链表插入方式：链表的插入方式从头插法改成了尾插法\",\"简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后。\",\"原因：因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环。\",\"扩容rehash：扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，不需要重新通过哈希函数计算位置，新的位置不变或索引 + 新增容量大小。\",\"原因：提高扩容的效率，更快地扩容。\",\"扩容时机：在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；\",\"散列函数：1.7 做了四次移位和四次异或，jdk1.8只做一次。\",\"原因：做 4 次的话，边际效用也不大，改为一次，提升效率。\"]},\"702\":{\"h\":\"18、HashMap 常见的遍历方式\",\"t\":[\"HashMap 常见的遍历方式？\",\"核心就是拿到entrySet / keySet，所有遍历都是基于这个，如lambda、stream流\",\"使用 entrySet() 遍历：\",\"通过 entrySet() 方法获取键值对的集合 Set<Map.Entry<K, V>>。\",\"遍历每个键值对，使用 getKey() 和 getValue() 获取键和值。\",\"Map<K, V> map = new HashMap<>(); // 假设 map 已经有键值对数据 // 遍历 entrySet for (Map.Entry<K, V> entry : map.entrySet()) { K key = entry.getKey(); V value = entry.getValue(); // 处理 key 和 value } \",\"使用 keySet() 遍历键集合：\",\"通过 keySet() 方法获取键的集合 Set<K>。\",\"遍历每个键，通过键获取对应的值。\",\"Map<K, V> map = new HashMap<>(); // 假设 map 已经有键值对数据 // 遍历 keySet for (K key : map.keySet()) { V value = map.get(key); // 处理 key 和 value } \",\"使用迭代器遍历：\",\"通过 entrySet() 方法获取键值对的集合，再通过迭代器进行遍历。\",\"Map<K, V> map = new HashMap<>(); // 假设 map 已经有键值对数据 Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<K, V> entry = iterator.next(); K key = entry.getKey(); V value = entry.getValue(); // 处理 key 和 value } \"]},\"703\":{\"h\":\"19、hashmap可以按照key来排序吗？如果不可以，有没有可以的实现？\",\"t\":[\"hashmap可以按照key来排序吗？如果不可以，有没有可以的实现？\",\"HashMap是无序的，根据 hash 值随机插入。因此不能直接按照键来排序。如果想使用有序的Map，可以使用LinkedHashMap 或者 TreeMap。\",\"TreeMap： TreeMap 是基于红黑树实现的，它会对键进行排序存储，因此可以按照键的自然顺序或者自定义的比较器来排序。示例：\",\"Map<K, V> map = new TreeMap<>(); // 添加键值对 //... // 遍历按键排序后的结果 for (K key : map.keySet()) { V value = map.get(key); // 处理 key 和 value } \",\"LinkedHashMap：LinkedHashMap 保留了元素插入的顺序，因此按照插入的顺序可以遍历键值对。示例：\",\"Map<K, V> map = new LinkedHashMap<>(); // 添加键值对 //... // 遍历按插入顺序的结果 for (K key : map.keySet()) { V value = map.get(key); // 处理 key 和 value } \"]},\"704\":{\"h\":\"20、HashMap 和 HashSet 区别\",\"t\":[\"详情\",\"HashSet 底层就是基于 HashMap 实现的\",\"相同点：它们都是基于哈希表的实现，并且具有快速查找、插入和删除元素的特性。\",\"区别：\",\"实现接口：HashMap实现了 Map 接口，HashSet是Collection接口下面的Set接口的子实现类\",\"内部数据结构：\",\"HashMap 是基于键值对的存储结构，使用键来唯一标识每个值，并通过哈希表实现，它允许键和值都可以为 null，但只能有一个 null 键。每个键值对都是由键和值组成的。\",\"HashSet 是基于哈希表的存储结构，它是基于 HashMap 实现的，只存储对象的唯一值，不允许重复，并且允许一个 null 元素。\",\"存储方式和特性：\",\"HashMap 存储键值对，通过键来获取值，可以根据键来查询、删除、更新对应的值。\",\"HashSet 存储唯一的元素集合，不能包含重复元素。它可以用来检查某个元素是否存在，但不提供像 HashMap 那样的键值对映射关系。\",\"使用场景：\",\"HashMap 通常用于需要存储键值对且需要根据键快速检索值的情况，比如存储缓存、数据库中的数据等。\",\"HashSet 适用于需要存储唯一元素集合且不需要键值对映射关系的情况，比如去重、集合运算等。\"]},\"705\":{\"h\":\"21、HashMap 和 TreeMap 区别\",\"t\":[\"HashMap 和 TreeMap 区别？\",\"TreeMap 和HashMap 都继承自AbstractMap ，HashMap 和 TreeMap 是 Java 中的两种不同的 Map 实现，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。\",\"HashMap 和 TreeMap 是 Java 中的两种不同的 Map 实现，它们之间有以下区别：\",\"内部数据结构：\",\"HashMap 是基于哈希表的实现，使用哈希表存储键值对，它通过键的哈希码来快速定位存储位置，具有 O(1) 的常数时间复杂度进行插入、删除和查找操作。\",\"TreeMap 是基于红黑树的实现，它是有序的键值对集合，根据键的自然顺序或者自定义的比较器进行排序。由于使用红黑树存储，它具有 O(log n) 的时间复杂度。\",\"存储顺序：\",\"HashMap 不保证元素的顺序，它是无序的。\",\"TreeMap 会根据键的顺序进行排序存储，因此它是有序的。\",\"性能和用途：\",\"HashMap 适用于需要快速查找、插入和删除键值对，并不需要保持顺序的情况。它在大多数情况下提供了更好的性能。\",\"TreeMap 适用于需要按键排序的情况，它提供了按键排序的有序映射。虽然它的性能相对较慢，但它提供了有序性和额外的方法来处理有序映射。\",\"null 键和排序：\",\"HashMap 允许一个 null 键和多个 null 值。\",\"TreeMap 不允许 null 键，但允许 null 值。\",\"综上所述，HashMap 和 TreeMap 在内部实现、存储顺序、性能和适用场景等方面存在明显差异，选择使用取决于具体的需求和情况。如果需要快速的插入、删除和查找，并且不需要顺序，则 HashMap 更合适；如果需要有序的键值对集合，就需要使用 TreeMap。\"]},\"706\":{\"h\":\"22、HashMap 和 Hashtable 的区别\",\"t\":[\"HashMap 和 Hashtable 的区别？\",\"HashMap 和 Hashtable 是 Java 中的两种不同的 Map 实现，都实现了Map接口，它们有一些区别：\",\"底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。Hashtable 没有这样的机制。\",\"HashMap 的底层是基于数组和链表/红黑树的组合实现的。它使用哈希表存储数据，通过键的哈希码来确定存储位置，当发生哈希冲突时，使用链表或红黑树来解决冲突。\",\"Hashtable 也是基于数组和链表实现的。它使用哈希表存储数据，同样通过哈希码来确定存储位置，但是在解决哈希冲突时，使用的是链表，没有红黑树优化。\",\"初始容量大小和每次扩充容量大小的不同：\",\"创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。\",\"创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小。\",\"存储数据null 键值：\",\"HashMap 允许有一个 null 键和多个 null 值，即键和值都可以为 null。\",\"Hashtable 不允许键或值为 null，如果尝试将 null 作为键或值放入 Hashtable，会抛出 NullPointerException。\",\"线程安全性：\",\"HashMap 是非线程安全的类，不提供线程同步，多个线程同时访问 HashMap 可能导致不确定的结果。在多线程环境下使用时，需要额外的同步措施来确保线程安全。\",\"Hashtable 是线程安全的类，所有的方法都是同步的。在多线程环境下，Hashtable 的线程安全性能会带来额外的开销，可能影响性能。\",\"继承关系：\",\"HashMap 继承自 AbstractMap 类，实现了 Map 接口。\",\"Hashtable 继承自 Dictionary 类（已经被淘汰，不推荐使用），实现了 Map 接口和 Hashtable 接口。\",\"迭代顺序：\",\"HashMap 不保证元素的顺序，它是无序的，遍历时不能保证顺序与插入顺序相同。\",\"Hashtable 也不保证元素的顺序，同样是无序的。\",\"性能：\",\"由于 Hashtable 的方法都是同步的，因此在多线程环境下提供了线程安全性，但性能相对较低。\",\"HashMap 不提供线程安全性，但在单线程环境下具有较好的性能。\",\"综上所述，主要区别在于线程安全性、对 null 键值的支持、迭代顺序和性能。通常情况下，在单线程环境下，使用 HashMap 更常见，而在多线程环境下，如果需要线程安全的操作，可以考虑使用 Hashtable 或者 ConcurrentHashMap。\"]},\"707\":{\"h\":\"23、HashMap为什么线程不安全？\",\"t\":[\"HashMap为什么线程不安全？\",\"JDK1.7 及之前版本，在多线程环境下，HashMap 扩容时会造成死循环和数据丢失的问题。\",\"数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。\",\"JDK 1.8 后，在 HashMap 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 HashMap 的 put 操作会导致线程不安全，具体来说会有数据覆盖的风险。\",\"举个例子：\",\"两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。\",\"不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。\",\"随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。\",\"还有一种情况是这两个线程同时 put 操作导致 size 的值不正确，进而导致数据覆盖的问题：\",\"线程 1 执行 if(++size > threshold) 判断时，假设获得 size 的值为 10，由于时间片耗尽挂起。\",\"线程 2 也执行 if(++size > threshold) 判断，获得 size 的值也为 10，并将元素插入到该桶位中，并将 size 的值更新为 11。\",\"随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。\",\"线程 1、2 都执行了一次 put 操作，但是 size 的值只增加了 1，也就导致实际上只有一个元素被添加到了 HashMap 中。\"]},\"708\":{\"h\":\"24、有什么办法能解决HashMap线程不安全的问题呢\",\"t\":[\"有什么办法能解决HashMap线程不安全的问题呢？\",\"Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map。\",\"HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大；\",\"Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；\",\"ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。\"]},\"709\":{\"h\":\"25、快速失败(fail-fast)和安全失败(fail-safe)\",\"t\":[\"快速失败(fail-fast)和安全失败(fail-safe)了解吗？\",\"快速失败（fail—fast）：快速失败是Java集合的一种错误检测机制\",\"在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。\",\"原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。\",\"注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。\",\"场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。\",\"安全失败（fail—safe）:\",\"采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。\",\"原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。\",\"缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。\",\"场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类。\"]},\"710\":{\"h\":\"26、并发修改异常是什么？什么情况下会发生\",\"t\":[\"并发修改异常是什么？什么情况下会发生？\",\"并发修改异常（ConcurrentModificationException）是 Java 集合框架中的一种异常，通常在使用迭代器遍历集合时，发生了对集合结构的并发修改操作时抛出。\",\"情况如下：\",\"并发修改： 当使用迭代器遍历集合的过程中，通过集合的方法（如 add()、remove()）或者迭代器的 remove() 方法修改了集合的结构时，即在迭代器遍历过程中进行了集合的结构性修改。\",\"遍历冲突： 在迭代器遍历过程中，如果有其他线程对集合进行了修改（结构性修改），导致迭代器的“修改次数”与集合实际的“修改次数”不一致。\",\"这种情况下，迭代器会检测到集合结构的修改，与自己遍历过程中所记录的修改次数不一致，就会抛出 ConcurrentModificationException 异常，以保证遍历过程中的一致性和防止数据不一致性。\",\"为什么要维护：\",\"维护“修改次数”（modification count）的计数器主要是为了在迭代器遍历集合时进行快速失败（fail-fast）机制的实现。\",\"这个计数器实际上是在 Java 集合中的一种内部结构，用于记录集合被修改的次数。在创建迭代器时，会记录当前集合的修改次数值。在迭代器进行遍历时，如果发现迭代器所记录的修改次数与集合实际的修改次数不一致，就会抛出 ConcurrentModificationException 异常，即迭代器快速失败，以保证遍历过程中的一致性和避免潜在的并发修改引起的数据不一致性。\",\"这样做的目的是确保迭代器在遍历时，能够及时发现集合结构的修改，避免继续遍历导致数据不一致或不可预测的结果。这种快速失败机制提供了一种机制来尽早检测并发修改，以确保程序的健壮性和可靠性。\",\"解决方法包括：\",\"避免在迭代器遍历期间对集合进行结构性修改。\",\"使用迭代器自身的 remove() 方法进行删除操作。\",\"在多线程环境下，使用线程安全的集合（如 ConcurrentHashMap）或者使用同步机制来避免并发修改异常的发生。\"]},\"711\":{\"h\":\"27、ConcurrentHashMap的底层实现原理是什么\",\"t\":[\"ConcurrentHashMap的底层实现原理是什么？\",\"ConcurrentHashmap线程安全在jdk1.7版本是基于分段锁实现，在jdk1.8是基于CAS+synchronized实现。\",\"1.7分段锁： \",\"从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。\",\"实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。\",\"put流程：整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已，后面的流程，就和HashMap基本上是一样的。 \",\"计算hash，定位到segment，segment如果是空就先初始化\",\"使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功\",\"遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作\",\"get流程：get也很简单，key通过hash定位到segment，再遍历链表定位到具体的元素上，需要注意的是value是volatile的，所以get是不需要加锁的。\",\"1.8cas+synchronized： \",\"jdk1.8实现线程安全不是在数据结构上下功夫，它的数据结构和HashMap是一样的，数组+链表+红黑树。它实现线程安全的关键点在于put流程。\",\"put流程： \",\"首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化\",\"如果当前数组位置是空则直接通过CAS自旋写入数据\",\"如果hash==MOVED，说明需要扩容，执行扩容\",\"如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树\",\"get查询：get很简单，和HashMap基本相同，通过key计算位置，table该位置key相同就返回，如果是红黑树按照红黑树获取，否则就遍历链表获取。\",\"区别：\",\"底层实现/Hash 碰撞解决方法 : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。\",\"线程安全实现方式：JDK 1.7 采用 Segment 分段锁来保证安全， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。\",\"并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。\"]},\"712\":{\"h\":\"28、ConcurrentHashMap 为什么 key 和 value可以为null吗\",\"t\":[\"ConcurrentHashMap 为什么 key 和 value可以为null吗？\",\"完善hashmap的key value为空，避免二义性\",\"ConcurrentHashMap 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 ConcurrentHashMap 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 ConcurrentHashMap 中的，还是因为找不到对应的键而返回的。\",\"拿 get 方法取值来说，返回的结果为 null 存在两种情况：\",\"值没有在集合中 ；\",\"值本身就是 null。\",\"这也就是二义性的由来。\"]},\"713\":{\"h\":\"29、ConcurrentHashMap能保证复合性操作吗\",\"t\":[\"ConcurrentHashMap能保证复合性操作吗？\",\"ConcurrentHashMap 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 HashMap 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！\",\"复合操作是指由多个基本操作(如put、get、remove、containsKey等)组成的操作，例如先判断某个键是否存在containsKey(key)，然后根据结果进行插入或更新put(key, value)。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。\",\"那如何保证 ConcurrentHashMap 复合操作的原子性呢？\",\"ConcurrentHashMap 提供了一些原子性的复合操作，如 putIfAbsent、compute、computeIfAbsent 、computeIfPresent、merge等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。\"]},\"714\":{\"h\":\"30、LinkedHashMap 底层实现\",\"t\":[\"LinkedHashMap 底层实现？\",\"LinkedHashMap 是继承自 HashMap 的一个类，在 HashMap 的基础上增加了按照插入顺序或者访问顺序（LRU）来维护键值对的顺序。\",\"底层实现结构上，LinkedHashMap 与 HashMap 类似，仍然使用哈希表（数组 + 链表 / 红黑树）来存储键值对，只是在 LinkedHashMap 中增加了一个双向链表来维护顺序。 \",\"它通过一个双向链表来维护键值对的插入顺序或者访问顺序（根据构造函数的不同而定）。这个链表使得 LinkedHashMap 能够保持键值对的迭代顺序与插入顺序或访问顺序一致。\",\"每个 LinkedHashMap 的 Entry（即键值对）不仅保存了键值对信息，还包含了两个指针用于维护双向链表的结构。一个指针指向链表的前一个元素，另一个指针指向链表的后一个元素，这样就构成了一个双向链表的结构。\",\"基于这种结构，在 LinkedHashMap 中，插入顺序或者访问顺序的维护是比较高效的，因为它只需要对双向链表进行简单的指针调整，而不需要对哈希表进行重新的散列或重排。\",\"总体来说，LinkedHashMap 在保留 HashMap 的查询性能的同时，通过双向链表的结构保持了键值对的顺序，是一个可以按照插入顺序或者访问顺序遍历的有序 Map。\"]},\"715\":{\"h\":\"31、LinkedHashMap和 HashMap 有什么区别\",\"t\":[\"LinkedHashMap和 HashMap 有什么区别?\",\"都是Map接口的子实现类\",\"底层实现结构：\",\"HashMap： 使用哈希表（数组 + 链表 / 红黑树）来存储键值对。它通过哈希码计算来确定元素的存储位置，具有较快的添加、查询和删除性能。\",\"LinkedHashMap： 在 HashMap 的基础上，增加了一个双向链表来维护元素的顺序。这个链表使得 LinkedHashMap 能够保持插入顺序或者访问顺序，但在维护顺序方面会带来额外的开销。\",\"元素顺序的处理/可以记录插入顺序：\",\"HashMap： 在 HashMap 中，元素的存储顺序是不确定的，不受添加顺序或者访问顺序影响。元素在哈希表中的存储位置是根据其哈希码计算得到的，因此在遍历时无法保证元素的顺序性。\",\"LinkedHashMap： 相比之下，LinkedHashMap 会按照插入顺序或访问顺序（可选择）来维护元素的顺序。插入顺序表示元素被插入的顺序，而访问顺序表示元素最近被访问的顺序。这意味着遍历 LinkedHashMap 可以按照插入顺序或者最近访问的顺序进行。\",\"性能方面的考量：\",\"HashMap： 由于不需要额外维护顺序，因此在一般情况下，在添加、查询和删除方面可能会略微快于 LinkedHashMap。\",\"LinkedHashMap： 在维护顺序的情况下，可能在性能上略微慢于 HashMap，但提供了按照插入顺序或访问顺序访问键值对的能力。\",\"初始容量大小和每次扩充容量大小的不同：\",\"两者在初始容量大小和每次扩充容量大小上没有本质的不同，都有默认的初始容量和加载因子（即扩容时的阈值）。\",\"线程安全性：\",\"HashMap 和 LinkedHashMap： 都不是线程安全的。在多线程环境中使用时，需要进行额外的同步措施。\"]},\"716\":{\"c\":[\"面经收藏\"]},\"717\":{\"h\":\"Java虚拟机-面试题\"},\"718\":{\"h\":\"一、内存区域\"},\"719\":{\"h\":\"1、什么是jvm\",\"t\":[\"说说你理解的jvm?\",\"是什么：JVM就是我们的Java 虚拟机。\",\"作用：\",\"我们书写的Java源代码提供我们的编译器（javac）编译成字节码文件（.class），然后我们的Java虚拟机提供它的指定的字节码文件规范进行解释，翻译成对应的机器指令然后进行运行的。\",\"我们的Java语言会自动进行垃圾回收，而这也是JVM为我们承担的任务\",\"特点：\",\"它是 Java 语言实现平台无关性的基石（跨平台），只要其他平台有Java虚拟机那就能运行Java语言\",\"因为只要和 class 的文件格式关联，任何语言，都能被 JVM 运行，例如kotlin编译后也是class文件。\"]},\"720\":{\"h\":\"2、jvm运行过程\",\"t\":[\"说说jvm运行过程？\",\"类加载：\",\"加载（Loading）： 类加载器加载字节码文件，生成对应的 Class 对象。\",\"验证（Verification）： 确保字节码符合 JVM 规范，并且不会对系统造成损害。\",\"准备（Preparation）： 为类变量（静态变量）分配内存，并设置默认初始值。\",\"解析（Resolution）： 将符号引用转换为直接引用，比如将类和方法的引用转换为内存地址的引用。\",\"初始化（Initialization）：\",\"JVM 在这个阶段执行类构造器 <clinit>() 方法，初始化类变量，执行静态代码块。这个阶段是类加载过程的最后一步，确保类变量被正确初始化。\",\"执行字节码（Bytecode Execution）：\",\"JVM 开始执行程序的主要逻辑，按照字节码指令逐行执行，这是程序的实际运行阶段。\",\"垃圾回收（Garbage Collection）：\",\"JVM 负责管理内存，在程序运行过程中，通过垃圾回收器回收不再使用的对象，释放内存空间。\",\"即时编译（Just-In-Time Compilation - JIT）：\",\"JVM 通过即时编译器将热点代码（频繁执行的部分）转换为本地机器代码，以提高执行效率。\",\"优化和监控（Optimization and Profiling）：\",\"JVM 可能会根据程序的执行情况进行优化，比如内联、去虚拟化等。同时，也会进行性能监控，收集程序运行的信息，用于优化和改进。\",\"卸载（Unloading）：\",\"当类不再被引用或者程序结束时，JVM 可能会卸载不再需要的类，释放相应的内存空间。\"]},\"721\":{\"h\":\"3、JVM 后台运行的系统线程主要有哪些\",\"t\":[\"JVM 后台运行的系统线程主要有哪些？\",\"JVM 后台运行的系统线程包括：\",\"主线程（Main Thread）： 这是 Java 应用程序启动时创建的线程，负责执行 main() 方法。它也被称为应用程序的入口点。\",\"垃圾回收器线程（Garbage Collector Threads）： JVM 中的垃圾回收器会有多个线程，每个线程负责执行不同类型的垃圾回收操作。例如，串行垃圾回收器（Serial Garbage Collector）会有一个专门的线程执行垃圾回收，而并行垃圾回收器（Parallel Garbage Collector）可能会使用多个线程并行进行垃圾回收操作。\",\"编译器线程（Compiler Threads）： 当 JVM 使用即时编译器（JIT）将字节码编译成本地机器代码时，会涉及到编译器线程。这些线程负责将热点代码编译成高效的本地代码。\",\"信号分发线程（Signal Dispatcher Thread）： 这个线程负责接收操作系统发送的信号，并将其转发给 JVM 的特定处理程序。\",\"周期性任务线程（Periodic Task Threads）： JVM 中会有一些线程执行周期性的任务，比如执行周期性的垃圾回收或者其他后台任务。\",\"Finalizer 线程（Finalizer Thread）： 这个线程负责执行对象的 finalize() 方法，用于释放对象占用的资源。\",\"虚拟机退出线程（VM Shutdown Hook Thread）： 这个线程用于执行在 JVM 即将关闭时注册的关闭钩子（Shutdown Hooks），可以用来执行一些清理或资源释放操作。\"]},\"722\":{\"h\":\"4、jvm的内存区域\",\"t\":[\"说说jvm的内存区域是怎么分布的？\",\"JVM 内存区域最简单粗暴的划分可以分为堆和栈，当然，按照虚拟机规范，可以划分为：线程私有区和线程共享区\",\"线程私有区：\",\"程序计数器： \",\"是什么：我们可以将其称为 PC 寄存器，是一块较小的内存空间\",\"有什么作用：用来配合我们的线程执行我们的代码的，是当前线程所执行的字节码的行号指示器。 \",\"因为可能会有很多线程都去执行那一段代码，而不同线程执行的时间又不同，执行途中也可能因为阻塞等原因停下，所以它的作用就是记录当前线程执行到哪了\",\"栈： \",\"Java 虚拟机栈： \",\"是什么：是线程执行 Java 方法的一个内存模型，也就是说它和我们的方法调用执行有关，栈又是由一个个栈帧组成，每调用一个方法JVM 会同步生成一个栈帧\",\"有什么作用：栈帧主要就用于记录方法执行过程中相关的数据，例如它里面有局部变量表存储方法调用过程中的创建的局部变量、传入的基础数据类型参数，操作数栈用于方法内的计算，动态连接用于解析对应对象的真实内存。\",\"本地方法栈： \",\"是什么，有什么作用：本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务，也就是使用了native标识的方法，比如我们Object类的wait()和notify()方法、clone()方法、getClass()方法。\",\"线程共享区：\",\"Java 堆： \",\"是什么：从Java程序来看 \",\"对于 Java 应用程序来说， 堆是虚拟机所管理的内存中最大的一块\",\"在虚拟机启动时创建，是被所有线程共享的一块内存区域\",\"是什么：从垃圾回收角度来看 \",\"Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作GC 堆。\",\"现代垃圾收集器大部分都是基于分代收集理论设计的，所以 Java 堆可以划分为新生代（Eden空间、From Survivor空间、To Survivor空间）、老年代\",\"作用：但是无论从什么角度看，这个内存区域的唯一目的就是存放对象实例，Java 里几乎所有的对象实例都在这里分配内存。\",\"方法区： \",\"是什么和有什么作用：和Java堆类似，它也是各个线程共享的内存区域，主要用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据（类常量池、运行时常量池、字符串常量池），它是一个逻辑上的实现，具体真正的实现有例如 jdk1.7及其之前使用永久代、jdk1.8及其之后的元空间作为方法区的实现。 \",\"类常量池： 类常量池是每个类的一部分，存储了编译时期生成的字面量常量、符号引用等信息。这些信息包括类、方法和接口的名称、字段的名称和描述符、方法的名称和描述符等。类常量池是在编译时确定的，随着类加载到内存中而被创建。\",\"运行时常量池： 运行时常量池是类常量池的一部分，它在类加载到内存时被 JVM 所创建，用于存储类加载后的符号引用解析信息、动态生成的常量等。在运行时，它是方法区的一部分。\",\"字符串常量池： 字符串常量池是运行时常量池的一部分，专门用来存储字符串字面量。字符串常量池是 String 类的私有静态成员变量，用于存储在编译期间由双引号引起来的字符串常量。Java 中的字符串常量池具有重用相同字符串的特性，即相同内容的字符串在常量池中只有一份拷贝。\"]},\"723\":{\"h\":\"5、jdk1.6、1.7、1.8 内存区域有什么变化\",\"t\":[\"jdk在1.6、1.7、1.8历史变化中的内存区域有什么变化吗？\",\"JDK1.6： \",\"使用永久代实现方法区\",\"常量池位于永久代\",\"大小、垃圾回收受JVM管理\",\"JDK1.7： \",\"字符串常量池、静态变量，存放在堆上\",\"类常量池、运行时常量池仍然位于永久代\",\"大小、垃圾回收受JVM管理\",\"JDK1.8： \",\"彻底干掉了永久代，而在直接内存中划出一块区域作为元空间\",\"类常量池、运行时常量池都移动到元空间。\",\"自动调整大小： 元空间的大小可以根据需要动态调整，不再受固定大小的永久代限制。\",\"受 JVM 管理： 元空间的管理依然由 JVM 进行，包括垃圾回收：垃圾回收的工作主要针对无用的类元数据信息进行处理，而不是直接回收元空间内存。\"]},\"724\":{\"h\":\"6、栈和堆有什么区别\",\"t\":[\"栈和堆有什么区别，你说说看？\",\"1、功能和作用：\",\"堆主要用来存放对象的，栈主要是用来执行程序的\",\"（1）栈，可以看成是方法的运行模型，所有方法的调用都是通过栈帧来进行的，而且它是线程私有，JVM会为每个线程都分配一个栈区，JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。当线程进入一个Java方法函数的时候，就会在当前线程的栈里压入一个栈帧，用于保存当前线程的状态（参数、局部变量、中间计算过程和其他数据），当退出函数方法时，修改栈指针就可以把栈中的内容销毁，采用的是后进先出的数据结构，最后调用的方法最先执行完成并退出栈。\",\"（2）堆，唯一的目的就是用于存放对象实例，每个Java应用都唯一对应一个JVM实例，每个JVM实例都唯一对应一个堆，并由堆内存被应用所有的线程共享。\",\"2、存储数据：\",\"Java中分配堆栈内存是由JVM自动分配和管理的。\",\"Java中的数据类型有两种：一种是8个基本类型（即int, short, long, byte, float, double, boolean, char），一种是引用类型。\",\"（1）函数中基本类型和对象的引用都是在栈内存中分配。当在一段代码块中定义一个变量时，由于这些变量大小可知，生存期可知，出于追求速度的原因，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间。\",\"（2）对于引用类型：Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配。也就是说在建立一个对象时，从两个地方都分配内存，在堆中分配的内存实际用于建立这个对象，而在栈中分配的内存只是一个指向这个堆对象的引用而已。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理，根据判断对象引用。\",\"3、访问速度：\",\"栈的访问速度比堆快，因为它的分配和释放内存都是有序的，而且大小固定，由JVM指定。\",\"堆的话看是直接指针还是句柄\"]},\"725\":{\"h\":\"7、为什么使用元空间替代永久代作为方法区的实现\",\"t\":[\"为什么要使用元空间替代永久代作为方法区的实现呢？\",\"为什么使用？ –> 1.肯定之前的有问题 2.现在的和之前的有什么区别\",\"元空间替代永久代后，它的大小不受JVM控制了，那可能是之前永久代来实现方法区的决定的设计导致了 Java 应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize 的上限，即使不设置也有默认大小，而 J9 和 JRockit 只要没有触碰到进程可用内存的上限，例如 32 位系统中的 4GB 限制，就不会出问题），而且有极少数方法 （例如 String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。\",\"元空间的内存管理更为灵活，并且不再依赖传统的垃圾回收机制，因此在类加载、卸载等场景下表现更优，能够提供更好的性能和内存管理效果。\",\"传统的垃圾回收方式主要针对对象实例的回收\",\"元空间的内存管理更侧重于类元数据的释放，通常是基于类加载器和类的引用关系来进行管理和释放。 \",\"当某个类不再被引用或使用，且不再需要时，元空间会进行相应的类卸载，释放相关的内存空间。这种方式与\"]},\"726\":{\"h\":\"8、jvm中对象的创建的过程\",\"t\":[\"java对象的创建的过程是怎么样的？\",\"在 JVM 中对象的创建，我们从一个 new 指令开始：\",\"首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用\",\"检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程\",\"类加载检查通过后，接下来虚拟机将为新生对象分配内存。\",\"内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。\",\"接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。\",\"这个过程大概如下：\",\"类加载：加载类的字节码文件到内存，并在方法区创建一个对应的Class对象，用于描述类的结构信息。\",\"分配内存：在堆内存中为新创建的对象分配内存空间。\",\"初始化零值：将分配的内存空间初始化为零值，即对象的成员变量在此阶段都为默认值（例如，int 类型默认为 0，引用类型默认为 null）。\",\"设置对象头：虚拟机会根据对象的类型设置对象头信息，包括对象的哈希码、GC 分代年龄等。\",\"执行<init>方法：在构造器方法<init>中进行对象的初始化工作，即根据构造器的实际内容为对象的成员变量赋值。\"]},\"727\":{\"h\":\"9、内存分配的方式有几种\",\"t\":[\"内存分配的方式有几种？\",\"两种方式的选择由 Java 堆是否规整决定，Java 堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的\",\"指针碰撞：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。\",\"空闲列表：如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。\"]},\"728\":{\"h\":\"10、JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？\",\"t\":[\"JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？\",\"会，假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。\",\"保证线程安全： \",\"每个人先分点零食，零食吃完再吃主食：每个线程在 Java 堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。\",\"先预定主食，再尝试购买，如果已售罄，则重新开始购买流程：采用 CAS 分配重试的方式来保证更新操作的原子性\"]},\"729\":{\"h\":\"11、说一下对象的内存布局组成结构\",\"t\":[\"说一下一个Java对象的组成结构？\",\"对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充\",\"对象头主要由两部分组成： \",\"第一部分存储对象自身的运行时数据（Mark Word）：它是个动态的结构，随着对象状态变化，包括哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等\",\"第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。\",\"此外，如果对象是一个 Java 数组，那还应该有一块用于记录数组长度的数据\",\"实例数据用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。\",\"对齐填充不是必须的，没有特别含义，仅仅起着占位符的作用\"]},\"730\":{\"h\":\"12、访问对象的有几种方式\",\"t\":[\"如果我要访问一个对象的有几种方式？\",\"句柄和直接指针两种：\",\"句柄访问：Java 堆中将可能会划分出一块内存来作为句柄池，栈中的引用存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 \",\"使用句柄来访问的最大好处就是栈中的引用存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而栈中的引用本身不需要被修改。\",\"句柄池 - 驿站，真实的数据 - 商家厂房，栈中的引用 - 用户取货码\",\"直接指针：栈中的引用存储的直接就是对象地址 \",\"速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本\",\"用户直接根据商家的地址去拿货\"]},\"731\":{\"h\":\"13、内存溢出和内存泄漏是什么意思？\",\"t\":[\"内存溢出和内存泄漏是什么意思？\",\"首先这两个都是属于Java异常体系的error - 错误，是程序无法处理的\",\"内存泄露：当某一个对象不再有用的时候，占用的内存却不能被回收，就是申请的内存空间没有被正确释放，导致内存被白白占用。\",\"内存溢出：就是申请的内存超过了可用内存，内存不够了。\",\"就比如我们去用花呗付款，超过了花呗已使用额度就用不了 - 内存溢出，如果可以使用的额度用换了还不还，那么下个月就没东西用力 - 内存泄漏\",\"两者关系：内存泄露可能会导致内存溢出\",\"内存泄漏：\",\"静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。\",\"创建的连接不再使用时，需要调用 close 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。\",\"单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。\",\"hash 值发生变化：如果我们使用的不是不变类型的key，那么对象 Hash 值改变，使用 HashMap、HashSet 等容器中时候，由于对象修改之后的 Hah 值和存储进容器时的 Hash 值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么 String 类型被设置成了不可变类型\",\"ThreadLocal 使用不当：ThreadLocal 的弱引用导致内存泄漏，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。\",\"内存溢出：\",\"在 JVM 的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OutOfMemoryError）异常的可能\",\"Java堆溢出：因为堆用于储存对象实例，只要不断创建不可被回收的对象，比如我们可以创建一个ArrayList集合，一直while循环添加静态内部类对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生OOM。\",\"Java栈溢出：因为堆是由一个个栈中组成，如果我们使用一个方法内总是无限制条件递归调用本方法，那么就会触发栈溢出。\",\"Java方法区溢出： \",\"大量动态生成类： 比如使用CGLIB、ASM等字节码生成工具，如果持续不断地生成新的类，方法区可能会耗尽。\",\"大量常量池： 如果不断往常量池添加数据，可能导致方法区溢出。这种情况通常发生在运行时大量动态生成字符串常量或者类加载器大量加载类的场景。\",\"持续不断的加载类： 在动态加载大量类文件时，如果无法及时回收不再使用的类，也可能导致方法区溢出。\"]},\"732\":{\"h\":\"二、垃圾回收\"},\"733\":{\"h\":\"1、如何判断对象是垃圾，对象是否死亡，有什么方法\",\"t\":[\"如何判断对象是垃圾，对象是否死亡，有什么方法？\",\"引用计数算法和可达性分析算法：\",\"引用计数算法：每个对象中都维护了一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。\",\"可达性分析算法：实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。\",\"废弃常量、类：\",\"有两种常见的垃圾回收策略分别用于判断常量和类的是否无用：根引用和类加载器。\",\"废弃常量判断： 在Java中，常量池中的常量可能会成为废弃常量，如果这些常量不再被任何活动对象或类所引用，那么它们可以被判定为废弃常量。垃圾回收器在清理常量池时，会考虑这些废弃常量并将其回收。\",\"无用类判断： 判断一个类是否是无用的，通常涉及到类加载器和类引用链的分析。如果一个类满足以下条件，则可以判定为无用类： \",\"该类的所有实例都已经被回收，即没有任何对象是该类的实例。\",\"该类的Class对象没有被引用，即没有任何代码通过反射调用该类的方法或访问其字段。\",\"该类所在的ClassLoader已经被回收，即该类的ClassLoader没有存在的必要，没有其他类需要加载。\"]},\"734\":{\"h\":\"2、Java 中可作为 GC Roots 的对象有哪几种\",\"t\":[\"Java 中可作为 GC Roots 的对象有哪几种？\",\"可以作为 GC Roots 的主要有四种对象：\",\"虚拟机栈(栈帧中的本地变量表)中引用的对象\",\"方法区中类静态属性引用的对象\",\"方法区中常量引用的对象\",\"本地方法栈中 JNI 引用的对象\"]},\"735\":{\"h\":\"3、说一下对象有哪几种引用\",\"t\":[\"说一下Java中对象有哪几种引用方式？\",\"Java 中的引用有四种，分为强引用、软引用、弱引用和虚引用4 种，强度依次逐渐减弱。\",\"强引用是最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象，不可达才会被回收。\",\"Object obj =new Object(); \",\"软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用，内存不足才会被回收。\",\"Object obj = new Object(); ReferenceQueue queue = new ReferenceQueue(); SoftReference reference = new SoftReference(obj, queue); //强引用对象滞空，保留软引用 obj = null; \",\"弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用，一定被回收。\",\"Object obj = new Object(); ReferenceQueue queue = new ReferenceQueue(); WeakReference reference = new WeakReference(obj, queue); //强引用对象滞空，保留软引用 obj = null; \",\"虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用，一定被回收。\",\"Object obj = new Object(); ReferenceQueue queue = new ReferenceQueue(); PhantomReference reference = new PhantomReference(obj, queue); //强引用对象滞空，保留软引用 obj = null; \"]},\"736\":{\"h\":\"4、finalize()方法了解吗？有什么作用\",\"t\":[\"finalize()方法了解吗？有什么作用？\",\"垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。\",\"如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。\",\"如果对象在在 finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。\"]},\"737\":{\"h\":\"5、Java 堆的内存分区了解吗\",\"t\":[\"Java 堆的内存分区了解吗？\",\"按照垃圾收集角度：\",\"Java 堆划分为新生代 和老年代两个区域\",\"新生代：eden、from、to，比例是 8：1：1 \",\"Eden空间：是对象最初分配的区域。大多数对象都是在这里被创建的。\",\"Survivor空间：包括两个区域，一般分别称为from和to。在新生代的垃圾收集过程中，存活下来的对象会被移动到这两个Survivor区域之一。\",\"新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。\",\"老年代： \",\"主要存放存活时间较长的对象，所以垃圾收集频率较低\",\"如从新生代晋升过来的对象或者是大对象直接分配到老年代。\"]},\"738\":{\"h\":\"6、Minor GC、Major GC、Mixed GC、Full GC 都是什么意思\",\"t\":[\"Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC 都是什么意思?\",\"部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：\",\"新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。\",\"老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS 收集器会有单独收集老年代的行为。\",\"混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。\",\"整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。\"]},\"739\":{\"h\":\"7、Minor GC和Full GC 什么时候触发\",\"t\":[\"Minor GC/Young GC 和 Full GC什么时候触发\",\"Minor GC/Young GC：\",\"新创建的对象优先在新生代 Eden 区进行分配，如果 Eden 区没有足够的空间时，就会触发 Young GC 来清理新生代。\",\"FullGC：\",\"Young GC 之前检查老年代：在要进行 Young GC 的时候，发现老年代可用的连续内存空间 < 新生代历次Young GC后升入老年代的对象总和的平均大小，说明本次 Young GC 后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。\",\"Young GC 之后老年代空间不足：执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次 Full GC\",\"老年代空间不足，老年代内存使用率过高，达到一定比例，也会触发 Full GC。\",\"空间分配担保失败（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。\",\"方法区内存空间不足：如果方法区由永久代实现，永久代空间不足 Full GC。\",\"System.gc()等命令触发：System.gc()、jmap -dump 等命令会触发 full gc。\"]},\"740\":{\"h\":\"8、对象什么时候会进入老年代\",\"t\":[\"对象什么时候会进入老年代？\",\"长期存活的对象将进入老年代：\",\"在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次 YoungGC 之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到 15(默认)之后,这个对象将会被移入老年代。\",\"可以通过这个参数设置这个年龄值。\",\"- XX:MaxTenuringThreshold \",\"大对象直接进入老年代：\",\"有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。\",\"HotSpot 虚拟机提供了这个参数来设置。\",\"-XX：PretenureSizeThreshold \",\"动态对象年龄判定：\",\"为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。\",\"空间分配担保\",\"假如在 Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。\"]},\"741\":{\"h\":\"9、你能说说young gc和full gc的过程吗\",\"t\":[\"详情\",\"当谈到垃圾回收（Garbage Collection，GC）时，通常会涉及到两种主要类型的垃圾回收过程：Young Generation GC和Full GC。这两种过程都是Java虚拟机（JVM）用来管理内存的一部分。\",\"Young Generation GC（年轻代垃圾回收）： 在JVM中，堆内存被划分为不同的区域，其中年轻代（Young Generation）通常是对象被创建后的初始分配区域。它又分为Eden空间和两个Survivor空间（通常称为S0和S1）。在年轻代GC中，新创建的对象首先被分配到Eden空间。当Eden空间满了之后，会触发一次年轻代GC。\",\"年轻代GC的过程包括：\",\"将存活的对象从Eden空间和Survivor空间移动到另一个Survivor空间，同时进行年龄计数（对象每经历一次年轻代GC，年龄加一）。\",\"当对象的年龄达到一定阈值时，会被移动到年老代（Old Generation）。\",\"未被引用的对象会被标记为垃圾并清理掉，释放内存。\",\"Full GC（完全垃圾回收）： Full GC涉及整个堆内存，包括年轻代和年老代。它的触发条件包括：\",\"年轻代没有足够空间容纳存活的对象。\",\"年老代空间不足。\",\"显式调用System.gc()。\",\"Full GC的过程包括：\",\"首先进行年轻代GC，清理年轻代中的垃圾。\",\"然后，对整个堆内存进行检查和清理，包括年轻代和年老代。这是一个相对耗时的过程，因为它需要对整个堆内存进行遍历和处理。\"]},\"742\":{\"h\":\"10、跨代引用问题\",\"t\":[\"什么是跨代引用问题？\",\"假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担\",\"跨代引用相对于同代引用来说仅占极少数，不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为记忆集，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用） 此后当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的\",\"记忆集（Remembered Set)：一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，在对象层面来说就是非收集区域对象对收集区域对象的引用的记录\",\"它存放在收集区域，比如在新生代里面存放着老年代对新生代对象的每一个引用。这样在收集新生代的时候，我们就可以根据记忆集知道哪些对象被老年代对象所引用，不能回收，这就解决了跨代引用的问题\",\"卡表（Card Table）：是以卡精度的方式实现的记忆集，也是目前最常用的方式。记忆集是抽象的概念，而卡表就是记忆集的一种具体实现\",\"在 HotSpot 虚拟机里是通过写屏障技术维护卡表状态的。写屏障可以看作在虚拟机层面对 引用类型字段赋值 这个动作的 AOP 切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内\"]},\"743\":{\"h\":\"11、空间分配担保机制\",\"t\":[\"什么是空间分配担保机制？\",\"1.谁进行空间担保？\",\"JVM使用分代收集算法，将堆内存划分为年轻代和老年代，两块内存分别采用不同的垃圾回收算法，空间担保指的是老年代进行空间分配担保\",\"2.什么是空间分配担保？\",\"在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，\",\"如果大于，则此次Minor GC是安全的\",\"如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。\",\"3.为什么要进行空间担保？\",\"是因为新生代采用复制收集算法，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。\"]},\"744\":{\"h\":\"13、垃圾收集算法了解吗\",\"t\":[\"垃圾收集算法有了解吗？\",\"垃圾收集算法主要有三类：\",\"标记-清除算法标记-清除（Mark-Sweep）算法分为两个阶段：\",\"标记 : 标记出所有需要回收的对象\",\"清除：回收所有被标记的对象\",\"缺点： \",\"内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\",\"执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。\",\"标记-复制算法：解决了标记-清除算法面对大量可回收对象时执行效率低的问题。\",\"将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。\",\"当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 \",\"缺点：存在空间的浪费，新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。\",\"标记-整理算法：为了降低内存的消耗，引入的一种针对性的算法：\",\"标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。\",\"主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要 Stop The World 才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。\"]},\"745\":{\"h\":\"14、你了解垃圾回收器有哪些，详细介绍一下？\",\"t\":[\"你了解垃圾回收器有哪些，详细介绍一下？\",\"根据进行垃圾回收的不同地点，也就是它们的工作区域分为不同的垃圾回收器：\",\"针对的新生代进行young gc的： \",\"serial、ParNew、Parallel Scavenge（GCTimeRatio、UseAdaptSizePolicy可控制吞吐量 = 运行代码时间 / （运行代码时间 + 垃圾回收时间））都是标记复制算法\",\"针对的老年代进行old gc的： \",\"serial old标记整理、Parallel Old标记整理、cms标记清除\",\"针对新手代和老年代mixed gc的：G1标记清除、标记整理\"]},\"746\":{\"h\":\"15、说一下cms垃圾回收器？\",\"t\":[\"详情\",\"CMS（Concurrent Mark Sweep）收集器是一种主打的就是并发和减少回收停顿时间为目标的收集器。它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作\",\"初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；它就是仅仅把gc roots对象能连到的对象加入到扫描栈中。\",\"并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。加入到扫描栈中的对象，（栈中引用的对象、方法区的静态属性、常量等引用对象，本地方法栈的引用对象），以这些对象触发，遍历整个堆内存的一个存活对象的对象图，把所有存活标记 \",\"但这存在一个对象消失问题：扫描过程中插入了一条或多条从黑色对象到白色对象的新引用，并且同时去掉了灰色对象到该白色对象的直接引用或者间接引用。 \",\"增量更新：黑色对象插入白色引用，就记录一下引用关系，等到并发标记后，再重写扫描一遍\",\"原始快照：把删除的引用记录下路，再次扫描有没有删除\",\"重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\",\"并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\"]},\"747\":{\"h\":\"16、什么是Strop The World？ 有哪些区域需要停顿，为什么要停顿？什么是 OopMap ？什么是安全点\",\"t\":[\"详情\",\"进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为Stop The World。也简称为 STW。\",\"在 HotSpot 中，有个数据结构（映射表）称为OopMap。一旦类加载动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，记录到 OopMap。在即时编译过程中，也会在特定的位置生成 OopMap，记录下栈上和寄存器里哪些位置是引用。\",\"这些特定的位置主要在：\",\"1.循环的末尾（非 counted 循环）\",\"2.方法临返回前 / 调用方法的 call 指令后\",\"3.可能抛异常的位置\",\"这些位置就叫作安全点(safepoint)。 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。\",\"用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。\"]},\"748\":{\"h\":\"17、三色标记法了解吗，在哪使用的，为什么要引入\",\"t\":[\"三色标记法了解吗，在哪使用的，为什么要引入？\",\"什么是？在哪使用的？为什么要引入？\",\"三色标记法主要用于并发标记阶段，用于实现并发垃圾回收器中的增量标记，例如在Java虚拟机的并发标记-清除（CMS）垃圾回收器中。\",\"并发标记是指在垃圾回收的过程中，能够允许程序继续执行，而不需要完全暂停程序的运行。这对于大型应用和需要高吞吐量的场景非常重要，以减少停顿时间。\",\"三色标记法的核心思想：将对象的标记状态分为三个不同的颜色(白色、灰色和黑色)\",\"白色：表示对象尚未被访问，即从根节点出发还没有遍历到的对象。\",\"灰色：表示对象已经被访问，但其引用的其他对象还未被访问。\",\"黑色：表示对象已经被访问，并且其引用的其他对象也都被访问过。\",\"在并发标记阶段，初始时所有的对象都是白色的。标记从根对象（如栈中的对象引用）开始，将根对象标记为灰色，然后逐步遍历灰色对象的引用，将被引用的对象标记为灰色，而引用被完全遍历后则标记为黑色。\",\"三色标记法的引入主要是为了在并发标记的过程中解决引用关系变化的问题。由于并发环境中，对象的引用关系可能会发生变化，即对象可能被添加或删除引用。使用三色标记法，可以通过将对象标记为灰色来识别正在遍历的对象，从而确保即使引用关系变化，也能正确地标记和遍历对象。\"]},\"749\":{\"h\":\"18、g1垃圾收集器了解吗，详细说说 ？G1中为什么划分Region\",\"t\":[\"g1垃圾收集器了解吗，详细说说 ？G1中为什么划分Region？\",\"g1，垃圾第一，它相对传统的垃圾回收器不同，它是一个全年代的垃圾回收器，他一个人就能负责新生代和老年代的垃圾回收。\",\"g1最大的特点就是它对对内存的划分模式和之前的所有垃圾回收器都不一样，之前谈到过是基于分代回收，会把堆空间分为新生代和老年代，1：3，它会进行整个进行物理划分，分为两个模块，而G1呢，是直接将整个堆空间切成一个一个的小内存，而不像之前切成两份，\",\"每个小内存的大小相等，把一个豆腐切成小块，一个小块叫做一个region区域，虽然不像一切一刀切成两半，但是他还保存了新生代和老年代的概念，其实就是说每个region他都是属于新生代或者老年代的，这样呢，只不过每个region是一快一块的，所以说整个新生代可能不是一块连续的物理地址，而是各个region块组成的新生代，老年代同样如此，总结就是取消了物理的分代，而是将堆内存划分为多个大小相等的region区域，每个region通过组合来形成代。\",\"g1最大的特点就是可以设置一个垃圾回收的停顿的一个预期时间，比如说我们可以制定她在一个小时内发生stw时间不超过一分钟。\",\"region就是一块内存空间，它就可能会产生垃圾，所以说每个region都可能会产生垃圾他都是回收的目标，所以说每个都维护了一个隐藏属性，被称为回收价值，回收价值就是说根据region内部垃圾的一个比率，对象存活率，回收的一个预期时间等等进行评估得到一个指数，那g1呢，通过跟踪每个region块的回收价值，这样就可以尽可能的把垃圾回收造成影响控制在一个可控范围内，同时呢，尽量在有限的时间内回收更多的垃圾。之前物理划分的时候，你肯定就是回收整个代码，你不能说cms进行回收的时候，只回收一部分，它会扫描整个老年代，而g1可以跟踪region的价值，组合一些region，比如我这次要回收新生代，我就组合一些最有回收价值的region，对它进行回收，而不是对整个内存进行回收，时间优势是建立在逻辑分代上。\",\"而且每个region是动态变化的，它既可以是新生代，也可能是老年代，刚开始的时候都不属于，是空白的，然后就会将region分为新生代，新生代在做垃圾回收的时候，采用的是复制算法，复制算法会把整个区域内的对象拷贝走，再将整个区域清空，清空之后呢，整个区域就可能被选为老年代，所以说g1对象内存模型中，region所属的年龄是动态变化的，新生代和老年代的区域也是在动态变化的，这一切都是g1进行的自动控制的，所以到这呢，g1就没有新生代多少空间，老年代多少空间。这个概念了。\"]},\"750\":{\"h\":\"19、g1的工作流程是怎么样的，详细展开\",\"t\":[\"详情\",\"新生代：\",\"默认2048个region，数量-新生代-5%，100个（8eden：2surivior）\",\"新生代的region占比到达60%进行垃圾回收，复制算法-stw，200ms\",\"晋升老年代：经过多次复制后达到年龄阈值；动态年龄判断\",\"g1提供称为humongous的region区去存放大对象\",\"老年代：老年代的region占比到达45%-900多个触发混合回收（humongous、新生代、老年代垃圾回收）- 复制算法，\",\"初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\",\"并发标记： 新增对象，发生引用关系变化 - 原始快照 - 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\",\"最终标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\",\"混合回收： 计算各个region区域的回收价值，然后stw，选择新生代、老年代、大对象的最具回收价值，通过复制算法进行回收\",\"分多次做完：比如一次要回收240个region，会分八次，避免回收时间过长\"]},\"751\":{\"h\":\"20、CMS和G1有什么区别\",\"t\":[\"CMS和G1有什么区别/为什么要引入G1？\",\"为什么有了 CMS，为什么还要引入 G1？\",\"优点：CMS 最主要的优点在名字上已经体现出来——并发收集、低停顿。\",\"缺点：CMS 同样有三个明显的缺点。\",\"Mark Sweep 算法会导致内存碎片比较多\",\"CMS 的并发能力比较依赖于 CPU 资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。\",\"并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。\",\"G1 主要解决了内存碎片过多的问题\",\"CMS和G1有什么区别：\",\"内存布局：CMS是只针对老年代的，也是基于分代回收，而G1则是使用Region块，是针对整个对空间，没有分代的概念，G1-垃圾第一，动态地选择垃圾最多的区域进行回收，以达到更好的垃圾回收效果。\",\"回收过程：CMS会产生内存碎片，需要搭配serial old使用，而G1不会。\"]},\"752\":{\"h\":\"21、垃圾收集器应该如何选择？\",\"t\":[\"垃圾收集器应该如何选择？\",\"基于垃圾收集器的特点：\",\"Serial ：如果应用程序有一个很小的内存空间（大约 100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。\",\"Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受 1 秒或更长的停顿时间。\",\"CMS/G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约 1 秒以内。\",\"ZGC：如果响应时间是高优先级的，或者堆空间比较大。\"]},\"753\":{\"h\":\"三、类加载\"},\"754\":{\"h\":\"1、类加载过程和类的生命周期\",\"t\":[\"详情\",\"一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段\",\"加载 、链接（验证、准备、解析）、初始化 、使用、卸载。\",\"加载：\",\"通过一个类的全限定名获取该类的二进制流。\",\"将该二进制流中的静态存储结构转化为方法去运行时数据结构。\",\"在内存中生成该类的 Class 对象，作为该类的数据访问入口。\",\"验证：确保 Class 文件的字节流中的信息不回危害到虚拟机\",\"文件格式验证：验证字节流是否符合 Class 文件的规范，如 主次版本号是否在当前虚拟机范围内，常量池中的常量是否 有不被支持的类型.\",\"元数据验证：对字节码描述的信息进行语义分析，如这个类是 否有父类，是否集成了不被继承的类等。\",\"字节码验证：是整个验证过程中最复杂的一个阶段，通过验 证数据流和控制流的分析，确定程序语义是否正确，主要针 对方法体的验证。如：方法中的类型转换是否正确，跳转指 令是否正确等。\",\"符号引用验证：这个动作在后面的解析过程中发生，主要是 为了确保解析动作能正确执行。\",\"准备：为类的静态变量分配内存并将其初始化为默认值，这些 内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆 中。\",\"public static int value=123;//在准备阶段 value 初始值为 0 。在初始化阶段才会变为 123 。 \",\"解析：将符号引用到直接引用的转换动作。解析动作并不一 定在初始化动作完成之前，也有可能在初始化之后。\",\"初始化：前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，这里就是我们自己的主场了，这里才真正开始执行类中定义的 Java 程序代码（静态代码块）。\"]},\"755\":{\"h\":\"2、哪些时候会触发类加载？\",\"t\":[\"详情\",\"类加载是Java虚拟机在运行时将类的字节码文件加载到内存中并转化为可执行的类对象的过程。类加载可以在以下情况下触发：\",\"首次访问类： 当程序首次访问一个类时，如果该类还没有被加载到内存中，就会触发类加载。这包括通过new关键字创建对象、调用静态方法、访问静态变量等操作。\",\"类继承关系： 当一个类继承自另一个类，子类在首次被访问时，父类也会被加载。同样，接口的实现类也会在首次被访问时加载。\",\"类引用： 如果在代码中通过类名引用了某个类的静态成员（如静态方法、静态变量），这会触发类的加载。\",\"显式调用： 可以使用Class.forName()方法显式地加载一个类。\",\"反射： 使用Java的反射机制，如Class.forName()、ClassLoader.loadClass()等方法，可以在运行时加载类。\",\"初始化子类： 如果一个类的子类初始化了，父类也会被初始化。\",\"启动类加载器： Java虚拟机的启动类加载器会加载Java标准库的类，以及其他被虚拟机认为是基础类的类。\",\"需要注意的是，并不是所有的类在程序启动时都会被加载，而是根据类的访问情况和程序的运行情况来动态地加载。加载的类会经过加载、连接（验证、准备、解析）和初始化等阶段，最终生成可执行的类对象，供程序运行时使用。\"]},\"756\":{\"h\":\"3、类加载器有哪些\",\"t\":[\"你知道的类加载器有哪些？\",\"主要有四种类加载器:\",\"启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。\",\"扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。\",\"系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。\",\"用户自定义类加载器 (user class loader)，用户通过继承 java.lang.ClassLoader 类的方式自行实现的类加载器。\"]},\"757\":{\"h\":\"4、创建对象有几种方式？\",\"t\":[\"创建一个Java对象有几种方式？\",\"new、反射获取className -> Class对象、克隆（深拷贝）、序列化和反序列化\"]},\"758\":{\"h\":\"5、什么是双亲委派机制\",\"t\":[\"什么是双亲委派机制？为什么要使用？\",\"双亲委派模型的工作过程：\",\"如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。\",\"为什么要使用：\",\"为了保证应用程序的稳定有序。\",\"例如类 java.lang.Object，它存放在 rt.jar 之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证 Object 的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类。\",\"好处：\",\"安全性： 使用双亲委派机制可以防止恶意类替换系统核心类，因为核心类通常由启动类加载器加载，而用户自定义的类由应用类加载器加载，这样恶意类无法通过类加载器的层次结构来替代核心类。\",\"类的隔离性： 双亲委派机制可以确保不同的类加载器加载不同的类，从而实现类的隔离，避免了类的冲突和混淆。\",\"重用性： 可以有效地利用已加载的类，减少内存占用和性能开销，因为父加载器加载的类对子加载器是可见的，但子加载器加载的类对父加载器不可见。\",\"坏处：\",\"限制性： 双亲委派机制会限制某些特定的类加载需求，比如一些应用可能需要在运行时动态加载一些类，而这在双亲委派机制下可能变得复杂。\",\"热更新问题： 在某些场景下，如热更新，可能需要打破双亲委派机制，导致一些类加载冲突和安全性问题。\",\"性能开销： 双亲委派机制可能在类加载过程中引入一些性能开销，因为需要逐级向上查找父加载器是否已加载该类。\"]},\"759\":{\"h\":\"6、打破双亲委派怎么操作\",\"t\":[\"打破双亲委派怎么操作？有什么具体案例？\",\"打破双亲委派机制意味着在自定义类加载器中实现一种类加载机制，不再严格遵循传统的双亲委派模型。这可以通过继承ClassLoader类并重写loadClass方法来实现。在重写的方法中，可以根据自定义的逻辑来加载类，而不是一味地向上委托给父加载器。\",\"Tomcat打破双亲委派机制主要是为了解决类加载隔离和动态模块化的问题。Tomcat是一个Servlet容器，用于运行Java Web应用程序，每个Web应用程序都有自己的类加载器，它们可以独立加载和管理各自的类库。这种隔离性是非常重要的，因为不同的Web应用程序可能使用不同版本的类库，如果不进行隔离，可能会出现类冲突和版本不兼容的问题。\",\"在传统的双亲委派机制下，类加载器在加载类时会委托给父类加载器去尝试加载，这可能会导致类库的冲突，特别是在多个Web应用程序同时运行的情况下。为了解决这个问题，Tomcat引入了自定义的类加载机制，具体体现在以下几个方面：\",\"Web应用程序的类加载器隔离： 每个Web应用程序都有自己的类加载器，它们之间是相互隔离的，不会互相影响。这意味着每个Web应用程序可以独立加载和管理它所需的类库，从而避免了类冲突和版本不一致的问题。\",\"打破双亲委派： Tomcat打破了双亲委派机制，即在加载Web应用程序的类时，不再委托给父类加载器。这样做的目的是让每个Web应用程序可以自己控制类的加载过程，不受其他Web应用程序的影响。\",\"Common类加载器： Tomcat引入了一个称为Common类加载器的特殊类加载器，用于加载Tomcat本身的类库，这些类库是所有Web应用程序共享的。这样可以减少重复加载，提高资源利用率。\",\"每个应用都有自己的类加载器，优先使用自己的，再引入一个公共类加载器加载tomcat本身的\",\"总的来说，Tomcat打破双亲委派机制是为了在Servlet容器中实现类加载的隔离性，确保每个Web应用程序都能独立加载和管理类库，避免类冲突和版本不兼容的问题。\"]},\"760\":{\"h\":\"7、Tomcat 的类加载机制\",\"t\":[\"Tomcat 的类加载机制了解吗？\",\"Tomcat 实际上也是破坏了双亲委派模型的。\",\"Tomact 是 web 容器，我们可以在tomcat的webapp目录下面部署多个应用程序。但是不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。\",\"如多个应用都要依赖 mysql-connecter.jar，但是 A 应用需要依赖 5.0 版本，但是 B 应用需要依赖 5.7 版本。这两个版本中都有一个类是 com.mysql.jdbc.Driver。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。\",\"所以，Tomcat 破坏了双亲委派原则，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。每一个 WebAppClassLoader 负责加载本身的目录下的 class 文件，加载不到时再交 CommonClassLoader 加载，这和双亲委派刚好相反。\",\"在每个应用程序的WEB-INF/lib目录下放置应用程序所需的第三方类库，这些类库只对该应用程序可见，避免了全局类库版本冲突。\",\"使用WEB-INF/classes目录放置应用程序的自定义类。\"]},\"761\":{\"h\":\"四、JVM调优\"},\"762\":{\"h\":\"1、常用的命令行性能监控和故障处理工具\",\"t\":[\"有哪些常用的命令行性能监控和故障处理工具？\",\"操作系统工具：\",\"top：显示系统整体资源使用情况\",\"vmstat：监控内存和 CPU\",\"iostat：监控 IO 使用\",\"netstat：监控网络使用\",\"JDK 性能监控工具：\",\"jps：虚拟机进程查看\",\"jstat：虚拟机运行时信息查看\",\"jinfo：虚拟机配置查看\",\"jmap：内存映像（导出）\",\"jhat：堆转储快照分析\",\"jstack：Java 堆栈跟踪\",\"jcmd：实现上面除了 jstat 外所有命令的功能\"]},\"763\":{\"h\":\"2、常用的可视化的性能监控和故障处理工具\",\"t\":[\"你了解哪些可视化的性能监控和故障处理工具？\",\"JDK自带：\",\"JConsole：可以查询线程的数量、CPU负载/占用率、类加载数量等\",\"VisualVM：可以实时监控应用程序的性能指标，查看堆内存、线程、垃圾回收等信息，并进行分析和诊断。\",\"Java Mission Control：用于生产环境的性能调优和故障排查。提供了诸多插件和功能，可用于分析JVM性能、垃圾回收、代码热点等。\"]},\"764\":{\"h\":\"3、JVM 的常见参数配置\",\"t\":[\"JVM 的常见参数配置知道哪些？\",\"堆配置：\",\"-Xms：初始堆大小\",\"-Xms：最大堆大小\",\"-XX:NewSize=n：设置年轻代大小\",\"-XX:NewRatio=n：设置年轻代和年老代的比值。如：为 3 表示年轻代和年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4\",\"-XX:SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如 3 表示 Eden： 3 Survivor：2，一个 Survivor 区占整个年轻代的 1/5\",\"-XX:MaxPermSize=n：设置持久代大小\",\"收集器设置：\",\"-XX:+UseSerialGC：设置串行收集器\",\"-XX:+UseParallelGC：设置并行收集器\",\"-XX:+UseParalledlOldGC：设置并行年老代收集器\",\"-XX:+UseConcMarkSweepGC：设置并发收集器\",\"并行收集器设置\",\"-XX:ParallelGCThreads=n：设置并行收集器收集时使用的 CPU 数。并行收集线程数\",\"-XX:MaxGCPauseMillis=n：设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）\",\"-XX:GCTimeRatio=n：设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n)\",\"-XX:+CMSIncrementalMode：设置为增量模式。适用于单 CPU 情况\",\"-XX:ParallelGCThreads=n：设置并发收集器年轻代手机方式为并行收集时，使用的 CPU 数。并行收集线程数\",\"打印 GC 回收的过程日志信息\",\"-XX:+PrintGC\",\"-XX:+PrintGCDetails\",\"-XX:+PrintGCTimeStamps\",\"-Xloggc:filename\"]},\"765\":{\"h\":\"4、线上服务 CPU 占用过高怎么排查\",\"t\":[\"线上服务 CPU 占用过高怎么排查？\",\"问题分析：CPU 高一定是某个程序长期占用了 CPU 资源。\",\"先需要找出那个进程占用 CPU 高。\",\"top 列出系统各个进程的资源占用情况。\",\"然后根据找到对应进行里哪个线程占用 CPU 高。\",\"top -Hp 进程id 列出对应进程里面的线程占用资源情况\",\"找到对应线程 ID 后，再打印出对应线程的堆栈信息\",\"printf \\\"%x\\\\n\\\" PID 把线程 ID 转换为 16 进制。\",\"jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为 16 进制的线程 ID 对应的线程信息。\",\"最后根据线程的堆栈信息定位到具体业务方法，从代码逻辑中找到问题所在。\",\"查看是否有线程长时间的 watting 或 blocked，如果线程长期处于 watting 状态下， 关注 watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。\"]},\"766\":{\"h\":\"5、内存飙高问题怎么排查\",\"t\":[\"内存飙高问题怎么排查？\",\"分析： 内存飚高如果是发生在 java 进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收\",\"先观察垃圾回收的情况\",\"jstat -gc PID 1000 查看 GC 次数，时间等信息，每隔一秒打印一次。\",\"jmap -histo PID | head -20 查看堆内存占用空间最大的前 20 个对象类型,可初步查看是哪个对象占用了内存。\",\"如果每次 GC 次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；\",\"如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。\",\"导出堆内存文件快照 \",\"jmap -dump:live,format=b,file=/home/myheapdump.hprof PID dump 堆内存信息到文件。\",\"使用 visualVM 对 dump 文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。\"]},\"767\":{\"h\":\"6、频繁 minor gc\",\"t\":[\"频繁 minor gc 怎么办？\",\"频繁 minor gc：\",\"内存空间真不足： \",\"可能是真不足，那就增大新生代空间-Xmn来降低 Minor GC 的频率，其次可以查看代码优化对象的生命周期，尽量减少对象的创建和短暂存活，如对象重用、缓存等方式。\",\"内存泄漏导致空间不足：使用内存分析工具（如VisualVM、JVisualVM）分析内存使用情况，查看内存泄漏或不合理的对象创建，再定位到代码去查看。\",\"分析是否有同类型对象频繁晋升到老年代：优化代码，减少对象的长期存活时间，减少对象晋升到老年代的情况。\",\"垃圾收集器不行：换一个，不同的垃圾收集器对于Minor GC的触发条件和机制可能略有不同，选择不合适的垃圾收集器可能导致过于频繁的Minor GC。\"]},\"768\":{\"h\":\"7、频繁 full gc\",\"t\":[\"频繁 full gc 怎么办？\",\"排查有哪些原因导致 Full GC？\",\"大对象：系统一次性加载了过多数据到内存中（比如 SQL 查询未做分页），导致大对象进入了老年代。\",\"内存泄漏：频繁创建了大量对象，但是无法被回收（比如 IO 对象使用完后未调用 close 方法释放资源），先引发 FGC，最后导致 OOM.\",\"程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发 FGC. （即本文中的案例）\",\"程序 BUG\",\"代码中显式调用了 gc方法，包括自己的代码甚至框架中的代码。\",\"JVM 参数设置问题：包括总内存大小、新生代和老年代的大小、Eden 区和 S 区的大小、元空间大小、垃圾回收算法等等。\",\"清楚排查问题时能使用哪些工具\",\"公司的监控系统：大部分公司都会有，可全方位监控 JVM 的各项指标。\",\"JDK 的自带工具，包括 jmap、jstat 等常用命令：\",\"# 查看堆内存各区域的使用率以及GC情况 jstat -gcutil -h20 pid 1000 # 查看堆内存中的存活对象，并按空间排序 jmap -histo pid | head -n20 # dump堆内存文件 jmap -dump:format=b,file=heap pid \",\"可视化的堆内存分析工具：JVisualVM、MAT 等\",\"排查指南\",\"查看监控，以了解出现问题的时间点以及当前 FGC 的频率（可对比正常情况看频率是否正常）\",\"了解该时间点之前有没有程序上线、基础组件升级等情况。\",\"了解 JVM 的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析 JVM 参数设置是否合理。\",\"再对步骤 1 中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用 gc 方法比较容易排查。\",\"针对大对象或者长生命周期对象导致的 FGC，可通过 jmap -histo 命令并结合 dump 堆内存文件作进一步分析，需要先定位到可疑对象。\",\"通过可疑对象定位到具体代码再次分析，这时候要结合 GC 原理和 JVM 参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。\"]},\"769\":{\"h\":\"8、如何定位内存泄漏问题\",\"t\":[\"如何定位内存泄漏问题？\",\"内存泄漏是内在病源，外在病症表现可能有：\",\"应用程序长时间连续运行时性能严重下降\",\"CPU 使用率飙升，甚至到 100%\",\"频繁 Full GC，各种报警，例如接口超时报警等\",\"应用程序抛出 OutOfMemoryError 错误\",\"应用程序偶尔会耗尽连接对象\",\"严重内存泄漏往往伴随频繁的 Full GC，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：\",\"1）使用 jps 查看运行的 Java 进程 ID\",\"2）使用top -p [pid] 查看进程使用 CPU 和 MEM 的情况\",\"3）使用 top -Hp [pid] 查看进程下的所有线程占 CPU 和 MEM 的情况\",\"4）将线程 ID 转换为 16 进制：printf \\\"%x\\\\n\\\" [pid]，输出的值就是线程栈信息中的 nid。\",\"例如：printf \\\"%x\\\\n\\\" 29471，换行输出 731f。\",\"5）抓取线程栈：jstack 29452 > 29452.txt，可以多抓几次做个对比。\",\"在线程栈信息中找到对应线程号的 16 进制值，如下是 731f 线程的信息。线程栈分析可使用 Visualvm 插件 TDA。\",\"\\\"Service Thread\\\" #7 daemon prio=9 os_prio=0 tid=0x00007fbe2c164000 nid=0x731f runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE \",\"6）使用jstat -gcutil [pid] 5000 10 每隔 5 秒输出 GC 信息，输出 10 次，查看 YGC 和 Full GC 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。\",\"或使用 jstat -gccause [pid] 5000 ，同样是输出 GC 摘要信息。\",\"或使用 jmap -heap [pid] 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。\",\"7）如果发现 Full GC 次数太多，就很大概率存在内存泄漏了\",\"8）使用 jmap -histo:live [pid] 输出每个类的对象数量，内存大小(字节单位)及全限定类名。\",\"9）生成 dump 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了\",\"使用 jmap 生成 dump 文件：\",\"# jmap -dump:live,format=b,file=29471.dump 29471 Dumping heap to /root/dump ... Heap dump file created \",\"10）dump 文件分析\",\"可以使用 jhat 命令分析：jhat -port 8000 29471.dump，浏览器访问 jhat 服务，端口是 8000。\",\"通常使用图形化工具分析，如 JDK 自带的 jvisualvm，从菜单 > 文件 > 装入 dump 文件。\",\"或使用第三方式具分析的，如 JProfiler 也是个图形化工具，GCViewer 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 GCEasy。\",\"注意：如果 dump 文件较大的话，分析会占比较大的内存。\",\"11）在 dump 文析结果中查找存在大量的对象，再查对其的引用。\",\"基本上就可以定位到代码层的逻辑了。\"]},\"770\":{\"h\":\"9、如何定位内存溢出问题\",\"t\":[\"如何定位内存溢出问题？\",\"内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。\",\"排查过程和排查内存泄漏过程类似。\"]},\"771\":{\"c\":[\"面经收藏\"]},\"772\":{\"h\":\"Java基础-面试题\"},\"773\":{\"h\":\"1、基本类型和包装类型的区别\",\"t\":[\"基本类型和包装类型的区别？\",\"1、基本类型和包装类型的区别？\",\"相同点：都可以用作变量，无论是方法传递的参数还是当中成员变量\",\"不同点：\",\"一个是基础数据类型，一个是引用数据类型 \",\"存储方式不同： \",\"基本类型：一般作为参数和代码块内的局部变量 - 栈的局部变量表中，如果是成员变量 - 堆，static修饰的 - 方法区\",\"引用数据类型：堆，static修饰的 - 方法区\",\"所占的空间大小也不同：\",\"初始化的默认值也不同：\",\"比较方式也不同：\",\"包装类的自动拆装箱：从字节码中，我们发现装箱其实就是调用了包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。\"]},\"774\":{\"h\":\"2、包装类的缓存机制\",\"t\":[\"包装类的缓存机制？\",\"2、包装类的缓存机制？\",\"Integer：-128 ~ 127\",\"Boolean：true / false\",\"Character：127 <=\",\"两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。\"]},\"775\":{\"h\":\"3、成员变量与局部变量的区别\",\"t\":[\"成员变量与局部变量的区别？\",\"3、成员变量与局部变量的区别？\",\"位置区别：成员变量 - 类里面，与方法同级；局部变量 - 方法内部 \",\"成员变量可以使用public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。\",\"存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，位于方法区，，如果没有使用 static 修饰，这个成员变量是属于实例的，存放在堆。局部变量则存在于栈内存的局部变量表。\",\"默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\",\"生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。\"]},\"776\":{\"h\":\"4、静态变量有什么作用\",\"t\":[\"静态变量有什么作用？\",\"4、静态变量有什么作用？\",\"static 的主要作用是使成员变量或方法与类关联，而不是与类的实例关联。\",\"这意味着它们可以在没有创建类的实例的情况下被访问和调用。同时，静态成员也可以被所有该类的实例共享，可以用于存储类级别的信息，比如计数器、常量等。\",\"静态变量只会被分配一次内存，即使创建多个对象，它们都共享同一份静态变量，这样可以节省内存。\",\"可以通过类名访问，可以搭配final关键字，做常量\"]},\"777\":{\"h\":\"5、字符型常量和字符串常量的区别\",\"t\":[\"字符型常量和字符串常量的区别?\",\"5、字符型常量和字符串常量的区别?\",\"形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。\",\"含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。\",\"占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。\",\"⚠️ 注意 char 在 Java 中占两个字节。\"]},\"778\":{\"h\":\"6、静态方法为什么不能调用非静态成员\",\"t\":[\"静态方法为什么不能调用非静态成员?\",\"6、静态方法为什么不能调用非静态成员?\",\"这个需要结合 JVM 的相关知识，主要原因如下：\",\"静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。\",\"在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。\"]},\"779\":{\"h\":\"7、静态方法和实例方法有何不同\",\"t\":[\"静态方法和实例方法有何不同？\",\"7、静态方法和实例方法有何不同？\",\"形式：静态方法 - static修饰，是属于类的，每个类就一份，在类加载的时候就会分配内存，可以通过类名直接访问，实例方法需要创建对应的实例对象才能调用，多个实例对象都有各自的实例方法。\",\"调用方式：静态方法 - 类名点进行调用，实例方法需要创建实例对象，然后实例对象点进行调用\",\"访问限制的区别：静态只能调用静态，实例都可以调用\",\"生命周期：静态方法的生命周期和类相关，而实例方法与对应实例相关\"]},\"780\":{\"h\":\"8、重载和重写有什么区别\",\"t\":[\"重载和重写有什么区别？\",\"8、重载和重写有什么区别？\",\"共同点：\",\"都涉及到方法：重载和重写都与方法相关，可以在类中定义多个方法，它们的方法名相同但参数列表不同。\",\"都是多态的体现：重载和重写都是Java中多态的实现方式之一。多态是指同一个方法名可以在不同的类或者同一个类的不同方法中以不同的方式实现。 \",\"重载一个类中可以有多个同名方法。\",\"重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。\",\"不同点：\",\"适用范围不同： \",\"重载（Overloading）指的是在同一个类中可以定义多个方法，它们的方法名相同但参数列表不同（参数的个数、类型、顺序不同），重载可以发生在同一个类中。\",\"重写（Overriding）指的是子类可以定义与父类中同名、同参数列表的方法，用于覆盖父类中的方法，重写只发生在子类覆盖父类的方法的情况下。\",\"方法签名不同： \",\"对于重载，方法名相同但参数列表必须不同（参数类型、个数、顺序）。\",\"对于重写，方法名、参数列表必须相同，返回类型可以是子类的类型或者其子类型。\",\"返回类型： \",\"对于重载，返回类型可以相同也可以不同，但是方法的参数列表必须不同。\",\"对于重写，返回类型必须相同或是其子类。\",\"运行时行为： \",\"对于重载，方法调用的解析在编译时发生，根据传入的参数类型来决定调用哪个方法。\",\"对于重写，方法的调用在运行时通过动态绑定（动态分派）发生，根据实际对象的类型来决定调用哪个方法。\"]},\"781\":{\"h\":\"9、面向对象和面向过程的区别\",\"t\":[\"面向对象和面向过程的区别？\",\"9、面向对象和面向过程的区别？\",\"面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\",\"面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\",\"具体：例如平常一个人自己一个人要吃饭，需要买菜，洗菜，做饭，这个吃饭的过程，拆分为一个一个行为，一个个方法\",\"而面向对象的话，就比如我们有了女朋友，再吃饭，我们可以把直接抽出为一个对象，我们还是要经过买菜，洗菜，做饭，这个吃饭的过程，我们把这些流程封装为对应的方法，女朋友要吃饭的时候可以之间调用我来进行做饭，可以体会到我的好处\"]},\"782\":{\"h\":\"10、面向对象三大特征\",\"t\":[\"面向对象三大特征？\",\"10、面向对象三大特征？\",\"封装、继承、多态：\",\"封装：把成员变量和具体的方法执行逻辑封装到一个具体类里面，以后的编码过程无需再关心对象内部的执行过程，而只面向这个对象本身，我们只需要知道这个对象可以为我提供便利，为我办事，这也就是基于面向对象编程的基础。\",\"继承：核心目的就是用于实现代码的复用，通过继承，子类可以复用父类的方法，并可以通过super关键字直接调用，当然也能重写父类的方法，形成一种多态。当然继承也不是非常好的，如果我们一种使用继承，会使得类过于庞大，类结构过于复杂，所以我们也可以通过组合的方式来实现代码复用，可以把一个类当作成员变量给另一个类进行组合使用，组合优于继承\",\"组合： \",\"松耦合，更灵活：组合可以降低类之间的耦合度。通过将对象作为成员变量引入，类之间的关系更加灵活，可以随时替换成员变量的实现，而不会影响其他部分的代码。\",\"更好的封装：通过组合，可以选择性地暴露对象的接口，从而更好地控制访问权限，避免不必要的继承导致的公共接口的暴露。\",\"多态，顾名思义，表示一个对象具有多种的状态，就比如我们传入的参数是一个父类，那么其子类也能接收，又或者是一个接口有多个实现类。\",\"多态具体实现：有继承（接口、抽象类、类）、有重写、有父类引用执行子类对象。\"]},\"783\":{\"h\":\"11、接口和抽象类有什么共同点和区别\",\"t\":[\"接口和抽象类有什么共同点和区别\",\"11、接口和抽象类有什么共同点和区别？\",\"接口和抽象类是Java中两种用于实现多态性和封装的重要概念：\",\"共同点：\",\"接口和抽象类都不能被实例化，不能通过new关键字进行实例化。\",\"接口和抽象类都可以包含抽象方法，没有方法体的方法。\",\"都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。\",\"区别：\",\"抽象类是一个类，使用abstract class，并且的抽象方法需要使用abstract修饰，而接口是使用interface修饰，接口的抽象方法，默认就是抽象，不需要添加abstract。\",\"对应抽象类而言，抽象类可以继承一个类，也可以实现接口，但是只能继承一个，但却可以实现多个，而接口只能继承，但是接口可以继承多个接口。\",\"接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。\",\"抽象类可以有构造器，而接口没有，当继承自抽象类的自己进行实例化时，会调用父类的构造器进行父类的初始化\",\"接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。\"]},\"784\":{\"h\":\"12、深拷贝和浅拷贝区别了解吗\",\"t\":[\"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\",\"12、深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\",\"深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象，得到的是一个全新的对象。\",\"浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），只拷贝当前对象，如果当前对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。\",\"引用拷贝： 简单来说，引用拷贝就是两个不同的引用指向同一个对象。\"]},\"785\":{\"h\":\"13、Object 类的常见方法有哪些\",\"t\":[\"Object 类的常见方法有哪些？\",\"13、Object 类的常见方法有哪些？\",\"11个常用方法：\",\"/** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */ public final native Class<?> getClass() /** * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。 */ public native int hashCode() /** * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。 */ public boolean equals(Object obj) /** * native 方法，用于创建并返回当前对象的一份拷贝。 */ protected native Object clone() throws CloneNotSupportedException /** * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。 */ public String toString() /** * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。 */ public final native void notify() /** * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 */ public final native void notifyAll() /** * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。 */ public final native void wait(long timeout) throws InterruptedException /** * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。 */ public final void wait(long timeout, int nanos) throws InterruptedException /** * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 */ public final void wait() throws InterruptedException /** * 实例被垃圾回收器回收的时候触发的操作 */ protected void finalize() throws Throwable { } \"]},\"786\":{\"h\":\"14、== 和 equals() 的区别\",\"t\":[\"== 和 equals() 的区别\",\"14、== 和 equals() 的区别？\"]},\"787\":{\"h\":\"15、什么是hashCode()\",\"t\":[\"什么是hashCode()？ 为什么要有hashCode()？那为什么不只提供 `hashCode()` 方法呢？那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？\",\"hashCode() 是 Java 中 Object 类的一个方法，用于返回对象的哈希码值。哈希码是一个整数，它代表了对象在内存中的地址或者说是对象的标识符。每个对象都有一个唯一的哈希码，即使它们的内容相同，哈希码也会不同。\",\"hashCode() 方法的存在是为了支持基于哈希表的数据结构，例如 HashMap 或 HashSet。这些数据结构在查找、插入等操作时依赖于哈希码来确定对象的存储位置，从而提高了操作的效率，而且先检验hashCode，这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\",\"虽然 hashCode() 方法对于基于哈希表的数据结构非常重要，但它仅仅是一个计算哈希码的方法，不提供确切的对象比较。实际上，在哈希表中，可能会出现不同对象具有相同哈希码的情况，这称为哈希冲突。因此，还需要提供 equals() 方法来确切地比较两个对象是否相等。\",\"两个对象具有相同的 hashCode 值，这意味着它们在哈希表中可能会被放置到相同的位置。然而，哈希码只是一个指示，它并不一定能够唯一地标识一个对象。因此，即使两个对象的哈希码相同，它们的内容也可能是不同的，这种情况称为哈希码冲突。 \",\"因为hashCode()可以重写，假如我们有一个学生类，有两个属性id和name，我们重写hashCode，把id当hashCode，他们id全是1，但是姓名却不同，这样虽然hashCode相等，但是equals却不相等。\",\"总的来说，hashCode() 提供了一种快速确定对象存储位置的方法，但它并不能保证对象的唯一性。因此，仍然需要使用 equals() 方法来确切地比较两个对象是否相等。\"]},\"788\":{\"h\":\"16、为什么重写 equals() 时必须重写 hashCode() 方法\",\"t\":[\"为什么重写 equals() 时必须重写 hashCode() 方法？\",\"16、为什么重写 equals() 时必须重写 hashCode() 方法？\",\"equals() 和 hashCode() 分别用于不同的目的：\",\"equals() 用于确切地比较两个对象的内容是否相等。\",\"hashCode() 用于在哈希表等数据结构中确定对象的存储位置，以提高查找和插入的效率。\",\"重写 equals() 方法时，必须同时重写 hashCode() 方法的原因是：\",\"hashCode() 和 equals() 是在哈希表等数据结构中配套使用的。在使用哈希表时，首先会根据对象的 hashCode() 值确定存储位置，然后再使用 equals() 方法来确切地比较对象是否相等。\",\"如果两个对象在 equals() 方法中被认为相等，那么它们的 hashCode() 值也必须相等，以确保它们在哈希表中的存储位置一致，否则会导致对象在哈希表中无法正确地被检索。\",\"总的来说，重写 equals() 方法时也要重写 hashCode() 方法，以保证对象在哈希表等数据结构中的正确性和性能。\",\"17、重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap 可能会出现什么问题\",\"写 `equals()` 时没有重写 `hashCode()` 方法的话，使用 `HashMap` 可能会出现什么问题？\",\"17、重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap 可能会出现什么问题？\",\"如果在使用 HashMap 或其他基于哈希表的数据结构时，重写了 equals() 方法但没有重写 hashCode() 方法，可能会导致以下问题：\",\"hashCode() 相等，但 equals() 不相等。\",\"这会导致两个对象在哈希表中被放置到相同的位置，但由于 equals() 返回 false，它们被认为不相等。这将导致在查找时无法正确地找到相等的对象。\",\"hashCode() 不相等，但 equals() 相等。\",\"这会导致两个对象在哈希表中被放置到不同的位置，但由于 equals() 返回 true，它们被认为相等。这将导致在查找时无法正确地找到相等的对象。\",\"这两种情况都会破坏了哈希表的正确性和性能。因此，在实现自定义类时，通常需要同时重写 hashCode() 和 equals() 方法，以确保正确的行为。\",\"哈希冲突：由于没有重写 hashCode() 方法，对象的哈希码将由默认的 Object 类的实现决定，这可能导致相同内容的对象具有不同的哈希码，从而产生哈希冲突。这会影响到对象在哈希表中的存储位置。\",\"无法正确地检索对象：如果将该对象用作哈希表的键，并且在没有正确实现 hashCode() 的情况下使用 get() 方法，可能会导致无法正确地检索对象，即使它们在逻辑上是相等的。\",\"无法正确地删除对象：在使用 remove() 方法时，由于哈希码计算错误，可能无法准确地从哈希表中删除对象。\",\"导致内存泄漏：如果使用对象作为键，但在 equals() 方法中进行了复杂的比较操作，而没有实现 hashCode() 方法，可能会导致在哈希表中无法正常释放对象，从而导致内存泄漏。\",\"总的来说，重写 equals() 方法但没有重写 hashCode() 方法可能会破坏哈希表的正确性和性能。因此，在实现自定义类并将其用作哈希表的键时，通常需要同时重写 hashCode() 和 equals() 方法，以确保正确的行为。\"]},\"789\":{\"h\":\"18、String、StringBuffer、StringBuilder 的区别\",\"t\":[\"String、StringBuffer、StringBuilder 的区别？\",\"18、String、StringBuffer、StringBuilder 的区别？\",\"String、StringBuffer 和 StringBuilder 都属于Java.lang包下的处理字符串的类\",\"区别：\",\"String 是不可变的，被final修饰了，不能被继承，同时，内部维护的是一个private final修饰的char数组，但是没有提供/暴露修改这个字符串的方法，是线程安全的。任何对 String 的操作都会返回一个新的 String 对象。\",\"StringBuffer 和StringBuilder 都继承自AbstractStringBuilder，内部维护的是char数组，是可变的，但是StringBuffer的所有方法都是synchronized修饰的同步方法，每次只能一个线程访问，是线程安全的，但StringBuilder不是线程安全的，不适合在多线程环境下使用。\",\"总结：\",\"如果在多线程环境下需要对字符串进行操作，应该使用 StringBuffer。\",\"在单线程环境下，如果需要频繁操作字符串，建议使用 StringBuilder，而在字符串内容基本不变的情况下，使用 String 即可。\",\"Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?\",\"新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，byte 占一个字节(8 位)，char 占用 2 个字节（16），byte 相较 char 节省一半的内存空间。\",\"JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。\"]},\"790\":{\"h\":\"19、字符串拼接用+还是 StringBuilder\",\"t\":[\"字符串拼接用“+” 还是 StringBuilder?\",\"19、字符串拼接用“+” 还是 StringBuilder?\",\"本质都是StringBuilder的append()方法拼接，但是用处不同：\",\"在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。\"]},\"791\":{\"h\":\"20、这句话创建了几个字符串对象\",\"t\":[\"String s1 = new String(\\\"abc\\\");这句话创建了几个字符串对象？String.intern() 方法有什么作用\",\"20、String s1 = new String(\\\"abc\\\");这句话创建了几个字符串对象？String.intern() 方法有什么作用?\",\"会创建 1 或 2 个字符串对象。\",\"1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。\",\"2、String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：\",\"如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。\",\"如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回\"]},\"792\":{\"h\":\"21、String 类型的变量和常量做+运算时发生了什么\",\"t\":[\"String 类型的变量和常量做“+”运算时发生了什么？\",\"21、String 类型的变量和常量做“+”运算时发生了什么？\",\"常量和常量：对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化 - 常量折叠。】\",\"常量和变量、变量和变量：引用的值在程序编译期是无法确定的，编译器无法对其进行优化。\",\"对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。\"]},\"793\":{\"h\":\"22、Java异常的体系介绍一下?\",\"t\":[\"Java异常的体系介绍一下 常用异常有哪些？ 说十个 处理异常主要注意什么？\",\"在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:\",\"Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为：\",\"Checked Exception (受检查异常，必须处理) - 编译时异常\",\"IOException 及其子类：\",\"FileNotFoundException\",\"IOException\",\"EOFException 等\",\"SQLException：与数据库操作相关的异常。\",\"ClassNotFoundException：当试图加载类但找不到对应的类文件时抛出。\",\"InterruptedException：当一个线程处于阻塞、等待或睡眠状态，但被另一个线程中断时抛出。\",\"CloneNotSupportedException：当试图克隆一个不支持克隆的对象时抛出。\",\"NoSuchMethodException：当试图调用一个不存在的方法时抛出。\",\"NoSuchFieldException：当试图访问一个不存在的字段时抛出。\",\"InstantiationException 和 IllegalAccessException：通常与反射相关，当试图实例化一个抽象类、接口或私有构造函数时抛出。\",\"ParseException：通常与日期解析相关，当无法解析字符串为指定格式的日期时抛出。\",\"MalformedURLException：当试图创建一个URL实例，但提供的URL格式不正确时抛出。\",\"Unchecked Exception (不受检查异常，可以不处理) - 运行时异常\",\"RuntimeException 及其子类都统称为非受检查异常\",\"ArithmeticException（算术错误）\",\"NullPointerException(空指针错误)\",\"ClassCastException（类型转换错误）\",\"ArrayIndexOutOfBoundsException（数组越界错误）\",\"IllegalArgumentException(参数错误比如方法入参类型错误)\",\"NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）\",\"SecurityException （安全错误比如权限不够）\",\"UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)\",\"Error：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。\",\"OutOfMemoryError：当JVM耗尽了可用的内存资源时抛出，导致无法继续执行程序。\",\"StackOverflowError：当一个线程递归调用的深度超过了JVM所能处理的范围时抛出，通常是因为调用栈溢出。\",\"NoClassDefFoundError：当试图加载类，但在运行时找不到类的定义时抛出。\",\"ExceptionInInitializerError：当一个类的静态初始化器（静态代码块）抛出异常时抛出，导致类无法被正确初始化。\",\"LinkageError：代表在链接阶段出现问题，通常是由于类版本不匹配、缺少依赖项等情况。\",\"VirtualMachineError：是所有错误的父类，用于表示与虚拟机操作有关的错误情况。\",\"AssertionError：通常由 assert 语句失败抛出，用于在测试代码中检查条件是否为真。\",\"InternalError：表示Java虚拟机发现了内部错误或不一致性。\",\"请注意，与编译时异常和运行时异常不同，Error 不是必须被捕获或抛出的，因为它们通常表示程序无法恢复的严重问题。通常情况下，最好的做法是让程序终止并记录错误信息以便调查。\",\"不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。\",\"建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。\",\"抛出 / 打印的异常信息一定要有意义。\",\"使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。\"]},\"794\":{\"h\":\"23、Throwable有哪些常用方法\",\"t\":[\"Throwable有哪些常用方法？\",\"23、Throwable有哪些常用方法？\",\"void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息\",\"String getMessage(): 返回异常发生时的简要描述\",\"String toString(): 返回异常发生时的详细信息\",\"String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同\"]},\"795\":{\"h\":\"24、try-catch-finally 使用介绍一下\",\"t\":[\"try-catch-finally 使用介绍一下\",\"24、try-catch-finally 使用介绍一下？\",\"try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\",\"catch块：用于处理 try 捕获到的异常。\",\"finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\",\"注意：不要在 finally 语句块中使用 return!\",\"当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略，但是会执行 try 语句的return代码\",\"代码示例：\",\"public static void main(String[] args) { System.out.println(f(2)); } public static int f(int value) { try { return value += 10; } finally { return value + 4; } }//输出：16 \"]},\"796\":{\"h\":\"25、finally 中的代码一定会执行吗\",\"t\":[\"finally 中的代码一定会执行吗？\",\"25、finally 中的代码一定会执行吗？\",\"finally 之前程序所在的线程死亡。\",\"finally 之前虚拟机被终止运行的话 - System.exit(1);\",\"finally 之前关闭 CPU。\"]},\"797\":{\"h\":\"26、什么是泛型\",\"t\":[\"什么是泛型？有什么作用？泛型的使用方式有哪几种？\",\"26、什么是泛型？有什么作用？泛型的使用方式有哪几种？\",\"泛型就是一种让程序能够处理各种不同类型的数据的方法。\",\"它就像一个容器，可以装不同类型的东西，但是在使用的时候，你可以告诉它具体装的是什么类型的东西，这样程序就能更加灵活和安全地处理数据。\",\"比如，你可以有一个容器，可以装数字、文字或者其他东西，但你可以在使用的时候告诉它具体装的是什么，这样就不会出现类型混乱的问题。简单来说，泛型就是让程序更聪明地处理不同类型的数据。\",\"泛型（Generics）是一种在编程中提供更强大类型安全性的特性。它允许你在代码中定义类、接口、方法等时使用一个或多个类型参数，从而实现对类型的参数化。这样可以在编译时期提供更强的类型检查，并减少了在运行时出现类型错误的可能性。\",\"泛型的作用：\",\"类型安全性: 泛型可以在编译时期检查代码，防止类型不匹配的错误。这使得代码更加健壮和可靠。\",\"代码复用: 泛型代码可以适用于多种数据类型，减少了重复编写相似代码的工作量。\",\"抽象数据类型: 泛型可以用于定义通用的数据结构和算法，如列表、栈、队列等。\",\"库的通用性: 泛型使得库能够提供通用的数据结构和算法，可以被不同的数据类型使用。\",\"泛型的使用方式有以下几种：\",\"泛型类（Generic Class）: 允许在类的定义中使用一个或多个类型参数。\",\"public class MyGenericClass<T> { private T value; public MyGenericClass(T value) { this.value = value; } public T getValue() { return value; } } \",\"泛型接口（Generic Interface）: 允许在接口的定义中使用一个或多个类型参数。\",\"public interface MyGenericInterface<T> { T performAction(T value); } \",\"泛型方法（Generic Method）: 允许在方法的定义中使用类型参数，不一定要在类或接口中定义。\",\"public <T> T myGenericMethod(T value) { // ... } \",\"泛型通配符（Wildcards）: 使用通配符来表示未知类型或者限制类型的上界或下界。\",\"public void printList(List<? extends Number> list) { // ... } \",\"总的来说，泛型提供了一种在编程中处理抽象类型的强大工具，能够在编译时期提供类型安全性，减少了运行时类型错误的可能性，同时也使得代码更具有通用性和复用性。\"]},\"798\":{\"h\":\"27、什么是反射\",\"t\":[\"什么是反射\",\"27、什么是反射？\",\"反射（Reflection）是一种在运行时动态获取类信息、调用对象方法、访问对象属性的能力。在许多编程语言中都有反射机制，例如Java、C#等。\",\"反射允许程序在运行时获取类的信息，比如类名、方法名、属性等，并且可以在运行时调用这些方法、访问这些属性。这样使得程序可以在运行时动态地进行操作，而不需要在编译时就确定好所有的类和方法。\",\"反射就是一种让程序在运行时“看见”并且操作自己的能力。就好像一个人在玩一个积木拼图游戏时，可以随时看着自己拼的图，也可以随时改变拼图的形状一样。反射让程序可以在运行时检查和修改自己的结构和行为，这让程序变得非常灵活。\"]},\"799\":{\"h\":\"27、反射的原理是什么\",\"t\":[\"反射的原理是什么？\",\"27、反射的原理是什么？\",\"反射的原理是依赖于底层虚拟机的机制的和在运行时通过反射API（例如在Java中是java.lang.reflect包）来操作程序的元信息（如类、方法、属性等）：\",\"在Java中，虚拟机会在加载类的时候生成相应的Class对象，这个对象包含了类的所有信息。反射API就是在这个基础上提供了一系列的方法来访问和操作这些信息。\",\"在运行时可以通过反射机制-反射API来获取和操作\",\"在底层，实现反射通常涉及以下几个步骤：\",\"获取类信息: 首先，程序通过类加载器加载一个类，并在内存中创建一个表示该类的Class对象。这个Class对象包含了该类的所有信息，如方法、属性等。\",\"获取成员信息: 通过Class对象可以获取到类的所有成员（字段和方法），包括公共的、私有的等。\",\"访问成员: 反射API提供了方法来访问类的成员，比如获取和设置属性的值，调用方法等。这可以绕过编译时的访问权限检查。\",\"创建对象实例: 反射可以通过Class对象来创建类的实例。\",\"调用方法: 反射可以动态地调用类的方法，包括公共的、私有的等。\",\"需要注意的是，由于反射的操作是在运行时进行的，相比直接调用代码，反射会带来一定的性能损耗。因此，在性能要求高的场景下，应该避免过度使用反射。\"]},\"800\":{\"h\":\"28、反射的应用场景有哪些\",\"t\":[\"反射的应用场景有哪些？\",\"28、反射的应用场景有哪些？\",\"动态代理: 反射可以用于创建动态代理，实现在运行时动态地生成代理类，对原有类进行增强，如动态代理设计模式。\",\"动态加载类: 可以在程序运行时动态加载一些类，例如插件系统，或者根据配置文件动态加载不同的实现。\",\"框架和库开发: 许多框架和库（比如Spring、Hibernate等）使用反射来实现各种功能，例如依赖注入、AOP、持久化等。\",\"配置文件处理: 可以通过反射来读取配置文件中的类名、方法名等信息，从而动态地创建对象或调用方法。\",\"总的来说，反射是一种非常强大的机制，可以让程序在运行时获取并操作类的信息，从而实现许多灵活和高级的功能。然而，由于反射的运行时性能开销相对较高，因此在使用时需要慎重考虑性能方面的影响。\"]},\"801\":{\"c\":[\"面经收藏\"]},\"802\":{\"h\":\"Java多线程-面试题\"},\"803\":{\"h\":\"一、基础\"},\"804\":{\"h\":\"1、程序、进程、线程\",\"t\":[\"说说你对程序、进程、线程的理解？\",\"程序：\",\"程序是一组指令集合，用来指示计算机执行特定任务的。它们以某种特定的编程语言编写，可以是像Python、Java、C++等高级语言，也可以是机器语言（二进制代码）。\",\"程序是静态的，它们只是存在于磁盘或内存中，直到被执行。\",\"进程：\",\"进程是程序的动态存在的状态，是在计算机中执行时的实例。而且一个程序同时启动多个，也就是可以同时运行多个进程，每个进程都有自己的内存空间、资源（如CPU时间、文件句柄等）和状态，就和我们的Java中类与对象实例的关系，每个进程都被独立地管理，彼此之间不会干扰。\",\"进程通常有两个任务：资源的分配和调度执行任务\",\"线程：\",\"线程和进程是紧密相关的，线程是进程的一部分，是进程内的一个独立执行单元，线程之间共享进程的内存资源，且承担调度执行的任务。而引入线程主要就是用于执行调度任务的，用来提高并发度（上下文切换开销少-地址、资源、内核的切换）。\",\"因为线程共享进程的资源，共享相同的地址空间。这种共享使得线程之间的通信更加直接和高效，可以通过共享内存等方式进行数据传递，而无需复杂的进程间通信机制。\",\"总体来说，举个不是很恰当的例子，程序就类似与我们的Java的类文件，它只有一个，是静态的文件，而进程就类似于对应类的对象实例，我们可以根据我们的类创建多个对象实例，同理一个程序可以启动多个进程，而线程是具体干活的，好比对象里面调用的方法，干不同的事情，调用不同的方法，他们之间的关系就类比与宅子-管家-仆人。\"]},\"805\":{\"h\":\"2、并行跟并发\",\"t\":[\"说说并行跟并发有什么区别？\",\"从操作系统的角度来看，线程是CPU分配的最小单位。 \",\"并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。\",\"并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的（这些程序在宏观上是同时发生的，在微观上是交替进行的）。\"]},\"806\":{\"h\":\"3、线程有几种创建方式\",\"t\":[\"说说线程有几种创建方式？\",\"Java中创建线程主要有四种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口、线程池。\",\"继承Thread类，重写run()方法，调用start()方法启动线程\",\"实现 Runnable 接口，重写run()方法\",\"实现Callable接口，重写call()方法，这种方式一般和FutureTask搭配使用用于获取任务执行的返回值\",\"通过线程池创建 - 线程工厂\"]},\"807\":{\"h\":\"4、线程有哪些常用的调度方法\",\"t\":[\"线程有哪些常用的调度方法？\",\"在Object类中有一些函数可以用于线程的等待与通知：\",\"wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ： \",\"（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；\",\"（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。\",\"wait(long timeout) ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。\",\"wait(long timeout、 int nanos)，其内部调用的是 wait(long timout）函数。\",\"上面是线程等待的方法，而唤醒线程主要是下面两个方法：\",\"notify() : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。\",\"notifyAll() ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。\",\"Thread类也提供了一个方法用于等待的方法：\",\"等待其他线程执行完 - join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。\",\"线程休眠 - sleep(long millis) :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。\",\"让出优先权 - yield() ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。\",\"线程中断 - Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。\",\"void interrupt() ：中断线程，例如，当线程A运行时，线程B可以调用线程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志、 线程A实际并没有被中断， 会继续往下执行。\",\"boolean isInterrupted() 方法： 检测当前线程是否被中断。\",\"boolean interrupted() 方法： 检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。\"]},\"808\":{\"h\":\"5、线程有几种状态/生命周期\",\"t\":[\"线程有几种状态/生命周期？\",\"在Java中，线程共有六种状态：\",\"状态\",\"说明\",\"NEW\",\"初始状态：线程被创建，但还没有调用start()方法\",\"RUNNABLE\",\"运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”\",\"BLOCKED\",\"阻塞状态：表示线程阻塞于锁\",\"WAITING\",\"等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）\",\"TIME_WAITING\",\"超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的\",\"TERMINATED\",\"终止状态：表示当前线程已经执行完毕\",\"线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换。\"]},\"809\":{\"h\":\"6、线程上下文切换\",\"t\":[\"什么是线程上下文切换？\",\"线程上下文切换和线程并发工作的原理有关，并发其实是一个CPU来应付多个线程，为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。\",\"切换实际上设计到了操作系统的原子性指令 - 原语：“关中断指令”和“开中断指令”这两个特权指令实现原子性 \",\"当时间片用完cpu就会执行外部中断指令，“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU\",\"例子：时钟中断一一由时钟部件发来的中断信号 \",\"时钟部件会以固定的时间间隔（例如50毫秒）发送一个时钟中断信号给CPU。这个信号会打断当前正在执行的程序，将控制权交给操作系统内核。操作系统可以利用时钟中断来更新系统时间、调度进程、以及进行其他与时间相关的操作。\",\"这个机制是实现并发操作的重要手段之一，使得操作系统可以在多个任务之间快速切换，从而实现多任务并发执行。\"]},\"810\":{\"h\":\"7、守护线程\",\"t\":[\"什么是守护线程？\",\"Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）\",\"在JVM 启动时会调用 main 函数，main函数所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。\",\"那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。\"]},\"811\":{\"h\":\"8、线程间通信方式\",\"t\":[\"线程间有哪些通信方式？\",\"不同线程之间、当前线程和它之前的\",\"对于操作系统而言：\",\"共享内存：多个线程共享同一块内存区域，它们可以直接读写这块内存来进行通信。\",\"锁机制： 使用锁来保护共享资源，例如互斥锁和读写锁，确保同时只有一个线程能够访问共享资源，从而避免竞争条件。\",\"等待/通知机制：可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。\",\"管道输入/输出流：管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。\",\"消息队列： 操作系统提供消息队列的机制，允许线程发送和接收消息。线程可以使用操作系统提供的 API 来操作消息队列，进行消息的发送和接收。\",\"具体到Java的实现：\",\"java内存模型和volatile关键字\",\"关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。\",\"synchronized关键字\",\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。\",\"wait()和notify()\",\"Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。\",\"管道输入/输出流\",\"Java主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。\",\"使用Thread.join()\",\"如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis、int nanos)两个具备超时特性的方法。\",\"使用ThreadLocal\",\"ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。\",\"可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。\"]},\"812\":{\"h\":\"9、sleep() 方法和 wait() 方法\",\"t\":[\"sleep() 方法和 wait() 方法的区别？\",\"共同点：两者都是用于线程进行调度的方法，可以实现线程在不同状态之间转换，作用都是用于暂停线程的执行，而且他俩都是本地方法。\",\"区别：\",\"所属者不同：sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。sleep() 方法没有释放锁，而 wait() 方法释放了锁 。\",\"资源释放不同：wait() 通常被侧重用于线程间交互/通信，调用的时候会释放锁，而sleep()通常被用于暂停执行，不会释放锁。\",\"其他：wait() 默认是一直等，但还有其他重载方法，里面可以传入等待时间，而sleep()方法执行完成后，线程会自动苏醒。\"]},\"813\":{\"h\":\"10、为什么 wait() 方法不定义在 Thread 中\",\"t\":[\"为什么 wait() 方法不定义在 Thread 中？\",\"为什么 wait() 方法不定义在 Thread 中？\",\"因为我们都知道嘛，先是根据我们需要什么功能再设计出什么来：\",\"主要在于理解其功能以及Java对象的锁机制。\",\"首先，锁机制的主要目的是保护共享资源。锁机制包括加锁和释放锁\",\"wait()方法涉及锁的释放，因此它需要知道应该释放哪个锁。若将其定义在Thread类中，这会导致Thread类和其他类没有相关性，使得难以确定其他对象是否存在锁。\",\"而如果定义在Object类中，考虑到Java中的继承关系，所有对象都隐式地继承自顶级父类Object。如果将wait()方法定义在Object内部，由于继承关系，每个子类对象都可以调用wait()方法，从而导致每个对象都有释放锁的能力，这不符合锁机制的意图。\",\"其次Java对象由对象头、示例数据和填充对齐组成，对象头包含了锁的标志信息（锁是否被持有）以及该锁属于哪个线程。\",\"因此，wait()方法被定义在Object类中，以确保锁的释放与对象的关联性，使其能够在正确的情况下释放相应的锁，维护了Java中锁机制的合理性和安全性。\",\"为什么 sleep() 方法定义在Thread中？\",\"因为 sleep() 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。\",\"因为sleep的作用是：让线程在预期的时间内执行，其他时候不要来占用CPU资源。从此可以理解为sleep是属于线程级别的，它是为了让线程在限定的时间后去执行。而且sleep方法是不会去释放锁的。\"]},\"814\":{\"h\":\"11、线程安全\",\"t\":[\"什么是线程安全？\",\"线程安全指的是在多线程环境下，当多个线程同时访问某个对象或资源时，该对象或资源仍然能够表现出正确的行为，不会产生不确定的结果或出现数据损坏等问题。\",\"具体来说，线程安全可以表现为以下几个方面：\",\"原子性（Atomicity）： 指的是对于涉及多步骤操作的方法或操作，要么全部执行成功，要么全部不执行，中间不会被其他线程打断。比如对共享变量的读写操作要么完整地执行，要么不执行。\",\"可见性（Visibility）： 表示当一个线程修改了共享变量的值时，其他线程能够立即看到这个修改后的值。如果缺乏可见性，一个线程对共享变量的修改可能对其他线程是不可见的，导致错误的结果。\",\"有序性（Ordering）： 多个线程按照一定的顺序执行时，程序的执行结果是符合预期的。在并发环境下，由于线程调度的不确定性，如果没有正确的同步机制，可能导致代码的执行顺序混乱，产生不正确的结果。\"]},\"815\":{\"h\":\"二、ThreadLocal\"},\"816\":{\"h\":\"1、什么是ThreadLocal\",\"t\":[\"什么是ThreadLocal？\",\"ThreadLocal，也就是线程本地变量。\",\"它是Java保证线程安全的一种无同步方案，也就是说无需同步， 因为ThreadLocal提供了线程内存储变量的能力，每一个线程读取的变量是对应的互相独立的，类似我们传参的形参，每个都是一个副本变量，其次我们可以通过其提供get和set方法设置/得到当前线程对应的值。\",\"ThreadLocal的话，它本质就是一个特殊的数据结构，本质实现就是一个ThreadLocal.ThreadLocalMap的实例变量threadLocals，也就是说每个线程实例对象有一个自己的ThreadLocalMap。\",\"而ThreadLocalMap它类似与我们的HashMap，也是一个键值对的存储，只不过它的底层实现是基于一个entry数组，每个entry就是key-value，它的key就是弱引用类型ThreadLocal对象，value就是我们真正存储的值。\",\"当每个线程在往ThreadLocal里放值的时候，都会往自己的ThreadLocalMap里存，读也是以ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。\",\"ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。\",\"我们通常使用static关键字修饰threadlocal\",\"例子：\",\"实习的时候中午吃饭点外卖\",\"ThreadLocal - 外卖柜\",\"ThreadLocalMap - 每个人自己的专用抽屉（线程在 ThreadLocal 中的存储空间 ）\",\"数据 - 抽屉内的外码\",\"钥匙/取件码 - 线程\",\"当每个人需要存储或者取出自己的书（数据）时，他们使用自己独有的钥匙（线程）打开自己的抽屉，而不会影响其他人的抽屉。虽然柜子是大家共用的，但每个人只能打开和操作自己的抽屉，保证了他们各自书本的独立性和安全性。这样，无论多少人共用同一个书柜，每个人都能安心地将自己的书本放在自己的抽屉里，互不干扰，也不会出现书本混乱或丢失的问题。\",\"为什么要使用static修饰：\",\"使用 static 修饰 ThreadLocal 有几个优势和好处：\",\"全局共享数据： 使用 static 修饰的 ThreadLocal 实例在整个类中都是共享的，不同对象实例间和不同线程间可以共享同一个 ThreadLocal 实例。这样可以方便地实现数据在多个对象实例（如请求层和数据层）之间的共享和访问。\",\"简化代码： 如果某个数据在类的多个方法中需要共享或者访问，使用 static 修饰的 ThreadLocal 可以减少参数传递的复杂性。不需要将 ThreadLocal 作为方法参数传递，而是可以直接在方法内部获取线程独立的数据。\",\"提高可访问性： 静态的 ThreadLocal 实例可以被类的所有实例和方法直接访问，不需要通过对象实例来获取。这样可以简化代码，更容易地管理线程特定的数据。\",\"与不使用 static 修饰的区别在于：\",\"作用域不同： 使用 static 修饰的 ThreadLocal 实例是类级别的，它的作用范围是整个类，可以被类的所有实例和方法直接访问和共享。而没有使用 static 修饰的 ThreadLocal 是对象级别的，每个对象实例都有自己的 ThreadLocal 实例，不同对象之间的数据是隔离的。\",\"访问范围不同： 使用 static 修饰的 ThreadLocal 实例可以在整个类中直接访问，而不需要通过对象实例。而非静态的 ThreadLocal 需要通过对象实例来访问其实例。\",\"总的来说，使用 static 修饰的 ThreadLocal 可以更方便地实现全局共享的线程局部变量，提高数据的访问性和代码的简洁性。而不使用 static 则更适合在对象级别实现线程安全的数据共享。选择使用哪种方式取决于具体的场景和需求。\"]},\"817\":{\"h\":\"2、ThreadLocal使用场景\",\"t\":[\"ThreadLocal使用场景？\",\"ThreadLocal使用场景有哪些？\",\"我觉得吧，ThreadLocal的使用场景主要是和它本身有关，他本质也就是一个Java对象，是我们Java实现线程安全的一种无同步方案，这种的话，为了避免创建多个对象，我们会使用static关键字修饰。\",\"第一种场景：每个线程内需要保存全局变量 \",\"例如-保存一些业务内存【用户权限信息，从用户系统获取到的用户名、userId等】可以让不同方法直接使用，例如我们常用MVC架构，可能Controller层不需要的参数，但是Dao层需要，这样就可以使用ThreadLocal保存参数，避免参数传递的麻烦\",\"例如-用来做用户信息上下文的存储，我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。\",\"其次我的RPC也使用了，因为RPC调用过程中可能会返回的RPC响应出现一些了调用失败的信息，比如可能当前的服务器关闭了，那我们的请求需要再次进行负载均衡，把请求往其他服务器发送，但是到这里我们并没有原来请求的RPC报文，所以使用了ThreadLocal在发送请求前，把封装的请求存入本地线程，如果是正常的响应没有问题，就调用remove方法移除即可。\",\"第二种场景：每个线程需要一个独享的对象 \",\"例如：通常是工具类，典型需要使用的类有SimpleDateFormat和Random，用于对每个请求或线程需要格式化时间的情况。\",\"如果不使用ThreadLocal，也可以，比如每次来都new新的，空间浪费比较大；又或者使用synchronized修饰，但是并发上不来\"]},\"818\":{\"h\":\"3、ThreadLocal 内存泄露\",\"t\":[\"ThreadLocal 内存泄露是怎么回事？\",\"ThreadLocal 内存泄露主要和ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用有关：\",\"因为线程内存储的不是此threadlocal，而是弱引用容器装载的threadlocal，而对于弱引用，只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。\",\"value基本都是我们创建的对象，是强引用回收不掉，ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会造成了内存泄漏问题。\",\"那怎么解决内存泄漏问题呢？\",\"很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。\",\"remove()方法会删除key为null的value也会删除，这样就ThreadLocalMap释放了空间\",\"那为什么key还要设计成弱引用？\",\"key设计成弱引用同样是为了防止内存泄漏。\",\"假如key被设计成强引用：强引用即使内存爆了也不会垃圾回收掉，也就说如果此时有很多用于访问，大量线程内存储了ThreadLocal对象，这样负载很高，如果我们内存足还没事，如果不足则可用内存就一直减少，最后可能引发内存溢出。\",\"所有设计成弱引用，每次垃圾回收时就删除，再搭配我们小心使用，使用完调用remove()就可以了。\"]},\"819\":{\"h\":\"4、ThreadLocalMap的结构\",\"t\":[\"ThreadLocalMap的结构了解吗？\",\"ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：元素数组和散列方法。\",\"元素数组：一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。\",\"散列方法：散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&运算（相当于取余）。\",\"int i = key.threadLocalHashCode & (table.length - 1); \",\"这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增0x61c88647，这个值很特殊，它是斐波那契数 也叫 黄金分割数。hash增量为 这个数字，带来的好处就是 hash分布非常均匀。\",\" private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } \"]},\"820\":{\"h\":\"5、ThreadLocalMap的Hash冲突\",\"t\":[\"ThreadLocalMap怎么解决Hash冲突的？\",\"ThreadLocalMap没有使用链表，它用的是另外一种方式——开放定址法（简单来说，就是这个坑被人占了，那就接着去找空着的坑。）。\",\"如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。\",\"在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。\"]},\"821\":{\"h\":\"6、ThreadLocalMap的扩容机制\",\"t\":[\"ThreadLocalMap扩容机制了解吗？\",\"在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值(len*2/3)，就开始执行rehash()逻辑：\",\"if (!cleanSomeSlots(i、 sz) && sz >= threshold) rehash(); \",\"再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断size >= threshold - threshold / 4 也就是size >= threshold* 3/4来决定是否需要扩容。\",\"private void rehash() { //清理过期Entry expungeStaleEntries(); //扩容 if (size >= threshold - threshold / 4) resize(); } //清理过期Entry private void expungeStaleEntries() { Entry[] tab = table; int len = tab.length; for (int j = 0; j < len; j++) { Entry e = tab[j]; if (e != null && e.get() == null) expungeStaleEntry(j); } } \",\"接着看看具体的resize()方法，扩容后的newTab的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的newTab，遍历完成之后，oldTab中所有的entry数据都已经放入到newTab中了，然后table引用指向newTab\"]},\"822\":{\"h\":\"7、父子线程怎么共享数据\",\"t\":[\"父子线程怎么共享数据？\",\"父线程使用类——InheritableThreadLocal 。\",\"使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。\",\"public class InheritableThreadLocalTest { public static void main(String[] args) { final ThreadLocal threadLocal = new InheritableThreadLocal(); // 主线程 threadLocal.set(\\\"不擅技术\\\"); //子线程 Thread t = new Thread() { @Override public void run() { super.run(); System.out.println(\\\"鄙人三某 ，\\\" + threadLocal.get()); } }; t.start(); } } \",\"那原理是什么呢？\",\"原理就是子线程被创建的时候会将父线程的ThreadLocalMap复制给子线程，但是后续两者就没啥关系了。\",\"原理很简单，在Thread类里还有另外一个变量：\",\"ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; \",\"在Thread.init的时候，如果父线程的inheritableThreadLocals不为空，就把它赋给当前线程（子线程）的inheritableThreadLocals 。\",\"if (inheritThreadLocals && parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); \"]},\"823\":{\"h\":\"三、Java内存模型\"},\"824\":{\"h\":\"1、Java内存模型（JMM）\",\"t\":[\"介绍一下Java内存模型？\",\"Java内存模型（Java Memory Model，JMM），是一种抽象的模型，是Java定义的出来的用来屏蔽各种硬件和操作系统的内存访问差异。\",\"JMM主要就是线程和主内存之间的抽象关系： \",\"线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。\",\"本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\"]},\"825\":{\"h\":\"2、说说你对原子性、可见性、有序性的理解\",\"t\":[\"说说你对原子性、可见性、有序性的理解？\",\"原子性：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。 \",\"应用实现：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用synchronized 或者原子类的原子操作。\",\"可见性：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。 \",\"应用实现：Java是利用volatile关键字来保证可见性的，除此之外，final和synchronized也能保证可见性。\",\"有序性：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。 \",\"应用实现：synchronized或者volatile都可以保证多线程之间操作的有序性。\"]},\"826\":{\"h\":\"3、那说说什么是指令重排？指令重排有限制吗\",\"t\":[\"那说说什么是指令重排？指令重排有限制吗？\",\"什么是指令重排：\",\"指令重排就是在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。\",\"编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\",\"指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。\",\"内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\",\"我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子：\",\"Singleton instance=new Singleton()；\",\"对应的JVM指令分为三步：分配内存空间-->初始化对象--->对象指向分配的内存空间\",\"但是经过了编译器的指令重排序，第二步和第三步就可能会重排序，在多线程的访问情况下，可能会有对象的半初始化的问题。\",\"指令重排的限制：\",\"指令重排也是有一些限制的，有两个规则as-if-serial和happens-before来约束。\",\"as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。\",\"happens-before的定义：多线程程序的执行结果不能被改变\",\"如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\",\"两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法\"]},\"827\":{\"h\":\"4、volatile有什么作用\",\"t\":[\"volatile有什么作用？\",\"volatile有两个作用，保证可见性和有序性。\",\"可见性：一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存，当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。\",\"例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。\",\"相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。\",\"有序性：重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。\",\"为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。\",\"StoreStore屏障： 在每个 volatile 写操作的前面插入一个 StoreStore 屏障，确保在当前 volatile 写操作之前的所有普通写操作（非 volatile 写操作）完成后，再执行当前 volatile 写操作。这样可以防止当前 volatile 写操作的数据与之前的非 volatile 写操作的数据重排序。\",\"StoreLoad屏障： 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障，确保当前 volatile 写操作的结果对后续的 volatile 读操作是可见的。它保证在当前 volatile 写操作之后的所有读操作（无论是 volatile 读操作还是普通读操作）都能看到当前 volatile 写操作所写入的最新值。\",\"LoadLoad屏障： 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障，确保当前 volatile 读操作之前的所有读操作（无论是 volatile 读操作还是普通读操作）都在当前 volatile 读操作之前完成。这样可以防止当前 volatile 读操作与之前的读操作重排序。\",\"LoadStore屏障： 在每个 volatile 读操作的后面插入一个 LoadStore 屏障，确保当前 volatile 读操作的结果被后续的写操作（无论是 volatile 写操作还是普通写操作）正确刷新到内存中。这样可以防止当前 volatile 读操作的结果与后续的写操作重排序。\",\"此外，在 Java 中，Unsafe 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：\",\"public native void loadFence(); public native void storeFence(); public native void fullFence(); \",\"理论上来说，你通过这个三个方法也可以实现和volatile禁止重排序一样的效果，只是会麻烦一些。\"]},\"828\":{\"h\":\"5、volatile实现原理了解吗\",\"t\":[\"volatile实现原理了解吗？\",\"volatile保证可见性和有序性的原理涉及到底层的硬件和内存模型：\",\"缓存一致性协议（Cache Coherence Protocol）： 多核处理器系统中，不同的核心有自己的缓存。当一个核心对一个共享的 volatile 变量进行写操作时，会发出信号通知其他核心的缓存失效，确保其他核心读取时能够获取到最新的值。\",\"内存屏障（Memory Barrier）： 编译器和处理器在生成和执行指令时，会在适当的地方插入内存屏障指令。对于 volatile 变量的写操作，会插入写屏障（Store Barrier），确保写操作将数据立即刷新到主内存。对于 volatile 变量的读操作，会插入读屏障（Load Barrier），确保读取的是主内存中最新的值。\"]},\"829\":{\"h\":\"6、为什么volatile不能保证原子性\",\"t\":[\"为什么volatile不能保证原子性\",\"虽然 volatile 可以保证可见性和禁止指令重排序，但它并不能保证原子性。\",\"原子性是指一个操作是不可中断的，要么全部执行成功，要么完全不执行，不会被其他线程中断或交错执行。\",\"而 volatile 只是保证了对变量的读写操作具有可见性，但并不能保证复合操作的原子性。\",\"考虑一个具体的场景：\",\"volatile int count = 0;，多个线程对 count 进行自增操作 count++。\",\"虽然 count 是 volatile 的，但是 count++ 是一个复合操作，包括读取 count 的值、对其进行加一操作、再将结果写回 count，这些操作之间可能会被其他线程打断，导致不同线程的操作交错执行，最终产生错误的结果。\",\"例如又A、B两个线程都对 count 进行自增操作 count++，A、B线程读取操作count 的值，进行操作，A先一步刷回主存，此时其他线程内的变量副本刷新，但是我B已经进行了自增，正要刷回主存，刷回后还是1，两次操作本来结果是2，但是因为多线程进行交错执行，导致丢失了更新操作，使得最终结果不是期望的，产生了错误结果1。\",\"要保证这种情况下的原子性操作，可以使用 AtomicInteger 等原子类来代替 volatile int。AtomicInteger 提供了诸如 getAndIncrement() 这样的原子性操作，确保了自增操作的原子性，不会被其他线程中断或交错执行。这些原子类内部使用了底层的 CAS（Compare and Swap）等机制来实现原子性操作。\"]},\"830\":{\"h\":\"四、锁\"},\"831\":{\"h\":\"1、保证线程安全有什么方案\",\"t\":[\"有什么保证线程安全的方案？\",\"实现线程安全的方法通常包括：\",\"数据不可变：\",\"在Java当中，一切不可变的对象（immutable）一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障的措施。\",\"比如final关键字修饰的基础数据类型，再比如说咱们的Java字符串儿。\",\"只要一个不可变的对象被正确的构建出来，那外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态，带来的安全性是最直接最纯粹的。\",\"比如使用final修饰的基础数据类型（引用数据类型不可以）、比如java字符串，而一旦被创建就永远不能改变，其实谷歌的开发工具包（guava）中也给我们提供了一些不可变的一类（immutable），咱们以后的学习过程当中可能会接触到。\",\"互斥/阻塞同步同步：\",\"互斥同步是常见的一种并发正确性的保障手段，同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用，互斥是实现同步的一种手段，互斥是因、同步是果，互斥是方法，同步是目的。\",\"synchronized 关键字：使用 synchronized 对象锁或方法锁来保护临界区。\",\"ReentrantLock：使用 ReentrantLock 显式锁来实现同步，提供了更多灵活性和功能，如可中断锁、公平性等。\",\"ReadWriteLock：ReentrantReadWriteLock 支持读写锁，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。\",\"但是互斥同步是一种【悲观的并发策略】，其总是认为，只要不去做正确的同步措施，那就肯定会出现问题，无论共享的数据是否真的出现，都会进行加锁。\",\"这将会导致用户态到内核态的转化、维护锁计数器和检查是否被阻塞的线程需要被唤醒等等开销，因此这种同步也被称为阻塞同步。\",\"非阻塞同步\",\"随着硬件指令级的发展，我们已经有了另外的选择，基于【冲突检测的乐观并发策略】。\",\"通俗的说，就是不管有没有风险，先进行操作，如果没有其他线程征用共享数据，那就直接成功，如果共享数据确实被征用产生了冲突，那就再进行补偿策略，常见的补偿策略就是不断的重试，直到出现没有竞争的共享数据为止，这种乐观并发策略的实现，不再需要把线程阻塞挂起，因此同步操作也被称为非阻塞同步，这种措施的代码也常常被称之为【无锁编程】，也就是咱们说的自旋。我们用cas来实现这种非阻塞同步。\",\"在 Java 中，非阻塞同步的实现方式通常涉及 java.util.concurrent.atomic 包中的原子类，如 AtomicInteger、AtomicLong 等。这些类使用了 CAS 操作来确保对变量的操作是原子性的。\",\"无同步方案\",\"在我们这个工作当中，还经常遇到这样一种情况，多个线程需要共享数据，但是这些数据又可以在单独的线程当中计算，得出结果，而不被其他的线程所影响，如果能保证这一点，我们就可以把共享数据的可见范围限制在一个线程之内，这样就无需同步，也能够保证个个线程之间不出现数据征用的问题，说人话就是数据拿过来，我用我的，你用你的，从而保证线程安全，比如说咱们的ThreadLocal。\",\"ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。\"]},\"832\":{\"h\":\"2、介绍一下Java里面常见的锁\",\"t\":[\"介绍一下Java里面常见的锁？\",\"从Java锁实现来看：\",\"synchronized 关键字： 是 Java 中最基本的锁机制之一。它可以用来修饰方法或代码块，确保同一时间只有一个线程可以访问被 synchronized 修饰的代码段，实现互斥同步。它是隐式锁，不需要手动加锁解锁，当线程进入 synchronized 块时获取锁，退出时释放锁，其次它的底层实现原理是…..。\",\"public synchronized void synchronizedMethod() { // 同步方法代码块 } \",\"ReentrantLock： 是juc（ java.util.concurrent） 包提供的显式锁实现，具有与 synchronized 相似的互斥同步能力，并且提供了更多的灵活性。它支持公平性设置、可中断锁、条件变量等特性，可以更精确地控制锁的获取和释放。\",\"ReentrantLock lock = new ReentrantLock(); lock.lock(); try { // 临界区代码块 } finally { lock.unlock(); } \",\"ReadWriteLock（读写锁）： 为了应对一些特殊场景，也引入了读写锁，也是 java.util.concurrent 包提供的，它包含了一个读锁和一个写锁，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。读写锁适用于读多写少的场景，能够提高读操作的并发性能。\",\"ReadWriteLock rwLock = new ReentrantReadWriteLock(); rwLock.readLock().lock(); // 获取读锁 try { // 读取共享资源的操作 } finally { rwLock.readLock().unlock(); // 释放读锁 } \",\"StampedLock： 其次在 Java 8 引入的一种机制，是 ReadWriteLock 的扩展，提供了三种访问模式：读、写和乐观读。StampedLock 的乐观读模式允许乐观地进行读操作，避免了使用读锁的开销。\",\"StampedLock stampedLock = new StampedLock(); long stamp = stampedLock.readLock(); // 获取悲观读锁 try { // 读操作 } finally { stampedLock.unlockRead(stamp); // 释放悲观读锁 } \",\"这些锁机制都提供了线程同步和控制并发访问的手段，每种锁都有其适用的场景和特性，开发者可以根据具体需求选择合适的锁来保证线程安全性。\",\"其次从解决问题的方式上来看：\",\"悲观锁：就是只要不去做正确的同步措施，那就肯定会出现问题，无论共享的数据是否真的出现，都会进行加锁。 \",\"使用诸如 synchronized 关键字、ReentrantLock 等锁来控制对共享资源的访问，确保同一时间只有一个线程可以访问共享资源。\",\"乐观锁：就是不管有没有风险，先进行操作，如果没有其他线程征用共享数据，那就直接成功，如果共享数据确实被征用产生了冲突，那就再进行补偿策略，常见的补偿策略就是不断的重试，直到出现没有竞争的共享数据为止。 \",\"使用无锁算法，如 CAS（比较并交换）机制，或者乐观锁的实现方式，例如 StampedLock 的乐观读模式，都是乐观锁的例子。\"]},\"833\":{\"h\":\"3、synchronized怎么使用\",\"t\":[\"synchronized怎么使用？\",\"synchronized主要有三种用法：\",\"修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁\",\"synchronized void method() { //业务代码 } \",\"修饰静态方法：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。\",\"如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。\",\"synchronized void staic method() { //业务代码 } \",\"修饰代码块 ：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁\",\"synchronized(this) { //业务代码 } \"]},\"834\":{\"h\":\"4、synchronized和volatile的区别\",\"t\":[\"详情\",\"volatile 和 synchronized 都是 Java 中用于处理多线程并发访问的关键字，但它们有着不同的作用和使用场景：\",\"可见性：\",\"volatile 保证了变量的可见性。当一个变量被 volatile 关键字修饰时，线程对该变量的修改会立即刷新到主内存中，其他线程可以立即看到最新值。\",\"synchronized 不仅保证了可见性，还确保了原子性和有序性。进入 synchronized 代码块之前会获取锁，退出时释放锁，只有获取锁的线程才能执行 synchronized 代码块。\",\"原子性：\",\"volatile 不能保证操作的原子性，特别是复合操作，如 count++ 不是原子操作，可能导致竞态条件。\",\"synchronized 保证了临界区的代码在同一时刻只能有一个线程执行，因此可以确保复合操作的原子性。\",\"禁止指令重排序：\",\"volatile： 保证了对 volatile 变量的读取和写入具有可见性，并禁止了指令重排序。对 volatile 变量的写操作会立即刷新到主内存，读操作也会直接从主内存中获取最新值，而不是从线程的本地缓存中获取。\",\"synchronized： 提供了更强大的特性，包括了 volatile 的可见性，同时还提供了互斥访问共享资源的能力。当一个线程获取到 synchronized 块或方法的锁时，其他线程无法同时访问被锁定的资源，确保了对临界区的互斥访问。\",\"适用范围：\",\"volatile 通常用于简单变量的状态标记，比如线程间的状态控制、开关变量等，不适合用于复合操作。\",\"synchronized 可以用于更复杂的并发控制，适用于临界区代码的同步。\",\"性能开销：\",\"volatile 的开销相对较小，因为它只是保证了可见性，没有锁的竞争和线程阻塞。\",\"synchronized 的开销较大，涉及到获取锁和释放锁的操作，可能导致线程阻塞和上下文切换，影响性能。\",\"总体来说，volatile 更适合简单的状态标记和某些特定的场景，而 synchronized 更适合复杂的并发控制和临界区同步。\"]},\"835\":{\"h\":\"5、synchronized的实现原理\",\"t\":[\"synchronized的实现原理是什么？\",\"synchronized是怎么加锁的呢？\",\"我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM的两个字节码指令帮我们把这个事情做了。\",\"synchronized修饰代码块时：JVM采用monitorenter、monitorexit两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。\",\"反编译一段synchronized修饰代码块代码，javap -c -s -v -l SynchronizedDemo.class，可以看到相应的字节码指令。\",\"synchronized修饰同步方法时：JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。\",\"详细：monitorenter、monitorexit或者ACC_SYNCHRONIZED都是基于Monitor实现的。\",\"实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了monitor。\",\"所谓的Monitor其实是一种同步工具，也可以说是一种同步机制。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，可以叫做内部锁，或者Monitor锁。\",\"ObjectMonitor的工作原理：\",\"ObjectMonitor有两个队列：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。\",\"_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。\",\"ObjectMonitor() { _count = 0; // 记录线程获取锁的次数 _recursions = 0; //锁的重入次数 _owner = NULL; // 指向持有ObjectMonitor对象的线程 _WaitSet = NULL; // 处于wait状态的线程，会被加入到_WaitSet _EntryList = NULL ; // 处于等待锁block状态的线程，会被加入到该列表 ...... } \",\"monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。\",\"monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。\"]},\"836\":{\"h\":\"6、除了原子性，synchronized可见性，有序性，可重入性怎么实现？\",\"t\":[\"详情\",\"synchronized怎么保证可见性？\",\"线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。\",\"线程加锁后，其它线程无法获取主内存中的共享变量。\",\"线程解锁前，必须把共享变量的最新值刷新到主内存中。\",\"synchronized怎么保证有序性？\",\"synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。\",\"因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。\",\"所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。\",\"synchronized怎么实现可重入的呢？\",\"synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。\",\"synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。\",\"之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。\"]},\"837\":{\"h\":\"7、synchronized优化了解吗\",\"t\":[\"synchronized优化了解吗？\",\"synchronized优化就是引入锁升级的过程，它主要是和不同锁的状态变化相关：\",\"Java对象头里，有一块结构，叫Mark Word标记字段，这块结构会随着锁的状态变化而变化。\",\"Mark Word存储对象自身的运行数据，如哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch） 等。\",\"synchronized做了哪些优化？\",\"在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。\",\"偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。\",\"轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。\",\"自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式\",\"锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。\",\"锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。\",\"锁升级的过程是什么样的？\",\"锁升级方向：无锁-->偏向锁---> 轻量级锁---->重量级锁，这个方向基本上是不可逆的。\",\"JVM一般是这样使用锁和Mark Word的：\",\"当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。\",\"当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。\",\"当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。\",\"当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。\",\"偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在【当前线程】的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，也叫所记录（lock record），同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。\",\"轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7，自旋默认10次。\",\"自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞排队。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等）进入阻塞状态，等待将来被唤醒。就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源。\"]},\"838\":{\"h\":\"8、介绍ReentrantLock\",\"t\":[\"什么是ReentrantLock？\",\"ReentrantLock 是juc包下面的，一个实现了 Lock 接口，是一个可重入且独占式的锁。\",\"和 synchronized 关键字类似。\",\"不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\",\"public class ReentrantLock implements Lock、 java.io.Serializable {} \",\"ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。\",\"ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。\",\"// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } \"]},\"839\":{\"h\":\"9、ReentrantLock实现原理\",\"t\":[\"ReentrantLock的实现原理是什么？\",\"实现：加锁（公平/非公平锁）+解锁+可重入锁\",\"原理：CAS、AQS（ 状态变量-state、CLH队列）\",\"AQS 是一个提供了构建同步器的框架，它利用一个整型的 state 变量来表示资源的占用情况，通过自旋CAS操作来实现对 state 的原子性更新。ReentrantLock 在内部使用了 AQS 的机制来实现可重入锁的功能。\",\"ReentrantLock 主要依赖于 AQS 中的 Sync 内部类来实现同步功能。Sync 类继承自 AQS，并提供了公平锁和非公平锁的不同实现方式：\",\"公平锁（FairSync）： 在 ReentrantLock 的构造方法中传入 true 参数，表示使用公平锁。公平锁会按照线程请求的顺序进行获取锁。\",\"非公平锁（NonfairSync）： 在 ReentrantLock 的构造方法中传入 false 参数（默认），表示使用非公平锁。非公平锁允许线程插队，尝试直接获取锁而不管其他线程的等待状态。\",\"主要的实现逻辑包括：\",\"锁的获取： 当一个线程尝试获取锁时，ReentrantLock 首先会调用 Sync 内部类的 lock 方法，尝试获取锁。如果获取失败，会根据锁的公平性策略进行后续等待队列的处理。 \",\"CAS 操作：ReentrantLock 使用 CAS 操作来尝试获取锁。它通过比较当前锁的状态（state）和期望值，然后根据比较结果来尝试获取锁。如果成功获取锁，就可以进入临界区执行操作；如果失败，则根据锁的公平性策略将当前线程加入到等待队列中。\",\"AQS： \",\"ReentrantLock 使用 AQS 来管理等待队列和同步状态。AQS 提供了一种框架，用于构建不同类型的同步器。ReentrantLock 利用 AQS 实现了独占锁的功能。\",\"AQS 使用一个整型变量（state）来表示同步状态。ReentrantLock 内部的状态变量（state）表示锁的占用情况，0 表示锁是自由的，大于 0 表示锁被某个线程持有。\",\"等待队列（CLH 队列）用于管理等待获取锁的线程，它是基于 CLH（Craig、 Landin、 and Hagersten）锁队列实现的。线程获取不到锁时，会被加入到队列中等待锁的释放。\",\"锁的释放： 当线程释放锁时，会调用 Sync 内部类的 unlock 方法。如果当前线程是最后一个持有锁的线程，那么释放锁之后，等待队列中的下一个线程将有机会获取到锁。\"]},\"840\":{\"h\":\"10、ReentrantLock怎么实现公平和非公平锁\",\"t\":[\"ReentrantLock怎么实现公平和非公平锁？\",\"new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync\",\"public ReentrantLock() { sync = new NonfairSync(); } \",\"同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync\",\"ReentrantLock lock = new ReentrantLock(true); --- ReentrantLock // true 代表公平锁，false 代表非公平锁 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } \",\"FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。\",\"非公平锁和公平锁的两处不同：\",\"非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。\",\"非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。\",\"相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。\"]},\"841\":{\"h\":\"11、可中断锁和不可中断锁有什么区别\",\"t\":[\"可中断锁和不可中断锁有什么区别？\",\"可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。\",\"不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。\"]},\"842\":{\"h\":\"12、ReentrantReadWriteLock\",\"t\":[\"ReentrantReadWriteLock是什么？\",\"ReentrantReadWriteLock 实现了 ReadWriteLock ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。\",\"public class ReentrantReadWriteLock implements ReadWriteLock、 java.io.Serializable{ } public interface ReadWriteLock { Lock readLock(); Lock writeLock(); } \",\"一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。\",\"读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。\",\"ReentrantReadWriteLock 其实是两把锁，一把是 WriteLock (写锁)，一把是 ReadLock（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\",\"和 ReentrantLock 一样，ReentrantReadWriteLock 底层也是基于 AQS 实现的。\",\"ReentrantReadWriteLock 适合什么场景：\",\"由于 ReentrantReadWriteLock 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 ReentrantReadWriteLock 能够明显提升系统性能。\",\"共享锁和独占锁有什么区别：\",\"共享锁：一把锁可以被多个线程同时获得。\",\"独占锁：一把锁只能被一个线程获得。\",\"线程持有读锁还能获取写锁吗：\",\"在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。\",\"在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。\"]},\"843\":{\"h\":\"13、说说synchronized和ReentrantLock的区别\",\"t\":[\"说说synchronized和ReentrantLock的区别？\",\"相同点：\",\"都是互斥同步方案保持线程安全的实现方式\",\"都是可重入锁\",\"不同点：\",\"锁的实现： synchronized是Java语言的关键字，基于JVM字节码指令实现，而ReentrantLock是一个实现Lock接口的类，是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）是显式的\",\"加锁方式：synchronized不需要手动加/释放锁，如果是方法底层会自动声明为ACC_SYNCHRONIZED，其次会为代码块插入指令monitorenter、monitorexit两个指令来实现同步，是隐式加锁的，而ReentrantLock需要手动调用lock/unlock方法进行加/释放锁。\",\"性能： 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。\",\"功能特点：ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。 \",\"ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制\",\"ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。\",\"synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。\",\"ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。\"]},\"844\":{\"h\":\"14、如何保证多线程下i++ 结果正确\",\"t\":[\"详情\",\"在多线程环境下执行 i++ 操作，确保结果的正确性通常需要考虑并确保以下几个方面：\",\"原子性操作： 确保对 i 的增加操作是原子性的，即在执行增加操作时，不会被其他线程中断或者同时执行其他操作。\",\"可见性： 确保一个线程对 i 的修改能够被其他线程立即看到，避免了线程间的数据不一致问题。\",\"线程安全： 确保在多线程环境下对 i 的操作是线程安全的，不会出现竞态条件等问题。\",\"为了保证多线程下 i++ 的结果正确，可以采取以下几种方式：\",\"使用同步机制：\",\"可以使用 synchronized 关键字或者 ReentrantLock 来确保对 i 的自增操作是原子性的，即同一时间只有一个线程可以修改 i 的值。\",\"private static int i = 0; private static final Object lock = new Object(); synchronized void increment() { i++; } \",\"使用原子类：\",\"可以使用 java.util.concurrent.atomic 包下的原子类，例如 AtomicInteger，它们提供了基本类型的原子性操作。\",\"AtomicInteger atomicInteger = new AtomicInteger(0); atomicInteger.incrementAndGet(); \",\"使用线程安全的集合类：\",\"某些线程安全的集合类，例如 ConcurrentHashMap、CopyOnWriteArrayList 等，在多线程环境下提供了安全的并发访问。\",\"ConcurrentHashMap<String、 Integer> map = new ConcurrentHashMap<>(); map.compute(\\\"key\\\"、 (k、 v) -> v == null ? 1 : v + 1); \",\"使用volatile修饰变量：\",\"将 i 声明为 volatile 可以确保对它的操作具有可见性，但并不能保证复合操作的原子性。\",\"private static volatile int i = 0; \",\"以上方法都可以保证在多线程环境下对 i 的自增操作是线程安全的，确保结果的正确性。选择合适的方法取决于具体的应用场景和性能要求。\"]},\"845\":{\"h\":\"15、什么是CAS？ CAS有什么问题\",\"t\":[\"什么是CAS？ CAS有什么问题？\",\"CAS，compare and swap的缩写，中文翻译成比较并交换，主要是通过处理器的指令来保证操作的原⼦性的，jdk11以后改成了compare and set。\",\"CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。\",\"只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。\",\"设计思想/原理：就是给一个元素赋值的时候，先看看内存里的那个值到底变没变，如果没变我就修改，变了我就不改了，其实这是一种无锁操作，不需要挂起线程，无锁的思路就是先尝试，如果失败了，进行补偿，也就是你可以继续尝试。这样在少量竞争的情况下能很大程度提升性能。\",\"CAS的经典三大问题：\",\"ABA 问题：指的是一个特定的并发问题，涉及到共享资源的状态变化。 \",\"具体而言，ABA问题发生在一个线程先检查某个共享变量的值是A，然后在其他线程修改该变量为B，最后又修改回A，使得在第一个线程看来，共享变量的值仍然是A，但实际上已经发生了变化。\",\"循环性能开销：自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。\",\"只能保证一个变量的原子操作：CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。\",\"怎么解决ABA问题？\",\"场景描述： 在一个在线支付系统中，用户发起支付请求，支付系统处理支付并更新支付状态。假设一个用户发起支付，支付成功后状态为已支付，但之后由于某种原因，支付被撤销并重新支付，最终又恢复为之前的状态（经历了ABA变化）。\",\"可能出现的ABA问题：\",\"用户A发起支付请求，支付状态变为已支付（A）。\",\"由于某种情况（网络波动、支付系统异常等），支付被撤销，状态变为未支付（B）。\",\"接着又发起相同金额的支付请求，支付状态再次变为已支付（A）。\",\"最后系统恢复了之前被撤销的支付，支付状态又变为已支付（A）。\",\"可能造成的影响：\",\"支付逻辑错误： 用户实际只发起了一次支付，但系统记录了两次支付成功，可能导致用户多次被扣款。\",\"账单不一致： 用户在账单中看到重复的支付记录，产生混乱和困惑。\",\"业务数据错误： 后续业务操作（比如发货、订单处理等）可能基于错误的支付状态进行，导致不一致的业务行为。\",\"用户体验受损： 用户的支付历史、订单状态等可能会出现混乱，影响用户对支付系统的信任和体验。\",\"解决方案 - 加版本号：每次修改变量，都在这个变量的版本号上加1，这样，刚刚A->B->A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。\",\"Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。\",\"怎么解决循环性能开销问题？\",\"在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。\",\"怎么解决只能保证一个变量的原子操作问题？\",\"可以考虑改用锁来保证操作的原子性\",\"可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性\"]},\"846\":{\"h\":\"16、什么是AQS\",\"t\":[\"什么是AQS？\",\"AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。\",\"AQS主要包括了：volatile 修饰的 int 类型的成员变量 state 来表示同步状态、CLH 队列\",\"AQS 核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁 实现的，即将暂时获取不到锁的线程加入到队列中。 \",\"获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。\",\"如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。 \",\"AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列\",\"AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配\"]},\"847\":{\"h\":\"17、AtomicInteger 的原理\",\"t\":[\"AtomicInteger 的原理是什么？\",\"一句话概括：使用CAS实现。\",\"以AtomicInteger的添加方法为例：\",\" public final int getAndIncrement() { return unsafe.getAndAddInt(this、 valueOffset、 1); } \",\"通过Unsafe类的实例来进行添加操作，来看看具体的CAS操作：\",\"public final int getAndAddInt(Object var1、 long var2、 int var4) { int var5; do { var5 = this.getIntVolatile(var1、 var2); } while(!this.compareAndSwapInt(var1、 var2、 var5、 var5 + var4)); return var5; } \",\"compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。\",\"原子类类型：基本类型、数组类型、引用类型、对象的属性修改类型\",\"基本类型：使用原子的方式更新基本类型\",\"AtomicInteger：整型原子类\",\"AtomicLong：长整型原子类\",\"AtomicBoolean：布尔型原子类\",\"数组类型：使用原子的方式更新数组里的某个元素\",\"AtomicIntegerArray：整型数组原子类\",\"AtomicLongArray：长整型数组原子类\",\"AtomicReferenceArray：引用类型数组原子类\",\"引用类型\",\"AtomicReference：引用类型原子类\",\"AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，不能解决 ABA 问题。\",\"AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\",\"对象的属性修改类型\",\"AtomicIntegerFieldUpdater:原子更新整型字段的更新器\",\"AtomicLongFieldUpdater：原子更新长整型字段的更新器\",\"AtomicReferenceFieldUpdater：原子更新引用类型里的字段\"]},\"848\":{\"h\":\"18、什么是死锁？如何避免\",\"t\":[\"什么是死锁？如何避免死锁？\",\"线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\",\"例如，有一线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，但是各自又不释放自身的资源，所以这两个线程就会互相等待而进入死锁状态。\",\"死锁产生的四个条件：\",\"互斥条件：该资源任意一个时刻只由一个线程占用。\",\"不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\",\"请求与保持条件：指一个线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。\",\"循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\",\"如何预防死锁：破坏死锁的产生的必要条件即可：\",\"其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？\",\"破坏请求与保持条件：一次性申请所有的资源。\",\"破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\",\"破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\",\"如何避免死锁：避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。\",\"安全状态 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。\"]},\"849\":{\"h\":\"19、如何排查死锁\",\"t\":[\"如何排查死锁？\",\"可以使用jdk自带的命令行工具排查：\",\"使用jps查找运行的Java进程：jps -l\",\"使用jstack查看线程堆栈信息：jstack -l 进程id\",\"基本就可以看到死锁的信息。\",\"还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的检测到死锁按钮，将会看到线程的死锁信息。\"]},\"850\":{\"h\":\"五、并发工具类\"},\"851\":{\"h\":\"1、CountDownLatch了解吗\",\"t\":[\"CountDownLatch了解吗？\",\"CountDownLatch，倒计数器，核心方法如下：\",\"await()：等待latch降为0；\",\"boolean await(long timeout、 TimeUnit unit)：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。\",\"countDown()：latch数量减1；\",\"getCount()：获取当前的latch数量。\",\"有两个常见的应用场景：\",\"场景1：协调子线程结束动作：等待所有子线程运行结束\",\"CountDownLatch允许一个或多个线程等待其他线程完成操作。\",\"例如，我们很多人喜欢玩的moba多人竞技游戏，英雄联盟/王者荣耀，得等所有人都确认之后，才能进入对局再选游戏。\",\"new CountDownLatch(5)用户创建初始的latch数量（玩家数量），各玩家线程通过countDownLatch.countDown()完成状态确认，主线程通过countDownLatch.await()等待。\",\"主线程await()，子线程countdown()\",\"场景2.：协调子线程开始动作：统一各线程动作开始的时机\",\"例如，英雄联盟/王者荣耀中也有类似的场景，游戏开始时，各玩家的初始状态必须一致，例如刚开局都是500块。\",\"子线程await()，主线程countdown()\"]},\"852\":{\"h\":\"2、CyclicBarrier了解吗\",\"t\":[\"CyclicBarrier了解吗？\",\"CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。\",\"它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方\",\"因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。\",\"CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程\"]},\"853\":{\"h\":\"3、Semaphore了解吗\",\"t\":[\"Semaphore了解吗？\",\"对Java而言：\",\"Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。\",\"我们再来看一个Semaphore的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。\",\"假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，\",\"对操作系统而言：\",\"信号量机制操作系统中用于实现进程同步和互斥的重要工具。\",\"通过使用信号量，进程可以对共享资源的访问进行控制，避免多个进程同时访问或修改同一资源，从而确保数据的一致性和完整性。\",\"信号量本质上是一个计数器，可以用来表示系统中某种资源的数量。 \",\"一个信号量可以是整数类型，也可以是更复杂的数据结构。\",\"比如，如果系统只有一台打印机可用，就可以用一个初值为1的信号量来表示打印机的可用性.\",\"对信号量的操作主要通过一对特殊的原语来完成，这对原语是操作系统提供的函数，用于对信号量进行操作。这些原语是不可中断的，确保操作的完整性。一般来说，这对原语包括wait(S)原语和signal(S)原语。 \",\"wait(S) 原语（或 P(S) 操作）用于申请资源或降低信号量的值。如果信号量的值大于零，则将其减一；否则，该操作会阻塞进程，直到信号量的值大于零为止。\",\"signal(S) 原语（或 V(S) 操作）用于释放资源或增加信号量的值。它增加信号量的值，并唤醒因为等待该资源而被阻塞的进程。\",\"这种机制使得进程可以通过对信号量的操作来实现对共享资源的控制和同步，确保在访问共享资源时的互斥性，从而避免竞态条件和数据不一致的问题。\"]},\"854\":{\"h\":\"4、Exchanger 了解吗\",\"t\":[\"Exchanger 了解吗？\",\"Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。\",\"这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。\",\"Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。\",\"Exchanger可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。\"]},\"855\":{\"h\":\"5、LongAdder原理\",\"t\":[\"LongAdder原理？\",\"LongAdder是Java 8 中引入的一种线程安全的累加器，用于高并发情况下对长整型（long类型）进行原子性的累加操作。它通常比AtomicLong性能更好，特别是在高度竞争情况下。\",\"实现原理：\",\"LongAdder的实现基于分段锁（Striped LongAdder）。它将一个long值分解为多个部分（通常是数组），每个部分都由一个独立的计数器维护。当多个线程同时尝试更新计数器时，不同的线程会被分配到不同的计数器上进行操作，而不会造成线程间的争用。\",\"当进行累加操作时，LongAdder会根据当前线程的哈希码（通过对线程 ID 的散列运算获得）来选择使用其中一个计数器。如果发生冲突（即多个线程的哈希码映射到同一个计数器），则会通过CAS（Compare and Set）循环来尝试更新计数器的值。如果更新失败，它会将任务分散到其他的计数器上，以减少竞争。在最终获取结果时，会将所有分段的计数器值累加起来得到最终的结果。\",\"LongAdder实现的关键点在于通过分段的方式降低了线程之间的竞争，从而提高了并发更新性能。这使得在高并发场景下，LongAdder能够比AtomicLong更高效地处理累加操作。\",\"减少竞争：AtomicLong是基于CAS（Compare and Set）操作实现的，它在高并发情况下可能导致多个线程同时竞争更新同一个变量，这会增加线程之间的竞争和CAS操作的失败重试次数，降低性能。而LongAdder使用了分段的思想，将一个long值分解成多个部分（通常是数组），不同的线程更新不同的部分，避免了大量线程竞争同一个变量的情况，从而减少了竞争。\",\"合并操作：LongAdder在获取最终结果时，会将所有分段的计数器值进行累加。这样，虽然在更新操作时会牺牲一定的内存以维护分段计数器数组，但在获取最终结果时，合并操作会更加高效。相比之下，AtomicLong在高并发情况下可能会产生大量的竞争和CAS重试，导致性能下降。\"]},\"856\":{\"h\":\"六、线程池\"},\"857\":{\"h\":\"1、什么是线程池？为什么要有线程池\",\"t\":[\"什么是线程池？为什么要有线程池？\",\"线程池： 简单理解，它就是一个管理线程的池子。\",\"线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。\",\"它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。\",\"提高响应速度。 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。\",\"重复利用。 线程用完，再放回池子，可以达到重复利用的效果，节省资源。\"]},\"858\":{\"h\":\"2、线程池的应用有哪些\",\"t\":[\"线程池的应用有哪些？\",\"线程池是一种管理和复用线程的机制，它能够在多任务处理中提供一定程度的优化和控制。线程池在许多应用场景中都有着广泛的应用，也基于它的机制：\",\"Web服务器： 在Web服务器中，线程池用于管理和处理客户端请求。当有请求到达时，不需要为每个请求创建一个新线程，而是从线程池中获取可用线程来处理请求，这样可以减少线程创建和销毁的开销，提高服务器的吞吐量和响应速度 \",\"BIO的优化\",\"并发任务处理： 在并发编程中，线程池可以用于管理和执行大量的并行任务。例如，当需要处理大量数据或执行一系列异步任务时，线程池可以有效地管理线程资源，控制并发度，避免资源过度占用，提高系统的性能。\",\"定时任务调度： 线程池也经常用于执行定时任务或周期性任务。通过线程池可以轻松地调度和执行这些任务，而不必每次都手动创建和管理线程。\",\"数据库连接池： 在数据库访问中，线程池可以用于管理数据库连接。通过复用连接，避免频繁地创建和关闭数据库连接，提高数据库访问的效率和性能。\",\"线程池的应用范围广泛，主要优势在于有效地管理和复用线程资源，提高系统的性能和响应能力，同时避免了频繁创建和销毁线程所带来的开销。\"]},\"859\":{\"h\":\"3、有哪几种常见的线程池\",\"t\":[\"有哪些常见的线程池？\",\"主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。\",\"newFixedThreadPool (固定数目线程的线程池)\",\"newCachedThreadPool (可缓存线程的线程池)\",\"newSingleThreadExecutor (单线程的线程池)\",\"newScheduledThreadPool (定时及周期执行的线程池)\"]},\"860\":{\"h\":\"4、线程池的参数有哪些\",\"t\":[\"线程池的参数有哪些？\",\"线程池有七大参数，需要重点关注corePoolSize、maximumPoolSize、workQueue、handler这四个。\",\"corePoolSize：此值是用来初始化线程池中核心线程数，当线程池中线程池数 < corePoolSize时，系统默认是添加一个任务才创建一个线程池。当线程数 = corePoolSize时，新任务会追加到workQueue中。\",\"maximumPoolSize：maximumPoolSize表示允许的最大线程数 = (非核心线程数+核心线程数)，当BlockingQueue也满了，但线程池中总线程数 < maximumPoolSize时候就会再次创建新的线程。\",\"keepAliveTime：非核心线程 =(maximumPoolSize - corePoolSize ) ，非核心线程闲置下来不干活最多存活时间。\",\"unit：线程池中非核心线程保持存活的时间的单位\",\"workQueue：线程池等待队列，维护着等待执行的Runnable对象。当运行当线程数= corePoolSize时，新的任务会被添加到workQueue中，如果workQueue也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。\",\"threadFactory：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。\",\"handler：corePoolSize、workQueue、maximumPoolSize都不可用的时候执行的饱和策略\"]},\"861\":{\"h\":\"5、线程池的拒绝策略有哪些\",\"t\":[\"线程池的拒绝策略有哪些？\",\"AbortPolicy ：直接抛出异常，默认使用此策略\",\"CallerRunsPolicy：用调用者所在的线程来执行任务\",\"DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务\",\"DiscardPolicy ：当前任务直接丢弃\",\"示例：AbortPolicy - 经理：我们系统瘫痪了、CallerRunsPolicy - 谁写的bug你找谁去、DiscardOldestPolicy - 走排期，你加塞、DiscardPolicy - 做不了一点，明天再来吧\"]},\"862\":{\"h\":\"6、线程池有哪几种工作队列\",\"t\":[\"线程池有哪几种工作队列？\",\"ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。\",\"LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列\",\"DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。\",\"PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列\",\"SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。\"]},\"863\":{\"h\":\"7、线程池提交execute和submit有什么区别\",\"t\":[\"线程池提交execute和submit有什么区别？\",\"区别：在于提交的任务是否需要返回值\",\"execute 用于提交不需要返回值的任务\",\"threadsPool.execute(new Runnable() { @Override public void run() { // TODO Auto-generated method stub } }); \",\"submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值\",\"Future<Object> future = executor.submit(harReturnValuetask); try { Object s = future.get(); } catch (InterruptedException e) { // 处理中断异常 } catch (ExecutionException e) { // 处理无法执行任务异常 } finally { // 关闭线程池 executor.shutdown(); } \"]},\"864\":{\"h\":\"8、线程池怎么关闭\",\"t\":[\"线程池怎么关闭？\",\"可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。\",\"shutdown() 将线程池状态置为shutdown、并不会立即停止：\",\"停止接收外部submit的任务\",\"内部正在跑的任务和队列里等待的任务，会执行完\",\"等到第二步完成后，才真正停止\",\"shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定：\",\"和shutdown()一样，先停止接收外部提交的任务\",\"忽略队列里等待的任务\",\"尝试将正在跑的任务interrupt中断\",\"返回未执行的任务列表\",\"shutdown 和shutdownnow简单来说区别如下：\",\"shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。\",\"shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。\"]},\"865\":{\"h\":\"9、线程池异常怎么处理\",\"t\":[\"线程池异常怎么处理？\",\"在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。\",\"常见的异常处理方式：\",\"try-catch捕获异常\",\"submit执行，Future.get接受异常\",\"重'写ThreadPoolExecutor.afterExcute方法，处理传递的异常引用\",\"实例化时，传入自己的ThreadFactory设置Thread.UncaughtExceptionHandler处理未检测的异常\"]},\"866\":{\"h\":\"10、线程池的线程数应该怎么配置\",\"t\":[\"线程池的线程数应该怎么配置？\",\"线程池的线程数配置应该看线程池的作用：\",\"线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。\",\"计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。\",\"IO密集型：数据库链接，网络通讯传输等。\",\"一般的经验，不同类型线程池的参数配置：\",\"计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在页缺失(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：\",\"Runtime.getRuntime().availableProcessors(); \",\"IO密集型：线程数适当大一点，机器的Cpu核心数*2。\",\"混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。\",\"当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。\"]},\"867\":{\"h\":\"11、线程池有几种状态\",\"t\":[\"线程池有几种状态？\",\"线程池有这几个状态：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED。\",\"//线程池状态 private static final int RUNNING = -1 << COUNT_BITS; private static final int SHUTDOWN = 0 << COUNT_BITS; private static final int STOP = 1 << COUNT_BITS; private static final int TIDYING = 2 << COUNT_BITS; private static final int TERMINATED = 3 << COUNT_BITS; \",\"线程池各个状态切换图：\",\"RUNNING\",\"该状态的线程池会接收新任务，并处理阻塞队列中的任务;\",\"调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;\",\"调用线程池的shutdownNow()方法，可以切换到STOP状态;\",\"SHUTDOWN\",\"该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；\",\"队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;\",\"STOP\",\"该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；\",\"线程池中执行的任务为空,进入TIDYING状态;\",\"TIDYING\",\"该状态表明所有的任务已经运行终止，记录的任务数量为0。\",\"terminated()执行完毕，进入TERMINATED状态\",\"TERMINATED\",\"该状态表示线程池彻底终止\"]},\"868\":{\"h\":\"12、线程池工作流程\",\"t\":[\"说说线程池的工作流程？\",\"线程池的工作原理：\",\"线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。\",\"当调用 execute() 方法添加一个任务时，线程池会做如下判断：\",\"如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；\",\"如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\",\"如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\",\"如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。\",\"当一个线程完成任务时，它会从队列中取下一个任务来执行。\",\"当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\",\"具体示例：\",\"比如我们去银行窗口取款，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。\",\"如果去办业务，可能会遇到什么情况呢？\",\"发现有空间的在营业的窗口，直接去找小姐姐办理业务。\",\"发现没有空闲的窗口，就在排队区排队等。\",\"老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。\",\"小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。\",\"六个窗口都满了，等待区也没位置了，我急了，你呢，要闹，经理赶紧出来了，经理该怎么办呢？ \",\"我们银行系统已经瘫痪\",\"谁叫你来办的你找谁去\",\"看你比较急，去队里加个塞\",\"今天没办法，不行你看改一天\"]},\"869\":{\"h\":\"13、线程池如何实现参数的动态修改\",\"t\":[\"线程池如何实现参数的动态修改？\",\"线程池提供了几个 setter方法来设置线程池的参数。\",\"在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例通过setter方法来修改线程池的参数。\",\"如果限制了配置中心的使用，也可以自己去扩展ThreadPoolExecutor，重写方法，监听线程池参数变化，来动态修改线程池参数。\"]},\"870\":{\"h\":\"14、你能设计实现一个线程池\",\"t\":[\"你能设计实现一个线程池？\",\"我们自己的实现就是完成这个核心流程：\",\"线程池中要有N个工作线程\",\"把任务提交给线程池运行\",\"如果线程池已满，把任务放入队列\",\"最后当有空闲时，获取队列中任务来执行\",\"在帮你调整格式和完善代码前，有一些错误需要修正，比如变量命名、缺失的部分等。让我对代码进行修正和整理，然后再呈现给你。\",\"import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; public class MyThreadPoolExecutor implements Executor { private final AtomicInteger ctl = new AtomicInteger(0); private volatile int corePoolSize; private volatile int maximumPoolSize; private final BlockingQueue<Runnable> workQueue; public MyThreadPoolExecutor(int corePoolSize, int maximumPoolSize, BlockingQueue<Runnable> workQueue) { this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; } @Override public void execute(Runnable command) { int c = ctl.get(); if (c < corePoolSize) { if (!addWorker(command)) { reject(); } return; } if (!workQueue.offer(command)) { if (!addWorker(command)) { reject(); } } } private void reject() { throw new RuntimeException(\\\"Can not execute! ctl.count:\\\" + ctl.get() + \\\" workQueue size:\\\" + workQueue.size()); } private boolean addWorker(Runnable firstTask) { if (ctl.get() > maximumPoolSize) return false; Worker worker = new Worker(firstTask); worker.thread.start(); ctl.incrementAndGet(); return true; } private final class Worker implements Runnable { final Thread thread; Runnable firstTask; public Worker(Runnable firstTask) { this.thread = new Thread(this); this.firstTask = firstTask; } @Override public void run() { Runnable task = firstTask; try { while (task != null || (task = getTask()) != null) { task.run(); if (ctl.get() > maximumPoolSize) { break; } task = null; } } finally { ctl.decrementAndGet(); } } } private Runnable getTask() { for (;;) { try { System.out.println(\\\"workQueue size:\\\" + workQueue.size()); return workQueue.take(); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { MyThreadPoolExecutor myThreadPoolExecutor = new MyThreadPoolExecutor(2, 2, new ArrayBlockingQueue<>(10)); for (int i = 0; i < 10; i++) { int taskNum = i; myThreadPoolExecutor.execute(() -> { try { Thread.sleep(1500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"任务编号：\\\" + taskNum); }); } } } \"]},\"871\":{\"h\":\"15、单机线程池执行断电了应该怎么处理\",\"t\":[\"单机线程池执行断电了应该怎么处理？\",\"在使用之前就对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，执行中打印过程日志，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销正在处理的已经执行成功的操作。然后重新执行整个阻塞队列。\",\"也就是说，对阻塞队列持久化\",\"正在处理任务事务控制\",\"断电之后正在处理任务的回滚，通过日志恢复该次操作\",\"服务器重启后阻塞队列中的数据再加载\"]},\"872\":{\"c\":[\"面经收藏\"]},\"873\":{\"h\":\"Mysql-面试题\"},\"874\":{\"c\":[\"面经收藏\"]},\"875\":{\"h\":\"Redis-面试题\"},\"876\":{\"c\":[\"面经收藏\"]},\"877\":{\"h\":\"Rabbitmq框架-面试题\"},\"878\":{\"c\":[\"面经收藏\"]},\"879\":{\"h\":\"基于Springboot的网页云盘\"},\"880\":{\"c\":[\"面经收藏\"]},\"881\":{\"h\":\"基于Netty的RPC远程调用框架\"},\"882\":{\"c\":[\"面经收藏\"]},\"883\":{\"h\":\"基于Springboot的网页版短视频\"},\"884\":{\"c\":[\"面经收藏\"]},\"885\":{\"h\":\"场景题\"},\"886\":{\"c\":[\"面经收藏\"]},\"887\":{\"h\":\"Mybatis框架-面试题\"},\"888\":{\"c\":[\"面经收藏\"]},\"889\":{\"h\":\"Spring框架-面试题\"},\"890\":{\"c\":[\"面经收藏\"]},\"891\":{\"h\":\"SpringBoot框架-面试题\"},\"892\":{\"c\":[\"面经收藏\"]},\"893\":{\"h\":\"Spring框架-面试题\"},\"894\":{\"c\":[\"面经收藏\"]},\"895\":{\"h\":\"Middleware\"},\"896\":{\"h\":\"Project Situation\"},\"897\":{\"h\":\"Spring Framework\"}},\"dirtCount\":0,\"index\":[[\"断电之后正在处理任务的回滚\",{\"1\":{\"871\":1}}],[\"断开连接\",{\"1\":{\"94\":1}}],[\"今天没办法\",{\"1\":{\"868\":1}}],[\"今天晚上吃什么\",{\"1\":{\"325\":1}}],[\"今天晚上打算出去吃饭\",{\"1\":{\"325\":1}}],[\"蚌埠住了\",{\"1\":{\"868\":1}}],[\"跑完再彻底停止线程池\",{\"1\":{\"864\":1}}],[\"忽略队列里等待的任务\",{\"1\":{\"864\":1}}],[\"忽略t\",{\"1\":{\"316\":1}}],[\"走排期\",{\"1\":{\"861\":1}}],[\"谁叫你来办的你找谁去\",{\"1\":{\"868\":1}}],[\"谁写的bug你找谁去\",{\"1\":{\"861\":1}}],[\"谁进行空间担保\",{\"1\":{\"743\":1}}],[\"阿里巴巴\",{\"1\":{\"859\":1}}],[\"阿里云安全组开放\",{\"1\":{\"14\":1,\"40\":1}}],[\"阿里云服务器实例添加安全组端口\",{\"1\":{\"3\":1,\"29\":1}}],[\"销毁一个对象\",{\"1\":{\"857\":1}}],[\"销售渠道接口\",{\"1\":{\"506\":1}}],[\"销售方式等\",{\"1\":{\"506\":1}}],[\"合并操作会更加高效\",{\"1\":{\"855\":1}}],[\"合并操作\",{\"1\":{\"855\":1}}],[\"合理应用接口隔离原则可以简化系统的设计和维护工作\",{\"1\":{\"474\":1}}],[\"合理地使用继承和组合等技术\",{\"1\":{\"385\":1}}],[\"合理地使用备忘录模式可以使系统更加灵活和可靠\",{\"1\":{\"379\":1}}],[\"合理地应用模板方法设计模式可以使代码更加清晰\",{\"1\":{\"339\":1}}],[\"录入到excel之后\",{\"1\":{\"854\":1}}],[\"遗传算法里需要选出两个人作为交配对象\",{\"1\":{\"854\":1}}],[\"玩家数量\",{\"1\":{\"851\":1}}],[\"王者荣耀中也有类似的场景\",{\"1\":{\"851\":1}}],[\"王者荣耀\",{\"1\":{\"851\":1}}],[\"英雄联盟\",{\"1\":{\"851\":2}}],[\"协调子线程开始动作\",{\"1\":{\"851\":1}}],[\"协调子线程结束动作\",{\"1\":{\"851\":1}}],[\"协议为什么不可靠\",{\"0\":{\"664\":1}}],[\"协议数据单元\",{\"1\":{\"251\":1}}],[\"协议字段\",{\"1\":{\"251\":1,\"304\":1,\"575\":1}}],[\"协议是一种在数据链路层中常见的通信协议\",{\"1\":{\"584\":1}}],[\"协议是无状态的\",{\"0\":{\"560\":1}}],[\"协议是\",{\"1\":{\"251\":1}}],[\"协议三要素\",{\"1\":{\"250\":1}}],[\"协议中使用\",{\"1\":{\"207\":1}}],[\"协议和\",{\"1\":{\"162\":1,\"584\":1}}],[\"协议版本\",{\"1\":{\"107\":1}}],[\"协议\",{\"0\":{\"663\":1},\"1\":{\"90\":1,\"94\":1,\"131\":2,\"162\":1,\"250\":2,\"584\":1}}],[\"倒计数器\",{\"1\":{\"851\":1}}],[\"称\",{\"1\":{\"848\":1}}],[\"称为oopmap\",{\"1\":{\"747\":1}}],[\"称为区域\",{\"1\":{\"211\":1}}],[\"称为收敛\",{\"1\":{\"208\":1}}],[\"借助于算法\",{\"1\":{\"848\":1}}],[\"借助工具分析哪\",{\"1\":{\"769\":1}}],[\"靠按序申请资源来预防\",{\"1\":{\"848\":1}}],[\"破坏循环等待条件\",{\"1\":{\"848\":2}}],[\"破坏不剥夺条件\",{\"1\":{\"848\":1}}],[\"破坏请求与保持条件\",{\"1\":{\"848\":1}}],[\"破坏死锁的产生的必要条件即可\",{\"1\":{\"848\":1}}],[\"破坏了双亲委派原则\",{\"1\":{\"760\":1}}],[\"布尔型原子类\",{\"1\":{\"847\":1}}],[\"布局\",{\"1\":{\"539\":1}}],[\"账单不一致\",{\"1\":{\"845\":1}}],[\"独占方式和共享方式\",{\"1\":{\"846\":1}}],[\"独占锁\",{\"1\":{\"842\":1}}],[\"独占链路\",{\"1\":{\"125\":1}}],[\"乖乖排到后面\",{\"1\":{\"840\":1}}],[\"抢锁\",{\"1\":{\"840\":1}}],[\"抢先进入此方法的线程会优先拥有\",{\"1\":{\"835\":1}}],[\"失败后\",{\"1\":{\"840\":1}}],[\"尝试将正在跑的任务interrupt中断\",{\"1\":{\"864\":1}}],[\"尝试获取锁\",{\"1\":{\"839\":1}}],[\"尝试直接获取锁而不管其他线程的等待状态\",{\"1\":{\"839\":1}}],[\"尝试抢锁\",{\"1\":{\"837\":1}}],[\"竞争太激烈\",{\"1\":{\"837\":1}}],[\"竞争使用总线进行通信\",{\"1\":{\"152\":1}}],[\"轻量级锁抢锁失败\",{\"1\":{\"837\":1}}],[\"轻量级锁\",{\"1\":{\"837\":2}}],[\"轻量级锁和偏向锁等优化策略\",{\"1\":{\"837\":1}}],[\"轻松扩展新的产品类\",{\"1\":{\"430\":1}}],[\"叫mark\",{\"1\":{\"837\":1}}],[\"处的值更新为新值\",{\"1\":{\"845\":1}}],[\"处的值等于\",{\"1\":{\"845\":1}}],[\"处于等待锁block状态的线程\",{\"1\":{\"835\":1}}],[\"处于wait状态的线程\",{\"1\":{\"835\":1}}],[\"处理传递的异常引用\",{\"1\":{\"865\":1}}],[\"处理无法执行任务异常\",{\"1\":{\"863\":1}}],[\"处理中断异常\",{\"1\":{\"863\":1}}],[\"处理异常主要注意什么\",{\"1\":{\"793\":1}}],[\"处理\",{\"1\":{\"702\":3,\"703\":2}}],[\"处理支付\",{\"1\":{\"518\":2}}],[\"处理订单\",{\"1\":{\"518\":1}}],[\"处理订单支付\",{\"1\":{\"510\":1}}],[\"处理订单逻辑\",{\"1\":{\"489\":2}}],[\"处理订单的逻辑\",{\"1\":{\"461\":2}}],[\"处理元素逻辑\",{\"1\":{\"365\":1}}],[\"处理请求\",{\"1\":{\"350\":3}}],[\"处理器可以改变语句对应\",{\"1\":{\"826\":1}}],[\"处理器\",{\"1\":{\"350\":2}}],[\"处理put请求逻辑\",{\"1\":{\"338\":1}}],[\"处理post请求逻辑\",{\"1\":{\"338\":1}}],[\"处理get请求逻辑\",{\"1\":{\"338\":1}}],[\"处理http\",{\"1\":{\"338\":2}}],[\"处理http请求并生成响应\",{\"1\":{\"338\":1}}],[\"处理和关闭的逻辑\",{\"1\":{\"335\":1}}],[\"处理数据\",{\"1\":{\"335\":1}}],[\"处理读取到的字节数据\",{\"1\":{\"335\":1}}],[\"处理时延\",{\"1\":{\"263\":3}}],[\"处理的是动态分配信道给用户\",{\"1\":{\"150\":1}}],[\"禁止指令重排序\",{\"1\":{\"834\":1}}],[\"⽽访问⾮静态\",{\"1\":{\"833\":1}}],[\"⽽线程\",{\"1\":{\"833\":1}}],[\"⽅法占⽤的锁是当前实例对象锁\",{\"1\":{\"833\":1}}],[\"⽅法占⽤的锁是当前类的锁\",{\"1\":{\"833\":1}}],[\"⽅法\",{\"1\":{\"833\":2}}],[\"了多少个对象\",{\"1\":{\"833\":1}}],[\"了解\",{\"1\":{\"768\":1}}],[\"了解该时间点之前有没有程序上线\",{\"1\":{\"768\":1}}],[\"了解吗\",{\"0\":{\"854\":1},\"1\":{\"709\":1,\"854\":1}}],[\"业务服务读取线程池配置\",{\"1\":{\"869\":1}}],[\"业务数据错误\",{\"1\":{\"845\":1}}],[\"业务代码\",{\"1\":{\"833\":3}}],[\"业务场景\",{\"1\":{\"344\":1,\"525\":2}}],[\"乐观锁\",{\"1\":{\"832\":1}}],[\"悲观锁\",{\"1\":{\"832\":1}}],[\"悲观的并发策略\",{\"1\":{\"831\":1}}],[\"临界区代码块\",{\"1\":{\"832\":1}}],[\"条件变量等特性\",{\"1\":{\"832\":1}}],[\"得等所有人都确认之后\",{\"1\":{\"851\":1}}],[\"得出结果\",{\"1\":{\"831\":1}}],[\"得到当前线程对应的值\",{\"1\":{\"816\":1}}],[\"得到一个\",{\"1\":{\"792\":1}}],[\"得到的是一个全新的对象\",{\"1\":{\"784\":1}}],[\"得到的余数才能用来访问数组下标\",{\"1\":{\"694\":1}}],[\"得到差错检测码\",{\"1\":{\"135\":1,\"576\":1}}],[\"咱们以后的学习过程当中可能会接触到\",{\"1\":{\"831\":1}}],[\"永远都不会看到它在多个线程之中处于不一致的状态\",{\"1\":{\"831\":1}}],[\"永久代空间不足\",{\"1\":{\"739\":1}}],[\"永久代有\",{\"1\":{\"725\":1}}],[\"刷回后还是1\",{\"1\":{\"829\":1}}],[\"刷新权限\",{\"1\":{\"11\":1,\"37\":1}}],[\"屏障才会开门\",{\"1\":{\"852\":1}}],[\"屏障\",{\"1\":{\"827\":4}}],[\"屏蔽了操作系统底层的差异\",{\"1\":{\"827\":1}}],[\"屏蔽了核心网络结构和各种子网间的差异\",{\"1\":{\"275\":1}}],[\"屏蔽下层不同设备\",{\"1\":{\"573\":1}}],[\"屏蔽掉对原始对象的直接访问\",{\"1\":{\"494\":1}}],[\"屏蔽双绞线stp电缆\",{\"1\":{\"230\":1}}],[\"屏蔽网络差异\",{\"0\":{\"184\":1,\"589\":1}}],[\"鄙人三某\",{\"1\":{\"822\":1}}],[\"父线程使用类\",{\"1\":{\"822\":1}}],[\"父子线程怎么共享数据\",{\"0\":{\"822\":1},\"1\":{\"822\":1}}],[\"父类也会被初始化\",{\"1\":{\"755\":1}}],[\"父类也会被加载\",{\"1\":{\"755\":1}}],[\"父类\",{\"1\":{\"468\":1,\"495\":1}}],[\"黄金分割数\",{\"1\":{\"819\":1}}],[\"典型需要使用的类有simpledateformat和random\",{\"1\":{\"817\":1}}],[\"典型的全双工设备包括大多数现代网络设备\",{\"1\":{\"582\":1}}],[\"钥匙\",{\"1\":{\"816\":1}}],[\"抽屉内的外码\",{\"1\":{\"816\":1}}],[\"抽象同步队列\",{\"1\":{\"846\":1}}],[\"抽象数据类型\",{\"1\":{\"797\":1}}],[\"抽象部分接口中会包含对实现部分对象的引用\",{\"1\":{\"505\":1}}],[\"抽象部分是桥接模式的核心\",{\"1\":{\"505\":1}}],[\"抽象部分\",{\"1\":{\"504\":1}}],[\"抽象部分和实现部分可以独立地变化\",{\"1\":{\"505\":1}}],[\"抽象部分和实现部分可以独立地扩展和变化\",{\"1\":{\"504\":1}}],[\"抽象部分和实现部分通过组合关系连接在一起\",{\"1\":{\"505\":1}}],[\"抽象部分和实现部分分别由两个独立的类层次结构组成\",{\"1\":{\"504\":1}}],[\"抽象部分包含高层的抽象接口和方法\",{\"1\":{\"504\":1}}],[\"抽象装饰器\",{\"1\":{\"501\":1}}],[\"抽象组件\",{\"1\":{\"501\":1}}],[\"抽象父类\",{\"1\":{\"495\":1}}],[\"抽象工厂模式\",{\"1\":{\"490\":1}}],[\"抽象工厂接口定义了创建产品的抽象方法和加载具体产品的工厂方法\",{\"1\":{\"443\":1}}],[\"抽象工厂由接口\",{\"1\":{\"443\":1}}],[\"抽象工厂设计模式通过将产品的创建与使用相分离\",{\"1\":{\"444\":1}}],[\"抽象工厂设计模式旨在提供一个接口\",{\"1\":{\"443\":1}}],[\"抽象工厂设计模式适用于以下情景\",{\"1\":{\"442\":1}}],[\"抽象工厂设计模式的基本流程\",{\"1\":{\"441\":1}}],[\"抽象工厂设计模式的核心思想是通过提供一个抽象工厂接口\",{\"1\":{\"440\":1}}],[\"抽象工厂设计模式包含以下组成\",{\"1\":{\"441\":1}}],[\"抽象工厂设计模式\",{\"1\":{\"439\":1}}],[\"抽象工厂\",{\"0\":{\"438\":1},\"1\":{\"441\":1,\"443\":4}}],[\"抽象工厂和具体工厂部分\",{\"1\":{\"436\":1}}],[\"抽象工厂和具体工厂\",{\"1\":{\"436\":1}}],[\"抽象工厂类\",{\"1\":{\"434\":1}}],[\"抽象产品由接口\",{\"1\":{\"443\":1}}],[\"抽象产品\",{\"1\":{\"441\":1,\"443\":5}}],[\"抽象产品和具体产品部分\",{\"1\":{\"436\":1}}],[\"抽象产品和具体产品\",{\"1\":{\"436\":1}}],[\"抽象产品类\",{\"1\":{\"434\":1}}],[\"抽象表达式\",{\"1\":{\"390\":2,\"394\":1}}],[\"抽象元素\",{\"1\":{\"371\":1}}],[\"抽象访问者\",{\"1\":{\"371\":1}}],[\"抽象方法\",{\"1\":{\"332\":1,\"335\":3,\"336\":3,\"338\":3}}],[\"抽象类主要用于代码复用\",{\"1\":{\"783\":1}}],[\"抽象类可以有构造器\",{\"1\":{\"783\":1}}],[\"抽象类可以继承一个类\",{\"1\":{\"783\":1}}],[\"抽象类是一个类\",{\"1\":{\"783\":1}}],[\"抽象类decorator作为装饰器的基类\",{\"1\":{\"502\":1}}],[\"抽象类中定义了三个抽象方法\",{\"1\":{\"338\":1}}],[\"抽象类\",{\"1\":{\"332\":1,\"336\":1,\"782\":1}}],[\"守护线程\",{\"0\":{\"810\":1},\"1\":{\"810\":1}}],[\"切换实际上设计到了操作系统的原子性指令\",{\"1\":{\"809\":1}}],[\"切面\",{\"1\":{\"742\":1}}],[\"阻塞同步同步\",{\"1\":{\"831\":1}}],[\"阻塞状态\",{\"1\":{\"808\":1}}],[\"阻塞端口\",{\"1\":{\"175\":1}}],[\"仆人\",{\"1\":{\"804\":1}}],[\"管道输入\",{\"1\":{\"811\":3}}],[\"管家\",{\"1\":{\"804\":1}}],[\"管理\",{\"1\":{\"723\":1}}],[\"管理起来就容易一些\",{\"1\":{\"254\":1}}],[\"管理不同的信号传输方式\",{\"1\":{\"229\":1}}],[\"管理和利用各种传输介质\",{\"1\":{\"229\":1}}],[\"管理员无须一一手动创建\",{\"1\":{\"206\":1}}],[\"管理一个庞大的广播域会变得复杂\",{\"1\":{\"159\":1}}],[\"干不同的事情\",{\"1\":{\"804\":1}}],[\"框架和库开发\",{\"1\":{\"800\":1}}],[\"框架中\",{\"1\":{\"405\":1}}],[\"看你比较急\",{\"1\":{\"868\":1}}],[\"看看是否录入一致\",{\"1\":{\"854\":1}}],[\"看见\",{\"1\":{\"798\":1}}],[\"看里面的\",{\"1\":{\"134\":1,\"576\":1}}],[\"泛型提供了一种在编程中处理抽象类型的强大工具\",{\"1\":{\"797\":1}}],[\"泛型通配符\",{\"1\":{\"797\":1}}],[\"泛型方法\",{\"1\":{\"797\":1}}],[\"泛型接口\",{\"1\":{\"797\":1}}],[\"泛型类\",{\"1\":{\"797\":1}}],[\"泛型使得库能够提供通用的数据结构和算法\",{\"1\":{\"797\":1}}],[\"泛型可以用于定义通用的数据结构和算法\",{\"1\":{\"797\":1}}],[\"泛型可以在编译时期检查代码\",{\"1\":{\"797\":1}}],[\"泛型代码可以适用于多种数据类型\",{\"1\":{\"797\":1}}],[\"泛型的使用方式有以下几种\",{\"1\":{\"797\":1}}],[\"泛型的使用方式有哪几种\",{\"1\":{\"797\":2}}],[\"泛型的作用\",{\"1\":{\"797\":1}}],[\"泛型\",{\"1\":{\"797\":1}}],[\"泛型就是让程序更聪明地处理不同类型的数据\",{\"1\":{\"797\":1}}],[\"泛型就是一种让程序能够处理各种不同类型的数据的方法\",{\"1\":{\"797\":1}}],[\"捕获到的异常\",{\"1\":{\"795\":1}}],[\"捕获一个对象的内部状态\",{\"1\":{\"375\":1}}],[\"块时获取锁\",{\"1\":{\"832\":1}}],[\"块中遇到\",{\"1\":{\"795\":1}}],[\"块或方法的锁时\",{\"1\":{\"834\":1}}],[\"块或\",{\"1\":{\"795\":1}}],[\"块里的语句都会被执行\",{\"1\":{\"795\":1}}],[\"块\",{\"1\":{\"795\":4}}],[\"抛出异常后\",{\"1\":{\"865\":1}}],[\"抛出异常时抛出\",{\"1\":{\"793\":1}}],[\"抛出\",{\"1\":{\"793\":1}}],[\"缺失的部分等\",{\"1\":{\"870\":1}}],[\"缺少依赖项等情况\",{\"1\":{\"793\":1}}],[\"缺点\",{\"1\":{\"153\":2,\"205\":1,\"206\":1,\"253\":1,\"254\":1,\"255\":1,\"312\":2,\"339\":1,\"361\":1,\"367\":1,\"373\":1,\"379\":1,\"385\":1,\"396\":1,\"410\":1,\"421\":1,\"430\":1,\"444\":1,\"495\":1,\"496\":1,\"519\":1,\"533\":1,\"709\":1,\"744\":2,\"751\":1}}],[\"算术错误\",{\"1\":{\"793\":1}}],[\"算法会导致内存碎片比较多\",{\"1\":{\"751\":1}}],[\"算法一样\",{\"1\":{\"744\":1}}],[\"算法分为两个阶段\",{\"1\":{\"744\":1}}],[\"算法可互换\",{\"1\":{\"345\":1}}],[\"算法在运行过程中使用的内存空间主要包括以下几种\",{\"1\":{\"317\":1}}],[\"算法运行时间随着\",{\"1\":{\"316\":1}}],[\"算法运行时间不随着\",{\"1\":{\"316\":1}}],[\"算法\",{\"1\":{\"316\":8}}],[\"算法的效率主要评估的是时间和空间\",{\"1\":{\"313\":1}}],[\"算法效率评估\",{\"0\":{\"313\":1}}],[\"算法复杂\",{\"1\":{\"206\":1}}],[\"拼接完成之后调用\",{\"1\":{\"792\":1}}],[\"官方就说了绝大部分字符串对象只包含\",{\"1\":{\"789\":1}}],[\"暴露修改这个字符串的方法\",{\"1\":{\"789\":1}}],[\"哈希冲突\",{\"1\":{\"788\":1}}],[\"哈希码只是一个指示\",{\"1\":{\"787\":1}}],[\"哈希码也会不同\",{\"1\":{\"787\":1}}],[\"哈希码是一个整数\",{\"1\":{\"787\":1}}],[\"哈希表\",{\"1\":{\"311\":2,\"312\":2}}],[\"纳秒\",{\"1\":{\"785\":1}}],[\"跟之前的2个wait方法一样\",{\"1\":{\"785\":1}}],[\"跟\",{\"1\":{\"785\":1}}],[\"跟它之间的交互是跨不同进程的\",{\"1\":{\"327\":1}}],[\"唤醒一个在此对象监视器上等待的线程\",{\"1\":{\"785\":1}}],[\"故不允许子类重写\",{\"1\":{\"785\":1}}],[\"故一般两个端口都是连接集线器\",{\"1\":{\"171\":1}}],[\"顾名思义\",{\"1\":{\"782\":1}}],[\"松耦合\",{\"1\":{\"782\":1}}],[\"女朋友要吃饭的时候可以之间调用我来进行做饭\",{\"1\":{\"781\":1}}],[\"洗菜\",{\"1\":{\"781\":2}}],[\"⚠️\",{\"1\":{\"777\":1}}],[\"占一个字节\",{\"1\":{\"789\":1}}],[\"占内存大小\",{\"1\":{\"777\":1}}],[\"占用部分资源的线程进一步申请其他资源时\",{\"1\":{\"848\":1}}],[\"占用\",{\"1\":{\"789\":1}}],[\"占用过高怎么排查\",{\"0\":{\"765\":1},\"1\":{\"765\":1}}],[\"占用率\",{\"1\":{\"763\":1}}],[\"占用的内存却不能被回收\",{\"1\":{\"731\":1}}],[\"占用内存空间\",{\"1\":{\"317\":1}}],[\"含义\",{\"1\":{\"777\":1}}],[\"形式\",{\"1\":{\"777\":1,\"779\":1}}],[\"形成一种多态\",{\"1\":{\"782\":1}}],[\"形成一种类与类之间的结构\",{\"1\":{\"493\":2}}],[\"形成一个树状结构\",{\"1\":{\"525\":1}}],[\"形成一个个小的分段\",{\"1\":{\"193\":1}}],[\"形成国际性的远程网络\",{\"1\":{\"161\":1}}],[\"形成数据帧\",{\"1\":{\"153\":1}}],[\"修饰代码块\",{\"1\":{\"833\":1}}],[\"修饰静态方法\",{\"1\":{\"833\":1}}],[\"修饰实例方法\",{\"1\":{\"833\":1}}],[\"修饰\",{\"1\":{\"775\":1,\"816\":1}}],[\"修饰的代码段\",{\"1\":{\"832\":1}}],[\"修饰的区别在于\",{\"1\":{\"816\":1}}],[\"修饰的成员变量也必须显式地赋值\",{\"1\":{\"775\":1}}],[\"修饰的\",{\"1\":{\"775\":1,\"816\":6,\"846\":1}}],[\"修改完之后就会把新的值刷新回主内存\",{\"1\":{\"827\":1}}],[\"修改栈指针就可以把栈中的内容销毁\",{\"1\":{\"724\":1}}],[\"修改次数\",{\"1\":{\"710\":3}}],[\"修改\",{\"1\":{\"709\":1}}],[\"修改的效率是o\",{\"1\":{\"685\":1}}],[\"修改或限制\",{\"1\":{\"495\":1}}],[\"修改一个对象的内部结构或实现不会对其他对象产生太大的影响\",{\"1\":{\"488\":1}}],[\"修改和扩展\",{\"1\":{\"470\":1}}],[\"修改模块\",{\"1\":{\"464\":1}}],[\"修改其中一个部分不会影响到其他部分\",{\"1\":{\"461\":1}}],[\"修改订单处理逻辑\",{\"1\":{\"461\":1}}],[\"修改新促销活动的部分规则\",{\"1\":{\"455\":1}}],[\"修改新促销活动的日期\",{\"1\":{\"455\":1}}],[\"修改新歌单内的歌曲bad\",{\"1\":{\"454\":4}}],[\"修改文本并保存到历史记录\",{\"1\":{\"378\":1}}],[\"修改originator的状态并保存到备忘录\",{\"1\":{\"377\":1}}],[\"修改标志位\",{\"1\":{\"153\":1}}],[\"修改环境变量\",{\"1\":{\"19\":1,\"45\":1}}],[\"修改默认用户名和密码\",{\"1\":{\"5\":2,\"31\":2}}],[\"成员变量是对象的一部分\",{\"1\":{\"775\":1}}],[\"成员变量如果没有被赋初始值\",{\"1\":{\"775\":1}}],[\"成员变量和局部变量都能被\",{\"1\":{\"775\":1}}],[\"成员变量可以使用public\",{\"1\":{\"775\":1}}],[\"成员变量\",{\"1\":{\"775\":1,\"811\":1}}],[\"成员变量与局部变量的区别\",{\"0\":{\"775\":1},\"1\":{\"775\":2}}],[\"成为主题的观察者\",{\"1\":{\"324\":1}}],[\"拆分可以提升吞吐量\",{\"1\":{\"866\":1}}],[\"拆分为一个一个行为\",{\"1\":{\"781\":1}}],[\"拆箱其实就是调用了\",{\"1\":{\"773\":1}}],[\"拆除\",{\"1\":{\"275\":1}}],[\"装入\",{\"1\":{\"769\":1}}],[\"装饰器模式允许通过包装对象来动态地为对象添加额外的行为\",{\"1\":{\"502\":1}}],[\"装饰器包装了原始对象\",{\"1\":{\"501\":1}}],[\"装饰器\",{\"1\":{\"501\":1}}],[\"装饰器不会屏蔽原始对象的访问\",{\"1\":{\"500\":1}}],[\"装饰器类附加的是跟原始类相关的增强功能\",{\"1\":{\"500\":2}}],[\"装饰器设计模式\",{\"0\":{\"499\":1},\"1\":{\"500\":2}}],[\"装饰模式\",{\"1\":{\"490\":1}}],[\"摘要信息\",{\"1\":{\"769\":1}}],[\"抓取线程栈\",{\"1\":{\"769\":1}}],[\"入手\",{\"1\":{\"769\":1}}],[\"严重内存泄漏往往伴随频繁的\",{\"1\":{\"769\":1}}],[\"弄清楚可疑对象是否满足了进入到老年代的条件才能下结论\",{\"1\":{\"768\":1}}],[\"列出对应进程里面的线程占用资源情况\",{\"1\":{\"765\":1}}],[\"列出系统各个进程的资源占用情况\",{\"1\":{\"765\":1}}],[\"列表\",{\"1\":{\"670\":1}}],[\"列表则是一个待办事项列表\",{\"1\":{\"375\":1}}],[\"监听线程池参数变化\",{\"1\":{\"869\":1}}],[\"监听端口\",{\"1\":{\"8\":1,\"34\":1}}],[\"监视器相当于就是锁的概念\",{\"1\":{\"785\":1}}],[\"监控网络使用\",{\"1\":{\"762\":1}}],[\"监控\",{\"1\":{\"762\":1}}],[\"监控内存和\",{\"1\":{\"762\":1}}],[\"热更新问题\",{\"1\":{\"758\":1}}],[\"坏处\",{\"1\":{\"758\":1}}],[\"坏消息传播得慢\",{\"1\":{\"209\":1}}],[\"克隆\",{\"1\":{\"757\":1}}],[\"令是否正确等\",{\"1\":{\"754\":1}}],[\"令牌环\",{\"1\":{\"158\":1}}],[\"令牌总线和令牌环\",{\"1\":{\"158\":1}}],[\"令牌再次回到发送主机\",{\"1\":{\"153\":1}}],[\"令牌继续循环\",{\"1\":{\"153\":1}}],[\"令牌\",{\"1\":{\"153\":1,\"158\":1}}],[\"令牌传递协议\",{\"1\":{\"144\":1,\"153\":1}}],[\"跳转指\",{\"1\":{\"754\":1}}],[\"跳变仅表示时钟\",{\"1\":{\"238\":1}}],[\"证数据流和控制流的分析\",{\"1\":{\"754\":1}}],[\"否有父类\",{\"1\":{\"754\":1}}],[\"否则插入操作一直处于阻塞状态\",{\"1\":{\"862\":1}}],[\"否则根据插入到队列的先后排序\",{\"1\":{\"862\":1}}],[\"否则就遍历链表获取\",{\"1\":{\"711\":1}}],[\"否则抛出异常\",{\"1\":{\"709\":1}}],[\"否则向链表中插入数据\",{\"1\":{\"695\":1}}],[\"否则等待\",{\"1\":{\"578\":1}}],[\"否则将请求传递给下一个处理器\",{\"1\":{\"350\":1}}],[\"否则会报错无法获取数据库连接\",{\"1\":{\"853\":1}}],[\"否则会导致对象在哈希表中无法正确地被检索\",{\"1\":{\"788\":1}}],[\"否则会中途中断数据的传输\",{\"1\":{\"275\":1}}],[\"否则会获取最新版本的文档\",{\"1\":{\"114\":1}}],[\"否则被丢弃\",{\"1\":{\"205\":1}}],[\"否则\",{\"1\":{\"159\":1,\"422\":1,\"495\":1,\"700\":2,\"853\":1}}],[\"否则也会造成数据在传输过程中的丢失\",{\"1\":{\"140\":1,\"576\":1}}],[\"否则接收端来不及接收就会造成数据在传输过程中的丢失\",{\"1\":{\"140\":1,\"576\":1}}],[\"亦或它在没有停顿时间要求的单线程处理器上运行\",{\"1\":{\"752\":1}}],[\"浮动垃圾\",{\"1\":{\"751\":1}}],[\"晋升老年代\",{\"1\":{\"750\":1}}],[\"刚刚a\",{\"1\":{\"845\":1}}],[\"刚开始的时候都不属于\",{\"1\":{\"749\":1}}],[\"刚上电启动时\",{\"1\":{\"174\":1}}],[\"黑色\",{\"1\":{\"748\":1}}],[\"黑色对象插入白色引用\",{\"1\":{\"746\":1}}],[\"灰色\",{\"1\":{\"748\":1}}],[\"灰色和黑色\",{\"1\":{\"748\":1}}],[\"白色\",{\"1\":{\"748\":2}}],[\"白话\",{\"1\":{\"257\":1}}],[\"喝口水\",{\"1\":{\"747\":1}}],[\"车上东西很重\",{\"1\":{\"747\":1}}],[\"车载等\",{\"1\":{\"537\":1}}],[\"像这样的停顿\",{\"1\":{\"747\":1}}],[\"扫描过程中插入了一条或多条从黑色对象到白色对象的新引用\",{\"1\":{\"746\":1}}],[\"扫地机器人\",{\"1\":{\"473\":1}}],[\"卡表\",{\"1\":{\"742\":1}}],[\"年老代空间不足\",{\"1\":{\"741\":1}}],[\"年轻代中\",{\"1\":{\"764\":1}}],[\"年轻代占整个年轻代年老代和的\",{\"1\":{\"764\":1}}],[\"年轻代没有足够空间容纳存活的对象\",{\"1\":{\"741\":1}}],[\"年轻代gc的过程包括\",{\"1\":{\"741\":1}}],[\"年轻代垃圾回收\",{\"1\":{\"741\":1}}],[\"年龄加一\",{\"1\":{\"741\":1}}],[\"年龄大于或等于该年龄的对象就可以直接进入老年代\",{\"1\":{\"740\":1}}],[\"年龄到达阈值需要晋升这两种情况\",{\"1\":{\"739\":1}}],[\"长整型数组原子类\",{\"1\":{\"847\":1}}],[\"长整型原子类\",{\"1\":{\"847\":1}}],[\"长字符串之类的对\",{\"1\":{\"740\":1}}],[\"长期存活的对象将进入老年代\",{\"1\":{\"740\":1}}],[\"长度字段\",{\"1\":{\"575\":2}}],[\"拷贝过来对象\",{\"1\":{\"739\":1}}],[\"达到一定比例\",{\"1\":{\"739\":1}}],[\"区时\",{\"1\":{\"835\":1}}],[\"区的大小\",{\"1\":{\"768\":1}}],[\"区的比值\",{\"1\":{\"764\":1}}],[\"区和\",{\"1\":{\"768\":1}}],[\"区占整个年轻代的\",{\"1\":{\"764\":1}}],[\"区有两个\",{\"1\":{\"764\":1}}],[\"区与两个\",{\"1\":{\"764\":1}}],[\"区放不下从\",{\"1\":{\"739\":1}}],[\"区没有足够的空间时\",{\"1\":{\"739\":1}}],[\"区进行分配\",{\"1\":{\"739\":1}}],[\"区别之一是当最后一个非守护线程束时\",{\"1\":{\"810\":1}}],[\"区别于引用拷贝的一点\",{\"1\":{\"784\":1}}],[\"区别\",{\"0\":{\"704\":1,\"705\":1},\"1\":{\"411\":1,\"704\":1,\"705\":1,\"711\":1,\"783\":1,\"789\":1,\"812\":1,\"863\":1}}],[\"区别在于地址表项是否绑定了vlan\",{\"1\":{\"198\":1}}],[\"混合型\",{\"1\":{\"866\":2}}],[\"混合回收\",{\"1\":{\"750\":1}}],[\"混合收集\",{\"1\":{\"738\":1}}],[\"混合调制\",{\"1\":{\"239\":1,\"240\":1,\"619\":1}}],[\"逃过一劫\",{\"1\":{\"736\":1}}],[\"赋值给某个类变量或者对象的成员变量\",{\"1\":{\"736\":1}}],[\"譬如把自己\",{\"1\":{\"736\":1}}],[\"筛选的条件是此对象是否有必要执行\",{\"1\":{\"736\":1}}],[\"青天大老爷看看有没有什么冤情\",{\"1\":{\"736\":1}}],[\"幻影引用\",{\"1\":{\"735\":1}}],[\"幽灵引用\",{\"1\":{\"735\":1}}],[\"弱引用也是用来描述那些非必须对象\",{\"1\":{\"735\":1}}],[\"弱引用和虚引用4\",{\"1\":{\"735\":1}}],[\"版之后提供了\",{\"1\":{\"735\":3}}],[\"版本为\",{\"1\":{\"539\":1}}],[\"版本不兼容时\",{\"1\":{\"346\":2}}],[\"版本\",{\"1\":{\"107\":1,\"539\":3,\"760\":2}}],[\"强引用即使内存爆了也不会垃圾回收掉\",{\"1\":{\"818\":1}}],[\"强引用对象滞空\",{\"1\":{\"735\":3}}],[\"强引用是最传统的引用的定义\",{\"1\":{\"735\":1}}],[\"强度依次逐渐减弱\",{\"1\":{\"735\":1}}],[\"强调的是所属关系\",{\"1\":{\"783\":1}}],[\"强调对象之间的松耦合\",{\"1\":{\"490\":1}}],[\"强调避免重复代码的重要性\",{\"1\":{\"486\":1}}],[\"强调保持代码简单易懂的重要性\",{\"1\":{\"482\":1}}],[\"强调接口的精确性和客户端的需求\",{\"1\":{\"474\":1}}],[\"强调类的单一职责\",{\"1\":{\"474\":1}}],[\"强调将大型\",{\"1\":{\"474\":1}}],[\"种\",{\"1\":{\"735\":1}}],[\"软引用是用来描述一些还有用\",{\"1\":{\"735\":1}}],[\"软引用\",{\"1\":{\"735\":1}}],[\"软件设计原则\",{\"1\":{\"458\":1}}],[\"软件审批流程\",{\"1\":{\"355\":1}}],[\"软件端口\",{\"1\":{\"279\":1}}],[\"软件体系等都可以不同\",{\"1\":{\"83\":1}}],[\"废弃常量判断\",{\"1\":{\"733\":1}}],[\"废弃常量\",{\"1\":{\"733\":1}}],[\"探索所有能够被该集合引用到的对象\",{\"1\":{\"733\":1}}],[\"持久化等\",{\"1\":{\"800\":1}}],[\"持续飚高说明垃圾回收跟不上对象创建的速度\",{\"1\":{\"766\":1}}],[\"持续不断的加载类\",{\"1\":{\"731\":1}}],[\"持有资源\",{\"1\":{\"848\":2}}],[\"持有command对象\",{\"1\":{\"383\":1}}],[\"持有receiver对象\",{\"1\":{\"383\":1}}],[\"持有一个命令对象\",{\"1\":{\"382\":1}}],[\"持有一个接收者对象\",{\"1\":{\"382\":1}}],[\"持有当前的状态对象\",{\"1\":{\"359\":1}}],[\"持有处理器链的头部和尾部\",{\"1\":{\"353\":1}}],[\"持有策略\",{\"1\":{\"343\":1,\"344\":1,\"346\":1}}],[\"忘记关闭这些资源会导致持续占有内存\",{\"1\":{\"731\":1}}],[\"速度肯定慢很多\",{\"1\":{\"857\":1}}],[\"速度很快\",{\"1\":{\"746\":1,\"750\":1}}],[\"速度更快\",{\"1\":{\"730\":1}}],[\"速率是指连接在计算机网络上的主机在数字信道上传送比特的速率\",{\"1\":{\"260\":1}}],[\"速率\",{\"0\":{\"260\":1},\"1\":{\"260\":1}}],[\"商家厂房\",{\"1\":{\"730\":1}}],[\"商品接口\",{\"1\":{\"506\":1}}],[\"商品b\",{\"1\":{\"384\":1}}],[\"商品a\",{\"1\":{\"384\":1}}],[\"真实的数据\",{\"1\":{\"730\":1}}],[\"真机应用内容显示\",{\"1\":{\"538\":1}}],[\"真机调试\",{\"1\":{\"538\":2}}],[\"驿站\",{\"1\":{\"730\":1}}],[\"垃圾第一\",{\"1\":{\"749\":1,\"751\":1}}],[\"垃圾收集器不行\",{\"1\":{\"767\":1}}],[\"垃圾收集器应该如何选择\",{\"0\":{\"752\":1},\"1\":{\"752\":1}}],[\"垃圾收集器就永远不会回收掉被引用的对象\",{\"1\":{\"735\":1}}],[\"垃圾收集算法主要有三类\",{\"1\":{\"744\":1}}],[\"垃圾收集算法有了解吗\",{\"1\":{\"744\":1}}],[\"垃圾收集算法了解吗\",{\"0\":{\"744\":1}}],[\"垃圾收集时移动对象是非常普遍的行为\",{\"1\":{\"730\":1}}],[\"垃圾回收算法等等\",{\"1\":{\"768\":1}}],[\"垃圾回收等信息\",{\"1\":{\"763\":1}}],[\"垃圾回收时间\",{\"1\":{\"745\":1}}],[\"垃圾回收就是古代的秋后问斩\",{\"1\":{\"736\":1}}],[\"垃圾回收器依然没有回收完\",{\"1\":{\"764\":1}}],[\"垃圾回收器中\",{\"1\":{\"748\":1}}],[\"垃圾回收器在清理常量池时\",{\"1\":{\"733\":1}}],[\"垃圾回收器线程\",{\"1\":{\"721\":1}}],[\"垃圾回收的工作主要针对无用的类元数据信息进行处理\",{\"1\":{\"723\":1}}],[\"垃圾回收受jvm管理\",{\"1\":{\"723\":2}}],[\"垃圾回收\",{\"0\":{\"732\":1},\"1\":{\"720\":1,\"763\":1}}],[\"句柄池\",{\"1\":{\"730\":1}}],[\"句柄访问\",{\"1\":{\"730\":1}}],[\"句柄和直接指针两种\",{\"1\":{\"730\":1}}],[\"偏向锁将升级为轻量级锁\",{\"1\":{\"837\":1}}],[\"偏向锁状态抢锁失败\",{\"1\":{\"837\":1}}],[\"偏向锁\",{\"1\":{\"837\":1}}],[\"偏向时间戳\",{\"1\":{\"837\":1}}],[\"偏向时间戳等\",{\"1\":{\"729\":1}}],[\"偏向线程\",{\"1\":{\"729\":1}}],[\"肯定之前的有问题\",{\"1\":{\"725\":1}}],[\"唯一的区别就是会唤醒在此对象监视器上等待的所有线程\",{\"1\":{\"785\":1}}],[\"唯一的目的就是用于存放对象实例\",{\"1\":{\"724\":1}}],[\"唯一标识主机中的应用进程\",{\"1\":{\"279\":1}}],[\"局部变量则存在于栈内存的局部变量表\",{\"1\":{\"775\":1}}],[\"局部变量\",{\"1\":{\"724\":1,\"775\":1}}],[\"局域网内部通信\",{\"1\":{\"583\":1}}],[\"局域网中的mac地址\",{\"1\":{\"166\":1}}],[\"局域网的介质访问控制方法主要有csma\",{\"1\":{\"158\":1}}],[\"局域网的特性主要由三个要素决定\",{\"1\":{\"157\":1}}],[\"局域网可以使用双绞线\",{\"1\":{\"158\":1}}],[\"局域网\",{\"0\":{\"154\":1},\"1\":{\"121\":1,\"155\":1,\"162\":1}}],[\"受检查异常\",{\"1\":{\"793\":1}}],[\"受\",{\"1\":{\"723\":1}}],[\"彻底干掉了永久代\",{\"1\":{\"723\":1}}],[\"专门用来存储字符串字面量\",{\"1\":{\"722\":1}}],[\"符号引用验证\",{\"1\":{\"754\":1}}],[\"符号引用等信息\",{\"1\":{\"722\":1}}],[\"符合多态性原则\",{\"1\":{\"470\":1}}],[\"符合里氏替换原则的情况下\",{\"1\":{\"469\":2}}],[\"符合开闭原则\",{\"1\":{\"361\":1,\"444\":1}}],[\"寄存器以及其他的硬件和编译器优化\",{\"1\":{\"824\":1}}],[\"寄存器\",{\"1\":{\"722\":1}}],[\"程序的执行结果是符合预期的\",{\"1\":{\"814\":1}}],[\"程序就类似与我们的java的类文件\",{\"1\":{\"804\":1}}],[\"程序是静态的\",{\"1\":{\"804\":1}}],[\"程序是一组指令集合\",{\"1\":{\"804\":1}}],[\"程序通过类加载器加载一个类\",{\"1\":{\"799\":1}}],[\"程序本身可以处理的异常\",{\"1\":{\"793\":1}}],[\"程序\",{\"0\":{\"804\":1},\"1\":{\"768\":1,\"804\":1}}],[\"程序频繁生成一些长生命周期的对象\",{\"1\":{\"768\":1}}],[\"程序直接引用\",{\"1\":{\"756\":1}}],[\"程序代码\",{\"1\":{\"754\":1}}],[\"程序计数器\",{\"1\":{\"722\":1}}],[\"程序成功启动在创建的安卓虚拟机上\",{\"1\":{\"538\":1}}],[\"周期性任务线程\",{\"1\":{\"721\":1}}],[\"串行垃圾回收器\",{\"1\":{\"721\":1}}],[\"串行传输接收端存在一个字符同步的问题\",{\"1\":{\"234\":1}}],[\"串行传输存在的问题\",{\"1\":{\"234\":1}}],[\"串行传输\",{\"0\":{\"232\":1},\"1\":{\"232\":1}}],[\"卸载等场景下表现更优\",{\"1\":{\"725\":1}}],[\"卸载\",{\"1\":{\"720\":1,\"754\":1}}],[\"卸装\",{\"1\":{\"120\":1}}],[\"翻译成对应的机器指令然后进行运行的\",{\"1\":{\"719\":1}}],[\"意味着它可以保证多个线程同时对它进行读写操作时\",{\"1\":{\"713\":1}}],[\"拿\",{\"1\":{\"712\":1}}],[\"锁队列实现的\",{\"1\":{\"839\":1}}],[\"锁的实现\",{\"1\":{\"843\":1}}],[\"锁的释放\",{\"1\":{\"839\":1}}],[\"锁的获取\",{\"1\":{\"839\":1}}],[\"锁的重入次数\",{\"1\":{\"835\":1}}],[\"锁标志位改为10\",{\"1\":{\"837\":1}}],[\"锁标志位还是01\",{\"1\":{\"837\":1}}],[\"锁标志位是01\",{\"1\":{\"837\":1}}],[\"锁升级方向\",{\"1\":{\"837\":1}}],[\"锁升级的过程是什么样的\",{\"1\":{\"837\":1}}],[\"锁粗化\",{\"1\":{\"837\":2}}],[\"锁消除等\",{\"1\":{\"843\":1}}],[\"锁消除\",{\"1\":{\"837\":2}}],[\"锁对象有个计数器\",{\"1\":{\"836\":1}}],[\"锁对象的时候有个计数器\",{\"1\":{\"836\":1}}],[\"锁\",{\"0\":{\"830\":1}}],[\"锁是否被持有\",{\"1\":{\"813\":1}}],[\"锁机制包括加锁和释放锁\",{\"1\":{\"813\":1}}],[\"锁机制的主要目的是保护共享资源\",{\"1\":{\"813\":1}}],[\"锁机制\",{\"1\":{\"811\":1}}],[\"锁状态标志\",{\"1\":{\"729\":1,\"837\":1}}],[\"锁粒度更细\",{\"1\":{\"711\":1}}],[\"锁住整个table数组\",{\"1\":{\"708\":1}}],[\"放弃了\",{\"1\":{\"711\":1}}],[\"什么时候触发\",{\"0\":{\"739\":1}}],[\"什么情况下会发生\",{\"0\":{\"710\":1},\"1\":{\"710\":1}}],[\"什么是死锁\",{\"0\":{\"848\":1},\"1\":{\"848\":1}}],[\"什么是aqs\",{\"0\":{\"846\":1},\"1\":{\"846\":1}}],[\"什么是arp\",{\"0\":{\"607\":1}}],[\"什么是cas\",{\"0\":{\"845\":1},\"1\":{\"845\":1}}],[\"什么是cidr\",{\"0\":{\"604\":1}}],[\"什么是reentrantlock\",{\"1\":{\"838\":1}}],[\"什么是restful\",{\"0\":{\"554\":1}}],[\"什么是指令重排\",{\"1\":{\"826\":1}}],[\"什么是threadlocal\",{\"0\":{\"816\":1},\"1\":{\"816\":1}}],[\"什么是tcp的超时重传机制\",{\"0\":{\"657\":1}}],[\"什么是tcp的粘包和拆包问题\",{\"0\":{\"656\":1}}],[\"什么是线程池\",{\"0\":{\"857\":1},\"1\":{\"857\":1}}],[\"什么是线程安全\",{\"1\":{\"814\":1}}],[\"什么是线程上下文切换\",{\"1\":{\"809\":1}}],[\"什么是守护线程\",{\"1\":{\"810\":1}}],[\"什么是反射\",{\"0\":{\"798\":1},\"1\":{\"798\":2}}],[\"什么是泛型\",{\"0\":{\"797\":1},\"1\":{\"797\":2}}],[\"什么是hashcode\",{\"0\":{\"787\":1},\"1\":{\"787\":1}}],[\"什么是https\",{\"0\":{\"549\":1}}],[\"什么是http\",{\"0\":{\"548\":1,\"563\":1}}],[\"什么是引用拷贝\",{\"1\":{\"784\":2}}],[\"什么是双亲委派机制\",{\"0\":{\"758\":1},\"1\":{\"758\":1}}],[\"什么是安全点\",{\"0\":{\"747\":1}}],[\"什么是\",{\"0\":{\"747\":1},\"1\":{\"748\":1}}],[\"什么是strop\",{\"0\":{\"747\":1}}],[\"什么是空间分配担保\",{\"1\":{\"743\":1}}],[\"什么是空间分配担保机制\",{\"1\":{\"743\":1}}],[\"什么是跨代引用问题\",{\"1\":{\"742\":1}}],[\"什么是jvm\",{\"0\":{\"719\":1}}],[\"什么是udp协议\",{\"0\":{\"661\":1}}],[\"什么是延迟确认机制\",{\"0\":{\"660\":1}}],[\"什么是nagle算法\",{\"0\":{\"659\":1}}],[\"什么是nat\",{\"0\":{\"605\":1}}],[\"什么是快速重传和快速恢复\",{\"0\":{\"658\":1}}],[\"什么是滑动窗口协议\",{\"0\":{\"654\":1}}],[\"什么是流量控制\",{\"0\":{\"653\":1}}],[\"什么是拥塞控制\",{\"0\":{\"652\":1}}],[\"什么是拥塞窗口\",{\"1\":{\"297\":1}}],[\"什么是半连接队列和\",{\"0\":{\"643\":1}}],[\"什么是dhcp\",{\"0\":{\"612\":1}}],[\"什么是dns\",{\"0\":{\"567\":1}}],[\"什么是防火墙\",{\"0\":{\"610\":1}}],[\"什么是bgp协议\",{\"0\":{\"609\":1}}],[\"什么是ospf协议\",{\"0\":{\"608\":1}}],[\"什么是静态路由和动态路由\",{\"0\":{\"606\":1}}],[\"什么是ip地址分配方式\",{\"0\":{\"613\":1}}],[\"什么是ip地址\",{\"0\":{\"599\":1}}],[\"什么是路由器\",{\"0\":{\"598\":1}}],[\"什么是默认网关\",{\"0\":{\"597\":1},\"1\":{\"597\":1}}],[\"什么是子网掩码\",{\"0\":{\"595\":1},\"1\":{\"595\":1}}],[\"什么是vlan\",{\"1\":{\"579\":1}}],[\"什么是虚拟局域网\",{\"0\":{\"579\":1},\"1\":{\"579\":1}}],[\"什么是mac地址\",{\"0\":{\"574\":1},\"1\":{\"574\":1}}],[\"什么是ftp\",{\"0\":{\"569\":1}}],[\"什么是websocket\",{\"0\":{\"565\":1}}],[\"什么是慢开始门限ssthresh\",{\"1\":{\"297\":1}}],[\"什么是网络\",{\"1\":{\"246\":1}}],[\"什么是调制和解调\",{\"0\":{\"619\":1},\"1\":{\"619\":1}}],[\"什么是调制\",{\"1\":{\"239\":1}}],[\"什么是编码\",{\"1\":{\"238\":1}}],[\"什么是数据链路管理\",{\"1\":{\"123\":1}}],[\"场景2\",{\"1\":{\"851\":1}}],[\"场景1\",{\"1\":{\"851\":1}}],[\"场景描述\",{\"1\":{\"845\":1}}],[\"场景\",{\"1\":{\"709\":2}}],[\"场景题\",{\"0\":{\"630\":1,\"885\":1}}],[\"粒度比较大\",{\"1\":{\"708\":1}}],[\"粒度更细的类\",{\"1\":{\"462\":1}}],[\"覆盖了\",{\"1\":{\"707\":1}}],[\"覆盖范围\",{\"1\":{\"162\":1}}],[\"获得当前cpu核心数代码如下\",{\"1\":{\"866\":1}}],[\"获得\",{\"1\":{\"707\":1}}],[\"获得时间片\",{\"1\":{\"707\":2}}],[\"获取队列中任务来执行\",{\"1\":{\"870\":1}}],[\"获取相应的线程池实例通过setter方法来修改线程池的参数\",{\"1\":{\"869\":1}}],[\"获取当前的latch数量\",{\"1\":{\"851\":1}}],[\"获取state的方式分为两种\",{\"1\":{\"846\":1}}],[\"获取锁的过程中可以被中断\",{\"1\":{\"841\":1}}],[\"获取\",{\"1\":{\"835\":1}}],[\"获取悲观读锁\",{\"1\":{\"832\":1}}],[\"获取读锁时如果发现写锁被占用\",{\"1\":{\"842\":1}}],[\"获取读锁\",{\"1\":{\"832\":1}}],[\"获取到\",{\"1\":{\"807\":1}}],[\"获取成员信息\",{\"1\":{\"799\":1}}],[\"获取类信息\",{\"1\":{\"799\":1}}],[\"获取键和值\",{\"1\":{\"702\":1}}],[\"获取节点\",{\"1\":{\"700\":1}}],[\"获取新的哈希值\",{\"1\":{\"700\":1}}],[\"获取一个新的哈希值\",{\"1\":{\"695\":1}}],[\"获取字节数组\",{\"1\":{\"455\":1}}],[\"获取前缀\",{\"1\":{\"436\":1,\"443\":1}}],[\"获取了具体工厂类的映射关系\",{\"1\":{\"436\":1}}],[\"获取所需的产品对象\",{\"1\":{\"427\":1}}],[\"获取长度和创建迭代器等方法\",{\"1\":{\"366\":1}}],[\"获取元素\",{\"1\":{\"366\":1}}],[\"获取运算数\",{\"1\":{\"343\":1,\"346\":1}}],[\"获取ip地址\",{\"1\":{\"64\":1}}],[\"举个不是很恰当的例子\",{\"1\":{\"804\":1}}],[\"举个例子\",{\"1\":{\"707\":1}}],[\"举例来说\",{\"1\":{\"222\":1}}],[\"倍\",{\"1\":{\"706\":1}}],[\"倍数\",{\"0\":{\"688\":1},\"1\":{\"688\":1}}],[\"做不了一点\",{\"1\":{\"861\":1}}],[\"做饭\",{\"1\":{\"781\":2}}],[\"做常量\",{\"1\":{\"776\":1}}],[\"做\",{\"1\":{\"701\":1}}],[\"做了四次移位和四次异或\",{\"1\":{\"701\":1}}],[\"做一个\",{\"1\":{\"694\":1}}],[\"散列方法重新计算位置\",{\"1\":{\"821\":1}}],[\"散列方法就是怎么把对应的key映射到table数组的相应下标\",{\"1\":{\"819\":1}}],[\"散列方法\",{\"1\":{\"819\":1}}],[\"散列函数\",{\"1\":{\"701\":1}}],[\"散列也更均衡\",{\"1\":{\"691\":1}}],[\"头插法会使链表发生反转\",{\"1\":{\"701\":1}}],[\"头插法扩容时\",{\"1\":{\"701\":1}}],[\"降为o\",{\"1\":{\"701\":1}}],[\"降低性能\",{\"1\":{\"855\":1}}],[\"降低修改一个功能对其他部分造成的影响\",{\"1\":{\"486\":1}}],[\"降低出错的概率\",{\"1\":{\"480\":1}}],[\"降低代码的耦合性\",{\"1\":{\"470\":2,\"473\":1}}],[\"降低代码复杂度\",{\"1\":{\"361\":1}}],[\"降低风险\",{\"1\":{\"461\":1}}],[\"降低客户端代码的耦合性时\",{\"1\":{\"428\":1}}],[\"降低耦合性\",{\"1\":{\"411\":1}}],[\"降低耦合\",{\"1\":{\"410\":1}}],[\"降低了内存占用\",{\"1\":{\"533\":1}}],[\"降低了出错的风险\",{\"1\":{\"486\":1}}],[\"降低了引入错误和bug的风险\",{\"1\":{\"482\":1}}],[\"降低了可维护性\",{\"1\":{\"465\":1}}],[\"降低了风险\",{\"1\":{\"461\":1}}],[\"降低了客户端代码的耦合性\",{\"1\":{\"425\":1,\"430\":1}}],[\"降低了对聚合对象的依赖\",{\"1\":{\"367\":1}}],[\"降低了代码的复杂度\",{\"1\":{\"361\":2}}],[\"降低发送的数据量\",{\"1\":{\"296\":1}}],[\"降低传输效率\",{\"1\":{\"291\":1}}],[\"冲突检测的乐观并发策略\",{\"1\":{\"831\":1}}],[\"冲突\",{\"1\":{\"701\":1}}],[\"冲突停止\",{\"1\":{\"578\":1}}],[\"左旋和右旋\",{\"1\":{\"699\":1}}],[\"左边为尾部\",{\"1\":{\"268\":1}}],[\"旋转分为两种\",{\"1\":{\"699\":1}}],[\"旋转\",{\"1\":{\"699\":1}}],[\"旋转和染色\",{\"1\":{\"699\":1}}],[\"阈值为什么要选8呢\",{\"1\":{\"697\":1}}],[\"牺牲了空间换时间\",{\"1\":{\"697\":1}}],[\"太小了容易hash冲突\",{\"1\":{\"696\":1}}],[\"太大了分布不均匀\",{\"1\":{\"696\":1}}],[\"太长的数据报来不及发送完毕\",{\"1\":{\"291\":1}}],[\"顺便说一下\",{\"1\":{\"694\":1}}],[\"顺序不同\",{\"1\":{\"780\":1}}],[\"顺序存储和分散存储\",{\"1\":{\"312\":1}}],[\"顺序\",{\"1\":{\"312\":1,\"780\":1}}],[\"顺序与链式\",{\"0\":{\"312\":1}}],[\"位于方法区\",{\"1\":{\"775\":1}}],[\"位于网络模型的最底部\",{\"1\":{\"226\":1,\"227\":1}}],[\"位置区别\",{\"1\":{\"775\":1}}],[\"位系统中的\",{\"1\":{\"725\":1}}],[\"位\",{\"1\":{\"694\":1,\"789\":1}}],[\"位运算比取余\",{\"1\":{\"694\":1}}],[\"亿长度的数组\",{\"1\":{\"694\":1}}],[\"亿的映射空间\",{\"1\":{\"694\":1}}],[\"型散列值\",{\"1\":{\"694\":1}}],[\"扰动函数\",{\"1\":{\"694\":1}}],[\"扰动函数能降hash碰撞\",{\"0\":{\"694\":1},\"1\":{\"694\":1}}],[\"扰动函数是怎么设计的\",{\"0\":{\"693\":1}}],[\"^\",{\"1\":{\"693\":1,\"695\":1}}],[\"^8\",{\"1\":{\"220\":1}}],[\"找到占用内存高的对象\",{\"1\":{\"766\":1}}],[\"找到对应线程\",{\"1\":{\"765\":1}}],[\"找到空闲位置的方法也有很多种\",{\"1\":{\"692\":1}}],[\"找不到对应的目的端口号\",{\"1\":{\"301\":1}}],[\"找不到对方\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"折叠法\",{\"1\":{\"691\":1}}],[\"折扣策略接口\",{\"1\":{\"465\":1}}],[\"折扣\",{\"1\":{\"455\":1}}],[\"取独占资源时被挂起后放入aqs\",{\"1\":{\"846\":1}}],[\"取出key的threadlocalhashcode\",{\"1\":{\"819\":1}}],[\"取件码\",{\"1\":{\"816\":1}}],[\"取key平方的中间几位作为映射的位置\",{\"1\":{\"691\":1}}],[\"取key的某些数字\",{\"1\":{\"691\":1}}],[\"取决于具体的设置和规则\",{\"1\":{\"205\":1}}],[\"效率更高\",{\"1\":{\"691\":1}}],[\"泊松分布是一种描述在一定时间或空间区域内随机事件发生次数的概率分布\",{\"1\":{\"696\":1}}],[\"泊松分布\",{\"1\":{\"690\":1,\"696\":1}}],[\"⽐如传了17\",{\"1\":{\"689\":1}}],[\"阀值\",{\"1\":{\"689\":1}}],[\"键和多个\",{\"1\":{\"705\":1,\"706\":1}}],[\"键和排序\",{\"1\":{\"705\":1}}],[\"键和值都可以是\",{\"1\":{\"687\":1}}],[\"键\",{\"1\":{\"704\":1,\"705\":1}}],[\"键值的支持\",{\"1\":{\"706\":1}}],[\"键值\",{\"1\":{\"706\":1}}],[\"键值类型自带的哈希函数\",{\"1\":{\"694\":1}}],[\"键值数据库\",{\"0\":{\"544\":1}}],[\"键是唯一的\",{\"1\":{\"687\":1}}],[\"桶数组\",{\"1\":{\"685\":1}}],[\"某些线程安全的集合类\",{\"1\":{\"844\":1}}],[\"某一个部位的链表特别长\",{\"1\":{\"685\":1,\"686\":1}}],[\"某主机的1p地址为180\",{\"1\":{\"218\":1}}],[\"红黑树\",{\"1\":{\"711\":1,\"714\":1,\"715\":1}}],[\"红黑树的组合实现的\",{\"1\":{\"706\":1}}],[\"红黑树有两种方式保持平衡\",{\"1\":{\"699\":1}}],[\"红黑树怎么保持平衡的知道吗\",{\"0\":{\"699\":1},\"1\":{\"699\":1}}],[\"红黑树是一种平衡的二叉树\",{\"1\":{\"698\":1}}],[\"红黑树本质上是一种二叉查找树\",{\"1\":{\"698\":1}}],[\"红黑树节点的大小大概是普通节点大小的两倍\",{\"1\":{\"697\":1}}],[\"红黑树用于以提高查询效率\",{\"1\":{\"685\":1,\"686\":1}}],[\"红外线\",{\"1\":{\"230\":1}}],[\"至于红黑树转回链表的阈值为什么是6\",{\"1\":{\"697\":1}}],[\"至于写操作\",{\"1\":{\"682\":1}}],[\"至此\",{\"1\":{\"81\":1}}],[\"读锁可以被同时读\",{\"1\":{\"842\":1}}],[\"读锁是共享锁\",{\"1\":{\"842\":1}}],[\"读锁\",{\"1\":{\"842\":1}}],[\"读读不互斥\",{\"1\":{\"842\":1}}],[\"读读互斥\",{\"1\":{\"842\":1}}],[\"读写互斥\",{\"1\":{\"842\":2}}],[\"读写锁进行并发控制的规则\",{\"1\":{\"842\":1}}],[\"读写锁适用于读多写少的场景\",{\"1\":{\"832\":1}}],[\"读写锁\",{\"1\":{\"832\":1}}],[\"读\",{\"1\":{\"832\":1}}],[\"读操作也会直接从主内存中获取最新值\",{\"1\":{\"834\":1}}],[\"读操作\",{\"1\":{\"832\":1}}],[\"读操作的结果与后续的写操作重排序\",{\"1\":{\"827\":1}}],[\"读操作的结果被后续的写操作\",{\"1\":{\"827\":1}}],[\"读操作的后面插入一个\",{\"1\":{\"827\":2}}],[\"读操作与之前的读操作重排序\",{\"1\":{\"827\":1}}],[\"读操作之前完成\",{\"1\":{\"827\":1}}],[\"读操作之前的所有读操作\",{\"1\":{\"827\":1}}],[\"读操作还是普通读操作\",{\"1\":{\"827\":2}}],[\"读操作是可见的\",{\"1\":{\"827\":1}}],[\"读操作是无锁的\",{\"1\":{\"682\":1}}],[\"读也是以threadlocal作为引用\",{\"1\":{\"816\":1}}],[\"读取共享资源的操作\",{\"1\":{\"832\":1}}],[\"读取\",{\"1\":{\"335\":1}}],[\"读取数据\",{\"1\":{\"335\":1}}],[\"读取文件中的字节数据\",{\"1\":{\"335\":1}}],[\"写threadpoolexecutor\",{\"1\":{\"865\":1}}],[\"写锁是独占锁\",{\"1\":{\"842\":1}}],[\"写锁\",{\"1\":{\"842\":1}}],[\"写写互斥\",{\"1\":{\"842\":2}}],[\"写和乐观读\",{\"1\":{\"832\":1}}],[\"写操作还是普通写操作\",{\"1\":{\"827\":1}}],[\"写操作所写入的最新值\",{\"1\":{\"827\":1}}],[\"写操作之后的所有读操作\",{\"1\":{\"827\":1}}],[\"写操作之前的所有普通写操作\",{\"1\":{\"827\":1}}],[\"写操作的结果对后续的\",{\"1\":{\"827\":1}}],[\"写操作的后面插入一个\",{\"1\":{\"827\":1}}],[\"写操作的数据重排序\",{\"1\":{\"827\":1}}],[\"写操作的数据与之前的非\",{\"1\":{\"827\":1}}],[\"写操作的前面插入一个\",{\"1\":{\"827\":1}}],[\"写操作\",{\"1\":{\"827\":2}}],[\"写操作在副本上\",{\"1\":{\"682\":1}}],[\"写缓冲区\",{\"1\":{\"824\":1,\"826\":1}}],[\"写共享变量的副本\",{\"1\":{\"824\":1}}],[\"写\",{\"1\":{\"788\":1}}],[\"写屏障可以看作在虚拟机层面对\",{\"1\":{\"742\":1}}],[\"写入数据同样判断链表\",{\"1\":{\"711\":1}}],[\"写完将元素数组指向副本\",{\"1\":{\"682\":1}}],[\"写时复制\",{\"1\":{\"682\":1}}],[\"写代码的时候要保持简单\",{\"1\":{\"480\":1}}],[\"剩下的50不用其实不用序列化\",{\"1\":{\"680\":1}}],[\"遍历完成之后\",{\"1\":{\"821\":1}}],[\"遍历整个堆内存的一个存活对象的对象图\",{\"1\":{\"746\":1}}],[\"遍历整个老年代所有对象的方案虽然理论上可行\",{\"1\":{\"742\":1}}],[\"遍历node数组\",{\"1\":{\"711\":1}}],[\"遍历hashentry\",{\"1\":{\"711\":1}}],[\"遍历冲突\",{\"1\":{\"710\":1}}],[\"遍历下一个元素之前\",{\"1\":{\"709\":1}}],[\"遍历时不能保证顺序与插入顺序相同\",{\"1\":{\"706\":1}}],[\"遍历按插入顺序的结果\",{\"1\":{\"703\":1}}],[\"遍历按键排序后的结果\",{\"1\":{\"703\":1}}],[\"遍历每个键\",{\"1\":{\"702\":1}}],[\"遍历每个键值对\",{\"1\":{\"702\":1}}],[\"遍历键集合\",{\"1\":{\"702\":1}}],[\"遍历\",{\"1\":{\"702\":3}}],[\"遍历链表\",{\"1\":{\"701\":1}}],[\"遍历链表查找\",{\"1\":{\"700\":1}}],[\"遍历方式\",{\"1\":{\"679\":1}}],[\"遍历文件系统\",{\"1\":{\"525\":1}}],[\"节省资源\",{\"1\":{\"857\":1}}],[\"节省一半的内存空间\",{\"1\":{\"789\":1}}],[\"节点内部的\",{\"1\":{\"846\":1}}],[\"节点\",{\"1\":{\"698\":1}}],[\"节点增减刚好在8附近\",{\"1\":{\"697\":1}}],[\"节点个数为8的情况\",{\"1\":{\"697\":1}}],[\"节点包括pre\",{\"1\":{\"678\":1}}],[\"节日折扣策略\",{\"1\":{\"465\":1}}],[\"节日折扣\",{\"1\":{\"465\":2}}],[\"尾部删除\",{\"1\":{\"677\":1,\"678\":1}}],[\"尾部插入\",{\"1\":{\"677\":1,\"678\":1}}],[\"排查过程和排查内存泄漏过程类似\",{\"1\":{\"770\":1}}],[\"排查指南\",{\"1\":{\"768\":1}}],[\"排查有哪些原因导致\",{\"1\":{\"768\":1}}],[\"排序等方面发挥了重要作用\",{\"1\":{\"674\":1}}],[\"排队时延\",{\"1\":{\"263\":2}}],[\"映射表\",{\"1\":{\"747\":1}}],[\"映射到hash表\",{\"1\":{\"685\":1}}],[\"映射\",{\"1\":{\"670\":1}}],[\"挥手为什么需要四次呢\",{\"0\":{\"645\":1}}],[\"攻击有什么关系\",{\"0\":{\"643\":1}}],[\"攻击者发送大量伪造的tcp连接请求\",{\"1\":{\"285\":1}}],[\"未抢到锁的线程都会被阻塞排队\",{\"1\":{\"837\":1}}],[\"未清理到任何数据\",{\"1\":{\"821\":1}}],[\"未被引用的对象会被标记为垃圾并清理掉\",{\"1\":{\"741\":1}}],[\"未被探索到的对象便是死亡的\",{\"1\":{\"733\":1}}],[\"未完待续\",{\"0\":{\"623\":1}}],[\"未打标签\",{\"1\":{\"159\":3}}],[\"规范\",{\"1\":{\"720\":1}}],[\"规定了在理想条件下\",{\"1\":{\"622\":1}}],[\"规则引擎将根据这些条件对输入数据进行判断和处理\",{\"1\":{\"391\":1}}],[\"规则引擎是典型的使用责任链模式的场景\",{\"1\":{\"355\":1}}],[\"规则引擎\",{\"1\":{\"355\":1}}],[\"奈氏准则用于确定最低的采样率\",{\"1\":{\"622\":1}}],[\"奈氏准则\",{\"1\":{\"622\":1}}],[\"奈氏准则和香农公式在通信中扮演着什么样的角色\",{\"0\":{\"622\":1},\"1\":{\"622\":1}}],[\"奈氏准用于确保信号采样的正确性\",{\"1\":{\"622\":1}}],[\"奈式准则\",{\"1\":{\"240\":1}}],[\"奈式准则和香农公式\",{\"1\":{\"240\":1}}],[\"抗干扰能力\",{\"1\":{\"619\":1}}],[\"哪些时候会触发类加载\",{\"0\":{\"755\":1}}],[\"哪些位用于主机标识\",{\"1\":{\"595\":1}}],[\"哪部分用于主机标识的32位二进制数字\",{\"1\":{\"595\":1}}],[\"帮助网络设备正确地定位和传输数据\",{\"1\":{\"595\":1}}],[\"帮助路由器决定如何将数据包传输到正确的目的地\",{\"1\":{\"595\":1}}],[\"帮助计算机识别一个ip地址所属的网络和主机\",{\"1\":{\"595\":1,\"596\":1}}],[\"帮助确保数据的可靠传输和通信的稳定性\",{\"1\":{\"584\":1}}],[\"家人可能喊二字\",{\"1\":{\"594\":1}}],[\"家居用品商品\",{\"1\":{\"506\":1}}],[\"家居用品等\",{\"1\":{\"506\":1}}],[\"老三去排队区排队\",{\"1\":{\"868\":1}}],[\"老三发现没有空闲的窗口\",{\"1\":{\"868\":1}}],[\"老王累的汗流浃背\",{\"1\":{\"747\":1}}],[\"老年代垃圾回收\",{\"1\":{\"750\":1}}],[\"老年代的region占比到达45\",{\"1\":{\"750\":1}}],[\"老年代多少空间\",{\"1\":{\"749\":1}}],[\"老年代同样如此\",{\"1\":{\"749\":1}}],[\"老年代使用标记\",{\"1\":{\"744\":1}}],[\"老年代要进行空间分配担保\",{\"1\":{\"743\":1}}],[\"老年代如果放不下的话都会触发\",{\"1\":{\"739\":1}}],[\"老年代内存使用率过高\",{\"1\":{\"739\":1}}],[\"老年代空间不足\",{\"1\":{\"739\":1}}],[\"老年代收集\",{\"1\":{\"738\":1}}],[\"老年代\",{\"1\":{\"722\":1,\"737\":1,\"750\":2}}],[\"老师可能喊我张阿三\",{\"1\":{\"594\":1}}],[\"老的支付接口实现\",{\"1\":{\"510\":1}}],[\"老的支付接口\",{\"1\":{\"510\":1}}],[\"街道地址\",{\"1\":{\"594\":1}}],[\"错误\",{\"1\":{\"731\":1,\"769\":1}}],[\"错误检测与纠正以及连接管理等多种作用\",{\"1\":{\"584\":1}}],[\"错误检测和纠错\",{\"1\":{\"584\":1}}],[\"错误的处理帧\",{\"1\":{\"132\":1,\"577\":1}}],[\"载波监听\",{\"1\":{\"581\":1}}],[\"载波监听多点接入\",{\"1\":{\"581\":1}}],[\"载波监听多址接入\",{\"1\":{\"152\":2}}],[\"间需要路由器才能通信\",{\"1\":{\"580\":1}}],[\"间距等样式\",{\"1\":{\"104\":1}}],[\"操作无法继续下去的时候\",{\"1\":{\"871\":1}}],[\"操作实现的\",{\"1\":{\"855\":1}}],[\"操作来尝试获取锁\",{\"1\":{\"839\":1}}],[\"操作来确保对变量的操作是原子性的\",{\"1\":{\"831\":1}}],[\"操作系统提供消息队列的机制\",{\"1\":{\"811\":1}}],[\"操作系统可以利用时钟中断来更新系统时间\",{\"1\":{\"809\":1}}],[\"操作系统工具\",{\"1\":{\"762\":1}}],[\"操作数栈用于方法内的计算\",{\"1\":{\"722\":1}}],[\"操作导致\",{\"1\":{\"707\":1}}],[\"操作会导致线程不安全\",{\"1\":{\"707\":1}}],[\"操作如下\",{\"1\":{\"694\":1}}],[\"操作的结果就是散列值的高位全部归零\",{\"1\":{\"694\":1}}],[\"操作\",{\"1\":{\"580\":2,\"694\":1,\"707\":2,\"839\":1,\"844\":1,\"853\":2}}],[\"操作封装到易于使用的高层模块中\",{\"1\":{\"419\":1}}],[\"跨代引用相对于同代引用来说仅占极少数\",{\"1\":{\"742\":1}}],[\"跨代引用问题\",{\"0\":{\"742\":1}}],[\"跨平台\",{\"1\":{\"719\":1}}],[\"跨网络通信\",{\"1\":{\"593\":1}}],[\"跨越了路由器等设备\",{\"1\":{\"579\":1}}],[\"跨越不同的网络设备\",{\"1\":{\"579\":1}}],[\"跨进程通信型\",{\"1\":{\"327\":1}}],[\"号\",{\"1\":{\"579\":1}}],[\"市场部门的设备被划分到一个独立的vlan中\",{\"1\":{\"579\":1}}],[\"市场部门vlan\",{\"1\":{\"579\":1}}],[\"市场部门和技术部门\",{\"1\":{\"579\":1}}],[\"想象一栋大楼里的不同办公室和部门组成了一个大的局域网\",{\"1\":{\"579\":1}}],[\"想办法实现发送端发送什么\",{\"1\":{\"136\":1}}],[\"影响用户对支付系统的信任和体验\",{\"1\":{\"845\":1}}],[\"影响性能\",{\"1\":{\"834\":1}}],[\"影响了性能\",{\"1\":{\"696\":1}}],[\"影响传输效率\",{\"1\":{\"578\":1}}],[\"影响因素\",{\"1\":{\"240\":1}}],[\"灵活\",{\"1\":{\"578\":1}}],[\"灵活性\",{\"1\":{\"396\":1}}],[\"灵活性差\",{\"1\":{\"253\":1}}],[\"边际效用也不大\",{\"1\":{\"701\":1}}],[\"边听边发\",{\"1\":{\"578\":1}}],[\"边界网关协议\",{\"1\":{\"212\":1}}],[\"先停止接收外部提交的任务\",{\"1\":{\"864\":1}}],[\"先看看内存里的那个值到底变没变\",{\"1\":{\"845\":1}}],[\"先进行操作\",{\"1\":{\"831\":1,\"832\":1}}],[\"先进行插入\",{\"1\":{\"701\":1}}],[\"先是根据我们需要什么功能再设计出什么来\",{\"1\":{\"813\":1}}],[\"先引发\",{\"1\":{\"768\":1}}],[\"先观察垃圾回收的情况\",{\"1\":{\"766\":1}}],[\"先需要找出那个进程占用\",{\"1\":{\"765\":1}}],[\"先预定主食\",{\"1\":{\"728\":1}}],[\"先在本地缓冲区中分配\",{\"1\":{\"728\":1}}],[\"先完成了插入操作\",{\"1\":{\"707\":1}}],[\"先判断是否需要扩容\",{\"1\":{\"701\":1}}],[\"先听后发\",{\"1\":{\"578\":1}}],[\"先检查缓存中是否存在查询结果\",{\"1\":{\"495\":1}}],[\"奇偶校验\",{\"1\":{\"576\":1}}],[\"奇偶校验码\",{\"0\":{\"134\":1},\"1\":{\"134\":1}}],[\"损坏或丢失\",{\"1\":{\"576\":1}}],[\"面经收藏\",{\"2\":{\"571\":1,\"585\":1,\"615\":1,\"624\":1,\"633\":1,\"667\":1,\"716\":1,\"771\":1,\"801\":1,\"872\":1,\"874\":1,\"876\":1,\"878\":1,\"880\":1,\"882\":1,\"884\":1,\"886\":1,\"888\":1,\"890\":1,\"892\":1,\"894\":1}}],[\"面试题\",{\"0\":{\"546\":1,\"572\":1,\"586\":1,\"616\":1,\"634\":1,\"668\":1,\"717\":1,\"772\":1,\"802\":1,\"873\":1,\"875\":1,\"877\":1,\"887\":1,\"889\":1,\"891\":1,\"893\":1}}],[\"面向对象三大特征\",{\"0\":{\"782\":1},\"1\":{\"782\":2}}],[\"面向对象会先抽象出对象\",{\"1\":{\"781\":1}}],[\"面向对象和面向过程的区别\",{\"0\":{\"781\":1},\"1\":{\"781\":2}}],[\"面向过程把解决问题的过程拆成一个个方法\",{\"1\":{\"781\":1}}],[\"面向切面编程\",{\"1\":{\"496\":1}}],[\"面向连接的tcp\",{\"1\":{\"273\":1}}],[\"面向连接的虚电路服务\",{\"1\":{\"184\":1}}],[\"面向连接\",{\"1\":{\"158\":1}}],[\"面向字符传输\",{\"1\":{\"131\":1}}],[\"活动的意图过滤器\",{\"1\":{\"539\":1}}],[\"活动的类名\",{\"1\":{\"539\":1}}],[\"圆形图标\",{\"1\":{\"539\":1}}],[\"库的通用性\",{\"1\":{\"797\":1}}],[\"库\",{\"1\":{\"539\":4}}],[\"库存\",{\"1\":{\"518\":2}}],[\"库存管理子系统\",{\"1\":{\"518\":1}}],[\"库存管理\",{\"1\":{\"518\":1}}],[\"清理过期entry\",{\"1\":{\"821\":2}}],[\"清理年轻代中的垃圾\",{\"1\":{\"741\":1}}],[\"清楚排查问题时能使用哪些工具\",{\"1\":{\"768\":1}}],[\"清空之后呢\",{\"1\":{\"749\":1}}],[\"清除算法面对大量可回收对象时执行效率低的问题\",{\"1\":{\"744\":1}}],[\"清除算法标记\",{\"1\":{\"744\":1}}],[\"清除之后会产生大量不连续的内存碎片\",{\"1\":{\"744\":1}}],[\"清除\",{\"1\":{\"744\":3,\"748\":1}}],[\"清单文件\",{\"1\":{\"539\":2}}],[\"清晰简洁的代码结构\",{\"1\":{\"361\":1}}],[\"💬\",{\"1\":{\"538\":1}}],[\"🔺ppp帧\",{\"1\":{\"129\":1}}],[\"启动时会调用\",{\"1\":{\"810\":1}}],[\"启动类加载器\",{\"1\":{\"755\":1,\"756\":1}}],[\"启动过程中\",{\"1\":{\"538\":1}}],[\"启用全方位dns风险监测\",{\"1\":{\"81\":1}}],[\"右侧device\",{\"1\":{\"538\":1}}],[\"手动选择accept\",{\"1\":{\"538\":1}}],[\"手机安卓发布的app\",{\"1\":{\"538\":1}}],[\"手机\",{\"1\":{\"537\":1}}],[\"碰到license\",{\"1\":{\"538\":1}}],[\"碰撞解决方法\",{\"1\":{\"711\":1}}],[\"碰撞的判断\",{\"1\":{\"707\":1}}],[\"碰撞也会很严重\",{\"1\":{\"694\":1}}],[\"碰撞避免\",{\"1\":{\"152\":1}}],[\"碰撞检测\",{\"1\":{\"152\":1,\"581\":2}}],[\"碰撞问题\",{\"1\":{\"121\":1}}],[\"平衡二叉树是比红黑树更严格的平衡树\",{\"1\":{\"698\":1}}],[\"平衡树呢\",{\"0\":{\"698\":1},\"1\":{\"698\":1}}],[\"平方探查法\",{\"1\":{\"692\":1}}],[\"平方取中法\",{\"1\":{\"691\":1}}],[\"平方阶通常出现在嵌套循环中\",{\"1\":{\"316\":1}}],[\"平方阶的操作数量相对于输入数据大小\",{\"1\":{\"316\":1}}],[\"平板\",{\"1\":{\"537\":1}}],[\"环境的配置\",{\"1\":{\"536\":1}}],[\"环主要用于环形局域网\",{\"1\":{\"158\":1}}],[\"学生\",{\"1\":{\"532\":1}}],[\"学习数据结构前的必会知识\",{\"0\":{\"308\":1}}],[\"学习完全依靠邻居路由器\",{\"1\":{\"208\":1}}],[\"考试系统里面的试卷\",{\"1\":{\"532\":1}}],[\"考虑一个具体的场景\",{\"1\":{\"829\":1}}],[\"考虑一个电商平台的订单处理系统\",{\"1\":{\"333\":1}}],[\"考虑到java中的继承关系\",{\"1\":{\"813\":1}}],[\"考虑到转义字符也可能在帧内部出现\",{\"1\":{\"132\":1}}],[\"考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流\",{\"1\":{\"227\":1}}],[\"样式\",{\"1\":{\"532\":1}}],[\"享元对象根据内部状态和外部状态的组合来执行具体操作\",{\"1\":{\"530\":1}}],[\"享元对象\",{\"1\":{\"530\":1}}],[\"享元工厂\",{\"1\":{\"530\":1}}],[\"享元设计模式在需要创建大量相似对象并且关注内存和性能优化的情况下非常有用\",{\"1\":{\"533\":1}}],[\"享元设计模式通过共享对象来减少内存使用和提高性能\",{\"1\":{\"533\":1}}],[\"享元设计模式适用于以下场景\",{\"1\":{\"531\":1}}],[\"享元设计模式的基本流程如下\",{\"1\":{\"530\":1}}],[\"享元设计模式的核心思想是共享对象\",{\"1\":{\"529\":1}}],[\"享元设计模式由以下组成部分构成\",{\"1\":{\"530\":1}}],[\"享元设计模式\",{\"0\":{\"527\":1},\"1\":{\"528\":1}}],[\"享元模式会引入共享对象的管理逻辑\",{\"1\":{\"533\":1}}],[\"享元模式旨在减少内存使用和提高性能\",{\"1\":{\"528\":1}}],[\"享元模式\",{\"1\":{\"490\":1}}],[\"希望这个总结对您有帮助\",{\"1\":{\"526\":1}}],[\"希望这个例子能够更好地展示模板方法设计模式的应用\",{\"1\":{\"335\":1}}],[\"搜索还是执行操作\",{\"1\":{\"526\":1}}],[\"角色\",{\"1\":{\"526\":1}}],[\"角色不同\",{\"1\":{\"386\":1}}],[\"显式锁来实现同步\",{\"1\":{\"831\":1}}],[\"显式调用\",{\"1\":{\"755\":1}}],[\"显式调用system\",{\"1\":{\"741\":1}}],[\"显示系统整体资源使用情况\",{\"1\":{\"762\":1}}],[\"显示在应用商店等地方\",{\"1\":{\"539\":1}}],[\"显示hello\",{\"1\":{\"538\":1}}],[\"显示sync\",{\"1\":{\"538\":1}}],[\"显示组织架构\",{\"1\":{\"525\":1}}],[\"显然\",{\"1\":{\"316\":1}}],[\"财务部门的计算机\",{\"1\":{\"579\":1}}],[\"财务部门vlan\",{\"1\":{\"579\":1}}],[\"财务部\",{\"1\":{\"525\":1}}],[\"人力资源部\",{\"1\":{\"525\":1}}],[\"员工和组合对象\",{\"1\":{\"525\":1}}],[\"员工\",{\"1\":{\"525\":1}}],[\"员工类\",{\"1\":{\"525\":1}}],[\"疾速备战\",{\"1\":{\"525\":3}}],[\"疾速追杀\",{\"1\":{\"525\":3}}],[\"音频还是其他类型的数据\",{\"1\":{\"577\":1}}],[\"音频和视频\",{\"1\":{\"238\":1}}],[\"音频和视频等多媒体内容\",{\"1\":{\"96\":1}}],[\"音乐文件夹下包含了三个音乐文件和一个歌词文件夹\",{\"1\":{\"525\":1}}],[\"音乐文件夹包含三首歌和一个歌词文件夹\",{\"1\":{\"525\":1}}],[\"音乐\",{\"1\":{\"525\":3}}],[\"歌词文件夹中包含了三个歌词文件\",{\"1\":{\"525\":1}}],[\"歌词文件夹中包含三个歌词文件\",{\"1\":{\"525\":1}}],[\"歌词\",{\"1\":{\"525\":3}}],[\"歌单包含原歌单playlist1的所有歌曲\",{\"1\":{\"454\":2}}],[\"歌单\",{\"1\":{\"454\":4}}],[\"菜单栏等\",{\"1\":{\"524\":1}}],[\"叶子对象不能有子组件\",{\"1\":{\"526\":1}}],[\"叶子对象的限制\",{\"1\":{\"526\":1}}],[\"叶子对象\",{\"1\":{\"526\":1}}],[\"叶子节点\",{\"1\":{\"524\":1}}],[\"叶子类\",{\"1\":{\"524\":1}}],[\"叶子类表示组合中的叶子节点\",{\"1\":{\"524\":1}}],[\"叶子\",{\"1\":{\"524\":1}}],[\"部门和员工都实现了component接口\",{\"1\":{\"525\":1}}],[\"部门\",{\"1\":{\"525\":1}}],[\"部门类\",{\"1\":{\"525\":1}}],[\"部分收集\",{\"1\":{\"738\":1}}],[\"部分\",{\"1\":{\"522\":1}}],[\"部署java项目\",{\"0\":{\"21\":1,\"47\":1}}],[\"尤其是当元素数量巨大时\",{\"1\":{\"685\":1}}],[\"尤其是在需要隐藏复杂性并提供统一接口的情况下\",{\"1\":{\"519\":1}}],[\"尤其是用于批量传输文件\",{\"1\":{\"83\":1}}],[\"承担过多的责任\",{\"1\":{\"519\":1}}],[\"揽件\",{\"1\":{\"518\":2}}],[\"付款成功\",{\"1\":{\"518\":2}}],[\"展示如何使用门面设计模式来简化订单处理系统\",{\"1\":{\"518\":1}}],[\"展示了装饰器模式的应用\",{\"1\":{\"502\":1}}],[\"展示了一个简单的订单处理系统\",{\"1\":{\"461\":1}}],[\"展示了抽象工厂设计模式的实现\",{\"1\":{\"443\":1}}],[\"展示了如何使用观察者设计模式实现网络聊天室\",{\"1\":{\"325\":1}}],[\"价格计算和订单生成等子系统的交互封装起来\",{\"1\":{\"517\":1}}],[\"门面模式可以将与客房管理\",{\"1\":{\"517\":1}}],[\"门面模式可以用于封装与库存管理\",{\"1\":{\"517\":1}}],[\"门面类可以调用子系统组件来完成客户端请求的处理\",{\"1\":{\"516\":1}}],[\"门面对象充当了客户端与子系统之间的中介\",{\"1\":{\"515\":1}}],[\"门面\",{\"1\":{\"515\":1,\"516\":1,\"518\":1}}],[\"门面设计模式是一种有助于简化复杂系统的交互和提高系统可维护性的设计模式\",{\"1\":{\"519\":1}}],[\"门面设计模式是一种有用的设计模式\",{\"1\":{\"519\":1}}],[\"门面设计模式在许多场景中都有应用\",{\"1\":{\"517\":1}}],[\"门面设计模式通常在以下情况下使用\",{\"1\":{\"517\":1}}],[\"门面设计模式的基本流程如下\",{\"1\":{\"516\":1}}],[\"门面设计模式的核心思想是提供一个高层接口\",{\"1\":{\"515\":1}}],[\"门面设计模式由以下几个主要组成部分组成\",{\"1\":{\"516\":1}}],[\"门面设计模式\",{\"0\":{\"513\":1},\"1\":{\"514\":1,\"520\":1}}],[\"服装商品\",{\"1\":{\"506\":1}}],[\"服务端使用的端口号\",{\"1\":{\"279\":1}}],[\"服务数据单元\",{\"1\":{\"251\":1}}],[\"服务原语\",{\"1\":{\"251\":1}}],[\"服务访问点\",{\"1\":{\"251\":1}}],[\"服务是\",{\"1\":{\"251\":1}}],[\"服务\",{\"0\":{\"251\":1},\"1\":{\"251\":2,\"722\":1,\"769\":1}}],[\"服务器重启后阻塞队列中的数据再加载\",{\"1\":{\"871\":1}}],[\"服务器端发完数据\",{\"1\":{\"286\":1}}],[\"服务器端回送一个确认报文段\",{\"1\":{\"286\":1}}],[\"服务器端为该tcp连接分配缓存和变量\",{\"1\":{\"285\":1}}],[\"服务器可以启用syn\",{\"1\":{\"285\":1}}],[\"服务器上\",{\"1\":{\"268\":1}}],[\"服务器就发回一个接一个的响应报文\",{\"1\":{\"112\":1}}],[\"服务器响应\",{\"1\":{\"108\":1}}],[\"服务器和服务器之间采用http\",{\"1\":{\"99\":1}}],[\"服务器接收邮件内容后\",{\"1\":{\"94\":1}}],[\"服务器接收到请求后\",{\"1\":{\"58\":1}}],[\"服务器回复应答代码221\",{\"1\":{\"94\":1}}],[\"服务器回复应答代码250\",{\"1\":{\"94\":3}}],[\"服务器回复应答代码354\",{\"1\":{\"94\":1}}],[\"服务器会在数据端口\",{\"1\":{\"86\":1}}],[\"服务器会在随机的端口上监听\",{\"1\":{\"85\":1}}],[\"服务器会告诉客户端在哪个端口上建立数据连接\",{\"1\":{\"85\":1}}],[\"服务器会通过控制连接告诉客户端在哪个端口上建立数据连接\",{\"1\":{\"85\":1}}],[\"服务器模型的\",{\"1\":{\"85\":1}}],[\"服务器模型中\",{\"1\":{\"58\":1}}],[\"服务器\",{\"0\":{\"80\":1},\"1\":{\"78\":2,\"79\":1,\"257\":1}}],[\"服务器具有固定端口号\",{\"1\":{\"58\":1}}],[\"服务器总是处于运行等待状态\",{\"1\":{\"58\":1}}],[\"服务器是服务提供方\",{\"1\":{\"58\":1}}],[\"服务器方式所描述的是进程之间服务和被服务的关系\",{\"1\":{\"58\":1}}],[\"服务器方式\",{\"1\":{\"58\":1,\"97\":1,\"98\":1}}],[\"移动存活对象是个极为负重的操作\",{\"1\":{\"744\":1}}],[\"移动应用渠道\",{\"1\":{\"506\":1}}],[\"移动应用\",{\"1\":{\"506\":1}}],[\"移除商品命令类\",{\"1\":{\"384\":1}}],[\"移除和调整处理器的顺序\",{\"1\":{\"353\":1}}],[\"移除订阅者和发布事件的方法\",{\"1\":{\"326\":1}}],[\"供程序运行时使用\",{\"1\":{\"755\":1}}],[\"供程序执行额外的动作\",{\"1\":{\"742\":1}}],[\"供抽象部分调用\",{\"1\":{\"504\":1}}],[\"供应商或客户\",{\"1\":{\"223\":1}}],[\"界面显示和逻辑处理\",{\"0\":{\"540\":1}}],[\"界面会有临时的进入网站\",{\"1\":{\"3\":1,\"29\":1}}],[\"界\",{\"1\":{\"502\":9}}],[\"里禁止使用这种方式来创建线程池\",{\"1\":{\"859\":1}}],[\"里\",{\"0\":{\"728\":1},\"1\":{\"728\":1}}],[\"里几乎所有的对象实例都在这里分配内存\",{\"1\":{\"722\":1}}],[\"里面没有一个线程\",{\"1\":{\"868\":1}}],[\"里面有一个内部类\",{\"1\":{\"838\":1}}],[\"里面保存指向对象锁mark\",{\"1\":{\"837\":1}}],[\"里面可以传入等待时间\",{\"1\":{\"812\":1}}],[\"里面包含一个segment数组\",{\"1\":{\"711\":1}}],[\"里面维护一个原生对象\",{\"1\":{\"500\":1}}],[\"里氏替换原则是面向对象设计中的一个重要原则\",{\"1\":{\"470\":1}}],[\"里氏替换原则是多态性的基础之一\",{\"1\":{\"470\":1}}],[\"里氏替换原则\",{\"0\":{\"467\":1},\"1\":{\"468\":1}}],[\"拦截器中的\",{\"1\":{\"498\":1}}],[\"领域\",{\"1\":{\"496\":1}}],[\"示例数据和填充对齐组成\",{\"1\":{\"813\":1}}],[\"示例\",{\"1\":{\"495\":4,\"582\":2,\"703\":2,\"861\":1}}],[\"示例代码如下\",{\"1\":{\"344\":1}}],[\"示例代码\",{\"1\":{\"332\":1}}],[\"示例代码的主类\",{\"1\":{\"325\":1}}],[\"隐藏底层的网络细节\",{\"1\":{\"495\":1}}],[\"隐藏底层的网络通信细节\",{\"1\":{\"495\":1}}],[\"隐藏了底层子系统的复杂性\",{\"1\":{\"520\":1}}],[\"隐藏了底层实现\",{\"1\":{\"366\":1}}],[\"隐藏了具体对象的创建细节\",{\"1\":{\"452\":1}}],[\"职责链模式\",{\"1\":{\"490\":1}}],[\"桥接类\",{\"1\":{\"506\":1}}],[\"桥接设计模式\",{\"0\":{\"503\":1}}],[\"桥接模式是一种结构型设计模式\",{\"1\":{\"505\":1}}],[\"桥接模式的核心思想\",{\"1\":{\"504\":1}}],[\"桥接模式\",{\"1\":{\"490\":1,\"504\":1}}],[\"桥标识\",{\"1\":{\"175\":1}}],[\"迪米特法则有助于提高代码的可测试性\",{\"1\":{\"490\":1}}],[\"迪米特法则能够促进代码的模块化和封装性\",{\"1\":{\"490\":1}}],[\"迪米特法则鼓励使用中间层或接口来实现对象之间的通信\",{\"1\":{\"490\":1}}],[\"迪米特法则的核心思想是减少对象之间的直接依赖关系\",{\"1\":{\"490\":1}}],[\"迪米特法则在设计和编写代码时\",{\"1\":{\"490\":1}}],[\"迪米特原则使得系统中的对象独立性更强\",{\"1\":{\"488\":1}}],[\"迪米特原则的核心思想是将对象设计为尽可能少地依赖其他对象\",{\"1\":{\"488\":1}}],[\"迪米特原则\",{\"0\":{\"487\":1},\"1\":{\"488\":1}}],[\"耦合度越低\",{\"1\":{\"488\":1}}],[\"喵喵\",{\"1\":{\"485\":1}}],[\"汪汪\",{\"1\":{\"485\":1}}],[\"动物在吃东西\",{\"1\":{\"485\":1}}],[\"动态加载类\",{\"1\":{\"800\":1}}],[\"动态分派\",{\"1\":{\"780\":1}}],[\"动态分配线路\",{\"1\":{\"255\":1}}],[\"动态地选择垃圾最多的区域进行回收\",{\"1\":{\"751\":1}}],[\"动态地组织和分配处理器\",{\"1\":{\"355\":1}}],[\"动态年龄判断\",{\"1\":{\"750\":1}}],[\"动态对象年龄判定\",{\"1\":{\"740\":1}}],[\"动态生成的常量等\",{\"1\":{\"722\":1}}],[\"动态连接用于解析对应对象的真实内存\",{\"1\":{\"722\":1}}],[\"动态获取mac地址\",{\"1\":{\"583\":1}}],[\"动态代理还可以用于远程方法调用\",{\"1\":{\"496\":1}}],[\"动态代理常用于aop\",{\"1\":{\"496\":1}}],[\"动态代理只能代理接口\",{\"1\":{\"496\":1}}],[\"动态代理的性能相对较低\",{\"1\":{\"496\":1}}],[\"动态代理可以减少代码量\",{\"1\":{\"496\":1}}],[\"动态代理可以在运行时动态地创建代理对象\",{\"1\":{\"496\":1}}],[\"动态代理不需要手动编写代理类\",{\"1\":{\"496\":1}}],[\"动态代理\",{\"0\":{\"496\":1},\"1\":{\"494\":1,\"496\":1,\"800\":1}}],[\"动态创建具体工厂对象\",{\"1\":{\"443\":1}}],[\"动态通信和状态同步\",{\"1\":{\"328\":1}}],[\"动态的网络拓扑变化可能导致数据包传输的不稳定性\",{\"1\":{\"296\":1}}],[\"动态的通过窗口字段调整发送方发送窗口的大小\",{\"1\":{\"294\":1}}],[\"动态改变重传时间rtts\",{\"1\":{\"291\":1}}],[\"动态路由\",{\"0\":{\"206\":1},\"1\":{\"206\":1}}],[\"动态arp表项\",{\"1\":{\"198\":1}}],[\"动态\",{\"1\":{\"168\":1,\"583\":1}}],[\"动态划分信道\",{\"0\":{\"151\":1},\"1\":{\"144\":1}}],[\"动态主机配置协议dhcp\",{\"0\":{\"60\":1}}],[\"李四\",{\"1\":{\"485\":1,\"525\":1}}],[\"张三\",{\"1\":{\"485\":1,\"525\":1}}],[\"张量\",{\"1\":{\"312\":1}}],[\"层模块之间的解耦和灵活性\",{\"1\":{\"477\":1}}],[\"层与层之间交换的数据包称为服务数据单元\",{\"1\":{\"251\":1}}],[\"促进了代码模块化\",{\"1\":{\"474\":1}}],[\"促销活动\",{\"1\":{\"455\":1}}],[\"促销规则\",{\"1\":{\"455\":1}}],[\"笼统的接口拆分成小而精确的接口\",{\"1\":{\"474\":2}}],[\"飞行机器人等\",{\"1\":{\"473\":1}}],[\"飞行和工作\",{\"1\":{\"473\":1}}],[\"飞机可以通过发送消息来进行通信\",{\"1\":{\"404\":1}}],[\"飞机发送和接收消息\",{\"1\":{\"403\":1}}],[\"飞机\",{\"1\":{\"403\":1}}],[\"飞机交通管制系统将处理多个飞机之间的通信和交互\",{\"1\":{\"400\":1}}],[\"机制\",{\"1\":{\"832\":1}}],[\"机制的实现\",{\"1\":{\"710\":1}}],[\"机器的cpu核心数\",{\"1\":{\"866\":1}}],[\"机器指令的执行顺序\",{\"1\":{\"826\":1}}],[\"机器人具有多种功能\",{\"1\":{\"473\":1}}],[\"机械特性\",{\"1\":{\"227\":1}}],[\"尽量减少对象的创建和短暂存活\",{\"1\":{\"767\":1}}],[\"尽量在有限的时间内回收更多的垃圾\",{\"1\":{\"749\":1}}],[\"尽量不要重写父类的方法\",{\"1\":{\"468\":1}}],[\"尽管单例模式存在一些缺点\",{\"1\":{\"421\":1}}],[\"尽管存在上述问题\",{\"1\":{\"316\":1}}],[\"尽管算法\",{\"1\":{\"316\":2}}],[\"季节折扣策略\",{\"1\":{\"465\":1}}],[\"季节折扣\",{\"1\":{\"465\":2}}],[\"替换邮件发送方式\",{\"1\":{\"461\":1}}],[\"替换为\",{\"1\":{\"317\":1}}],[\"好比对象里面调用的方法\",{\"1\":{\"804\":1}}],[\"好处\",{\"1\":{\"540\":1,\"758\":1}}],[\"好处解析\",{\"1\":{\"461\":1}}],[\"好的\",{\"1\":{\"384\":1,\"454\":1,\"469\":1,\"525\":1}}],[\"案例\",{\"0\":{\"502\":1,\"506\":1,\"525\":1},\"1\":{\"461\":1,\"465\":1,\"469\":1,\"500\":1}}],[\"满减\",{\"1\":{\"455\":1}}],[\"900多个触发混合回收\",{\"1\":{\"750\":1}}],[\"96946\",{\"1\":{\"538\":1}}],[\"999999\",{\"1\":{\"785\":1}}],[\"99\",{\"1\":{\"506\":1}}],[\"9折\",{\"1\":{\"465\":2}}],[\"9\",{\"0\":{\"555\":1,\"581\":1,\"601\":1,\"643\":1,\"693\":1,\"727\":1,\"741\":1,\"770\":1,\"781\":1,\"812\":1,\"839\":1,\"865\":1},\"1\":{\"455\":1,\"465\":2,\"539\":1,\"769\":1,\"781\":1,\"789\":1}}],[\"递归遍历组合结构时\",{\"1\":{\"526\":1}}],[\"递归遍历\",{\"1\":{\"526\":1}}],[\"递归处理\",{\"1\":{\"526\":1}}],[\"递归复制\",{\"1\":{\"455\":2}}],[\"递归查询\",{\"1\":{\"72\":2}}],[\"深拷贝会完全复制整个对象\",{\"1\":{\"784\":1}}],[\"深拷贝和浅拷贝区别了解吗\",{\"0\":{\"784\":1},\"1\":{\"784\":2}}],[\"深拷贝可以用于创建新订单并复制现有订单的商品和客户信息\",{\"1\":{\"455\":1}}],[\"深拷贝可以解决对象拷贝过程中可能出现的共享引用和副作用问题\",{\"1\":{\"455\":1}}],[\"深拷贝的通用做法就是使用对象想对原型对象进行序列化\",{\"1\":{\"455\":1}}],[\"深拷贝是指在复制对象时\",{\"1\":{\"455\":1}}],[\"深拷贝\",{\"0\":{\"455\":1},\"1\":{\"757\":1,\"784\":1}}],[\"旧歌单的原信息会改变吗\",{\"1\":{\"454\":2}}],[\"浅拷贝会直接复制内部对象的引用地址\",{\"1\":{\"784\":1}}],[\"浅拷贝会在堆上创建一个新的对象\",{\"1\":{\"784\":1}}],[\"浅拷贝输出示例\",{\"1\":{\"454\":1}}],[\"浅拷贝是原型设计模式中的一种复制方式\",{\"1\":{\"454\":1}}],[\"浅拷贝\",{\"0\":{\"454\":1},\"1\":{\"784\":1}}],[\"浅拷贝和深拷贝\",{\"1\":{\"453\":1}}],[\"配料和尺寸等属性的方法\",{\"1\":{\"452\":1}}],[\"配料和尺寸等\",{\"1\":{\"452\":1}}],[\"配置文件处理\",{\"1\":{\"800\":1}}],[\"配置文件\",{\"1\":{\"539\":1}}],[\"配置块\",{\"1\":{\"539\":1}}],[\"配置android\",{\"1\":{\"538\":1}}],[\"配置环境\",{\"0\":{\"538\":1}}],[\"配置环境变量\",{\"0\":{\"19\":1,\"45\":1},\"1\":{\"19\":1,\"45\":1}}],[\"配置规则来过滤恶意流量\",{\"1\":{\"285\":1}}],[\"配置为特定vlan\",{\"1\":{\"159\":1}}],[\"配置前端项目访问后端接口代理\",{\"1\":{\"22\":1,\"48\":1}}],[\"配置访问文件地址\",{\"1\":{\"22\":1,\"48\":1}}],[\"配置nginx反向代理\",{\"1\":{\"22\":1,\"48\":1}}],[\"配置redis设置\",{\"1\":{\"14\":1,\"40\":1}}],[\"配置和远程连接\",{\"0\":{\"11\":1,\"14\":1,\"37\":1,\"40\":1}}],[\"配置\",{\"1\":{\"1\":1,\"27\":1}}],[\"素食披萨等\",{\"1\":{\"452\":1}}],[\"奶酪披萨\",{\"1\":{\"452\":1}}],[\"隔离了构建过程和表示\",{\"1\":{\"451\":1}}],[\"属于程序无法处理的错误\",{\"1\":{\"793\":1}}],[\"属于非法操作\",{\"1\":{\"778\":1}}],[\"属于gof设计模式中的一员\",{\"1\":{\"388\":1,\"398\":1}}],[\"属性等\",{\"1\":{\"798\":1,\"799\":2}}],[\"属性\",{\"1\":{\"450\":1}}],[\"省略构造函数\",{\"1\":{\"455\":3}}],[\"省略其他方法和属性的访问器\",{\"1\":{\"448\":1}}],[\"省略所有系数\",{\"1\":{\"316\":1}}],[\"详情\",{\"1\":{\"448\":1,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"606\":1,\"607\":1,\"608\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1,\"614\":1,\"693\":1,\"704\":1,\"741\":1,\"746\":1,\"747\":1,\"750\":1,\"754\":1,\"755\":1,\"834\":1,\"836\":1,\"844\":1}}],[\"详细\",{\"1\":{\"835\":1}}],[\"详细展开\",{\"0\":{\"750\":1}}],[\"详细介绍一下\",{\"0\":{\"745\":1},\"1\":{\"745\":1}}],[\"详细说说\",{\"0\":{\"644\":1,\"749\":1},\"1\":{\"749\":1}}],[\"详细图例\",{\"1\":{\"251\":2}}],[\"详细表格\",{\"1\":{\"217\":1}}],[\"详细报文首部\",{\"1\":{\"202\":1}}],[\"容量可以选择进行设置\",{\"1\":{\"862\":1}}],[\"容量变为原来的\",{\"1\":{\"706\":2}}],[\"容易扩展新的产品家族\",{\"1\":{\"444\":1}}],[\"容器单独提供一个\",{\"1\":{\"760\":1}}],[\"容器\",{\"1\":{\"760\":1}}],[\"容器相辅相成\",{\"1\":{\"477\":1}}],[\"容器可以管理多个单例对象并控制其生命周期\",{\"1\":{\"421\":1}}],[\"容器范围的单例\",{\"1\":{\"421\":1}}],[\"视频资源组共有方法\",{\"1\":{\"443\":1}}],[\"视频等资源\",{\"1\":{\"104\":1}}],[\"起一个定时器\",{\"1\":{\"436\":1}}],[\"起始位\",{\"1\":{\"235\":1}}],[\"描述产品对象的公共接口\",{\"1\":{\"434\":1}}],[\"描述了产品的公共方法\",{\"1\":{\"434\":1}}],[\"旨在以树状结构组织对象\",{\"1\":{\"526\":1}}],[\"旨在通过复制现有对象来创建新对象\",{\"1\":{\"453\":1}}],[\"旨在通过一个工厂类来封装对象的创建过程\",{\"1\":{\"430\":1}}],[\"旨在提供一个接口来创建一系列相关或依赖对象的家族\",{\"1\":{\"439\":1}}],[\"旨在解决对象的创建过程\",{\"1\":{\"432\":1}}],[\"异常的可能\",{\"1\":{\"731\":1}}],[\"异常的约束\",{\"1\":{\"468\":1}}],[\"异常信息\",{\"1\":{\"497\":1}}],[\"异常\",{\"1\":{\"422\":1,\"710\":2}}],[\"异步非阻塞型\",{\"1\":{\"327\":1}}],[\"异步传输以字符为独立的传输单位\",{\"1\":{\"235\":1}}],[\"异步传输\",{\"0\":{\"235\":1},\"1\":{\"234\":1,\"235\":1}}],[\"异步传输模式atm等\",{\"1\":{\"184\":1}}],[\"工具查看\",{\"1\":{\"769\":1}}],[\"工具\",{\"1\":{\"769\":1}}],[\"工具属性\",{\"1\":{\"539\":1}}],[\"工厂模式隐藏了对象的创建细节\",{\"1\":{\"452\":1}}],[\"工厂模式通常适用于创建不同类型对象的场景\",{\"1\":{\"452\":1}}],[\"工厂将返回相应类型的披萨对象\",{\"1\":{\"452\":1}}],[\"工厂方法模式\",{\"1\":{\"490\":1}}],[\"工厂方法模式通过将对象的创建和使用分离\",{\"1\":{\"432\":1}}],[\"工厂方法设计模式是一种非常常用和灵活的设计模式\",{\"1\":{\"437\":1}}],[\"工厂方法设计模式也存在一些缺点\",{\"1\":{\"437\":1}}],[\"工厂方法设计模式适用于以下场景\",{\"1\":{\"435\":1}}],[\"工厂方法设计模式的优点包括\",{\"1\":{\"437\":1}}],[\"工厂方法设计模式的基本流程如下\",{\"1\":{\"434\":1}}],[\"工厂方法设计模式的核心思想是将对象的创建委托给子类来实现\",{\"1\":{\"433\":1}}],[\"工厂方法设计模式通常由以下组成部分构成\",{\"1\":{\"434\":1}}],[\"工厂方法设计模式\",{\"1\":{\"432\":1}}],[\"工厂方法\",{\"0\":{\"431\":1}}],[\"工厂类根据参数或条件的不同\",{\"1\":{\"430\":1}}],[\"工厂类根据参数的不同来创建对应的具体产品对象\",{\"1\":{\"425\":1}}],[\"工厂类的职责较重\",{\"1\":{\"430\":1}}],[\"工厂类\",{\"1\":{\"426\":1}}],[\"工厂设计模式适用于创建不同类型的对象\",{\"1\":{\"452\":1}}],[\"工厂设计模式旨在通过一个工厂类来创建对象\",{\"1\":{\"452\":1}}],[\"工厂设计模式可以用来改善这些问题\",{\"1\":{\"422\":1}}],[\"工厂设计模式\",{\"0\":{\"422\":1}}],[\"工作层次\",{\"1\":{\"580\":1}}],[\"工作流引擎\",{\"1\":{\"355\":1}}],[\"工作流程\",{\"0\":{\"64\":1,\"94\":1},\"1\":{\"86\":1,\"210\":1}}],[\"工作原理\",{\"1\":{\"210\":1,\"580\":1,\"581\":1,\"582\":2}}],[\"日志\",{\"1\":{\"500\":1}}],[\"日志中的多例\",{\"1\":{\"421\":1}}],[\"日志记录\",{\"1\":{\"495\":1}}],[\"日志记录器\",{\"1\":{\"355\":1}}],[\"日志记录等操作\",{\"1\":{\"495\":1}}],[\"日志记录等场景\",{\"1\":{\"386\":1}}],[\"日志记录等功能\",{\"1\":{\"386\":1,\"494\":1}}],[\"日志记录等\",{\"1\":{\"352\":1}}],[\"日志记录系统等\",{\"1\":{\"326\":1}}],[\"极难的横向扩展\",{\"1\":{\"421\":1}}],[\"极限\",{\"1\":{\"240\":1}}],[\"造成代码冗余\",{\"1\":{\"421\":1}}],[\"造成拥塞\",{\"1\":{\"296\":1}}],[\"限制性\",{\"1\":{\"758\":1}}],[\"限制\",{\"1\":{\"725\":1}}],[\"限制了继承和多态的特性\",{\"1\":{\"421\":1}}],[\"限制最大路径距离为15\",{\"1\":{\"209\":1}}],[\"违反单一职责原则\",{\"1\":{\"519\":1}}],[\"违反里氏替换原则可能导致代码的不稳定和不可靠\",{\"1\":{\"469\":1}}],[\"违反了单一职责原则\",{\"1\":{\"421\":1}}],[\"违背了开闭原则\",{\"1\":{\"430\":1}}],[\"违法编码法\",{\"1\":{\"131\":1}}],[\"底层也是基于\",{\"1\":{\"842\":1}}],[\"底层数据结构\",{\"1\":{\"706\":1}}],[\"底层就是基于\",{\"1\":{\"704\":1}}],[\"底层实现结构\",{\"1\":{\"715\":1}}],[\"底层实现结构上\",{\"1\":{\"714\":1}}],[\"底层实现是在jdk1\",{\"1\":{\"685\":2,\"686\":2}}],[\"底层实现是基于链表实现\",{\"1\":{\"678\":1}}],[\"底层实现是基于一个object数组\",{\"1\":{\"677\":1}}],[\"底层实现\",{\"0\":{\"714\":1},\"1\":{\"679\":1,\"711\":1,\"714\":1}}],[\"底层\",{\"1\":{\"419\":2}}],[\"侧重点不同\",{\"1\":{\"411\":1}}],[\"准备阶段不分配类中的实例变量的内存\",{\"1\":{\"754\":1}}],[\"准备\",{\"1\":{\"720\":1,\"754\":2,\"755\":1}}],[\"准备降落\",{\"1\":{\"403\":3}}],[\"准备发送的数据\",{\"1\":{\"282\":1}}],[\"准备发送信息\",{\"1\":{\"168\":1,\"583\":1}}],[\"准备发送邮件内容\",{\"1\":{\"94\":1}}],[\"空指针错误\",{\"1\":{\"793\":1}}],[\"空闲列表\",{\"1\":{\"727\":2}}],[\"空闲的内存被放在另一边\",{\"1\":{\"727\":1}}],[\"空间浪费比较大\",{\"1\":{\"817\":1}}],[\"空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作\",{\"1\":{\"744\":1}}],[\"空间担保指的是老年代进行空间分配担保\",{\"1\":{\"743\":1}}],[\"空间分配担保机制\",{\"0\":{\"743\":1}}],[\"空间分配担保\",{\"1\":{\"740\":1}}],[\"空间分配担保失败\",{\"1\":{\"739\":1}}],[\"空间的一半\",{\"1\":{\"740\":1}}],[\"空间中相同年龄所有对象大小的总和大于\",{\"1\":{\"740\":1}}],[\"空间利用和内存效率\",{\"1\":{\"696\":1}}],[\"空间复杂度的统计范围是\",{\"1\":{\"317\":1}}],[\"空间复杂度\",{\"0\":{\"317\":1},\"1\":{\"317\":1}}],[\"空气等\",{\"1\":{\"619\":1}}],[\"空字符串或包含冒号\",{\"1\":{\"422\":1,\"436\":1}}],[\"空中交通管制\",{\"1\":{\"403\":2}}],[\"小姐姐比较辛苦\",{\"1\":{\"868\":1}}],[\"小于\",{\"1\":{\"392\":1,\"394\":1}}],[\"小写i的internet是通用名词\",{\"1\":{\"248\":1}}],[\"减法\",{\"1\":{\"390\":1}}],[\"减少竞争\",{\"1\":{\"855\":1}}],[\"减少不必要的cpu上下文切换\",{\"1\":{\"837\":1}}],[\"减少不相关功能的耦合\",{\"1\":{\"474\":1}}],[\"减少操作系统互斥量带来的性能消耗\",{\"1\":{\"837\":1}}],[\"减少对象晋升到老年代的情况\",{\"1\":{\"767\":1}}],[\"减少对象的长期存活时间\",{\"1\":{\"767\":1}}],[\"减少对数据库的访问\",{\"1\":{\"495\":1}}],[\"减少内存占用和性能开销\",{\"1\":{\"758\":1}}],[\"减少内存使用\",{\"1\":{\"533\":1}}],[\"减少哈希冲突和提高性能\",{\"1\":{\"696\":1}}],[\"减少hash碰撞\",{\"1\":{\"688\":1}}],[\"减少耦合\",{\"1\":{\"488\":1}}],[\"减少意外行为的发生\",{\"1\":{\"470\":1}}],[\"减少了运行时类型错误的可能性\",{\"1\":{\"797\":1}}],[\"减少了重复编写相似代码的工作量\",{\"1\":{\"797\":1}}],[\"减少了工作量\",{\"1\":{\"673\":1}}],[\"减少了网络中的冲突\",{\"1\":{\"580\":1}}],[\"减少了代码的藕合度\",{\"1\":{\"488\":1}}],[\"减少了代码之间的依赖关系\",{\"1\":{\"470\":1}}],[\"减少了类之间的直接依赖关系\",{\"1\":{\"481\":1}}],[\"减少了不必要的依赖和耦合\",{\"1\":{\"461\":1}}],[\"减少了手动编写重复代码的工作量\",{\"1\":{\"450\":1}}],[\"减少了浪费\",{\"1\":{\"222\":1}}],[\"减少出错率和重复数据量\",{\"1\":{\"254\":1}}],[\"十一\",{\"0\":{\"397\":1}}],[\"十\",{\"0\":{\"387\":1}}],[\"购物车类\",{\"1\":{\"384\":1}}],[\"购物中心\",{\"1\":{\"372\":2}}],[\"购物中心等等\",{\"1\":{\"372\":1}}],[\"遥控器类\",{\"1\":{\"383\":1}}],[\"延迟队列\",{\"1\":{\"862\":1}}],[\"延迟重发\",{\"1\":{\"578\":1}}],[\"延迟加载等场景\",{\"1\":{\"496\":1}}],[\"延迟请求的执行\",{\"1\":{\"381\":1}}],[\"延时\",{\"1\":{\"210\":1}}],[\"九\",{\"0\":{\"380\":1}}],[\"历史记录管理\",{\"1\":{\"378\":1}}],[\"拥有需要保存和恢复状态的对象\",{\"1\":{\"377\":1}}],[\"拥塞避免\",{\"1\":{\"297\":1,\"298\":1}}],[\"拥塞窗口每次只扩大1\",{\"1\":{\"298\":1}}],[\"拥塞窗口从1开始\",{\"1\":{\"298\":1}}],[\"拥塞窗口\",{\"1\":{\"294\":2,\"297\":2}}],[\"拥塞控制主要是四个算法\",{\"1\":{\"297\":1}}],[\"拥塞控制有哪些控制算法\",{\"1\":{\"297\":1}}],[\"拥塞控制可以保证网络的稳定性和吞吐量的合理分配\",{\"1\":{\"296\":1}}],[\"拥塞控制可以解决以下问题\",{\"1\":{\"296\":1}}],[\"拥塞控制是为了保证网络稳定运行\",{\"1\":{\"296\":1}}],[\"拥塞控制是一种网络流量控制的机制\",{\"1\":{\"296\":1}}],[\"拥塞控制机制可以确保网络中的各个流量源公平地共享网络资源\",{\"1\":{\"296\":1}}],[\"拥塞控制的原因\",{\"1\":{\"296\":1}}],[\"拥塞控制的背景\",{\"1\":{\"296\":1}}],[\"拥塞控制的出现背景和原因\",{\"1\":{\"296\":1}}],[\"拥塞控制的意义\",{\"1\":{\"296\":1}}],[\"拥塞控制\",{\"0\":{\"187\":1,\"592\":1},\"1\":{\"282\":1,\"296\":1}}],[\"恢复为空\",{\"1\":{\"835\":1}}],[\"恢复originator的状态到之前的备忘录\",{\"1\":{\"377\":1}}],[\"恢复\",{\"1\":{\"376\":1}}],[\"恢复到之前的状态\",{\"1\":{\"375\":1}}],[\"➡️\",{\"1\":{\"376\":1,\"419\":3}}],[\"待办事项\",{\"1\":{\"375\":1}}],[\"待完善\",{\"1\":{\"53\":1}}],[\"撤销到之前的状态\",{\"1\":{\"378\":1}}],[\"撤销和重做操作\",{\"1\":{\"378\":1}}],[\"撤销是指在执行一个操作后\",{\"1\":{\"375\":1}}],[\"撤销\",{\"1\":{\"375\":1}}],[\"补充知识\",{\"1\":{\"375\":1}}],[\"备忘录模式\",{\"1\":{\"490\":1}}],[\"备忘录模式允许我们捕获对象的状态并在后续需要时恢复\",{\"1\":{\"375\":1}}],[\"备忘录类\",{\"1\":{\"377\":1,\"378\":1}}],[\"备忘录\",{\"1\":{\"377\":1}}],[\"备忘录设计模式是一种功能强大的模式\",{\"1\":{\"379\":1}}],[\"备忘录设计模式的核心思想是\",{\"1\":{\"376\":1}}],[\"备忘录设计模式\",{\"0\":{\"374\":1},\"1\":{\"375\":1}}],[\"备份和恢复\",{\"1\":{\"83\":1}}],[\"备份恢复\",{\"1\":{\"83\":1}}],[\"八\",{\"0\":{\"374\":1,\"487\":1}}],[\"产生混乱和困惑\",{\"1\":{\"845\":1}}],[\"产生了错误结果1\",{\"1\":{\"829\":1}}],[\"产生不正确的结果\",{\"1\":{\"814\":1}}],[\"产生太多ack\",{\"1\":{\"294\":1}}],[\"产品\",{\"1\":{\"448\":1}}],[\"产品页\",{\"1\":{\"372\":2}}],[\"产品页等\",{\"1\":{\"372\":1}}],[\"观察他们在每个景点上执行的不同访问操作\",{\"1\":{\"372\":1}}],[\"观察者模式\",{\"1\":{\"490\":1}}],[\"观察者模式旨在建立对象之间的松耦合关系\",{\"1\":{\"411\":1}}],[\"观察者对象直接订阅和监听被观察对象的状态变化\",{\"1\":{\"411\":1}}],[\"观察者之间无法直接通信\",{\"1\":{\"328\":1}}],[\"观察者之间的通信是单向的\",{\"1\":{\"328\":1}}],[\"观察者只管从消息队列中读取消息来执行相应的逻辑\",{\"1\":{\"327\":1}}],[\"观察者也完全不感知被观察者\",{\"1\":{\"327\":1}}],[\"观察者需要注册到被观察者中\",{\"1\":{\"327\":1}}],[\"观察者和被观察者代码在同一个线程内执行\",{\"1\":{\"327\":1}}],[\"观察者的进阶使用\",{\"0\":{\"327\":1}}],[\"观察者接口\",{\"1\":{\"325\":1,\"327\":1}}],[\"观察者接口chatuser定义了接收消息和发送消息的方法\",{\"1\":{\"325\":1}}],[\"观察者接收到通知后进行相应的处理\",{\"1\":{\"323\":1}}],[\"观察者通过将自身注册到主题中\",{\"1\":{\"324\":1}}],[\"观察者\",{\"1\":{\"324\":1}}],[\"观察者设计模式侧重于建立对象之间的松耦合关系\",{\"1\":{\"411\":1}}],[\"观察者设计模式适用于一个对象的状态变化需要通知多个观察者对象的场景\",{\"1\":{\"411\":1}}],[\"观察者设计模式适用于以下场景\",{\"1\":{\"325\":1}}],[\"观察者设计模式关注的是对象之间的一对多依赖关系\",{\"1\":{\"411\":1}}],[\"观察者设计模式是一种非常有用的模式\",{\"1\":{\"328\":1}}],[\"观察者设计模式的缺点包括\",{\"1\":{\"328\":1}}],[\"观察者设计模式的优点包括\",{\"1\":{\"328\":1}}],[\"观察者设计模式的使用基本流程\",{\"1\":{\"324\":1}}],[\"观察者设计模式的核心思想\",{\"1\":{\"323\":1}}],[\"观察者设计模式由以下几个关键组件组成\",{\"1\":{\"324\":1}}],[\"观察者设计模式\",{\"0\":{\"321\":1},\"1\":{\"322\":1,\"411\":1}}],[\"游戏开始时\",{\"1\":{\"851\":1}}],[\"游戏中的棋子对象\",{\"1\":{\"532\":1}}],[\"游戏关卡设计\",{\"1\":{\"333\":1}}],[\"游客\",{\"1\":{\"372\":1}}],[\"博物馆\",{\"1\":{\"372\":2}}],[\"博客封面图片\",{\"1\":{\"0\":1}}],[\"演示了组合设计模式的基本流程\",{\"1\":{\"524\":1}}],[\"演示了如何使用静态代理来实现远程代理\",{\"1\":{\"495\":1}}],[\"演示了如何使用静态代理来实现安全代理\",{\"1\":{\"495\":1}}],[\"演示了如何使用静态代理来实现数据库查询缓存的功能\",{\"1\":{\"495\":1}}],[\"演示了如何使用静态代理来实现继承类的功能增强\",{\"1\":{\"495\":1}}],[\"演示如何使用适配器设计模式来实现支付接口的替换\",{\"1\":{\"510\":1}}],[\"演示如何使用访问者设计模式来模拟旅行团游览大城市的场景\",{\"1\":{\"372\":1}}],[\"演示中介者设计模式的应用\",{\"1\":{\"400\":1}}],[\"演变为o\",{\"1\":{\"316\":1}}],[\"城市\",{\"1\":{\"372\":1}}],[\"城市对象结构在接受访问者时\",{\"1\":{\"372\":1}}],[\"城市和国家\",{\"1\":{\"161\":1}}],[\"旅行团成员可以依次访问每个景点\",{\"1\":{\"372\":1}}],[\"旅行团成员则是访问者\",{\"1\":{\"372\":1}}],[\"声明为\",{\"1\":{\"844\":1}}],[\"声明通用的操作方法\",{\"1\":{\"524\":1}}],[\"声明一系列创建产品的方法\",{\"1\":{\"441\":1}}],[\"声明产品的共性方法\",{\"1\":{\"441\":1}}],[\"声明了一系列创建产品的方法\",{\"1\":{\"441\":1}}],[\"声明了执行操作的接口\",{\"1\":{\"382\":1}}],[\"声明接受访问者对象的方法\",{\"1\":{\"371\":1}}],[\"声明访问具体元素对象的方法\",{\"1\":{\"371\":1}}],[\"声音被转换成模拟的声波信号\",{\"1\":{\"239\":1}}],[\"理论上来说\",{\"1\":{\"827\":1}}],[\"理解不了\",{\"1\":{\"368\":1}}],[\"理想情况下\",{\"1\":{\"697\":1}}],[\"理想低通信道常用于数字通信系统中\",{\"1\":{\"240\":1}}],[\"理想低通信道是一个理想化的信道\",{\"1\":{\"240\":1}}],[\"理想低通信道\",{\"1\":{\"240\":2}}],[\"理想低通道的最高码元传输速率\",{\"1\":{\"240\":1}}],[\"理想带通信道只允许特定频率范围内的信号通过\",{\"1\":{\"240\":1}}],[\"理想带通信道常用于模拟通信系统中\",{\"1\":{\"240\":1}}],[\"理想带通信道是一个理想化的信道\",{\"1\":{\"240\":1}}],[\"理想带通信道\",{\"1\":{\"240\":2}}],[\"理想带通道的最高码元传输速率\",{\"1\":{\"240\":1}}],[\"说十个\",{\"1\":{\"793\":1}}],[\"说句题外话\",{\"1\":{\"731\":1}}],[\"说一下cms垃圾回收器\",{\"0\":{\"746\":1}}],[\"说一下java中对象有哪几种引用方式\",{\"1\":{\"735\":1}}],[\"说一下对象有哪几种引用\",{\"0\":{\"735\":1}}],[\"说一下对象的内存布局组成结构\",{\"0\":{\"729\":1}}],[\"说一下一个java对象的组成结构\",{\"1\":{\"729\":1}}],[\"说说线程池的工作流程\",{\"1\":{\"868\":1}}],[\"说说线程有几种创建方式\",{\"1\":{\"806\":1}}],[\"说说synchronized和reentrantlock的区别\",{\"0\":{\"843\":1},\"1\":{\"843\":1}}],[\"说说并行跟并发有什么区别\",{\"1\":{\"805\":1}}],[\"说说jvm的内存区域是怎么分布的\",{\"1\":{\"722\":1}}],[\"说说jvm运行过程\",{\"1\":{\"720\":1}}],[\"说说java集合的框架体系\",{\"1\":{\"670\":1}}],[\"说说你理解的jvm\",{\"1\":{\"719\":1}}],[\"说说你对原子性\",{\"0\":{\"825\":1},\"1\":{\"825\":1}}],[\"说说你对程序\",{\"1\":{\"804\":1}}],[\"说说你对hashmap的理解\",{\"0\":{\"685\":1},\"1\":{\"685\":1}}],[\"说说你对linkedlist的理解\",{\"0\":{\"678\":1}}],[\"说说你对arraylist的理解\",{\"0\":{\"677\":1},\"1\":{\"677\":1}}],[\"说说arraylist和linkedlist的区别\",{\"1\":{\"679\":1}}],[\"说说arraylist的添加元素的过程和扩容过程\",{\"1\":{\"678\":1}}],[\"说说什么是三次握手和工作流程\",{\"0\":{\"638\":1}}],[\"说说计算机网络体系结构\",{\"0\":{\"627\":1}}],[\"说说它的工作流程和作用\",{\"0\":{\"607\":1}}],[\"说说\",{\"0\":{\"566\":1,\"632\":1,\"650\":1,\"662\":1},\"1\":{\"671\":1}}],[\"说人话就是数据拿过来\",{\"1\":{\"831\":1}}],[\"说人话就是\",{\"1\":{\"464\":1,\"468\":1,\"472\":1,\"476\":1,\"480\":1,\"488\":1}}],[\"说实话我也看不懂\",{\"1\":{\"368\":1}}],[\"说明\",{\"1\":{\"808\":1}}],[\"说明线程在等待这把锁\",{\"1\":{\"765\":1}}],[\"说明本次\",{\"1\":{\"739\":1}}],[\"说明需要扩容\",{\"1\":{\"711\":1}}],[\"说明其运行时间的增长趋势是线性的\",{\"1\":{\"316\":1}}],[\"说明有一段丢失了\",{\"1\":{\"299\":1}}],[\"说明文档已经发生了变化\",{\"1\":{\"114\":1}}],[\"说明浏览器等的一些信息\",{\"1\":{\"107\":1}}],[\"访问范围不同\",{\"1\":{\"816\":1}}],[\"访问成员\",{\"1\":{\"799\":1}}],[\"访问这些属性\",{\"1\":{\"798\":1}}],[\"访问对象属性的能力\",{\"1\":{\"798\":1}}],[\"访问对象的有几种方式\",{\"0\":{\"730\":1}}],[\"访问限制的区别\",{\"1\":{\"779\":1}}],[\"访问静态变量等操作\",{\"1\":{\"755\":1}}],[\"访问速度\",{\"1\":{\"724\":1}}],[\"访问指定节点只能遍历链表\",{\"1\":{\"678\":1}}],[\"访问者接口\",{\"1\":{\"372\":2}}],[\"访问者可以访问所有具体元素\",{\"1\":{\"371\":1}}],[\"访问者模式\",{\"1\":{\"490\":1}}],[\"访问者模式适用于需要在不改变数据结构的情况下\",{\"1\":{\"373\":1}}],[\"访问者模式可能会显得过于繁琐\",{\"1\":{\"373\":1}}],[\"访问者模式将网站数据统计与网站的页面结构解耦\",{\"1\":{\"372\":1}}],[\"访问者模式在现实世界中有很多应用场景\",{\"1\":{\"372\":1}}],[\"访问者模式主要包括以下组成\",{\"1\":{\"371\":1}}],[\"访问者模式的核心思想是将数据结构与对数据的操作分离\",{\"1\":{\"370\":1}}],[\"访问者设计模式示例\",{\"1\":{\"372\":1}}],[\"访问者设计模式\",{\"0\":{\"368\":1},\"1\":{\"369\":1}}],[\"访问控制和安全性\",{\"1\":{\"495\":1}}],[\"访问控制\",{\"1\":{\"268\":1}}],[\"遵循开闭原则\",{\"1\":{\"500\":1}}],[\"遵循开闭原则的案例\",{\"1\":{\"465\":1}}],[\"遵循迪米特法则可以降低代码的脆弱性\",{\"1\":{\"490\":1}}],[\"遵循迪米特原则可以帮助我们设计出更加松耦合\",{\"1\":{\"488\":1}}],[\"遵循适度原则\",{\"1\":{\"488\":1}}],[\"遵循\",{\"1\":{\"485\":1}}],[\"遵循kiss原则可以减少代码的冗余和复杂度\",{\"1\":{\"482\":1}}],[\"遵循该原则可以提高代码的可复用性\",{\"1\":{\"470\":1}}],[\"遵循里氏替换原则\",{\"1\":{\"470\":1}}],[\"遵循里氏替换原则可以确保代码在处理父类对象时\",{\"1\":{\"469\":1}}],[\"遵循这些注意事项\",{\"1\":{\"367\":1}}],[\"遵循ftp协议与服务器传送文件的电脑\",{\"1\":{\"83\":1}}],[\"另一个为\",{\"1\":{\"728\":1}}],[\"另一个指针指向链表的后一个元素\",{\"1\":{\"714\":1}}],[\"另一种就是map\",{\"1\":{\"670\":1}}],[\"另一种就是基于消息队列\",{\"1\":{\"327\":1}}],[\"另外一个线程还可以通过cas的方式进行获取\",{\"1\":{\"846\":1}}],[\"另外\",{\"1\":{\"367\":1,\"476\":1}}],[\"综上所述\",{\"1\":{\"367\":1,\"465\":1,\"705\":1,\"706\":1}}],[\"建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出numberformatexception而不是其父类illegalargumentexception\",{\"1\":{\"793\":1}}],[\"建议使用\",{\"1\":{\"789\":1}}],[\"建议\",{\"1\":{\"785\":1}}],[\"建议在使用迭代器期间\",{\"1\":{\"367\":1}}],[\"建造者模式\",{\"1\":{\"490\":1}}],[\"建造者模式更适合\",{\"1\":{\"452\":1}}],[\"建造者模式通常适用于创建具有复杂结构或多个可选组件的对象\",{\"1\":{\"452\":1}}],[\"建造者设计模式关注的是逐步构建复杂对象\",{\"1\":{\"452\":1}}],[\"建造者设计模式和工厂设计模式是两种常见的创建型设计模式\",{\"1\":{\"452\":1}}],[\"建造者设计模式\",{\"0\":{\"445\":1},\"1\":{\"446\":1}}],[\"建立公共溢出区\",{\"1\":{\"692\":1}}],[\"建立对象结构\",{\"1\":{\"372\":1}}],[\"建立邻居关系后\",{\"1\":{\"210\":1}}],[\"建立和维护邻居关系\",{\"1\":{\"210\":1}}],[\"建立网络层连接\",{\"1\":{\"184\":1}}],[\"建立并管理的\",{\"1\":{\"123\":1}}],[\"建立连接时间长\",{\"1\":{\"253\":1}}],[\"建立连接\",{\"1\":{\"94\":3,\"253\":1}}],[\"建立数据连接\",{\"1\":{\"86\":1}}],[\"聚合对象\",{\"1\":{\"366\":1}}],[\"聚合c类网的数量\",{\"1\":{\"220\":1}}],[\"聚合c类网数量\",{\"1\":{\"220\":1}}],[\"迭代年龄会在每次\",{\"1\":{\"740\":1}}],[\"迭代过程中被修改\",{\"1\":{\"709\":1}}],[\"迭代顺序和性能\",{\"1\":{\"706\":1}}],[\"迭代顺序\",{\"1\":{\"706\":1}}],[\"迭代器会检测到集合结构的修改\",{\"1\":{\"710\":1}}],[\"迭代器遍历的是开始遍历那一刻拿到的集合拷贝\",{\"1\":{\"709\":1}}],[\"迭代器并不能访问到修改后的内容\",{\"1\":{\"709\":1}}],[\"迭代器在遍历时直接访问集合中的内容\",{\"1\":{\"709\":1}}],[\"迭代器模式\",{\"1\":{\"490\":1}}],[\"迭代器持有当前对象实例\",{\"1\":{\"366\":1}}],[\"迭代器接口\",{\"1\":{\"365\":1,\"366\":1}}],[\"迭代器\",{\"1\":{\"365\":1}}],[\"迭代器设计模式提供了一种优雅的方式来遍历聚合对象\",{\"1\":{\"367\":1}}],[\"迭代器设计模式适用于以下场景\",{\"1\":{\"366\":1}}],[\"迭代器设计模式的基本流程如下\",{\"1\":{\"365\":1}}],[\"迭代器设计模式的核心思想是将迭代逻辑从聚合对象中抽离出来\",{\"1\":{\"364\":1}}],[\"迭代器设计模式由以下两个主要组件组成\",{\"1\":{\"365\":1}}],[\"迭代器设计模式\",{\"0\":{\"362\":1},\"1\":{\"363\":1}}],[\"迭代查询\",{\"1\":{\"72\":2}}],[\"`hashmap`\",{\"1\":{\"788\":1}}],[\"`hashcode`\",{\"1\":{\"787\":1}}],[\"`hashcode\",{\"1\":{\"787\":1,\"788\":1}}],[\"`equals\",{\"1\":{\"788\":1}}],[\"`\",{\"1\":{\"787\":1,\"788\":2}}],[\"`character`\",{\"1\":{\"360\":1}}],[\"`tv`\",{\"1\":{\"360\":1}}],[\"`tvoffstate`\",{\"1\":{\"360\":1}}],[\"`tvonstate`\",{\"1\":{\"360\":1}}],[\"`tvstate`\",{\"1\":{\"360\":1}}],[\"```\",{\"1\":{\"346\":5}}],[\"```java\",{\"1\":{\"346\":5}}],[\"静音等功能后呢\",{\"1\":{\"360\":1}}],[\"静态内部类\",{\"1\":{\"840\":1}}],[\"静态的\",{\"1\":{\"816\":1}}],[\"静态只能调用静态\",{\"1\":{\"779\":1}}],[\"静态方法的生命周期和类相关\",{\"1\":{\"779\":1}}],[\"静态方法\",{\"1\":{\"779\":2}}],[\"静态方法和实例方法有何不同\",{\"0\":{\"779\":1},\"1\":{\"779\":2}}],[\"静态方法是属于类的\",{\"1\":{\"778\":1}}],[\"静态方法为什么不能调用非静态成员\",{\"0\":{\"778\":1},\"1\":{\"778\":2}}],[\"静态成员也可以被所有该类的实例共享\",{\"1\":{\"776\":1}}],[\"静态代码块\",{\"1\":{\"754\":1,\"793\":1}}],[\"静态代理可以用于实现远程对象的访问\",{\"1\":{\"495\":1}}],[\"静态代理可以用于实现对被代理对象的事务管理\",{\"1\":{\"495\":1}}],[\"静态代理可以用于实现对被代理对象的结果进行缓存\",{\"1\":{\"495\":1}}],[\"静态代理可以用于监控被代理对象的性能\",{\"1\":{\"495\":1}}],[\"静态代理可以用于记录对被代理对象的操作日志\",{\"1\":{\"495\":1}}],[\"静态代理可以用于控制对被代理对象的访问权限\",{\"1\":{\"495\":1}}],[\"静态代理在编译时就已经确定代理类\",{\"1\":{\"495\":1}}],[\"静态代理\",{\"0\":{\"495\":1},\"1\":{\"494\":1}}],[\"静态集合的生命周期和\",{\"1\":{\"731\":1}}],[\"静态变量只会被分配一次内存\",{\"1\":{\"776\":1}}],[\"静态变量有什么作用\",{\"0\":{\"776\":1},\"1\":{\"776\":2}}],[\"静态变量\",{\"1\":{\"720\":1,\"722\":1,\"723\":1,\"755\":1}}],[\"静态分配和动态分配\",{\"0\":{\"613\":1}}],[\"静态路由中包括目的节点或目的网络的ip地址\",{\"1\":{\"205\":1}}],[\"静态路由\",{\"0\":{\"205\":1},\"1\":{\"205\":2}}],[\"静态arp表项又分为短静态arp表项和长静态arp表项\",{\"1\":{\"198\":1}}],[\"静态arp表项\",{\"1\":{\"198\":1}}],[\"静态\",{\"1\":{\"168\":1,\"583\":1}}],[\"静态划分信道\",{\"0\":{\"146\":1},\"1\":{\"144\":1}}],[\"具有排他性\",{\"1\":{\"836\":1}}],[\"具有与\",{\"1\":{\"832\":1}}],[\"具有较快的添加\",{\"1\":{\"715\":1}}],[\"具有保存key\",{\"1\":{\"711\":1}}],[\"具有\",{\"1\":{\"705\":1}}],[\"具有更高的性能\",{\"1\":{\"580\":1}}],[\"具有以下不利影响\",{\"1\":{\"465\":1}}],[\"具有一个私有的\",{\"1\":{\"422\":1}}],[\"具有开启\",{\"1\":{\"360\":1}}],[\"具体示例\",{\"1\":{\"868\":1}}],[\"具体而言\",{\"1\":{\"845\":1}}],[\"具体到java的实现\",{\"1\":{\"811\":1}}],[\"具体唤醒哪个等待的线程是随机的\",{\"1\":{\"807\":1}}],[\"具体\",{\"1\":{\"781\":1}}],[\"具体体现在以下几个方面\",{\"1\":{\"759\":1}}],[\"具体真正的实现有例如\",{\"1\":{\"722\":1}}],[\"具体是使用数组做hash容器\",{\"1\":{\"685\":1}}],[\"具体是偶数还是奇数\",{\"1\":{\"134\":1,\"576\":1}}],[\"具体销售渠道类\",{\"1\":{\"506\":1}}],[\"具体商品类\",{\"1\":{\"506\":2}}],[\"具体抽象部分类通过调用实现部分对象的方法来实现自己的操作\",{\"1\":{\"505\":1}}],[\"具体抽象部分类通常会持有一个实现部分对象的引用\",{\"1\":{\"505\":1}}],[\"具体抽象部分类是抽象部分接口的具体实现\",{\"1\":{\"505\":1}}],[\"具体装饰器\",{\"1\":{\"501\":1}}],[\"具体组件\",{\"1\":{\"501\":1}}],[\"具体地说\",{\"1\":{\"497\":1}}],[\"具体构建者\",{\"1\":{\"448\":1}}],[\"具体定义产品的具体实现\",{\"1\":{\"441\":1}}],[\"具体产品\",{\"1\":{\"441\":1,\"443\":6}}],[\"具体产品类\",{\"1\":{\"434\":1}}],[\"具体工厂\",{\"1\":{\"441\":1,\"443\":1}}],[\"具体工厂类实现了抽象工厂接口\",{\"1\":{\"443\":1}}],[\"具体工厂类\",{\"1\":{\"434\":1}}],[\"具体中介者\",{\"1\":{\"400\":1}}],[\"具体命令\",{\"1\":{\"382\":1,\"383\":2}}],[\"具体元素\",{\"1\":{\"371\":1,\"372\":6}}],[\"具体访问者\",{\"1\":{\"371\":1,\"372\":3}}],[\"具体聚合对象\",{\"1\":{\"365\":1}}],[\"具体迭代器\",{\"1\":{\"365\":2,\"366\":1}}],[\"具体状态对象根据当前状态处理请求\",{\"1\":{\"359\":1}}],[\"具体状态\",{\"1\":{\"359\":2}}],[\"具体处理器\",{\"1\":{\"350\":2}}],[\"具体策略类是策略接口的实现类\",{\"1\":{\"343\":1}}],[\"具体策略\",{\"1\":{\"343\":3,\"344\":3,\"346\":2,\"386\":1}}],[\"具体判断文件末尾的逻辑\",{\"1\":{\"335\":1}}],[\"具体判断逻辑\",{\"1\":{\"335\":1}}],[\"具体关闭逻辑\",{\"1\":{\"335\":1}}],[\"具体方法\",{\"1\":{\"335\":2}}],[\"具体步骤实现\",{\"1\":{\"332\":3}}],[\"具体步骤由子类实现\",{\"1\":{\"332\":1}}],[\"具体步骤如下\",{\"1\":{\"210\":1}}],[\"具体类\",{\"1\":{\"332\":1,\"335\":1,\"336\":2,\"338\":1}}],[\"具体的对象创建由子类来完成\",{\"1\":{\"433\":1}}],[\"具体的参与者类\",{\"1\":{\"403\":1,\"408\":1}}],[\"具体的中介者类\",{\"1\":{\"403\":1,\"408\":1}}],[\"具体的支付逻辑\",{\"1\":{\"344\":3}}],[\"具体的策略类根据实现方式执行算法\",{\"1\":{\"343\":1}}],[\"具体的put请求处理逻辑\",{\"1\":{\"338\":1}}],[\"具体的post请求处理逻辑\",{\"1\":{\"338\":1}}],[\"具体的get请求处理逻辑\",{\"1\":{\"338\":1}}],[\"具体的实现细节则交给子类去实现\",{\"1\":{\"335\":1}}],[\"具体的文件关闭逻辑\",{\"1\":{\"335\":1}}],[\"具体的文件打开逻辑\",{\"1\":{\"335\":1}}],[\"具体的处理逻辑\",{\"1\":{\"335\":1}}],[\"具体的读取字节逻辑\",{\"1\":{\"335\":1}}],[\"具体的观察者类\",{\"1\":{\"327\":1}}],[\"具体的被观察者类\",{\"1\":{\"327\":1}}],[\"具体的传输过程如下\",{\"1\":{\"86\":1}}],[\"具体案例2\",{\"0\":{\"336\":1}}],[\"具体案例1\",{\"0\":{\"335\":1,\"338\":1}}],[\"具体案例\",{\"0\":{\"352\":1,\"353\":1,\"354\":1,\"420\":1,\"429\":1,\"436\":1,\"443\":1,\"450\":1,\"518\":1,\"532\":1},\"1\":{\"325\":1}}],[\"具体观察者类\",{\"1\":{\"325\":1}}],[\"具体观察者类qquser实现了该接口\",{\"1\":{\"325\":1}}],[\"具体观察者是观察者的具体实现类\",{\"1\":{\"324\":1}}],[\"具体观察者\",{\"1\":{\"324\":1}}],[\"具体主题类\",{\"1\":{\"325\":1}}],[\"具体主题类qqgroup实现了该接口\",{\"1\":{\"325\":1}}],[\"具体主题是主题的具体实现类\",{\"1\":{\"324\":1}}],[\"具体主题\",{\"1\":{\"324\":1}}],[\"具体主机ip\",{\"1\":{\"205\":1}}],[\"具体计算方式\",{\"1\":{\"316\":1}}],[\"具体如何根据跳变实现同步\",{\"1\":{\"238\":1}}],[\"具体图例\",{\"1\":{\"230\":1}}],[\"具体实现部分类是实现部分接口的具体实现\",{\"1\":{\"505\":1}}],[\"具体实现部分\",{\"1\":{\"504\":1}}],[\"具体实现了创建产品的方法\",{\"1\":{\"441\":1}}],[\"具体实现\",{\"1\":{\"205\":1,\"821\":1}}],[\"具体可再根据icmp的代码字段细分为目的网络不可达\",{\"1\":{\"201\":1}}],[\"具体来说会有数据覆盖的风险\",{\"1\":{\"707\":1}}],[\"具体来说\",{\"1\":{\"87\":1,\"96\":1,\"382\":1,\"814\":1}}],[\"具体修改操作\",{\"1\":{\"19\":1,\"45\":1}}],[\"需不需要刀下留人\",{\"1\":{\"736\":1}}],[\"需求审批\",{\"1\":{\"355\":1}}],[\"需要结合测试和监控来进行调整\",{\"1\":{\"866\":1}}],[\"需要重点关注corepoolsize\",{\"1\":{\"860\":1}}],[\"需要重新还原成原始报文\",{\"1\":{\"254\":1}}],[\"需要走gc垃圾回收流程\",{\"1\":{\"857\":1}}],[\"需要经过类加载过程\",{\"1\":{\"857\":1}}],[\"需要一定的阻塞等待唤醒机制来保证锁的分配\",{\"1\":{\"846\":1}}],[\"需要调⽤这个实例对象所属类的静态\",{\"1\":{\"833\":1}}],[\"需要调用\",{\"1\":{\"731\":1}}],[\"需要使用synchronized\",{\"1\":{\"825\":1}}],[\"需要买菜\",{\"1\":{\"781\":1}}],[\"需要先定位到可疑对象\",{\"1\":{\"768\":1}}],[\"需要搭配serial\",{\"1\":{\"751\":1}}],[\"需要进行额外的同步措施\",{\"1\":{\"715\":1}}],[\"需要额外的同步措施来确保线程安全\",{\"1\":{\"706\":1}}],[\"需要对原数组中的元素进行重新\",{\"1\":{\"701\":1}}],[\"需要对上层传来的报文进行分割\",{\"1\":{\"189\":1}}],[\"需要旋转的次数更多\",{\"1\":{\"698\":1}}],[\"需要同时重写\",{\"1\":{\"672\":1}}],[\"需要下载对应的gradle\",{\"1\":{\"538\":1}}],[\"需要适当处理组件和叶子对象的差异\",{\"1\":{\"526\":1}}],[\"需要权衡好门面对象的责任和灵活性之间的平衡\",{\"1\":{\"519\":1}}],[\"需要权衡好全局状态的管理和对象职责的合理划分\",{\"1\":{\"421\":1}}],[\"需要简化客户端与子系统之间的交互时\",{\"1\":{\"517\":1}}],[\"需要在系统中引入新的功能\",{\"1\":{\"512\":1}}],[\"需要在不修改现有代码的情况下与已有类或接口进行协同工作\",{\"1\":{\"512\":1}}],[\"需要通过对象实例来访问其实例\",{\"1\":{\"816\":1}}],[\"需要通过类的实例对象去访问\",{\"1\":{\"778\":1}}],[\"需要通过密码验证\",{\"1\":{\"495\":1}}],[\"需要通过主题进行中转\",{\"1\":{\"328\":1}}],[\"需要手动点击每个license\",{\"1\":{\"538\":1}}],[\"需要手动创建代理类和被代理类\",{\"1\":{\"495\":1}}],[\"需要手动配置路由信息\",{\"1\":{\"205\":1}}],[\"需要递归地复制对象及其子对象\",{\"1\":{\"455\":1}}],[\"需要解耦客户端和具体产品的实现\",{\"1\":{\"442\":1}}],[\"需要定义抽象工厂和抽象产品接口\",{\"1\":{\"437\":1}}],[\"需要修改\",{\"1\":{\"422\":1,\"461\":1,\"489\":1}}],[\"需要仔细考虑其适用性和潜在的问题\",{\"1\":{\"421\":1}}],[\"需要仔细设计状态之间的转换逻辑\",{\"1\":{\"361\":1}}],[\"需要将一个已存在的类或接口适配到另一个接口\",{\"1\":{\"512\":1}}],[\"需要将一系列操作参数化\",{\"1\":{\"384\":1}}],[\"需要将请求的发送者和接收者解耦\",{\"1\":{\"384\":1}}],[\"需要支持请求的撤销\",{\"1\":{\"384\":1}}],[\"需要保存对象状态的历史记录\",{\"1\":{\"378\":1}}],[\"需要实现撤销和恢复功能\",{\"1\":{\"378\":1}}],[\"需要遍历整个责任链\",{\"1\":{\"355\":1}}],[\"需要遍历才能找到特定位置的元素\",{\"1\":{\"312\":1}}],[\"需要\",{\"1\":{\"315\":3}}],[\"需要较大的存储转发空间\",{\"1\":{\"255\":1}}],[\"需要传输额外信息量\",{\"1\":{\"254\":1,\"255\":1}}],[\"需要采取方法使双方的时钟保持同步\",{\"1\":{\"236\":1}}],[\"需要等待时间和花费更多的费用\",{\"1\":{\"218\":1}}],[\"需要释放之前所建立的虚拟电路\",{\"1\":{\"184\":1}}],[\"需要给ack分组编号\",{\"1\":{\"137\":1}}],[\"需要给数据分组编号\",{\"1\":{\"137\":1}}],[\"需要注意\",{\"1\":{\"859\":1}}],[\"需要注意工厂类的职责和代码的扩展性\",{\"1\":{\"430\":1}}],[\"需要注意中介者对象的复杂性\",{\"1\":{\"410\":1}}],[\"需要注意避免在使用迭代器时并发修改集合的结构\",{\"1\":{\"367\":1}}],[\"需要注意以下几点\",{\"1\":{\"367\":1}}],[\"需要注意的是value是volatile的\",{\"1\":{\"711\":1}}],[\"需要注意的是\",{\"1\":{\"94\":1,\"205\":1,\"486\":1,\"755\":1,\"799\":1}}],[\"需要注册oracle账号\",{\"1\":{\"17\":1,\"43\":1}}],[\"授权\",{\"1\":{\"355\":1}}],[\"授予用户远程连接的权限\",{\"1\":{\"11\":1,\"37\":1}}],[\"插件\",{\"1\":{\"769\":1}}],[\"插件就是一种责任链模式的应用\",{\"1\":{\"352\":1}}],[\"插入等操作时依赖于哈希码来确定对象的存储位置\",{\"1\":{\"787\":1}}],[\"插入顺序表示元素被插入的顺序\",{\"1\":{\"715\":1}}],[\"插入顺序或者访问顺序的维护是比较高效的\",{\"1\":{\"714\":1}}],[\"插入的数据被线程\",{\"1\":{\"707\":1}}],[\"插入和删除键值对\",{\"1\":{\"705\":1}}],[\"插入和删除元素的特性\",{\"1\":{\"704\":1}}],[\"插入和删除操作相对容易\",{\"1\":{\"312\":1}}],[\"插入和删除操作可能涉及大量数据的移动\",{\"1\":{\"312\":1}}],[\"插入完成再判断是否需要扩容\",{\"1\":{\"701\":1}}],[\"插入\",{\"1\":{\"698\":1}}],[\"插入可以头部插入\",{\"1\":{\"677\":1,\"678\":1}}],[\"插个线就行\",{\"1\":{\"573\":1}}],[\"插上数据线连接手机和电脑\",{\"1\":{\"538\":1}}],[\"依次判断下一个位置是否空闲\",{\"1\":{\"692\":1}}],[\"依次尝试处理请求\",{\"1\":{\"348\":1}}],[\"依赖声明块\",{\"1\":{\"539\":1}}],[\"依赖\",{\"1\":{\"539\":1}}],[\"依赖下载成功\",{\"1\":{\"538\":1}}],[\"依赖倒置原则与\",{\"1\":{\"477\":1}}],[\"依赖倒置原则也鼓励通过依赖注入等方式来实现模块之间的解耦\",{\"1\":{\"476\":1}}],[\"依赖倒置原则\",{\"0\":{\"475\":1},\"1\":{\"476\":1,\"478\":1}}],[\"依照ftp协议提供服务\",{\"1\":{\"83\":1}}],[\"责任链模式是很多系统设计中常用的一种设计模式\",{\"1\":{\"355\":1}}],[\"责任链模式使得请求的处理和任务的分配变得灵活和可配置\",{\"1\":{\"355\":1}}],[\"责任链模式可以确保每个执行器只关注自己可以处理的任务\",{\"1\":{\"355\":1}}],[\"责任链模式可以用于创建一个事件处理器链\",{\"1\":{\"355\":1}}],[\"责任链模式能够确保每个审批者只关注自己的审批职责\",{\"1\":{\"355\":1}}],[\"责任链模式将请求发送者和接收者解耦\",{\"1\":{\"351\":1}}],[\"责任链模式允许在运行时动态地确定请求的处理顺序\",{\"1\":{\"351\":1}}],[\"责任链上的第一个处理器开始检查是否能够处理该请求\",{\"1\":{\"350\":1}}],[\"责任链上的每个处理器都有机会处理该请求\",{\"1\":{\"349\":1}}],[\"责任链设计模式的缺点\",{\"1\":{\"355\":1}}],[\"责任链设计模式的优点\",{\"1\":{\"355\":1}}],[\"责任链设计模式的核心思想是解耦请求的发送者和接收者\",{\"1\":{\"349\":1}}],[\"责任链设计模式在一些特定的场景下能够带来很大的便利\",{\"1\":{\"355\":1}}],[\"责任链设计模式在实际应用中有许多场景\",{\"1\":{\"352\":1}}],[\"责任链设计模式在以下情况下适用\",{\"1\":{\"351\":1}}],[\"责任链设计模式由以下几个要素组成\",{\"1\":{\"350\":1}}],[\"责任链设计模式\",{\"0\":{\"347\":1},\"1\":{\"348\":1}}],[\"责任分配和消息传递等行为\",{\"1\":{\"320\":2}}],[\"您将会看到文件夹结构被递归地打印出来\",{\"1\":{\"525\":1}}],[\"您可以更方便地创建和操作user对象\",{\"1\":{\"450\":1}}],[\"您可以使用这些序列化器\",{\"1\":{\"346\":1}}],[\"您说得对\",{\"1\":{\"346\":1}}],[\"易读\",{\"1\":{\"346\":1}}],[\"易于扩展\",{\"1\":{\"526\":1}}],[\"易于扩展和添加新功能\",{\"1\":{\"361\":1}}],[\"易于扩展和维护\",{\"1\":{\"346\":1}}],[\"易于单独测试和调试\",{\"1\":{\"488\":1}}],[\"易于理解和维护\",{\"1\":{\"345\":1,\"361\":1}}],[\"易于理解和设计的模块\",{\"1\":{\"268\":1}}],[\"易于维护和理解\",{\"1\":{\"396\":1}}],[\"易于维护和扩展\",{\"1\":{\"333\":1}}],[\"易于维护\",{\"1\":{\"339\":1}}],[\"扩缩容的条件\",{\"1\":{\"690\":1}}],[\"扩展成一个范围更大的锁\",{\"1\":{\"837\":1}}],[\"扩展类加载器\",{\"1\":{\"756\":1}}],[\"扩展的抽象部分\",{\"1\":{\"504\":1}}],[\"扩展困难\",{\"1\":{\"465\":1}}],[\"扩展和测试代码\",{\"1\":{\"461\":1}}],[\"扩展性受到限制\",{\"1\":{\"421\":1}}],[\"扩展语法规则\",{\"1\":{\"396\":1}}],[\"扩展系统的功能\",{\"1\":{\"345\":1}}],[\"扩容后的newtab的大小为老数组的两倍\",{\"1\":{\"821\":1}}],[\"扩容时会造成死循环和数据丢失的问题\",{\"1\":{\"707\":1}}],[\"扩容时机\",{\"1\":{\"701\":1}}],[\"扩容的时候\",{\"1\":{\"701\":1}}],[\"扩容rehash\",{\"1\":{\"701\":1}}],[\"扩容在什么时候呢\",{\"0\":{\"696\":1},\"1\":{\"696\":1}}],[\"扩容到\",{\"1\":{\"688\":1}}],[\"扩容长度为原来的两倍\",{\"1\":{\"685\":1}}],[\"扩容方式\",{\"1\":{\"679\":1}}],[\"扩容方式是创建一个新数组\",{\"1\":{\"677\":1}}],[\"扩容是满了才会扩容\",{\"1\":{\"677\":1}}],[\"扩容\",{\"1\":{\"366\":1,\"821\":1}}],[\"扩散法\",{\"1\":{\"205\":1}}],[\"元数据验证\",{\"1\":{\"754\":1}}],[\"元空间大小\",{\"1\":{\"768\":1}}],[\"元空间会进行相应的类卸载\",{\"1\":{\"725\":1}}],[\"元空间替代永久代后\",{\"1\":{\"725\":1}}],[\"元空间的内存管理更侧重于类元数据的释放\",{\"1\":{\"725\":1}}],[\"元空间的内存管理更为灵活\",{\"1\":{\"725\":1}}],[\"元空间的管理依然由\",{\"1\":{\"723\":1}}],[\"元空间的大小可以根据需要动态调整\",{\"1\":{\"723\":1}}],[\"元\",{\"1\":{\"344\":3,\"510\":2}}],[\"元素数组\",{\"1\":{\"819\":1}}],[\"元素数组和散列方法\",{\"1\":{\"819\":1}}],[\"元素在哈希表中的存储位置是根据其哈希码计算得到的\",{\"1\":{\"715\":1}}],[\"元素的存储顺序是不确定的\",{\"1\":{\"715\":1}}],[\"元素的方法\",{\"1\":{\"363\":1}}],[\"元素顺序的处理\",{\"1\":{\"715\":1}}],[\"元素\",{\"1\":{\"704\":1}}],[\"元素会存入链表\",{\"1\":{\"701\":1}}],[\"元素不允许重复\",{\"1\":{\"687\":1}}],[\"元素不是按照序列排列的\",{\"1\":{\"311\":1}}],[\"元素可以重复吗\",{\"0\":{\"687\":1},\"1\":{\"687\":1}}],[\"元素接口\",{\"1\":{\"372\":2}}],[\"元素对象可以被访问者访问\",{\"1\":{\"371\":1}}],[\"元素之间存在多对多的关系\",{\"1\":{\"311\":1}}],[\"元素间存在明确的顺序关系\",{\"1\":{\"311\":1}}],[\"微信支付\",{\"1\":{\"344\":1}}],[\"微信支付和信用卡支付的具体逻辑\",{\"1\":{\"344\":1}}],[\"微信支付和信用卡支付\",{\"1\":{\"344\":1}}],[\"微波是直线传播的\",{\"1\":{\"230\":1}}],[\"微波会穿透电离层进入宇宙\",{\"1\":{\"230\":1}}],[\"微波\",{\"1\":{\"230\":1}}],[\"策略模式\",{\"1\":{\"490\":1}}],[\"策略模式适用于在运行时动态选择算法或行为的场景\",{\"1\":{\"386\":1}}],[\"策略模式的核心角色是策略\",{\"1\":{\"386\":1}}],[\"策略模式主要用于在不同算法或行为之间进行灵活切换\",{\"1\":{\"386\":1}}],[\"策略工厂\",{\"1\":{\"346\":1}}],[\"策略的选择逻辑\",{\"1\":{\"345\":1}}],[\"策略接口定义了算法的统一接口\",{\"1\":{\"343\":1}}],[\"策略接口\",{\"1\":{\"343\":2,\"344\":1,\"346\":1}}],[\"策略设计模式关注的是封装不同的算法或行为\",{\"1\":{\"386\":1}}],[\"策略设计模式是一种非常有用的模式\",{\"1\":{\"345\":1}}],[\"策略设计模式帮助我们实现了不同支付方式的逻辑隔离和动态替换\",{\"1\":{\"344\":1}}],[\"策略设计模式案例\",{\"1\":{\"344\":1}}],[\"策略设计模式适用于以下场景\",{\"1\":{\"344\":1}}],[\"策略设计模式的缺点包括\",{\"1\":{\"345\":1}}],[\"策略设计模式的优点包括\",{\"1\":{\"345\":1}}],[\"策略设计模式的基本流程\",{\"1\":{\"343\":1}}],[\"策略设计模式的核心思想是把算法的定义和使用分开\",{\"1\":{\"342\":1}}],[\"策略设计模式由以下几个关键组件组成\",{\"1\":{\"343\":1}}],[\"策略设计模式\",{\"0\":{\"340\":1},\"1\":{\"341\":1,\"386\":1}}],[\"判断一个类是否是无用的\",{\"1\":{\"733\":1}}],[\"判断\",{\"1\":{\"707\":1}}],[\"判断tab\",{\"1\":{\"695\":1}}],[\"判断tab是否位空或者长度为0\",{\"1\":{\"695\":1}}],[\"判断当前元素存放的位置\",{\"1\":{\"686\":1}}],[\"判断时\",{\"1\":{\"672\":1,\"707\":1}}],[\"判断报文格式获取不同的适配器对象\",{\"1\":{\"511\":1}}],[\"判断方法名\",{\"1\":{\"497\":1,\"498\":1}}],[\"判断并输出结果\",{\"1\":{\"394\":1}}],[\"判断是否超过阈值\",{\"1\":{\"695\":1}}],[\"判断是否有下一个\",{\"1\":{\"366\":1}}],[\"判断是否达到文件末尾\",{\"1\":{\"335\":1}}],[\"判断是否达到输入流的末尾\",{\"1\":{\"335\":1}}],[\"判断容量\",{\"1\":{\"366\":1}}],[\"判断帧的结尾\",{\"1\":{\"131\":1}}],[\"报告生成模板\",{\"1\":{\"336\":1}}],[\"报销申请需要金额核对\",{\"1\":{\"333\":1}}],[\"报销申请\",{\"1\":{\"333\":1}}],[\"报文首部格式\",{\"0\":{\"650\":1,\"662\":1}}],[\"报文段序号初始值为1\",{\"1\":{\"294\":1}}],[\"报文在节点交换机上要经历存储转发的过程\",{\"1\":{\"255\":1}}],[\"报文交换与分组交换类似\",{\"1\":{\"255\":1}}],[\"报文交换\",{\"0\":{\"255\":1}}],[\"报文\",{\"1\":{\"212\":4}}],[\"报文中的各个字段及其详细描述\",{\"1\":{\"56\":1}}],[\"审核记录等\",{\"1\":{\"333\":1}}],[\"审批处理\",{\"1\":{\"333\":1}}],[\"审批流程通常有一定的通用结构\",{\"1\":{\"333\":1}}],[\"敌人种类和数量\",{\"1\":{\"333\":1}}],[\"胜利条件等\",{\"1\":{\"333\":1}}],[\"退货订单\",{\"1\":{\"333\":1}}],[\"退出时释放锁\",{\"1\":{\"832\":1,\"834\":1}}],[\"退出聊天群和通知所有用户的方法\",{\"1\":{\"325\":1}}],[\"退出\",{\"1\":{\"11\":1,\"37\":1}}],[\"预期的值\",{\"1\":{\"845\":1}}],[\"预定订单\",{\"1\":{\"333\":1}}],[\"预估时间和运行平台绑定\",{\"1\":{\"315\":1}}],[\"普通旅游者\",{\"1\":{\"372\":1}}],[\"普通订单\",{\"1\":{\"333\":1}}],[\"普通用户通过isp接入因特网\",{\"1\":{\"249\":1}}],[\"验证字节流是否符合\",{\"1\":{\"754\":1}}],[\"验证\",{\"1\":{\"720\":1,\"754\":2,\"755\":1}}],[\"验证元素\",{\"1\":{\"367\":1}}],[\"验证支付\",{\"1\":{\"333\":1}}],[\"验证事务id是否相符\",{\"1\":{\"64\":1}}],[\"物流处理\",{\"1\":{\"518\":1}}],[\"物流管理子系统\",{\"1\":{\"518\":1}}],[\"物流管理\",{\"1\":{\"518\":1}}],[\"物流管理等\",{\"1\":{\"518\":1}}],[\"物流等过程有一些共性步骤\",{\"1\":{\"333\":1}}],[\"物理结构\",{\"0\":{\"312\":1}}],[\"物理地址\",{\"1\":{\"165\":1}}],[\"物理拓扑是双环结构\",{\"1\":{\"158\":1}}],[\"物理拓扑是星形结构\",{\"1\":{\"158\":1}}],[\"物理拓扑是星形或拓展星形结构\",{\"1\":{\"158\":1}}],[\"物理层工作的关键部分是介质\",{\"1\":{\"618\":1}}],[\"物理层接口卡\",{\"1\":{\"618\":1}}],[\"物理层是网络体系结构的基础也就是第一层\",{\"1\":{\"617\":1}}],[\"物理层是计算机网络体系结构中的底层层级\",{\"1\":{\"226\":1,\"227\":1}}],[\"物理层为数据通信提供实际的物理线路和通信信道\",{\"1\":{\"274\":1}}],[\"物理层先将帧看成比特流\",{\"1\":{\"268\":1}}],[\"物理层先将帧看做是比特流\",{\"1\":{\"268\":1}}],[\"物理层将信号变换为比特流\",{\"1\":{\"268\":1}}],[\"物理层将信号变为比特流\",{\"1\":{\"268\":1}}],[\"物理层将装有前导码的比特流变换成相应的信号发送给传输媒体\",{\"1\":{\"268\":2}}],[\"物理层还涉及各种传输介质\",{\"1\":{\"240\":1}}],[\"物理层传输的比特流0\",{\"1\":{\"238\":1}}],[\"物理层标准与协议\",{\"1\":{\"229\":1}}],[\"物理层的主要任务是在计算机网络中负责在不同的物理机之间通过物理媒介传输原始比特流而进行通信\",{\"1\":{\"617\":1}}],[\"物理层的主要功能是什么\",{\"0\":{\"617\":1},\"1\":{\"617\":1}}],[\"物理层的传输媒体\",{\"1\":{\"230\":1}}],[\"物理层的特点\",{\"1\":{\"227\":1}}],[\"物理层的功能\",{\"1\":{\"119\":1}}],[\"物理层并非指具体的硬件设备\",{\"1\":{\"227\":1}}],[\"物理层\",{\"0\":{\"226\":1},\"1\":{\"162\":2,\"227\":1,\"268\":1}}],[\"物理层相邻的是mac子层\",{\"1\":{\"120\":1}}],[\"支付逻辑错误\",{\"1\":{\"845\":1}}],[\"支付逻辑可能更加复杂\",{\"1\":{\"344\":1}}],[\"支付状态又变为已支付\",{\"1\":{\"845\":1}}],[\"支付状态再次变为已支付\",{\"1\":{\"845\":1}}],[\"支付状态变为已支付\",{\"1\":{\"845\":1}}],[\"支付被撤销\",{\"1\":{\"845\":1}}],[\"支付被撤销并重新支付\",{\"1\":{\"845\":1}}],[\"支付系统异常等\",{\"1\":{\"845\":1}}],[\"支付系统处理支付并更新支付状态\",{\"1\":{\"845\":1}}],[\"支付成功后状态为已支付\",{\"1\":{\"845\":1}}],[\"支付服务子系统\",{\"1\":{\"518\":1}}],[\"支付服务和物流管理子系统的方法来处理订单\",{\"1\":{\"518\":1}}],[\"支付服务和物流管理子系统的实例\",{\"1\":{\"518\":1}}],[\"支付服务和物流管理\",{\"1\":{\"518\":1}}],[\"支付服务\",{\"1\":{\"518\":2}}],[\"支付宝支付\",{\"1\":{\"344\":1}}],[\"支付\",{\"1\":{\"333\":1}}],[\"支持读写锁\",{\"1\":{\"831\":1}}],[\"支持\",{\"1\":{\"539\":1}}],[\"支持大量对象\",{\"1\":{\"533\":1}}],[\"支持撤销\",{\"1\":{\"386\":1}}],[\"支持请求的撤销\",{\"1\":{\"385\":1}}],[\"支持输入文本\",{\"1\":{\"378\":1}}],[\"支持开闭原则\",{\"1\":{\"361\":1}}],[\"支持各种交互通信方式\",{\"1\":{\"301\":1}}],[\"支持原因\",{\"1\":{\"282\":3}}],[\"订单状态等可能会出现混乱\",{\"1\":{\"845\":1}}],[\"订单状态管理等\",{\"1\":{\"344\":1}}],[\"订单类\",{\"1\":{\"465\":3}}],[\"订单处理等\",{\"1\":{\"845\":1}}],[\"订单处理涉及多个子系统\",{\"1\":{\"518\":1}}],[\"订单处理门面\",{\"1\":{\"518\":2}}],[\"订单处理系统涉及多个子系统\",{\"1\":{\"518\":1}}],[\"订单处理和支付系统等子系统的交互\",{\"1\":{\"517\":1}}],[\"订单处理\",{\"1\":{\"333\":1}}],[\"订阅模式的实现\",{\"1\":{\"326\":1}}],[\"订阅模式\",{\"1\":{\"326\":2}}],[\"订阅模式广泛应用于各种场景\",{\"1\":{\"326\":1}}],[\"订阅模式是一种行为型设计模式\",{\"1\":{\"326\":1}}],[\"订阅感兴趣的消息主题或事件类型\",{\"1\":{\"326\":1}}],[\"订阅系统中\",{\"1\":{\"322\":1}}],[\"继承thread类\",{\"1\":{\"806\":1}}],[\"继承关系\",{\"1\":{\"706\":1}}],[\"继承了抽象装饰器\",{\"1\":{\"501\":1}}],[\"继承了抽象组件接口\",{\"1\":{\"501\":1}}],[\"继承自\",{\"1\":{\"706\":2}}],[\"继承自基础类\",{\"1\":{\"495\":1}}],[\"继承自抽象类\",{\"1\":{\"332\":1}}],[\"继承实现代理设计模式示例代码\",{\"1\":{\"495\":1}}],[\"继承\",{\"1\":{\"493\":2,\"782\":2,\"838\":1}}],[\"继续执行步骤6\",{\"1\":{\"837\":1}}],[\"继续检查\",{\"1\":{\"350\":1}}],[\"继续传送令牌\",{\"1\":{\"153\":1}}],[\"继续发送数据\",{\"1\":{\"141\":1,\"576\":1}}],[\"继续\",{\"1\":{\"141\":1,\"576\":1}}],[\"模块化和封装性\",{\"1\":{\"490\":1}}],[\"模块\",{\"1\":{\"466\":1}}],[\"模块中包含多个类\",{\"1\":{\"460\":1}}],[\"模板方法模式\",{\"1\":{\"490\":1}}],[\"模板方法\",{\"1\":{\"332\":1,\"335\":1,\"336\":1,\"338\":3}}],[\"模板方法中会调用多个抽象方法\",{\"1\":{\"331\":1}}],[\"模板方法设计模式在许多情况下都能很好地提高代码的复用性和灵活性\",{\"1\":{\"339\":1}}],[\"模板方法设计模式提高了代码复用性\",{\"1\":{\"339\":1}}],[\"模板方法设计模式能够将稳定的处理流程与特定实现解耦\",{\"1\":{\"333\":1}}],[\"模板方法设计模式可以应用于以下情况\",{\"1\":{\"333\":1}}],[\"模板方法设计模式适用于以下情况\",{\"1\":{\"333\":1}}],[\"模板方法设计模式主要由以下组成部分构成\",{\"1\":{\"332\":1}}],[\"模板方法设计模式的核心思想在于定义一个抽象类\",{\"1\":{\"331\":1}}],[\"模板方法设计模式\",{\"1\":{\"330\":1}}],[\"模板设计模式\",{\"0\":{\"329\":1}}],[\"模拟执行数据库删除\",{\"1\":{\"497\":1,\"498\":1}}],[\"模拟执行数据库查询\",{\"1\":{\"495\":1,\"497\":1,\"498\":1}}],[\"模拟网络响应\",{\"1\":{\"495\":1}}],[\"模拟网络请求和响应的过程\",{\"1\":{\"495\":1}}],[\"模拟网络请求\",{\"1\":{\"495\":1}}],[\"模拟从用户输入获取密码的逻辑\",{\"1\":{\"495\":1}}],[\"模拟了一个处理器链\",{\"1\":{\"353\":1}}],[\"模拟信号的传输更为可靠\",{\"1\":{\"619\":1}}],[\"模拟信号的传输损耗相对较低\",{\"1\":{\"619\":1}}],[\"模拟信号在某些传输介质中的传输更为可靠和高效\",{\"1\":{\"619\":1}}],[\"模拟信号在某些情况下具有更好的抗干扰能力\",{\"1\":{\"619\":1}}],[\"模拟信号在传输过程中的衰减相对较小\",{\"1\":{\"619\":1}}],[\"模拟信号需要在电话线路或无线传输中传递\",{\"1\":{\"239\":1}}],[\"模拟信号角度的带宽\",{\"1\":{\"147\":1}}],[\"模拟基带信号\",{\"1\":{\"238\":1}}],[\"模拟传输\",{\"1\":{\"230\":1}}],[\"才真正停止\",{\"1\":{\"864\":1}}],[\"才会抛出内存溢出异常\",{\"1\":{\"735\":1}}],[\"才会回收对应的对象\",{\"1\":{\"731\":1}}],[\"才进入\",{\"0\":{\"646\":1}}],[\"才能进入对局再选游戏\",{\"1\":{\"851\":1}}],[\"才能进行其他逻辑处理\",{\"1\":{\"841\":1}}],[\"才能进行\",{\"1\":{\"744\":1}}],[\"才能将内存中地址\",{\"1\":{\"845\":1}}],[\"才能将dns故障风险及其带来的损失降至最低点\",{\"1\":{\"81\":1}}],[\"才能晋升老年代\",{\"1\":{\"740\":1}}],[\"才能接收来自其他设备的数据\",{\"1\":{\"582\":1}}],[\"才能执行实际的敏感操作\",{\"1\":{\"495\":1}}],[\"才能正确地执行删除操作\",{\"1\":{\"367\":1}}],[\"才执行后续的代码\",{\"1\":{\"327\":1}}],[\"关中断指令\",{\"1\":{\"809\":1}}],[\"关键字或者\",{\"1\":{\"844\":1}}],[\"关键字类似\",{\"1\":{\"838\":1}}],[\"关键字synchronized可以修饰方法或者以同步块的形式来进行使用\",{\"1\":{\"811\":1}}],[\"关键字volatile可以用来修饰字段\",{\"1\":{\"811\":1}}],[\"关键字修饰时\",{\"1\":{\"834\":1}}],[\"关键字修饰\",{\"1\":{\"785\":1}}],[\"关键字在接口中定义默认方法\",{\"1\":{\"783\":1}}],[\"关键字\",{\"1\":{\"708\":1,\"736\":1,\"831\":1,\"832\":2}}],[\"关键字除以一个不大于哈希表长度的正整数p\",{\"1\":{\"691\":1}}],[\"关系型数据库mysql\",{\"0\":{\"543\":1}}],[\"关注老年代内存使用是否达到阀值\",{\"1\":{\"769\":1}}],[\"关注\",{\"1\":{\"765\":1}}],[\"关注对象之间的通信\",{\"1\":{\"490\":1}}],[\"关注对象的创建过程\",{\"1\":{\"490\":1}}],[\"关注类和对象之间的组合\",{\"1\":{\"490\":1}}],[\"关注点\",{\"1\":{\"411\":2}}],[\"关注点不同\",{\"1\":{\"386\":1}}],[\"关注的是定义一系列算法或行为\",{\"1\":{\"386\":1}}],[\"关注的是将请求\",{\"1\":{\"386\":1}}],[\"关注了明星的追星人可以接收到通过总线发送来的消息\",{\"1\":{\"326\":1}}],[\"关联起来\",{\"1\":{\"326\":1}}],[\"关闭线程池\",{\"1\":{\"863\":1}}],[\"关闭状态\",{\"0\":{\"646\":1}}],[\"关闭\",{\"1\":{\"360\":1}}],[\"关闭和调整音量的功能\",{\"1\":{\"360\":1}}],[\"关闭流\",{\"1\":{\"335\":1}}],[\"关闭文件输入流\",{\"1\":{\"335\":1}}],[\"关闭控制连接\",{\"1\":{\"86\":1}}],[\"关闭数据连接\",{\"1\":{\"86\":1}}],[\"事务和我们的业务不强相关\",{\"1\":{\"500\":1}}],[\"事务\",{\"1\":{\"500\":1}}],[\"事务管理等\",{\"1\":{\"496\":1}}],[\"事务管理\",{\"1\":{\"495\":1,\"496\":1}}],[\"事件处理系统\",{\"1\":{\"355\":1}}],[\"事件驱动系统\",{\"1\":{\"326\":1}}],[\"事实上不一定\",{\"1\":{\"864\":1}}],[\"事实上\",{\"1\":{\"316\":1}}],[\"事实上是因为这类服务所用的数据链路已建立起来\",{\"1\":{\"126\":1}}],[\"宿舍四个室友创建qq\",{\"1\":{\"325\":1}}],[\"聊天室\",{\"1\":{\"408\":1}}],[\"聊天室中的用户可以实时接收和发送消息\",{\"1\":{\"325\":1}}],[\"聊天室会调用notifyalluser方法通知其他用户接收消息\",{\"1\":{\"325\":1}}],[\"执行中打印过程日志\",{\"1\":{\"871\":1}}],[\"执行完毕\",{\"1\":{\"867\":1}}],[\"执行完哈希冲突判断后\",{\"1\":{\"707\":1}}],[\"执行任务\",{\"1\":{\"809\":1}}],[\"执行效率不稳定\",{\"1\":{\"744\":1}}],[\"执行<init>方法\",{\"1\":{\"726\":1}}],[\"执行途中也可能因为阻塞等原因停下\",{\"1\":{\"722\":1}}],[\"执行字节码\",{\"1\":{\"720\":1}}],[\"执行静态代码块\",{\"1\":{\"720\":1}}],[\"执行扩容\",{\"1\":{\"711\":1}}],[\"执行\",{\"1\":{\"707\":1,\"739\":1}}],[\"执行的机会\",{\"1\":{\"707\":1}}],[\"执行ieee\",{\"1\":{\"578\":1}}],[\"执行数据库删除操作\",{\"1\":{\"497\":1}}],[\"执行数据库查询操作\",{\"1\":{\"497\":1}}],[\"执行远程任务时\",{\"1\":{\"495\":1}}],[\"执行远程任务\",{\"1\":{\"495\":1}}],[\"执行敏感操作时\",{\"1\":{\"495\":1}}],[\"执行敏感操作\",{\"1\":{\"495\":1}}],[\"执行反序列化操作\",{\"1\":{\"455\":1}}],[\"执行命令\",{\"1\":{\"383\":2,\"384\":1}}],[\"执行具体命令\",{\"1\":{\"383\":1}}],[\"执行状态b的行为\",{\"1\":{\"359\":1}}],[\"执行状态a的行为\",{\"1\":{\"359\":1}}],[\"执行一些通用的处理逻辑\",{\"1\":{\"338\":6}}],[\"执行相应的更新操作\",{\"1\":{\"324\":1}}],[\"执行其他操作\",{\"1\":{\"86\":1}}],[\"维护着等待执行的runnable对象\",{\"1\":{\"860\":1}}],[\"维护锁计数器和检查是否被阻塞的线程需要被唤醒等等开销\",{\"1\":{\"831\":1}}],[\"维护了java中锁机制的合理性和安全性\",{\"1\":{\"813\":1}}],[\"维护\",{\"1\":{\"710\":1}}],[\"维护和终止数据链路连接\",{\"1\":{\"584\":1}}],[\"维护一个享元池用于存储和管理共享对象\",{\"1\":{\"530\":1}}],[\"维护一个聚合对象\",{\"1\":{\"366\":1}}],[\"维护一份观察者列表\",{\"1\":{\"324\":1}}],[\"维护遍历时的状态信息\",{\"1\":{\"365\":1}}],[\"维护性\",{\"1\":{\"345\":1}}],[\"维护事件和订阅者\",{\"1\":{\"326\":1}}],[\"维度\",{\"1\":{\"312\":1}}],[\"被final修饰了\",{\"1\":{\"789\":1}}],[\"被\",{\"1\":{\"775\":1}}],[\"被称为回收价值\",{\"1\":{\"749\":1}}],[\"被弱引用关联的对象只能生存到下一次垃圾收集发生为止\",{\"1\":{\"735\":1}}],[\"被编码在网络接口卡上\",{\"1\":{\"574\":1}}],[\"被适配者执行相应的操作\",{\"1\":{\"509\":1}}],[\"被适配者是需要被适配的类或接口\",{\"1\":{\"508\":1}}],[\"被适配者\",{\"1\":{\"508\":1}}],[\"被调用的方法对象\",{\"1\":{\"497\":1}}],[\"被代理类实现的接口数组\",{\"1\":{\"496\":1}}],[\"被代理类的方法就会被代理类所覆盖\",{\"1\":{\"494\":1}}],[\"被声明为\",{\"1\":{\"450\":1}}],[\"被观察者只管发送消息到消息队列\",{\"1\":{\"327\":1}}],[\"被观察者完全不感知观察者\",{\"1\":{\"327\":1}}],[\"被观察者和观察者解耦更加彻底\",{\"1\":{\"327\":1}}],[\"被观察者需要依次遍历观察者来发送消息\",{\"1\":{\"327\":1}}],[\"被观察者接口\",{\"1\":{\"327\":1}}],[\"被观察者一直阻塞\",{\"1\":{\"327\":1}}],[\"被观察者\",{\"1\":{\"323\":1}}],[\"被动模式\",{\"1\":{\"85\":1}}],[\"核心方法如下\",{\"1\":{\"851\":1}}],[\"核心目的就是用于实现代码的复用\",{\"1\":{\"782\":1}}],[\"核心目的就是给我们提供了一系列全新的创建对象的方式方法\",{\"1\":{\"414\":1}}],[\"核心类库\",{\"1\":{\"756\":1}}],[\"核心就是拿到entryset\",{\"1\":{\"702\":1}}],[\"核心使用场景\",{\"1\":{\"504\":1}}],[\"核心思想是\",{\"1\":{\"846\":1}}],[\"核心思想\",{\"0\":{\"323\":1,\"331\":1,\"342\":1,\"349\":1,\"358\":1,\"364\":1,\"370\":1,\"376\":1,\"382\":1,\"389\":1,\"399\":1,\"417\":1,\"425\":1,\"433\":1,\"440\":1,\"447\":1,\"515\":1,\"523\":1,\"529\":1}}],[\"核心问题\",{\"1\":{\"121\":1,\"131\":1}}],[\"行为型模式\",{\"1\":{\"490\":1}}],[\"行为型设计模式的核心目的是提供一种灵活\",{\"1\":{\"320\":2}}],[\"行为型设计模式关注对象之间行为\",{\"1\":{\"320\":2}}],[\"行为型设计模式\",{\"0\":{\"320\":1}}],[\"行政区域名\",{\"1\":{\"69\":1}}],[\"输出流不同之处在于\",{\"1\":{\"811\":1}}],[\"输出流或者网络输入\",{\"1\":{\"811\":1}}],[\"输出流和普通的文件输入\",{\"1\":{\"811\":1}}],[\"输出流\",{\"1\":{\"811\":2}}],[\"输出每个类的对象数量\",{\"1\":{\"769\":1}}],[\"输出的值就是线程栈信息中的\",{\"1\":{\"769\":1}}],[\"输出方法的返回结果\",{\"1\":{\"497\":1,\"498\":1}}],[\"输出结果仍然是\",{\"1\":{\"502\":1}}],[\"输出结果展示\",{\"1\":{\"495\":1}}],[\"输出结果可能不符合预期\",{\"1\":{\"469\":1}}],[\"输出结果将符合预期\",{\"1\":{\"469\":1}}],[\"输出结果显示每个用户成功发送了消息\",{\"1\":{\"408\":1}}],[\"输出结果如下\",{\"1\":{\"403\":1}}],[\"输出\",{\"1\":{\"378\":1,\"390\":1,\"769\":1,\"795\":1}}],[\"输出相应的消息\",{\"1\":{\"326\":1}}],[\"输出空间\",{\"1\":{\"317\":2}}],[\"输入数据\",{\"1\":{\"394\":1}}],[\"输入第二次文本并保存到历史记录\",{\"1\":{\"378\":1}}],[\"输入第一次文本并保存到历史记录\",{\"1\":{\"378\":1}}],[\"输入空间\",{\"1\":{\"317\":1}}],[\"输入的n不受控制\",{\"1\":{\"316\":1}}],[\"输入用户名和密码访问即可\",{\"1\":{\"3\":1,\"29\":1}}],[\"输入y选择即可\",{\"1\":{\"3\":1,\"29\":1}}],[\"函数会唤醒被阻塞到该共享变量上的一个线程\",{\"1\":{\"807\":1}}],[\"函数\",{\"1\":{\"807\":1,\"810\":1}}],[\"函数中基本类型和对象的引用都是在栈内存中分配\",{\"1\":{\"724\":1}}],[\"函数中调用\",{\"1\":{\"327\":1}}],[\"函数计算出的插入下标是相同的\",{\"1\":{\"707\":1}}],[\"函数调用的是\",{\"1\":{\"694\":1}}],[\"函数或模块中\",{\"1\":{\"486\":1}}],[\"函数等\",{\"1\":{\"466\":1}}],[\"函数返回后\",{\"1\":{\"317\":1}}],[\"函数上下文等数据\",{\"1\":{\"317\":1}}],[\"函数表示\",{\"1\":{\"316\":2}}],[\"暂停线程的执行\",{\"1\":{\"785\":1}}],[\"暂停所有的其他线程\",{\"1\":{\"746\":1,\"750\":1}}],[\"暂存数据\",{\"1\":{\"317\":1}}],[\"暂存空间可以进一步划分为三个部分\",{\"1\":{\"317\":1}}],[\"暂存空间\",{\"1\":{\"317\":2}}],[\"暂时停止接受新的连接请求\",{\"1\":{\"285\":1}}],[\"暂时未被大范围应用\",{\"1\":{\"230\":1}}],[\"暂时不参与转发数据\",{\"1\":{\"175\":1}}],[\"现代处理器采用了指令级并行技术\",{\"1\":{\"826\":1}}],[\"现代垃圾收集器大部分都是基于分代收集理论设计的\",{\"1\":{\"722\":1}}],[\"现代的以太网通常使用交换机\",{\"1\":{\"581\":1}}],[\"现象\",{\"1\":{\"622\":1}}],[\"现有对象的实例来创建新的对象\",{\"1\":{\"453\":1}}],[\"现在有三个窗口坐着三个营业员小姐姐在营业\",{\"1\":{\"868\":1}}],[\"现在开放了三个窗口\",{\"1\":{\"868\":1}}],[\"现在的和之前的有什么区别\",{\"1\":{\"725\":1}}],[\"现在newevent是originalevent的一个深拷贝副本\",{\"1\":{\"455\":1}}],[\"现在\",{\"1\":{\"360\":1,\"377\":1,\"452\":2,\"455\":2,\"461\":1,\"473\":2,\"489\":1,\"506\":1,\"579\":1}}],[\"现在我们来看一个简单的java示例\",{\"1\":{\"360\":1}}],[\"现在很发达了\",{\"1\":{\"317\":1}}],[\"现如今多使用分组交换\",{\"1\":{\"255\":1}}],[\"求其所有可能的排列方案\",{\"1\":{\"316\":1}}],[\"阶乘阶对应数学上的\",{\"1\":{\"316\":1}}],[\"轮后有\",{\"1\":{\"316\":1}}],[\"轮询开销\",{\"1\":{\"153\":1}}],[\"轮询访问\",{\"1\":{\"153\":1}}],[\"轮询访问介质控制\",{\"0\":{\"153\":1},\"1\":{\"144\":1}}],[\"轮询协议\",{\"1\":{\"144\":1,\"153\":1}}],[\"初始状态\",{\"1\":{\"808\":1}}],[\"初始状态为状态a\",{\"1\":{\"359\":1}}],[\"初始状态为\",{\"1\":{\"316\":1}}],[\"初始堆大小\",{\"1\":{\"764\":1}}],[\"初始值为\",{\"1\":{\"754\":1}}],[\"初始时所有的对象都是白色的\",{\"1\":{\"748\":1}}],[\"初始标记\",{\"1\":{\"746\":1,\"750\":1}}],[\"初始化的默认值也不同\",{\"1\":{\"773\":1}}],[\"初始化子类\",{\"1\":{\"755\":1}}],[\"初始化零值\",{\"1\":{\"726\":1}}],[\"初始化类变量\",{\"1\":{\"720\":1}}],[\"初始化\",{\"1\":{\"720\":1,\"754\":2}}],[\"初始化hashmap\",{\"1\":{\"685\":1}}],[\"初始容量大小和每次扩充容量大小的不同\",{\"1\":{\"706\":1,\"715\":1}}],[\"初始内容为include\",{\"1\":{\"539\":1}}],[\"初始arp高速缓存表为空\",{\"1\":{\"168\":1,\"583\":1}}],[\"细胞分裂\",{\"1\":{\"316\":1}}],[\"系列方法而被挂起的线程\",{\"1\":{\"807\":1}}],[\"系列方法后被挂起的线程\",{\"1\":{\"807\":1}}],[\"系数\",{\"1\":{\"316\":1}}],[\"系统默认是添加一个任务才创建一个线程池\",{\"1\":{\"860\":1}}],[\"系统需要加载这两个excel\",{\"1\":{\"854\":1}}],[\"系统需要创建一系列相关或依赖的产品家族\",{\"1\":{\"442\":1}}],[\"系统一次性加载了过多数据到内存中\",{\"1\":{\"768\":1}}],[\"系统类加载器\",{\"1\":{\"756\":1}}],[\"系统更容易进行扩展和修改\",{\"1\":{\"488\":1}}],[\"系统在每次调用函数时都会在栈顶部创建一个栈帧\",{\"1\":{\"317\":1}}],[\"系统环境等\",{\"1\":{\"315\":1}}],[\"系统就会使用默认路由来指示数据包的下一跳\",{\"1\":{\"205\":1}}],[\"系统效率较高\",{\"1\":{\"147\":1}}],[\"系统自动生成\",{\"1\":{\"91\":1}}],[\"加密\",{\"1\":{\"866\":1}}],[\"加版本号\",{\"1\":{\"845\":1}}],[\"加入到扫描栈中的对象\",{\"1\":{\"746\":1}}],[\"加入群聊\",{\"1\":{\"325\":1}}],[\"加载不到时再交\",{\"1\":{\"760\":1}}],[\"加载器\",{\"1\":{\"760\":1}}],[\"加载的类会经过加载\",{\"1\":{\"755\":1}}],[\"加载类的字节码文件到内存\",{\"1\":{\"726\":1}}],[\"加载\",{\"1\":{\"720\":1,\"754\":2,\"760\":1}}],[\"加起来大概\",{\"1\":{\"694\":1}}],[\"加锁方式\",{\"1\":{\"843\":1}}],[\"加锁\",{\"1\":{\"682\":1,\"839\":1}}],[\"加法\",{\"1\":{\"390\":1}}],[\"加法策略\",{\"1\":{\"343\":1,\"346\":1}}],[\"加班申请等\",{\"1\":{\"333\":1}}],[\"加上\",{\"1\":{\"317\":1}}],[\"加n+1\",{\"1\":{\"316\":1}}],[\"加速传输\",{\"1\":{\"254\":1}}],[\"趋近于无穷大时\",{\"1\":{\"316\":1}}],[\"渐近上界asymptotic\",{\"1\":{\"316\":1}}],[\"明天再来吧\",{\"1\":{\"861\":1}}],[\"明星发布消息\",{\"1\":{\"326\":1}}],[\"明显优于算法\",{\"1\":{\"316\":1}}],[\"明确丢弃\",{\"1\":{\"174\":1}}],[\"明确转发\",{\"1\":{\"174\":1}}],[\"较高的加载因子意味着哈希表需要更少的空间来存储相同数量的元素\",{\"1\":{\"696\":1}}],[\"较低的加载因子可以减少哈希碰撞\",{\"1\":{\"696\":1}}],[\"较低的时延和较低的误码率\",{\"1\":{\"156\":1}}],[\"较小时\",{\"1\":{\"316\":1}}],[\"足够大\",{\"1\":{\"316\":1}}],[\"仍然需要使用\",{\"1\":{\"787\":1}}],[\"仍然使用哈希表\",{\"1\":{\"714\":1}}],[\"仍然能够有效且均匀地分布元素到新的数组中\",{\"1\":{\"688\":1}}],[\"仍然可以实现不同\",{\"1\":{\"579\":1}}],[\"仍然可以选择默认的版本1的反序列化方式\",{\"1\":{\"346\":1}}],[\"仍然可以使用载波监听多址接入csma\",{\"1\":{\"152\":1}}],[\"仍为\",{\"1\":{\"316\":1}}],[\"虽然在更新操作时会牺牲一定的内存以维护分段计数器数组\",{\"1\":{\"855\":1}}],[\"虽然a的值没变\",{\"1\":{\"845\":1}}],[\"虽然柜子是大家共用的\",{\"1\":{\"816\":1}}],[\"虽然\",{\"1\":{\"787\":1,\"829\":2}}],[\"虽然不像一切一刀切成两半\",{\"1\":{\"749\":1}}],[\"虽然这种方法需要在对象改变引用关系\",{\"1\":{\"742\":1}}],[\"虽然只有低位参与了运算\",{\"1\":{\"688\":1}}],[\"虽然并不是一种正式的设计模式\",{\"1\":{\"430\":1}}],[\"虽然中介者设计模式和观察者设计模式有不同的关注点和应用场景\",{\"1\":{\"411\":1}}],[\"虽然它的性能相对较慢\",{\"1\":{\"705\":1}}],[\"虽然它们有相似之处\",{\"1\":{\"386\":1}}],[\"虽然它增加了一些类的复杂性\",{\"1\":{\"385\":1}}],[\"虽然与备忘录模式没有直接关联\",{\"1\":{\"375\":1}}],[\"虽然运行时间很长\",{\"1\":{\"316\":1}}],[\"虽然没有分组失序问题\",{\"1\":{\"254\":1}}],[\"很多使用自旋cas的地方\",{\"1\":{\"845\":1}}],[\"很简单\",{\"1\":{\"818\":1}}],[\"很复杂的逻辑\",{\"1\":{\"436\":5}}],[\"很复杂的操作\",{\"1\":{\"422\":3,\"429\":3}}],[\"很难获知每种操作的运行时间\",{\"1\":{\"315\":1}}],[\"很显然\",{\"1\":{\"275\":1}}],[\"次数太多\",{\"1\":{\"769\":1}}],[\"次数频繁\",{\"1\":{\"766\":1}}],[\"次数\",{\"1\":{\"766\":1,\"769\":1}}],[\"次的话\",{\"1\":{\"701\":1}}],[\"次握手可以携带数据吗\",{\"0\":{\"642\":1}}],[\"次等\",{\"1\":{\"316\":1}}],[\"次\",{\"1\":{\"315\":1,\"316\":5,\"769\":1}}],[\"循环来尝试更新计数器的值\",{\"1\":{\"855\":1}}],[\"循环等待条件\",{\"1\":{\"848\":1}}],[\"循环性能开销\",{\"1\":{\"845\":1}}],[\"循环的末尾\",{\"1\":{\"747\":1}}],[\"循环嵌套时使用乘法\",{\"1\":{\"316\":1}}],[\"循环\",{\"1\":{\"315\":1,\"316\":2,\"747\":1}}],[\"循环冗余校验\",{\"0\":{\"135\":1},\"1\":{\"135\":1,\"573\":1,\"576\":1}}],[\"乘法操作\",{\"1\":{\"315\":1}}],[\"乘车\",{\"1\":{\"119\":1}}],[\"评估各种计算操作所需的运行时间\",{\"1\":{\"315\":1}}],[\"编程中\",{\"1\":{\"485\":1}}],[\"编程语言\",{\"1\":{\"315\":1}}],[\"编译时异常\",{\"1\":{\"793\":1}}],[\"编译器在生成字节码时\",{\"1\":{\"827\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"826\":1}}],[\"编译器\",{\"1\":{\"826\":1}}],[\"编译器和处理器在生成和执行指令时\",{\"1\":{\"828\":1}}],[\"编译器和处理器为了提高并行度\",{\"1\":{\"826\":1}}],[\"编译器和处理器常常会对指令做重排序\",{\"1\":{\"826\":1}}],[\"编译器优化的重排序\",{\"1\":{\"826\":1}}],[\"编译器无法对其进行优化\",{\"1\":{\"792\":1}}],[\"编译器不会创建单个\",{\"1\":{\"790\":1}}],[\"编译器线程\",{\"1\":{\"721\":1}}],[\"编译成字节码文件\",{\"1\":{\"719\":1}}],[\"编译选项配置块\",{\"1\":{\"539\":1}}],[\"编译配置\",{\"1\":{\"538\":1}}],[\"编译后的代码中添加了一些内容\",{\"1\":{\"450\":1}}],[\"编译后的代码\",{\"1\":{\"450\":1}}],[\"编译前的代码\",{\"1\":{\"450\":1}}],[\"编写出来的代码可能是这个样子的\",{\"1\":{\"360\":1}}],[\"编码方案下\",{\"1\":{\"789\":1}}],[\"编码方式\",{\"1\":{\"238\":1}}],[\"编码转换\",{\"1\":{\"355\":1}}],[\"编码将声音转换成模拟信号\",{\"1\":{\"239\":1}}],[\"编码和调制区别\",{\"1\":{\"239\":1}}],[\"编码效率低\",{\"1\":{\"238\":1}}],[\"编码则是进行转换\",{\"1\":{\"238\":1}}],[\"编码是将数字信号转换为另一种形式\",{\"1\":{\"238\":1}}],[\"编码\",{\"0\":{\"238\":1},\"1\":{\"239\":1}}],[\"≥3\",{\"1\":{\"312\":1}}],[\"矩阵\",{\"1\":{\"312\":1}}],[\"连续空间存储\",{\"1\":{\"312\":1}}],[\"连接\",{\"1\":{\"755\":1}}],[\"连接计算机与网络介质\",{\"1\":{\"618\":1}}],[\"连接设备\",{\"1\":{\"618\":1}}],[\"连接管理\",{\"1\":{\"584\":1}}],[\"连接在一起\",{\"1\":{\"348\":1}}],[\"连接建立时\",{\"1\":{\"294\":1}}],[\"连接彻底关闭\",{\"1\":{\"286\":1}}],[\"连接限制\",{\"1\":{\"285\":1}}],[\"连接是逻辑连接\",{\"1\":{\"282\":1}}],[\"连接起来的最典型通信协议\",{\"1\":{\"189\":1}}],[\"连接到企业网络\",{\"1\":{\"223\":1}}],[\"连接到一个广域网或一个局域网上的主机在该网内进行通信时\",{\"1\":{\"162\":1}}],[\"连接到ftp服务器\",{\"1\":{\"86\":1}}],[\"连接方式\",{\"1\":{\"162\":1}}],[\"连接广域网各结点交换机的链路都是高速链路\",{\"1\":{\"161\":1}}],[\"连接释放\",{\"1\":{\"94\":1}}],[\"连接ftp服务器\",{\"1\":{\"83\":1}}],[\"连接成功界面\",{\"1\":{\"14\":1,\"40\":1}}],[\"堆空间各个区域的大小设置\",{\"1\":{\"768\":1}}],[\"堆内存文件作进一步分析\",{\"1\":{\"768\":1}}],[\"堆内存信息到文件\",{\"1\":{\"766\":1}}],[\"堆内存被划分为不同的区域\",{\"1\":{\"741\":1}}],[\"堆配置\",{\"1\":{\"764\":1}}],[\"堆栈跟踪\",{\"1\":{\"762\":1}}],[\"堆转储快照分析\",{\"1\":{\"762\":1}}],[\"堆和方法区的垃圾收集\",{\"1\":{\"738\":1}}],[\"堆划分为新生代\",{\"1\":{\"737\":1}}],[\"堆的垃圾收集\",{\"1\":{\"738\":1}}],[\"堆的内存分区了解吗\",{\"0\":{\"737\":1},\"1\":{\"737\":1}}],[\"堆的话看是直接指针还是句柄\",{\"1\":{\"724\":1}}],[\"堆会发生抢占吗\",{\"0\":{\"728\":1},\"1\":{\"728\":1}}],[\"堆中包含大量对象\",{\"1\":{\"744\":1}}],[\"堆中将可能会划分出一块内存来作为句柄池\",{\"1\":{\"730\":1}}],[\"堆中预先分配一小块内存\",{\"1\":{\"728\":1}}],[\"堆中的内存并不是规整的\",{\"1\":{\"727\":1}}],[\"堆中内存是绝对规整的\",{\"1\":{\"727\":1}}],[\"堆主要用来存放对象的\",{\"1\":{\"724\":1}}],[\"堆可以划分为新生代\",{\"1\":{\"722\":1}}],[\"堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的\",{\"1\":{\"727\":1}}],[\"堆是否规整决定\",{\"1\":{\"727\":1}}],[\"堆是垃圾收集器管理的内存区域\",{\"1\":{\"722\":1}}],[\"堆是虚拟机所管理的内存中最大的一块\",{\"1\":{\"722\":1}}],[\"堆\",{\"1\":{\"311\":1,\"312\":2,\"722\":2,\"724\":1,\"754\":1,\"773\":2}}],[\"树化发生在table数组的长度大于64\",{\"1\":{\"697\":1}}],[\"树\",{\"1\":{\"311\":1,\"312\":2}}],[\"队列为空\",{\"1\":{\"867\":1}}],[\"队列的\",{\"1\":{\"846\":1}}],[\"队列中\",{\"1\":{\"846\":1}}],[\"队列锁\",{\"1\":{\"846\":1}}],[\"队列等\",{\"1\":{\"797\":1}}],[\"队列请求\",{\"1\":{\"386\":2}}],[\"队列\",{\"1\":{\"311\":1,\"312\":2,\"670\":1,\"839\":1,\"846\":2}}],[\"栈的局部变量表中\",{\"1\":{\"773\":1}}],[\"栈的访问速度比堆快\",{\"1\":{\"724\":1}}],[\"栈中引用的对象\",{\"1\":{\"746\":1}}],[\"栈中的引用存储的直接就是对象地址\",{\"1\":{\"730\":1}}],[\"栈中的引用存储的就是对象的句柄地址\",{\"1\":{\"730\":1}}],[\"栈中的引用\",{\"1\":{\"730\":1}}],[\"栈主要是用来执行程序的\",{\"1\":{\"724\":1}}],[\"栈和堆有什么区别\",{\"0\":{\"724\":1},\"1\":{\"724\":1}}],[\"栈帧中的本地变量表\",{\"1\":{\"734\":1}}],[\"栈帧主要就用于记录方法执行过程中相关的数据\",{\"1\":{\"722\":1}}],[\"栈帧空间会被释放\",{\"1\":{\"317\":1}}],[\"栈帧空间\",{\"1\":{\"317\":1}}],[\"栈又是由一个个栈帧组成\",{\"1\":{\"722\":1}}],[\"栈\",{\"1\":{\"311\":1,\"312\":2,\"722\":1,\"724\":1,\"797\":1}}],[\"线上服务\",{\"0\":{\"765\":1},\"1\":{\"765\":1}}],[\"线行探查法\",{\"1\":{\"692\":1}}],[\"线\",{\"1\":{\"502\":9}}],[\"线程数适当大一点\",{\"1\":{\"866\":1}}],[\"线程用完\",{\"1\":{\"857\":1}}],[\"线程已获得的资源在未使用完之前不能被其他线程强行剥夺\",{\"1\":{\"848\":1}}],[\"线程死锁描述的是这样一种情况\",{\"1\":{\"848\":1}}],[\"线程持有读锁还能获取写锁吗\",{\"1\":{\"842\":1}}],[\"线程持有的锁\",{\"1\":{\"729\":1}}],[\"线程获取不到锁时\",{\"1\":{\"839\":1}}],[\"线程解锁前\",{\"1\":{\"836\":1}}],[\"线程加锁后\",{\"1\":{\"836\":1}}],[\"线程加锁前\",{\"1\":{\"836\":1}}],[\"线程对该变量的修改会立即刷新到主内存中\",{\"1\":{\"834\":1}}],[\"线程会自动苏醒\",{\"1\":{\"812\":1}}],[\"线程thread除了提供join\",{\"1\":{\"811\":1}}],[\"线程可以使用操作系统提供的\",{\"1\":{\"811\":1}}],[\"线程间有哪些通信方式\",{\"1\":{\"811\":1}}],[\"线程间通信方式\",{\"0\":{\"811\":1}}],[\"线程在java中属于稀缺资源\",{\"1\":{\"866\":1}}],[\"线程在写入变量时不会把值缓存在寄存器或者其他地方\",{\"1\":{\"827\":1}}],[\"线程在\",{\"1\":{\"816\":1}}],[\"线程在时间片内占用\",{\"1\":{\"809\":1}}],[\"线程在自身的生命周期中\",{\"1\":{\"808\":1}}],[\"线程上下文切换和线程并发工作的原理有关\",{\"1\":{\"809\":1}}],[\"线程上下文切换\",{\"0\":{\"809\":1}}],[\"线程被创建\",{\"1\":{\"808\":1}}],[\"线程共有六种状态\",{\"1\":{\"808\":1}}],[\"线程共享区\",{\"1\":{\"722\":1}}],[\"线程b读取x的时候\",{\"1\":{\"827\":1}}],[\"线程b可以调用线程interrupt\",{\"1\":{\"807\":1}}],[\"线程b对集合对象的内容进行了修改\",{\"1\":{\"709\":1}}],[\"线程中断\",{\"1\":{\"807\":1}}],[\"线程休眠\",{\"1\":{\"807\":1}}],[\"线程a修改x=1\",{\"1\":{\"827\":1}}],[\"线程a实际并没有被中断\",{\"1\":{\"807\":1}}],[\"线程a会暂时让出指定时间的执行权\",{\"1\":{\"807\":1}}],[\"线程a会被阻塞挂起\",{\"1\":{\"807\":1}}],[\"线程a抛出interruptedexception异常返回\",{\"1\":{\"807\":1}}],[\"线程a调用了共享对象\",{\"1\":{\"807\":1}}],[\"线程有几种状态\",{\"0\":{\"808\":1},\"1\":{\"808\":1}}],[\"线程有几种创建方式\",{\"0\":{\"806\":1}}],[\"线程有哪些常用的调度方法\",{\"0\":{\"807\":1},\"1\":{\"807\":1}}],[\"线程工厂\",{\"1\":{\"806\":1}}],[\"线程池提供了几个\",{\"1\":{\"869\":1}}],[\"线程池提交execute和submit有什么区别\",{\"0\":{\"863\":1},\"1\":{\"863\":1}}],[\"线程池如何实现参数的动态修改\",{\"0\":{\"869\":1},\"1\":{\"869\":1}}],[\"线程池会判断\",{\"1\":{\"868\":1}}],[\"线程池会做如下判断\",{\"1\":{\"868\":1}}],[\"线程池会返回一个future类型的对象\",{\"1\":{\"863\":1}}],[\"线程池也不会马上执行它们\",{\"1\":{\"868\":1}}],[\"线程池也经常用于执行定时任务或周期性任务\",{\"1\":{\"858\":1}}],[\"线程池刚创建时\",{\"1\":{\"868\":1}}],[\"线程池工作流程\",{\"0\":{\"868\":1}}],[\"线程池中要有n个工作线程\",{\"1\":{\"870\":1}}],[\"线程池中执行的任务为空\",{\"1\":{\"867\":1}}],[\"线程池中非核心线程保持存活的时间的单位\",{\"1\":{\"860\":1}}],[\"线程池各个状态切换图\",{\"1\":{\"867\":1}}],[\"线程池状态\",{\"1\":{\"867\":1}}],[\"线程池不是越大越好也不是越小越好\",{\"1\":{\"866\":1}}],[\"线程池可能捕获它\",{\"1\":{\"865\":1}}],[\"线程池可以用于管理数据库连接\",{\"1\":{\"858\":1}}],[\"线程池可以用于管理和执行大量的并行任务\",{\"1\":{\"858\":1}}],[\"线程池可以有效地管理线程资源\",{\"1\":{\"858\":1}}],[\"线程池异常怎么处理\",{\"0\":{\"865\":1},\"1\":{\"865\":1}}],[\"线程池怎么关闭\",{\"0\":{\"864\":1},\"1\":{\"864\":1}}],[\"线程池有这几个状态\",{\"1\":{\"867\":1}}],[\"线程池有几种状态\",{\"0\":{\"867\":1},\"1\":{\"867\":1}}],[\"线程池有哪几种工作队列\",{\"0\":{\"862\":1},\"1\":{\"862\":1}}],[\"线程池有七大参数\",{\"1\":{\"860\":1}}],[\"线程池等待队列\",{\"1\":{\"860\":1}}],[\"线程池的工作原理\",{\"1\":{\"868\":1}}],[\"线程池的线程数配置应该看线程池的作用\",{\"1\":{\"866\":1}}],[\"线程池的线程数应该怎么配置\",{\"0\":{\"866\":1},\"1\":{\"866\":1}}],[\"线程池的拒绝策略有哪些\",{\"0\":{\"861\":1},\"1\":{\"861\":1}}],[\"线程池的参数有哪些\",{\"0\":{\"860\":1},\"1\":{\"860\":1}}],[\"线程池的应用范围广泛\",{\"1\":{\"858\":1}}],[\"线程池的应用有哪些\",{\"0\":{\"858\":1},\"1\":{\"858\":1}}],[\"线程池用于管理和处理客户端请求\",{\"1\":{\"858\":1}}],[\"线程池在许多应用场景中都有着广泛的应用\",{\"1\":{\"858\":1}}],[\"线程池是一种管理和复用线程的机制\",{\"1\":{\"858\":1}}],[\"线程池一般用于执行多个不相关联的耗时任务\",{\"1\":{\"857\":1}}],[\"线程池\",{\"0\":{\"856\":1},\"1\":{\"806\":1,\"857\":1}}],[\"线程是cpu分配的最小单位\",{\"1\":{\"805\":1}}],[\"线程是进程的一部分\",{\"1\":{\"804\":1}}],[\"线程之间的共享变量存储在主内存\",{\"1\":{\"824\":1}}],[\"线程之间共享进程的内存资源\",{\"1\":{\"804\":1}}],[\"线程之间互不干扰\",{\"1\":{\"421\":1}}],[\"线程和进程是紧密相关的\",{\"1\":{\"804\":1}}],[\"线程的挂起和唤醒\",{\"1\":{\"837\":1}}],[\"线程的理解\",{\"1\":{\"804\":1}}],[\"线程的信息\",{\"1\":{\"769\":1}}],[\"线程栈分析可使用\",{\"1\":{\"769\":1}}],[\"线程开始对未标记的区域做清扫\",{\"1\":{\"746\":1}}],[\"线程无法保证可达性分析的实时性\",{\"1\":{\"746\":1,\"750\":1}}],[\"线程私有区\",{\"1\":{\"722\":1}}],[\"线程私有区和线程共享区\",{\"1\":{\"722\":1}}],[\"线程\",{\"0\":{\"804\":1},\"1\":{\"707\":6,\"721\":1,\"763\":1,\"804\":1,\"810\":2,\"816\":2,\"848\":1}}],[\"线程安全可以表现为以下几个方面\",{\"1\":{\"814\":1}}],[\"线程安全指的是在多线程环境下\",{\"1\":{\"814\":1}}],[\"线程安全\",{\"0\":{\"814\":1},\"1\":{\"844\":1}}],[\"线程安全实现方式\",{\"1\":{\"711\":1}}],[\"线程安全性\",{\"1\":{\"706\":1,\"715\":1}}],[\"线程安全的问题\",{\"1\":{\"690\":1}}],[\"线程级别的单例\",{\"1\":{\"421\":1}}],[\"线性对数阶常出现于嵌套循环中\",{\"1\":{\"316\":1}}],[\"线性阶通常出现在单层循环中\",{\"1\":{\"316\":1}}],[\"线性阶的操作数量相对于输入数据大小\",{\"1\":{\"316\":1}}],[\"线性阶表示\",{\"1\":{\"316\":1}}],[\"线性阶时间复杂度\",{\"1\":{\"316\":1}}],[\"线性阶\",{\"1\":{\"316\":3}}],[\"线性数据结构\",{\"1\":{\"311\":1}}],[\"线性与非线性\",{\"0\":{\"311\":1}}],[\"线路利用率高\",{\"1\":{\"254\":1}}],[\"线路独占\",{\"1\":{\"253\":1}}],[\"伪首部模仿的是ip数据报的首部\",{\"1\":{\"304\":1}}],[\"伪首部是用于计算udp校验和的一个辅助数据结构\",{\"1\":{\"304\":1}}],[\"伪首部\",{\"0\":{\"304\":1},\"1\":{\"304\":1}}],[\"必要\",{\"1\":{\"302\":1}}],[\"必须把共享变量的最新值刷新到主内存中\",{\"1\":{\"836\":1}}],[\"必须处理\",{\"1\":{\"793\":1}}],[\"必须同时重写\",{\"1\":{\"788\":1}}],[\"必须到下一次垃圾收集才能处理\",{\"1\":{\"751\":1}}],[\"必须暂停所有的用户线程\",{\"1\":{\"747\":1}}],[\"必须使用统一的方法对tcp\",{\"1\":{\"279\":1}}],[\"必须先调用hasnext\",{\"1\":{\"367\":1}}],[\"必须先拨号请求建立连接\",{\"1\":{\"253\":1}}],[\"必须先建立好双方通信连接\",{\"1\":{\"125\":1}}],[\"必须在一个微波通信信道的两个终端之间建立若干个中继站\",{\"1\":{\"230\":1}}],[\"必须要求对方确认后才进行\",{\"1\":{\"125\":1}}],[\"必须要全球唯一\",{\"1\":{\"69\":1}}],[\"必须填入\",{\"1\":{\"91\":1}}],[\"适配器将适配逻辑封装在一个单独的类中\",{\"1\":{\"512\":1}}],[\"适配器将结果转换为客户端所期望的格式\",{\"1\":{\"509\":1}}],[\"适配器可以包装现有的类或接口\",{\"1\":{\"512\":1}}],[\"适配器可以重复使用\",{\"1\":{\"512\":1}}],[\"适配器可以帮助将其接口转换为符合项目需求的接口\",{\"1\":{\"510\":1}}],[\"适配器允许不兼容的接口或类之间进行协同工作\",{\"1\":{\"512\":1}}],[\"适配器通过包装或转换一个类\",{\"1\":{\"512\":1}}],[\"适配器充当两个不兼容实体之间的桥梁\",{\"1\":{\"512\":1}}],[\"适配器定义行为\",{\"1\":{\"511\":1}}],[\"适配器类\",{\"1\":{\"510\":1}}],[\"适配器接收客户端的请求\",{\"1\":{\"509\":1}}],[\"适配器是将原本不兼容的接口转换成目标接口的类\",{\"1\":{\"508\":1}}],[\"适配器\",{\"1\":{\"508\":1,\"511\":1}}],[\"适配器设计模式提供了一种解决接口不匹配问题的灵活而可扩展的方式\",{\"1\":{\"512\":1}}],[\"适配器设计模式适用于以下情况\",{\"1\":{\"512\":1}}],[\"适配器设计模式的优点包括\",{\"1\":{\"512\":1}}],[\"适配器设计模式它允许不兼容的接口或类之间进行协同工作\",{\"1\":{\"512\":1}}],[\"适配器设计模式可以帮助我们平滑过渡并确保系统的兼容性\",{\"1\":{\"510\":1}}],[\"适配器设计模式允许不兼容的接口之间进行协同工作\",{\"1\":{\"510\":1}}],[\"适配器设计模式\",{\"0\":{\"507\":1},\"1\":{\"508\":1,\"520\":1}}],[\"适配器模式可以用于平滑迁移旧的接口到新的接口\",{\"1\":{\"510\":1}}],[\"适配器模式在软件开发中经常用于以下场景\",{\"1\":{\"510\":1}}],[\"适配器模式的工作原理如下\",{\"1\":{\"509\":1}}],[\"适配器模式涉及三个主要角色\",{\"1\":{\"508\":1}}],[\"适配器模式\",{\"1\":{\"490\":1}}],[\"适合什么场景\",{\"1\":{\"842\":1}}],[\"适合很多实时应用\",{\"1\":{\"301\":1}}],[\"适合一次性传输少量数据的网络应用\",{\"1\":{\"301\":1}}],[\"适用范围\",{\"1\":{\"834\":1}}],[\"适用范围不同\",{\"1\":{\"780\":1}}],[\"适用范围广\",{\"1\":{\"253\":1}}],[\"适用场景\",{\"1\":{\"411\":2}}],[\"适用效率低\",{\"1\":{\"253\":1}}],[\"适用于临界区代码的同步\",{\"1\":{\"834\":1}}],[\"适用于单\",{\"1\":{\"764\":1}}],[\"适用于需要按键排序的情况\",{\"1\":{\"705\":1}}],[\"适用于需要快速查找\",{\"1\":{\"705\":1}}],[\"适用于需要存储唯一元素集合且不需要键值对映射关系的情况\",{\"1\":{\"704\":1}}],[\"适用于需要撤销和恢复操作的场景\",{\"1\":{\"379\":1}}],[\"适用于不同的接口和被代理类\",{\"1\":{\"496\":1}}],[\"适用于传输模拟信号\",{\"1\":{\"253\":1}}],[\"适用于大型网络\",{\"1\":{\"206\":1}}],[\"适用于负荷稳定\",{\"1\":{\"205\":1}}],[\"适用于具有一定信道质量的网络环境\",{\"1\":{\"139\":1}}],[\"适用于具有较高信道质量的网络环境\",{\"1\":{\"138\":1}}],[\"适用于许多实时性要求不高\",{\"1\":{\"138\":1}}],[\"慢开始和拥塞避免\",{\"0\":{\"298\":1},\"1\":{\"298\":1}}],[\"慢开始\",{\"1\":{\"297\":1,\"298\":1}}],[\"慢开始门限ssthresh是tcp拥塞控制算法中的一个阈值\",{\"1\":{\"297\":1}}],[\"应避免过度设计和复杂化\",{\"1\":{\"480\":1}}],[\"应该避免过度使用反射\",{\"1\":{\"799\":1}}],[\"应该使用\",{\"1\":{\"789\":1}}],[\"应该使用迭代器的remove\",{\"1\":{\"367\":1}}],[\"应该通过抽象来定义模块之间的关系\",{\"1\":{\"476\":1}}],[\"应该将其拆分成更小\",{\"1\":{\"472\":1}}],[\"应该将它拆分成多个功能更加单一\",{\"1\":{\"462\":1}}],[\"应该对扩展开放\",{\"1\":{\"466\":1}}],[\"应该在已有代码基础上扩展代码\",{\"1\":{\"464\":1}}],[\"应该根据具体情况权衡利弊\",{\"1\":{\"373\":1}}],[\"应根据实际情况仔细设计状态之间的转换逻辑\",{\"1\":{\"361\":1}}],[\"应答大小2\",{\"1\":{\"298\":1}}],[\"应答报文\",{\"1\":{\"297\":1}}],[\"应用实现\",{\"1\":{\"825\":3}}],[\"应用需要依赖\",{\"1\":{\"760\":2}}],[\"应用的类都是由它来完成加载的\",{\"1\":{\"756\":1}}],[\"应用的类路径\",{\"1\":{\"756\":1}}],[\"应用更容易遇到内存溢出的问题\",{\"1\":{\"725\":1}}],[\"应用插件声明\",{\"1\":{\"539\":1}}],[\"应用名\",{\"1\":{\"539\":1}}],[\"应用接口隔离原则可以带来以下好处\",{\"1\":{\"473\":1}}],[\"应用场景\",{\"1\":{\"455\":1}}],[\"应用场景不同\",{\"1\":{\"386\":1}}],[\"应用建议\",{\"1\":{\"373\":1}}],[\"应用程序偶尔会耗尽连接对象\",{\"1\":{\"769\":1}}],[\"应用程序抛出\",{\"1\":{\"769\":1}}],[\"应用程序长时间连续运行时性能严重下降\",{\"1\":{\"769\":1}}],[\"应用程序来说\",{\"1\":{\"722\":1}}],[\"应用程序启动时创建的线程\",{\"1\":{\"721\":1}}],[\"应用程序通过同步机制去控制\",{\"1\":{\"681\":1}}],[\"应用程序的主题\",{\"1\":{\"539\":1}}],[\"应用程序的主体部分\",{\"1\":{\"539\":1}}],[\"应用程序的名称\",{\"1\":{\"539\":1}}],[\"应用程序的图标\",{\"1\":{\"539\":1}}],[\"应用程序的版本名称\",{\"1\":{\"539\":1}}],[\"应用程序的版本代码\",{\"1\":{\"539\":1}}],[\"应用程序的唯一标识符\",{\"1\":{\"539\":1}}],[\"应用程序也不能创建自己的\",{\"1\":{\"419\":1}}],[\"应用程序都有一个\",{\"1\":{\"419\":1}}],[\"应用程序\",{\"1\":{\"279\":1}}],[\"应用协议\",{\"1\":{\"279\":1}}],[\"应用\",{\"1\":{\"121\":2,\"206\":2,\"240\":2,\"539\":1}}],[\"应用进程交换的报文类型\",{\"1\":{\"56\":1}}],[\"应用层常用端口有哪些\",{\"0\":{\"570\":1}}],[\"应用层给udp多长的报文\",{\"1\":{\"301\":1}}],[\"应用层所有的应用进程都可以通过传输层再传输到网络层\",{\"1\":{\"280\":1}}],[\"应用层对http请求报文进行解析\",{\"1\":{\"268\":1}}],[\"应用层将http请求报文交付给运输层处理\",{\"1\":{\"268\":1}}],[\"应用层按照http协议的规定构建一个http请求报文\",{\"1\":{\"268\":1}}],[\"应用层直接使用网际层icmp\",{\"1\":{\"200\":1}}],[\"应用层直接使用网际层的icmp\",{\"1\":{\"200\":1}}],[\"应用层协议定义了什么\",{\"1\":{\"56\":1}}],[\"应用层协议定义了应用程序之间的通信规则和数据交换的格式\",{\"1\":{\"56\":2}}],[\"应用层是网络中最直接面向用户的层次\",{\"1\":{\"56\":1}}],[\"应用层的主要功能是什么\",{\"0\":{\"547\":1}}],[\"应用层的主要任务是什么\",{\"1\":{\"56\":1}}],[\"应用层的任务是为用户提供所需的服务\",{\"1\":{\"56\":1}}],[\"应用层位于最顶层\",{\"1\":{\"54\":1}}],[\"应用层\",{\"0\":{\"54\":1},\"1\":{\"268\":1}}],[\"应用设置\",{\"0\":{\"4\":1,\"30\":1}}],[\"变体的虚拟双向队列\",{\"1\":{\"846\":1}}],[\"变了我就不改了\",{\"1\":{\"845\":1}}],[\"变化的放在子类实现\",{\"1\":{\"330\":1}}],[\"变化的规则\",{\"1\":{\"297\":1}}],[\"变量来表示资源的占用情况\",{\"1\":{\"839\":1}}],[\"变量的读取和写入具有可见性\",{\"1\":{\"834\":1}}],[\"变量的读操作\",{\"1\":{\"828\":1}}],[\"变量的写操作会立即刷新到主内存\",{\"1\":{\"834\":1}}],[\"变量的写操作\",{\"1\":{\"828\":1}}],[\"变量进行写操作时\",{\"1\":{\"828\":1}}],[\"变量和变量\",{\"1\":{\"792\":1}}],[\"变量\",{\"1\":{\"317\":1,\"709\":1,\"827\":1}}],[\"变长子网掩码\",{\"1\":{\"222\":1}}],[\"新任务会追加到workqueue中\",{\"1\":{\"860\":1}}],[\"新版的\",{\"1\":{\"789\":1}}],[\"新创建的对象首先被分配到eden空间\",{\"1\":{\"741\":1}}],[\"新创建的对象优先在新生代\",{\"1\":{\"739\":1}}],[\"新生代和老年代分别采用了哪些垃圾收集器\",{\"1\":{\"768\":1}}],[\"新生代和老年代的大小\",{\"1\":{\"768\":1}}],[\"新生代和老年代的区域也是在动态变化的\",{\"1\":{\"749\":1}}],[\"新生代在做垃圾回收的时候\",{\"1\":{\"749\":1}}],[\"新生代垃圾收集主要采用这种算法\",{\"1\":{\"744\":1}}],[\"新生代仍然有大量对象存活\",{\"1\":{\"740\":1}}],[\"新生代的region占比到达60\",{\"1\":{\"750\":1}}],[\"新生代的\",{\"1\":{\"739\":1}}],[\"新生代历次young\",{\"1\":{\"739\":1}}],[\"新生代收集\",{\"1\":{\"738\":1}}],[\"新生代存放存活时间短的对象\",{\"1\":{\"737\":1}}],[\"新生代\",{\"1\":{\"737\":1,\"750\":3}}],[\"新订单和原始订单是相互独立的对象\",{\"1\":{\"455\":1}}],[\"新的任务会被添加到workqueue中\",{\"1\":{\"860\":1}}],[\"新的位置不变或索引\",{\"1\":{\"701\":1}}],[\"新的支付接口实现\",{\"1\":{\"510\":1}}],[\"新的支付接口\",{\"1\":{\"510\":1}}],[\"新的促销活动\",{\"1\":{\"455\":1}}],[\"新的版本也可以很方便地添加到现有系统中\",{\"1\":{\"346\":1}}],[\"新增对象\",{\"1\":{\"750\":1}}],[\"新增容量大小\",{\"1\":{\"701\":1}}],[\"新增模块\",{\"1\":{\"464\":1}}],[\"新增产品需要修改工厂类的代码\",{\"1\":{\"430\":1}}],[\"新增状态时只需添加新的状态类\",{\"1\":{\"361\":1}}],[\"新到达的数据包可能会被丢弃\",{\"1\":{\"296\":1}}],[\"新路由劣势\",{\"1\":{\"208\":1}}],[\"新路由优势\",{\"1\":{\"208\":1}}],[\"缓冲区溢出\",{\"1\":{\"296\":1}}],[\"缓存一致性协议\",{\"1\":{\"828\":1}}],[\"缓存机制提高效率\",{\"1\":{\"583\":1}}],[\"缓存代理\",{\"1\":{\"495\":1,\"496\":1}}],[\"缓存代理当涉及到数据库查询时\",{\"1\":{\"495\":1}}],[\"缓存代理示例代码\",{\"1\":{\"495\":1}}],[\"缓存等方式\",{\"1\":{\"767\":1}}],[\"缓存等\",{\"1\":{\"495\":1,\"496\":1}}],[\"缓存中获取对应的具体工厂对象\",{\"1\":{\"436\":1}}],[\"缓存中进行查询\",{\"1\":{\"77\":1}}],[\"缓存处理等\",{\"1\":{\"352\":1}}],[\"缓存空间满了\",{\"1\":{\"142\":1,\"576\":1}}],[\"缓存服务器中进行查找\",{\"1\":{\"77\":1}}],[\"缓存\",{\"0\":{\"77\":1},\"1\":{\"76\":1,\"436\":1,\"495\":1}}],[\"缓存是否有该域名对应\",{\"1\":{\"75\":1}}],[\"于是\",{\"1\":{\"296\":1}}],[\"于是会导致更大的延迟以及更多的丢包\",{\"1\":{\"296\":1}}],[\"于是在osi\",{\"1\":{\"273\":1}}],[\"∞\",{\"1\":{\"296\":1}}],[\"讨论前提\",{\"1\":{\"296\":1}}],[\"零食吃完再吃主食\",{\"1\":{\"728\":1}}],[\"零窗口探测报文也有超时重传机制\",{\"1\":{\"294\":1}}],[\"零窗口探测报文可以避免连接在窗口为零的情况下被错误地认为是不活跃的\",{\"1\":{\"294\":1}}],[\"零窗口探测报文的出现是为了提升tcp通信的可靠性和效率\",{\"1\":{\"294\":1}}],[\"零窗口探测报文的出现是为了及时解决这种情况\",{\"1\":{\"294\":1}}],[\"零窗口探测报文的出现是为了解决tcp通信中可能出现的接收方窗口为零\",{\"1\":{\"294\":1}}],[\"零窗口探测报文允许发送方主动探测接收方窗口的变化\",{\"1\":{\"294\":1}}],[\"零窗口探测报文\",{\"1\":{\"294\":1}}],[\"零比特填充法\",{\"1\":{\"132\":1}}],[\"滑动窗口过大\",{\"1\":{\"294\":1}}],[\"滑动窗口过小\",{\"1\":{\"294\":1}}],[\"情况如下\",{\"1\":{\"710\":1}}],[\"情况\",{\"1\":{\"294\":1,\"764\":1}}],[\"死锁产生的四个条件\",{\"1\":{\"848\":1}}],[\"死锁问题\",{\"1\":{\"294\":1}}],[\"死锁\",{\"1\":{\"294\":1}}],[\"窗口大小可以实时调整\",{\"1\":{\"294\":1}}],[\"窗口的大小为n\",{\"1\":{\"138\":1,\"139\":1}}],[\"冗余确认\",{\"1\":{\"291\":1}}],[\"冗余ack\",{\"1\":{\"291\":4}}],[\"冗余码fcs\",{\"1\":{\"135\":2,\"576\":2}}],[\"累计确认\",{\"1\":{\"290\":1}}],[\"捎带确认\",{\"1\":{\"290\":1}}],[\"返回未执行的任务列表\",{\"1\":{\"864\":1}}],[\"返回的结果相同\",{\"1\":{\"794\":1}}],[\"返回的结果为\",{\"1\":{\"712\":1}}],[\"返回异常对象的本地化信息\",{\"1\":{\"794\":1}}],[\"返回异常发生时的详细信息\",{\"1\":{\"794\":1}}],[\"返回异常发生时的简要描述\",{\"1\":{\"794\":1}}],[\"返回类的名字实例的哈希码的\",{\"1\":{\"785\":1}}],[\"返回类型必须相同或是其子类\",{\"1\":{\"780\":1}}],[\"返回类型可以相同也可以不同\",{\"1\":{\"780\":1}}],[\"返回类型可以是子类的类型或者其子类型\",{\"1\":{\"780\":1}}],[\"返回类型\",{\"1\":{\"780\":1}}],[\"返回\",{\"1\":{\"672\":1,\"694\":1,\"788\":2,\"807\":1,\"811\":1}}],[\"返回方法的返回结果\",{\"1\":{\"497\":1,\"498\":1}}],[\"返回删除结果\",{\"1\":{\"497\":1,\"498\":1}}],[\"返回查询结果\",{\"1\":{\"495\":1,\"497\":1,\"498\":1}}],[\"返回相应类型的产品对象\",{\"1\":{\"430\":1}}],[\"返回到过去的状态\",{\"1\":{\"375\":1}}],[\"返回当前元素\",{\"1\":{\"366\":1}}],[\"返回一个迭代器对象\",{\"1\":{\"366\":1}}],[\"返回给1的确认\",{\"1\":{\"291\":4}}],[\"返回确认字段\",{\"1\":{\"290\":1}}],[\"返回应答代码250\",{\"1\":{\"94\":1}}],[\"校验数据帧是否有误\",{\"1\":{\"575\":1}}],[\"校验和等\",{\"1\":{\"573\":1,\"577\":1}}],[\"校验过程\",{\"0\":{\"305\":1},\"1\":{\"305\":1}}],[\"校验\",{\"0\":{\"288\":1}}],[\"序列为安全序列\",{\"1\":{\"848\":1}}],[\"序列化方式\",{\"1\":{\"455\":1}}],[\"序列化和反序列化\",{\"1\":{\"455\":1,\"757\":1}}],[\"序列号\",{\"1\":{\"287\":1}}],[\"序号\",{\"0\":{\"289\":1}}],[\"序号和确认保证了数据的有序传输\",{\"1\":{\"282\":1}}],[\"半关闭状态\",{\"1\":{\"286\":1}}],[\"半双工和全双工是两种不同的通信模式\",{\"1\":{\"582\":1}}],[\"半双工通信只能单向进行数据传输\",{\"1\":{\"582\":1}}],[\"半双工通信\",{\"1\":{\"237\":1,\"582\":1}}],[\"半双工\",{\"1\":{\"237\":1}}],[\"识别和阻止大量伪造的连接请求\",{\"1\":{\"285\":1}}],[\"消耗cpu和内存\",{\"1\":{\"285\":1}}],[\"消息队列\",{\"1\":{\"327\":1,\"811\":1}}],[\"消息总线会将消息传递给对应的订阅者\",{\"1\":{\"326\":1}}],[\"消息\",{\"1\":{\"238\":1}}],[\"针对大对象或者长生命周期对象导致的\",{\"1\":{\"768\":1}}],[\"针对新手代和老年代mixed\",{\"1\":{\"745\":1}}],[\"针对的老年代进行old\",{\"1\":{\"745\":1}}],[\"针对的新生代进行young\",{\"1\":{\"745\":1}}],[\"针对tcp协议中的三次握手过程\",{\"1\":{\"285\":1}}],[\"针对特定组的设备的一对多通信方式\",{\"1\":{\"166\":1}}],[\"已被使用的内存和空闲的内存相互交错在一起\",{\"1\":{\"727\":1}}],[\"已经有了\",{\"1\":{\"820\":1}}],[\"已经有键值对数据\",{\"1\":{\"702\":3}}],[\"已经被淘汰\",{\"1\":{\"706\":1}}],[\"已知键\",{\"1\":{\"685\":1}}],[\"已成为主流的以太网技术\",{\"1\":{\"578\":1}}],[\"已收到\",{\"1\":{\"403\":3}}],[\"已从购物车移除\",{\"1\":{\"384\":1}}],[\"已添加到购物车\",{\"1\":{\"384\":1}}],[\"已发送但尚未收到确认的数据\",{\"1\":{\"282\":1}}],[\"已打标签的帧\",{\"1\":{\"159\":1}}],[\"套接字唯一标识了网络中的一个主机\",{\"1\":{\"279\":1}}],[\"套接字就是\",{\"1\":{\"279\":1}}],[\"套接字\",{\"1\":{\"279\":1}}],[\"短暂端口号\",{\"1\":{\"279\":1}}],[\"短连接\",{\"1\":{\"111\":1}}],[\"熟知端口号\",{\"1\":{\"279\":1}}],[\"寻址与端口号\",{\"0\":{\"279\":1}}],[\"寻找一个不同网络间能共同遵守的网络通信规范\",{\"1\":{\"184\":1,\"589\":1}}],[\"体现在两个终端系统的连接中时要经过一个或多个设备\",{\"1\":{\"275\":1}}],[\"体系结构的各层在整个过程中起到怎样的作用\",{\"1\":{\"268\":1}}],[\"体系结构如下\",{\"1\":{\"268\":1}}],[\"体系结构\",{\"0\":{\"268\":1},\"1\":{\"268\":1}}],[\"两次操作本来结果是2\",{\"1\":{\"829\":1}}],[\"两种浮点数类型的包装类\",{\"1\":{\"774\":1}}],[\"两种方式的选择由\",{\"1\":{\"727\":1}}],[\"两块内存分别采用不同的垃圾回收算法\",{\"1\":{\"743\":1}}],[\"两者性能就差不多了\",{\"1\":{\"843\":1}}],[\"两者都是\",{\"1\":{\"840\":1}}],[\"两者都是用于线程进行调度的方法\",{\"1\":{\"812\":1}}],[\"两者不要同时存在一段代码逻辑中\",{\"1\":{\"793\":1}}],[\"两者关系\",{\"1\":{\"731\":1}}],[\"两者在初始容量大小和每次扩充容量大小上没有本质的不同\",{\"1\":{\"715\":1}}],[\"两部分的耦合更小\",{\"1\":{\"327\":1}}],[\"两主机间可以进行多个应用通信\",{\"1\":{\"274\":1}}],[\"两个子类\",{\"1\":{\"838\":1}}],[\"两个操作之间存在happens\",{\"1\":{\"826\":1}}],[\"两个具备超时特性的方法\",{\"1\":{\"811\":1}}],[\"两个具体访问者类\",{\"1\":{\"372\":1}}],[\"两个对象具有相同的\",{\"1\":{\"787\":1}}],[\"两个对等实体间的逻辑通信使得本层能够向上一层提供服务\",{\"1\":{\"251\":1}}],[\"两个线程可以交换彼此的数据\",{\"1\":{\"854\":1}}],[\"两个线程都执行了\",{\"1\":{\"805\":1}}],[\"两个线程都在执行\",{\"1\":{\"805\":1}}],[\"两个线程\",{\"1\":{\"707\":1}}],[\"两个接口都是\",{\"1\":{\"674\":1}}],[\"两个方向的车辆可以同时行驶而不会相互干扰\",{\"1\":{\"582\":1}}],[\"两个方法\",{\"1\":{\"498\":1}}],[\"两个相邻节点的通过链路连接\",{\"1\":{\"121\":1}}],[\"既包含了用户管理逻辑\",{\"1\":{\"481\":1}}],[\"既可使用慢开始算法\",{\"1\":{\"299\":1}}],[\"既可以保证多个线程同时读的效率\",{\"1\":{\"842\":2}}],[\"既可以访问原始对象\",{\"1\":{\"500\":1}}],[\"既可以连接局域网\",{\"1\":{\"161\":1}}],[\"既可以属于一个vlan\",{\"1\":{\"159\":1}}],[\"既然发送方收到3个重复的确认\",{\"1\":{\"299\":1}}],[\"既然网络层已把源主机上发出的数据包传送给了目的主机\",{\"1\":{\"274\":1}}],[\"交付给数据链路层\",{\"1\":{\"268\":1}}],[\"交换者\",{\"1\":{\"854\":1}}],[\"交换式以太网通过交换机等设备提高了信道利用率和传输速率\",{\"1\":{\"578\":1}}],[\"交换\",{\"1\":{\"253\":1}}],[\"交换的是完整的路由表项\",{\"1\":{\"208\":1}}],[\"交换时延非常小\",{\"1\":{\"173\":1}}],[\"交换机更适用于局域网内部设备的连接和数据交换\",{\"1\":{\"580\":1}}],[\"交换机与路由器的区别又是什么\",{\"0\":{\"580\":1},\"1\":{\"580\":1}}],[\"交换机和集线器有哪些区别\",{\"0\":{\"580\":1},\"1\":{\"580\":1}}],[\"交换机或路由器\",{\"1\":{\"579\":1}}],[\"交换机等\",{\"1\":{\"574\":1}}],[\"交换机等网络设备的处理能力不足以处理大量的数据流时\",{\"1\":{\"296\":1}}],[\"交换机中的一个端口会被选为指定端口\",{\"1\":{\"175\":1}}],[\"交换机中除了转发表\",{\"1\":{\"159\":1,\"579\":1}}],[\"交换机的接口改接了另一台主机\",{\"1\":{\"174\":1}}],[\"交换机知道该数据属于哪个\",{\"1\":{\"579\":1}}],[\"交换机知道不应该转发该帧\",{\"1\":{\"174\":1}}],[\"交换机知道应当从哪个\",{\"1\":{\"174\":1}}],[\"交换机不知道应当从哪个端口转发帧\",{\"1\":{\"174\":1}}],[\"交换机每个接口是一个独立的碰撞域\",{\"1\":{\"173\":1}}],[\"交换机是一种负责转发信号的网络设备\",{\"1\":{\"173\":1}}],[\"交换机\",{\"0\":{\"172\":1},\"1\":{\"169\":1,\"580\":8,\"596\":1}}],[\"交换机会将vlan标签移除并将帧转发\",{\"1\":{\"159\":1}}],[\"交换机会根据该端口的pvid为该帧打上相应的vlan标签\",{\"1\":{\"159\":1}}],[\"交换机各端口的缺省vlan\",{\"1\":{\"159\":1}}],[\"交换机端口是vlan的另一种实现方式\",{\"1\":{\"159\":1}}],[\"转换为\",{\"1\":{\"765\":1,\"769\":1}}],[\"转换为本地机器代码\",{\"1\":{\"720\":1}}],[\"转换为对应的ip地址的分布式系统\",{\"1\":{\"67\":1}}],[\"转为time\",{\"1\":{\"286\":1}}],[\"转为last\",{\"1\":{\"286\":1}}],[\"转为fin\",{\"1\":{\"286\":1}}],[\"转发功能\",{\"1\":{\"274\":1}}],[\"转发\",{\"1\":{\"268\":2}}],[\"制定\",{\"1\":{\"268\":2}}],[\"制定和遵循物理层标准和协议\",{\"1\":{\"229\":1}}],[\"参考乐观锁的版本号\",{\"1\":{\"845\":1}}],[\"参考下列的因素试出来的\",{\"1\":{\"696\":1}}],[\"参考模型\",{\"1\":{\"268\":2}}],[\"参数错误比如方法入参类型错误\",{\"1\":{\"793\":1}}],[\"参数列表必须相同\",{\"1\":{\"780\":1}}],[\"参数类型\",{\"1\":{\"780\":1}}],[\"参数的个数\",{\"1\":{\"780\":1}}],[\"参数设置\",{\"1\":{\"768\":1}}],[\"参数设置是否合理\",{\"1\":{\"768\":1}}],[\"参数设置问题\",{\"1\":{\"768\":1}}],[\"参数\",{\"1\":{\"422\":2,\"724\":1,\"785\":1,\"839\":2}}],[\"参数问题\",{\"1\":{\"201\":1}}],[\"参与者对象\",{\"1\":{\"408\":1}}],[\"参与者接口\",{\"1\":{\"403\":1,\"408\":1}}],[\"参与一条tcp连接的两个进程中的任何一个都能终止该连接\",{\"1\":{\"286\":1}}],[\"丢弃阻塞队列里最老的任务\",{\"1\":{\"861\":1}}],[\"丢包和重传\",{\"1\":{\"296\":1}}],[\"丢包率\",{\"0\":{\"267\":1},\"1\":{\"267\":1}}],[\"丢失等\",{\"1\":{\"296\":1}}],[\"丢失\",{\"1\":{\"184\":2,\"254\":1}}],[\"往返时间\",{\"0\":{\"265\":1},\"1\":{\"265\":1}}],[\"甚至到\",{\"1\":{\"769\":1}}],[\"甚至比特\",{\"1\":{\"263\":1}}],[\"甚至更低\",{\"1\":{\"262\":1}}],[\"吞吐量通常要高于linkedblockingquene\",{\"1\":{\"862\":1}}],[\"吞吐量通常要高于arrayblockingquene\",{\"1\":{\"862\":1}}],[\"吞吐量还可以用每秒传送的字节数或帧数表示\",{\"1\":{\"262\":1}}],[\"吞吐量受网络的带宽或额定速率的限制\",{\"1\":{\"262\":1}}],[\"吞吐量被经常用于对现实世界中的网络的一种测量\",{\"1\":{\"262\":1}}],[\"吞吐量表示在单位时间内通过某个网络\",{\"1\":{\"262\":1}}],[\"吞吐量\",{\"0\":{\"262\":1},\"1\":{\"262\":1}}],[\"k\",{\"1\":{\"702\":3,\"703\":2,\"844\":1}}],[\"key设计成弱引用同样是为了防止内存泄漏\",{\"1\":{\"818\":1}}],[\"key通过hash定位到segment\",{\"1\":{\"711\":1}}],[\"keyset\",{\"1\":{\"702\":5,\"703\":2}}],[\"key的hashcode右移\",{\"1\":{\"694\":1}}],[\"key的hashcode和key的hashcode右移16位做异或运算\",{\"1\":{\"693\":1}}],[\"key\",{\"0\":{\"712\":1},\"1\":{\"671\":4,\"683\":3,\"686\":2,\"691\":1,\"693\":4,\"694\":2,\"695\":2,\"702\":7,\"703\":6,\"711\":1,\"712\":2,\"713\":3,\"818\":1,\"819\":1,\"844\":1}}],[\"keep\",{\"1\":{\"480\":1,\"482\":1}}],[\"keepalivetime\",{\"1\":{\"860\":1,\"868\":1}}],[\"keepalive\",{\"1\":{\"8\":1,\"34\":1,\"212\":1}}],[\"kotlin\",{\"1\":{\"537\":1}}],[\"knowledge\",{\"1\":{\"488\":1}}],[\"kiss原则是一种鼓励简洁和直观代码的设计原则\",{\"1\":{\"482\":1}}],[\"kiss原则建议在编写代码时避免过度设计和复杂化\",{\"1\":{\"482\":1}}],[\"kiss原则鼓励我们使用简单直接的方法来实现功能\",{\"1\":{\"480\":1}}],[\"kiss原则\",{\"0\":{\"479\":1},\"1\":{\"480\":1,\"482\":1}}],[\"kpop\",{\"1\":{\"454\":1}}],[\"kb\",{\"1\":{\"261\":1}}],[\"khz\",{\"1\":{\"261\":1}}],[\"越宽\",{\"1\":{\"261\":1}}],[\"大部分都在用cpu跟内存\",{\"1\":{\"866\":1}}],[\"大部分公司都会有\",{\"1\":{\"768\":1}}],[\"大约\",{\"1\":{\"752\":1}}],[\"大对象\",{\"1\":{\"768\":1}}],[\"大对象的最具回收价值\",{\"1\":{\"750\":1}}],[\"大对象直接进入老年代\",{\"1\":{\"740\":1}}],[\"大多数对象都是在这里被创建的\",{\"1\":{\"737\":1}}],[\"大量线程内存储了threadlocal对象\",{\"1\":{\"818\":1}}],[\"大量常量池\",{\"1\":{\"731\":1}}],[\"大量动态生成类\",{\"1\":{\"731\":1}}],[\"大量广播消息可能导致网络拥塞\",{\"1\":{\"159\":1}}],[\"大小\",{\"1\":{\"723\":2}}],[\"大小为100mb\",{\"1\":{\"260\":1}}],[\"大于\",{\"1\":{\"394\":1,\"839\":1}}],[\"大o记号big\",{\"1\":{\"316\":1}}],[\"性能开销\",{\"1\":{\"758\":1,\"834\":1}}],[\"性能方面的考量\",{\"1\":{\"715\":1}}],[\"性能\",{\"1\":{\"706\":1,\"843\":1}}],[\"性能和适用场景等方面存在明显差异\",{\"1\":{\"705\":1}}],[\"性能和用途\",{\"1\":{\"705\":1}}],[\"性能和速度\",{\"1\":{\"580\":1}}],[\"性能较高\",{\"1\":{\"682\":1}}],[\"性能监控工具\",{\"1\":{\"762\":1}}],[\"性能监控\",{\"1\":{\"495\":1}}],[\"性能指标\",{\"0\":{\"259\":1}}],[\"性能更好\",{\"1\":{\"171\":1}}],[\"集\",{\"1\":{\"670\":1}}],[\"集合中的一种内部结构\",{\"1\":{\"710\":1}}],[\"集合框架中的一种异常\",{\"1\":{\"710\":1}}],[\"集合在被遍历期间如果内容发生变化\",{\"1\":{\"709\":1}}],[\"集合工具的内部类\",{\"1\":{\"708\":1}}],[\"集合运算等\",{\"1\":{\"704\":1}}],[\"集合种类多样\",{\"1\":{\"673\":1}}],[\"集合封装了一些了对数据操作的常用方法\",{\"1\":{\"673\":1}}],[\"集合更灵活\",{\"1\":{\"673\":1}}],[\"集合底层是基于obejct动态数组实现\",{\"1\":{\"673\":1}}],[\"集合相关类和接口都在java\",{\"1\":{\"670\":1}}],[\"集合等\",{\"1\":{\"363\":1}}],[\"集合\",{\"1\":{\"257\":1}}],[\"集线器的使用逐渐减少\",{\"1\":{\"618\":1}}],[\"集线器在现代网络中已经很少使用\",{\"1\":{\"580\":1}}],[\"集线器上各端口都是共享同一条背板总线的\",{\"1\":{\"171\":1}}],[\"集线器是半双工模式\",{\"1\":{\"170\":1}}],[\"集线器可以检测到这个问题\",{\"1\":{\"170\":1}}],[\"集线器一般都有少量的容错能力和网络管理功能\",{\"1\":{\"170\":1}}],[\"集线器只工作在物理层\",{\"1\":{\"170\":1}}],[\"集线器hub的主要功能是对接收到的信号进行再生整形放大\",{\"1\":{\"170\":1}}],[\"集线器\",{\"0\":{\"170\":1},\"1\":{\"169\":1,\"240\":1,\"580\":3,\"618\":1}}],[\"他会记录下线程获取锁的次数\",{\"1\":{\"836\":1}}],[\"他本质也就是一个java对象\",{\"1\":{\"817\":1}}],[\"他一个人就能负责新生代和老年代的垃圾回收\",{\"1\":{\"749\":1}}],[\"他也存在一些问题\",{\"1\":{\"690\":1}}],[\"他的最优时间复杂度可以达到o\",{\"1\":{\"690\":1}}],[\"他们同时都想申请对方的资源\",{\"1\":{\"848\":1}}],[\"他们使用自己独有的钥匙\",{\"1\":{\"816\":1}}],[\"他们之间的关系就类比与宅子\",{\"1\":{\"804\":1}}],[\"他们id全是1\",{\"1\":{\"787\":1}}],[\"他们合作编写了一本具有里程碑意义的著作\",{\"1\":{\"490\":1}}],[\"他们的前缀前两个字节和第三个字节的前6位相同\",{\"1\":{\"221\":1}}],[\"他都有自己的设计方案和设计理念\",{\"1\":{\"458\":1}}],[\"他有自己的硬件和软件\",{\"1\":{\"257\":1}}],[\"难以维护和扩展\",{\"1\":{\"465\":1}}],[\"难以规格化\",{\"1\":{\"253\":1}}],[\"难以管理和维护\",{\"1\":{\"159\":1}}],[\"归\",{\"1\":{\"835\":1}}],[\"归还通信资源\",{\"1\":{\"253\":1}}],[\"归零\",{\"1\":{\"238\":3}}],[\"归零编码中的大部分数据带宽都用来传输\",{\"1\":{\"238\":1}}],[\"归零编码把时钟信号用\",{\"1\":{\"238\":1}}],[\"归零编码\",{\"1\":{\"238\":2}}],[\"运算时发生了什么\",{\"1\":{\"792\":2}}],[\"运算要快\",{\"1\":{\"694\":1}}],[\"运算\",{\"1\":{\"688\":1,\"819\":1}}],[\"运输层常用端口有哪些\",{\"0\":{\"666\":1}}],[\"运输层将tcp报文段的首部去掉后成为http请求报文\",{\"1\":{\"268\":1}}],[\"运输层将tcp报文段交付给网络层处理\",{\"1\":{\"268\":1}}],[\"运输层给http请求报文添加一个tcp首部\",{\"1\":{\"268\":1}}],[\"运输层\",{\"1\":{\"268\":1}}],[\"运输层的服务访问点为\",{\"1\":{\"251\":1}}],[\"运行状态\",{\"1\":{\"808\":1}}],[\"运行代码时间\",{\"1\":{\"745\":2}}],[\"运行时异常\",{\"1\":{\"793\":1}}],[\"运行时行为\",{\"1\":{\"780\":1}}],[\"运行时常量池都移动到元空间\",{\"1\":{\"723\":1}}],[\"运行时常量池仍然位于永久代\",{\"1\":{\"723\":1}}],[\"运行时常量池是类常量池的一部分\",{\"1\":{\"722\":1}}],[\"运行时常量池\",{\"1\":{\"722\":2}}],[\"运行时间\",{\"1\":{\"317\":1}}],[\"运行\",{\"1\":{\"719\":1,\"808\":1}}],[\"运行成功\",{\"1\":{\"538\":1}}],[\"运行输出\",{\"1\":{\"510\":1,\"518\":1}}],[\"运行上述客户端代码\",{\"1\":{\"403\":1}}],[\"运行这段代码将得到正确的输出\",{\"1\":{\"377\":1}}],[\"运行平台和计算操作类型都与算法运行时间的增长趋势无关\",{\"1\":{\"316\":1}}],[\"运行在计算机上的进程使用进程标识符pid来标志\",{\"1\":{\"279\":1}}],[\"运行客户指明文件的类型与格式\",{\"1\":{\"83\":1}}],[\"运行过程中如有选择\",{\"1\":{\"3\":1,\"29\":1}}],[\"运行下列命令\",{\"1\":{\"3\":1,\"29\":1}}],[\"透明\",{\"1\":{\"251\":1}}],[\"透明传输指的是数据链路层对于传输的数据是透明的\",{\"1\":{\"577\":1}}],[\"透明传输和可靠传输是什么\",{\"0\":{\"577\":1},\"1\":{\"577\":1}}],[\"透明传输\",{\"0\":{\"132\":1},\"1\":{\"158\":1,\"577\":1}}],[\"垂直的\",{\"1\":{\"251\":1}}],[\"水平的\",{\"1\":{\"251\":1}}],[\"水平分割\",{\"1\":{\"209\":1}}],[\"语言实现平台无关性的基石\",{\"1\":{\"719\":1}}],[\"语句的return代码\",{\"1\":{\"795\":1}}],[\"语句会被忽略\",{\"1\":{\"795\":1}}],[\"语句中都有\",{\"1\":{\"795\":1}}],[\"语句和\",{\"1\":{\"795\":1}}],[\"语句块来完成\",{\"1\":{\"843\":1}}],[\"语句块中的\",{\"1\":{\"795\":1}}],[\"语句块中使用\",{\"1\":{\"795\":1}}],[\"语句块将在方法返回之前被执行\",{\"1\":{\"795\":1}}],[\"语句时\",{\"1\":{\"795\":2}}],[\"语句失败抛出\",{\"1\":{\"793\":1}}],[\"语句\",{\"1\":{\"346\":2,\"485\":1,\"807\":1,\"811\":1}}],[\"语义\",{\"1\":{\"250\":1}}],[\"语法\",{\"1\":{\"250\":1}}],[\"任意对象为值的存储结构\",{\"1\":{\"811\":1}}],[\"任何对\",{\"1\":{\"789\":1}}],[\"任何对引用类型的修改将会影响到两个对象\",{\"1\":{\"454\":1}}],[\"任何时刻计数器为零的对象就是不可能再被使用的\",{\"1\":{\"733\":1}}],[\"任何语言\",{\"1\":{\"719\":1}}],[\"任何一个方法的调用也是请求\",{\"1\":{\"348\":1}}],[\"任何可发送或接收信息的硬件或软件进程\",{\"1\":{\"250\":1}}],[\"任何机构和个人只要向isp交纳规定的费用\",{\"1\":{\"249\":1}}],[\"任务编号\",{\"1\":{\"870\":1}}],[\"任务队列是作为参数传进来的\",{\"1\":{\"868\":1}}],[\"任务分为计算密集型\",{\"1\":{\"866\":1}}],[\"任务代码可能抛出runtimeexception\",{\"1\":{\"865\":1}}],[\"任务顺序执行\",{\"1\":{\"857\":1}}],[\"任务调度系统\",{\"1\":{\"355\":1}}],[\"任务难度等可能会有所不同\",{\"1\":{\"333\":1}}],[\"任务目标\",{\"1\":{\"333\":1}}],[\"任务\",{\"0\":{\"229\":1}}],[\"名词称为\",{\"1\":{\"313\":1}}],[\"名词解析\",{\"0\":{\"244\":1}}],[\"名词拓展\",{\"1\":{\"152\":1}}],[\"计数\",{\"1\":{\"836\":1}}],[\"计数器就会\",{\"1\":{\"836\":1}}],[\"计数器\",{\"1\":{\"835\":1}}],[\"计数器值就减一\",{\"1\":{\"733\":1}}],[\"计数器值就加一\",{\"1\":{\"733\":1}}],[\"计数简化技巧\",{\"1\":{\"316\":1}}],[\"计网前置知识扫盲\",{\"1\":{\"243\":1}}],[\"计算密集型一般推荐线程池不要过大\",{\"1\":{\"866\":1}}],[\"计算密集型\",{\"1\":{\"866\":1}}],[\"计算各个region区域的回收价值\",{\"1\":{\"750\":1}}],[\"计算hash\",{\"1\":{\"711\":1}}],[\"计算数组下标\",{\"1\":{\"700\":1}}],[\"计算过程是向右移位1\",{\"1\":{\"689\":1}}],[\"计算折扣后的金额\",{\"1\":{\"465\":2}}],[\"计算并输出结果\",{\"1\":{\"390\":1}}],[\"计算结果\",{\"1\":{\"343\":1,\"346\":1,\"390\":2}}],[\"计算操作数量统计\",{\"1\":{\"316\":1}}],[\"计算操作运行时间统计\",{\"1\":{\"316\":1}}],[\"计算信道传输的速率\",{\"1\":{\"240\":1}}],[\"计算机中数据量的单位\",{\"1\":{\"260\":1}}],[\"计算机中的网卡将比特1和0变换成相应电信号发送到网线\",{\"1\":{\"238\":1}}],[\"计算机网络传输层\",{\"0\":{\"634\":1}}],[\"计算机网络场景题\",{\"0\":{\"625\":1}}],[\"计算机网络物理层\",{\"0\":{\"616\":1}}],[\"计算机网络网络层\",{\"0\":{\"586\":1}}],[\"计算机网络数据链路层\",{\"0\":{\"572\":1}}],[\"计算机网络应用层\",{\"0\":{\"546\":1}}],[\"计算机网络中有许多使用udp的应用服务\",{\"1\":{\"301\":1}}],[\"计算机网络都处在一个共享的环境\",{\"1\":{\"296\":1}}],[\"计算机网络采用分层结构的设计方式\",{\"1\":{\"268\":1}}],[\"计算机网络是由多个计算机\",{\"1\":{\"257\":1}}],[\"计算机网络是指通过通信设备和通信线路\",{\"1\":{\"257\":1}}],[\"计算机网络并非专门用来传送数据\",{\"1\":{\"257\":1}}],[\"计算机网络所连接的硬件\",{\"1\":{\"257\":1}}],[\"计算机网络主要是由一些通用的\",{\"1\":{\"257\":1}}],[\"计算机网络的分类\",{\"1\":{\"258\":1}}],[\"计算机网络的较好的定义是\",{\"1\":{\"257\":1}}],[\"计算机网络的最简单的定义是\",{\"1\":{\"257\":1}}],[\"计算机网络模型\",{\"1\":{\"243\":1}}],[\"计算机网络模型镇楼\",{\"1\":{\"243\":1}}],[\"计算机网络\",{\"0\":{\"256\":1},\"2\":{\"116\":1,\"177\":1,\"225\":1,\"242\":1,\"270\":1,\"307\":1}}],[\"计算机基础\",{\"2\":{\"115\":1,\"176\":1,\"224\":1,\"241\":1,\"269\":1,\"306\":1,\"318\":1,\"412\":1,\"456\":1,\"491\":1,\"534\":1}}],[\"换而言之\",{\"1\":{\"810\":1}}],[\"换行输出\",{\"1\":{\"769\":1}}],[\"换行标志\",{\"1\":{\"107\":2}}],[\"换一个\",{\"1\":{\"767\":1}}],[\"换种哈希函数\",{\"1\":{\"692\":1}}],[\"换个角度来讲就是\",{\"1\":{\"462\":1}}],[\"换句话说\",{\"1\":{\"240\":1}}],[\"术语\",{\"1\":{\"240\":1}}],[\"香农公式\",{\"1\":{\"240\":1,\"622\":1}}],[\"秒输出\",{\"1\":{\"769\":1}}],[\"秒以内\",{\"1\":{\"752\":1}}],[\"秒或更长的停顿时间\",{\"1\":{\"752\":1}}],[\"秒\",{\"1\":{\"240\":2}}],[\"噪声干扰和传输距离限制\",{\"1\":{\"619\":1}}],[\"噪声干扰\",{\"1\":{\"240\":1}}],[\"你呢\",{\"1\":{\"868\":1}}],[\"你加塞\",{\"1\":{\"861\":1}}],[\"你用你的\",{\"1\":{\"831\":1}}],[\"你通过这个三个方法也可以实现和volatile禁止重排序一样的效果\",{\"1\":{\"827\":1}}],[\"你实现了某个接口就具有了对应的行为\",{\"1\":{\"783\":1}}],[\"你了解哪些可视化的性能监控和故障处理工具\",{\"1\":{\"763\":1}}],[\"你了解垃圾回收器有哪些\",{\"0\":{\"745\":1},\"1\":{\"745\":1}}],[\"你知道的类加载器有哪些\",{\"1\":{\"756\":1}}],[\"你不能说cms进行回收的时候\",{\"1\":{\"749\":1}}],[\"你肯定就是回收整个代码\",{\"1\":{\"749\":1}}],[\"你能设计实现一个线程池\",{\"0\":{\"870\":1},\"1\":{\"870\":1}}],[\"你能说说young\",{\"0\":{\"741\":1}}],[\"你能列举一些常见的流控制和差错控制协议吗\",{\"0\":{\"576\":1},\"1\":{\"576\":1}}],[\"你说说看\",{\"1\":{\"724\":1}}],[\"你对红黑树了解多少\",{\"0\":{\"698\":1},\"1\":{\"698\":1}}],[\"你还知道哪些哈希函数的构造方法呢\",{\"0\":{\"691\":1},\"1\":{\"691\":1}}],[\"你和我简单的说一说hash算法\",{\"0\":{\"690\":1},\"1\":{\"690\":1}}],[\"你是否了解copyonwritearraylist\",{\"0\":{\"682\":1}}],[\"你是怎么理解的\",{\"0\":{\"560\":1}}],[\"你给我一块我就传一块\",{\"1\":{\"577\":1}}],[\"你将看到方法调用的输出结果和日志记录\",{\"1\":{\"498\":1}}],[\"你需要在项目的依赖中添加\",{\"1\":{\"498\":1}}],[\"你好\",{\"1\":{\"485\":1}}],[\"你可以有一个容器\",{\"1\":{\"797\":1}}],[\"你可以有一个披萨建造者\",{\"1\":{\"452\":1}}],[\"你可以有一个披萨工厂\",{\"1\":{\"452\":1}}],[\"你可以告诉它具体装的是什么类型的东西\",{\"1\":{\"797\":1}}],[\"你可以将以下依赖添加到你的\",{\"1\":{\"498\":1}}],[\"你可以逐步调用这些方法来构建披萨对象\",{\"1\":{\"452\":1}}],[\"你只需要告诉工厂你想要的披萨类型\",{\"1\":{\"452\":1}}],[\"你会发现条件分支会急速膨胀\",{\"1\":{\"360\":1}}],[\"你们可以听到对方的声音\",{\"1\":{\"239\":1}}],[\"你的密码\",{\"1\":{\"11\":2,\"14\":1,\"37\":2,\"40\":1}}],[\"涉及到共享资源的状态变化\",{\"1\":{\"845\":1}}],[\"涉及到获取锁和释放锁的操作\",{\"1\":{\"834\":1}}],[\"涉及到了编码和调制两个过程\",{\"1\":{\"239\":1}}],[\"涉及支付安全\",{\"1\":{\"344\":1}}],[\"涉及两个非常重要的术语\",{\"1\":{\"276\":1}}],[\"涉及传输数据所使用的介质\",{\"1\":{\"227\":1}}],[\"波特率\",{\"1\":{\"240\":1}}],[\"波形\",{\"1\":{\"239\":1}}],[\"波分多路复用\",{\"0\":{\"149\":1},\"1\":{\"144\":1}}],[\"调⽤⼀个实例对象的⾮静态\",{\"1\":{\"833\":1}}],[\"调度进程\",{\"1\":{\"809\":1}}],[\"调试日志成功打印了\",{\"1\":{\"538\":1}}],[\"调试方法等\",{\"1\":{\"536\":1}}],[\"调试和维护\",{\"1\":{\"480\":1,\"482\":1}}],[\"调用线程池的shutdownnow\",{\"1\":{\"867\":1}}],[\"调用线程池的shutdown\",{\"1\":{\"867\":1}}],[\"调用的时候会释放锁\",{\"1\":{\"812\":1}}],[\"调用start\",{\"1\":{\"806\":1}}],[\"调用不同的方法\",{\"1\":{\"804\":1}}],[\"调用对象方法\",{\"1\":{\"798\":1}}],[\"调用方式\",{\"1\":{\"779\":1}}],[\"调用方法\",{\"1\":{\"799\":1}}],[\"调用方法等\",{\"1\":{\"799\":1}}],[\"调用方法的\",{\"1\":{\"747\":1}}],[\"调用方法时\",{\"1\":{\"469\":1}}],[\"调用静态方法\",{\"1\":{\"755\":1}}],[\"调用支付接口进行支付\",{\"1\":{\"510\":1}}],[\"调用decoratorb对象的operation方法\",{\"1\":{\"502\":1}}],[\"调用decoratora对象的operation方法\",{\"1\":{\"502\":1}}],[\"调用原始对象的operation方法\",{\"1\":{\"502\":1}}],[\"调用原始方法\",{\"1\":{\"502\":2}}],[\"调用了component对象的operation方法\",{\"1\":{\"502\":1}}],[\"调用代理对象的方法\",{\"1\":{\"497\":1,\"498\":1}}],[\"调用被代理对象的方法\",{\"1\":{\"497\":1,\"498\":1}}],[\"调用被代理类对象的对应方法\",{\"1\":{\"495\":1}}],[\"调用远程服务对象的方法执行远程任务\",{\"1\":{\"495\":1}}],[\"调用远程服务对象的方法\",{\"1\":{\"495\":1}}],[\"调用次数等指标\",{\"1\":{\"495\":1}}],[\"调用父类方法\",{\"1\":{\"495\":1}}],[\"调用用户服务获取用户信息\",{\"1\":{\"489\":1}}],[\"调用库存服务获取库存信息\",{\"1\":{\"489\":1}}],[\"调用命令对象的execute方法\",{\"1\":{\"383\":1}}],[\"调用者在需要执行命令时\",{\"1\":{\"383\":1}}],[\"调用者\",{\"1\":{\"382\":1,\"383\":1,\"386\":1}}],[\"调用访问者的访问方法对元素进行操作\",{\"1\":{\"371\":1}}],[\"调用位置\",{\"1\":{\"367\":1}}],[\"调用输出\",{\"1\":{\"353\":1}}],[\"调用策略接口的方法\",{\"1\":{\"343\":1}}],[\"调用抽象方法\",{\"1\":{\"338\":3}}],[\"调用模板方法执行算法\",{\"1\":{\"332\":1}}],[\"调用\",{\"1\":{\"326\":1,\"792\":1}}],[\"调节所要发送数据的量\",{\"1\":{\"296\":1}}],[\"调相\",{\"1\":{\"239\":1,\"619\":1}}],[\"调频\",{\"1\":{\"239\":1,\"619\":1}}],[\"调幅\",{\"1\":{\"239\":1,\"619\":1}}],[\"调制就是将数字信号适配不同的传输介质\",{\"1\":{\"619\":1}}],[\"调制过程允许数据能够更有效地通过传输介质传输\",{\"1\":{\"619\":1}}],[\"调制和解调是什么\",{\"1\":{\"619\":1}}],[\"调制解调器\",{\"1\":{\"240\":1,\"618\":1}}],[\"调制使其适合传输\",{\"1\":{\"239\":1}}],[\"调制涉及改变信号的某些特性\",{\"1\":{\"239\":1}}],[\"调制\",{\"0\":{\"239\":1},\"1\":{\"239\":2,\"619\":1}}],[\"方便扩展和维护\",{\"1\":{\"505\":1}}],[\"方便后续的分析和监控\",{\"1\":{\"495\":1}}],[\"方便维护和管理\",{\"1\":{\"430\":1}}],[\"方便其他对象使用\",{\"1\":{\"421\":1}}],[\"方便使用者使用\",{\"1\":{\"419\":1}}],[\"方便在电话线上传输\",{\"1\":{\"240\":1}}],[\"方案数量为n\",{\"1\":{\"316\":1}}],[\"方式编码在了数据之内\",{\"1\":{\"238\":1}}],[\"方法添加一个任务时\",{\"1\":{\"868\":1}}],[\"方法实现\",{\"1\":{\"843\":1}}],[\"方法实现的\",{\"1\":{\"792\":1}}],[\"方法结合实现等待\",{\"1\":{\"843\":1}}],[\"方法配合try\",{\"1\":{\"843\":1}}],[\"方法会删除key为null的value也会删除\",{\"1\":{\"818\":1}}],[\"方法会被触发\",{\"1\":{\"496\":1}}],[\"方法定义在thread中\",{\"1\":{\"813\":1}}],[\"方法定义在object内部\",{\"1\":{\"813\":1}}],[\"方法被定义在object类中\",{\"1\":{\"813\":1}}],[\"方法被调用时\",{\"1\":{\"326\":1}}],[\"方法涉及锁的释放\",{\"1\":{\"813\":1}}],[\"方法不定义在\",{\"0\":{\"813\":1},\"1\":{\"813\":2}}],[\"方法执行完成后\",{\"1\":{\"812\":1}}],[\"方法则会唤醒所有在该共享变量上由于调用\",{\"1\":{\"807\":1}}],[\"方法多了一个超时参数\",{\"1\":{\"807\":1}}],[\"方法启动线程\",{\"1\":{\"806\":1}}],[\"方法有什么作用\",{\"1\":{\"791\":2}}],[\"方法拼接\",{\"1\":{\"790\":1}}],[\"方法可能会破坏哈希表的正确性和性能\",{\"1\":{\"788\":1}}],[\"方法但没有重写\",{\"1\":{\"788\":2}}],[\"方法对于基于哈希表的数据结构非常重要\",{\"1\":{\"787\":1}}],[\"方法呢\",{\"1\":{\"787\":1}}],[\"方法释放内存空间\",{\"1\":{\"818\":1}}],[\"方法释放了锁\",{\"1\":{\"785\":1,\"812\":1}}],[\"方法释放资源\",{\"1\":{\"768\":1}}],[\"方法没有释放锁\",{\"1\":{\"785\":1,\"812\":1}}],[\"方法调用的解析在编译时发生\",{\"1\":{\"780\":1}}],[\"方法名等信息\",{\"1\":{\"800\":1}}],[\"方法名\",{\"1\":{\"780\":1,\"798\":1}}],[\"方法名相同但参数列表必须不同\",{\"1\":{\"780\":1}}],[\"方法签名不同\",{\"1\":{\"780\":1}}],[\"方法内部\",{\"1\":{\"775\":1}}],[\"方法内通过对象锁实现\",{\"1\":{\"708\":1}}],[\"方法比较容易排查\",{\"1\":{\"768\":1}}],[\"方法显式地加载一个类\",{\"1\":{\"755\":1}}],[\"方法临返回前\",{\"1\":{\"747\":1}}],[\"方法了解吗\",{\"0\":{\"736\":1},\"1\":{\"736\":1}}],[\"方法关闭连接\",{\"1\":{\"731\":1}}],[\"方法区的静态属性\",{\"1\":{\"746\":1}}],[\"方法区内存空间不足\",{\"1\":{\"739\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"734\":1}}],[\"方法区中类静态属性引用的对象\",{\"1\":{\"734\":1}}],[\"方法区可能会耗尽\",{\"1\":{\"731\":1}}],[\"方法区\",{\"1\":{\"722\":1,\"773\":2}}],[\"方法服务\",{\"1\":{\"722\":1}}],[\"方法取值来说\",{\"1\":{\"712\":1}}],[\"方法进行删除操作\",{\"1\":{\"710\":1}}],[\"方法进行展示\",{\"1\":{\"525\":1}}],[\"方法修改了集合的结构时\",{\"1\":{\"710\":1}}],[\"方法保证\",{\"1\":{\"706\":1}}],[\"方法用来排序\",{\"1\":{\"674\":2}}],[\"方法用于提交需要返回值的任务\",{\"1\":{\"863\":1}}],[\"方法用于发起支付操作\",{\"1\":{\"510\":1}}],[\"方法用于在方法调用前后进行逻辑处理\",{\"1\":{\"498\":1}}],[\"方法用于处理支付操作\",{\"1\":{\"510\":1}}],[\"方法用于处理代理对象的方法调用\",{\"1\":{\"497\":1}}],[\"方法用于处理收到的事件\",{\"1\":{\"326\":1}}],[\"方法用于从\",{\"1\":{\"422\":1,\"436\":1}}],[\"方法用于加载资源\",{\"1\":{\"422\":1}}],[\"方法用于设置支付策略\",{\"1\":{\"344\":1}}],[\"方法用于执行支付逻辑\",{\"1\":{\"344\":1}}],[\"方法和接口的名称\",{\"1\":{\"722\":1}}],[\"方法和\",{\"0\":{\"812\":1},\"1\":{\"672\":1,\"812\":1}}],[\"方法创建代理对象\",{\"1\":{\"498\":1}}],[\"方法创建抽象产品对象\",{\"1\":{\"436\":1,\"443\":1}}],[\"方法增强\",{\"1\":{\"494\":1}}],[\"方法避免了重复的\",{\"1\":{\"485\":1}}],[\"方法应该输出相应动物的声音\",{\"1\":{\"469\":1}}],[\"方法根据不同的折扣类型应用相应的折扣\",{\"1\":{\"465\":1}}],[\"方法根据传入的\",{\"1\":{\"436\":1,\"443\":1}}],[\"方法等时使用一个或多个类型参数\",{\"1\":{\"797\":1}}],[\"方法等\",{\"1\":{\"464\":2}}],[\"方法的最后\",{\"1\":{\"821\":1}}],[\"方法的区别\",{\"1\":{\"812\":1}}],[\"方法的话\",{\"1\":{\"788\":3}}],[\"方法的原因是\",{\"1\":{\"788\":1}}],[\"方法的存在是为了支持基于哈希表的数据结构\",{\"1\":{\"787\":1}}],[\"方法的调用在运行时通过动态绑定\",{\"1\":{\"780\":1}}],[\"方法的名称和描述符等\",{\"1\":{\"722\":1}}],[\"方法的一个内存模型\",{\"1\":{\"722\":1}}],[\"方法的返回结果\",{\"1\":{\"497\":1}}],[\"方法的参数数组\",{\"1\":{\"497\":1}}],[\"方法的代码\",{\"1\":{\"465\":1,\"485\":1}}],[\"方法的具体实现\",{\"1\":{\"450\":2}}],[\"方法的支持\",{\"1\":{\"338\":1}}],[\"方法加载资源\",{\"1\":{\"436\":1}}],[\"方法需要遵循特定的调用顺序\",{\"1\":{\"367\":1}}],[\"方法抛出nosuchelementexception异常\",{\"1\":{\"367\":1}}],[\"方法来设置一个值\",{\"1\":{\"811\":1}}],[\"方法来设置线程的中断标志为true\",{\"1\":{\"807\":1}}],[\"方法来确切地比较对象是否相等\",{\"1\":{\"788\":1}}],[\"方法来确切地比较两个对象是否相等\",{\"1\":{\"787\":2}}],[\"方法来进行清除\",{\"1\":{\"731\":1}}],[\"方法来实际显示图片\",{\"1\":{\"495\":1}}],[\"方法来显示图片\",{\"1\":{\"495\":2}}],[\"方法来执行浅拷贝\",{\"1\":{\"454\":1}}],[\"方法来执行具体的支付逻辑\",{\"1\":{\"344\":1}}],[\"方法来创建\",{\"1\":{\"450\":1}}],[\"方法来获取返回值\",{\"1\":{\"863\":1}}],[\"方法来获取\",{\"1\":{\"422\":1}}],[\"方法来接收消息\",{\"1\":{\"408\":1}}],[\"方法来发送消息\",{\"1\":{\"408\":1}}],[\"方法来安全地删除元素\",{\"1\":{\"367\":1}}],[\"方法来检查是否还有元素\",{\"1\":{\"367\":1}}],[\"方法之外\",{\"1\":{\"811\":1}}],[\"方法之前要进行元素的验证\",{\"1\":{\"367\":1}}],[\"方法之前\",{\"1\":{\"367\":1}}],[\"方法之后再次调用remove\",{\"1\":{\"367\":1}}],[\"方法之后再调用\",{\"1\":{\"367\":1}}],[\"方法后\",{\"1\":{\"367\":1,\"807\":2}}],[\"方法在一次迭代中只能被调用一次\",{\"1\":{\"367\":1}}],[\"方法只能在调用了next\",{\"1\":{\"367\":1}}],[\"方法时也要重写\",{\"1\":{\"788\":1}}],[\"方法时能够正常而安全地移除集合中的元素\",{\"1\":{\"367\":1}}],[\"方法时\",{\"1\":{\"367\":1,\"469\":2,\"497\":1,\"788\":2,\"807\":2}}],[\"方法获取到原先设置的值\",{\"1\":{\"811\":1}}],[\"方法获取键的集合\",{\"1\":{\"702\":1}}],[\"方法获取键值对的集合\",{\"1\":{\"702\":2}}],[\"方法获取当前runtime运行时对象的引用\",{\"1\":{\"419\":1}}],[\"方法获取迭代器对象\",{\"1\":{\"366\":1}}],[\"方法获取下一个元素\",{\"1\":{\"365\":1}}],[\"方法判断是否有下一个元素\",{\"1\":{\"365\":1}}],[\"方法处理事件\",{\"1\":{\"326\":1}}],[\"方法发布了事件\",{\"1\":{\"326\":1}}],[\"方法发布名为\",{\"1\":{\"326\":1}}],[\"方法注册了订阅者\",{\"1\":{\"326\":1}}],[\"方法中进行了复杂的比较操作\",{\"1\":{\"788\":1}}],[\"方法中进行安全验证\",{\"1\":{\"495\":1}}],[\"方法中被认为相等\",{\"1\":{\"788\":1}}],[\"方法中的类型转换是否正确\",{\"1\":{\"754\":1}}],[\"方法中调用支付接口的支付方法\",{\"1\":{\"510\":1}}],[\"方法中调用被代理类中的对应方法\",{\"1\":{\"494\":1}}],[\"方法中添加远程通信的逻辑\",{\"1\":{\"495\":1}}],[\"方法中先检查缓存中是否存在查询结果\",{\"1\":{\"495\":1}}],[\"方法中先输出加载图片的信息\",{\"1\":{\"495\":1}}],[\"方法中计算折扣金额\",{\"1\":{\"465\":1}}],[\"方法中\",{\"1\":{\"326\":1,\"366\":1,\"422\":1,\"436\":2,\"469\":1,\"497\":1,\"525\":1,\"840\":1}}],[\"方法\",{\"0\":{\"788\":1,\"812\":1},\"1\":{\"107\":1,\"338\":1,\"404\":1,\"409\":1,\"436\":1,\"450\":2,\"469\":5,\"495\":2,\"497\":1,\"506\":1,\"672\":1,\"720\":1,\"721\":2,\"722\":4,\"736\":1,\"773\":2,\"785\":5,\"788\":9,\"791\":1,\"799\":1,\"806\":3,\"807\":4,\"808\":1,\"813\":1,\"821\":1,\"835\":1,\"839\":2,\"840\":1,\"854\":1,\"867\":2}}],[\"负载因子\",{\"1\":{\"696\":1}}],[\"负载因子0\",{\"1\":{\"690\":1}}],[\"负载均衡器等网络设备\",{\"1\":{\"285\":1}}],[\"负电平代表比特0\",{\"1\":{\"238\":1}}],[\"负责加载本身的目录下的\",{\"1\":{\"760\":1}}],[\"负责管理内存\",{\"1\":{\"720\":1}}],[\"负责管理特定顶级域名下的次级域名信息\",{\"1\":{\"71\":1}}],[\"负责将数据转换为适合在物理媒介上传输的形式\",{\"1\":{\"618\":1}}],[\"负责将发往其他网络或互联网的数据包转发到正确的目标网络\",{\"1\":{\"597\":1}}],[\"负责将域名转换为相应的ip地址\",{\"1\":{\"594\":1}}],[\"负责将比特流组装成帧进行传输\",{\"1\":{\"268\":1}}],[\"负责设备的定位\",{\"1\":{\"593\":1}}],[\"负责在网络中定位和传递数据包\",{\"1\":{\"593\":1}}],[\"负责在源地址和目的地址之间传送数据报\",{\"1\":{\"189\":1}}],[\"负责创建和管理享元对象\",{\"1\":{\"530\":1}}],[\"负责创建具体的产品对象\",{\"1\":{\"434\":2}}],[\"负责创建具体产品对象的工厂类\",{\"1\":{\"426\":1}}],[\"负责处理数据传输和物理媒介的连接\",{\"1\":{\"617\":1}}],[\"负责处理物流\",{\"1\":{\"518\":1}}],[\"负责处理支付\",{\"1\":{\"518\":1}}],[\"负责更新库存\",{\"1\":{\"518\":1}}],[\"负责具体的构建逻辑\",{\"1\":{\"448\":1}}],[\"负责具体的遍历逻辑\",{\"1\":{\"365\":1}}],[\"负责控制对象的构建过程\",{\"1\":{\"448\":1}}],[\"负责根据客户端的需求创建不同类型的产品对象\",{\"1\":{\"430\":1}}],[\"负责根据url加载对应的资源\",{\"1\":{\"429\":1}}],[\"负责协调各个相关对象的交互关系\",{\"1\":{\"400\":1}}],[\"负责执行\",{\"1\":{\"721\":1}}],[\"负责执行实际操作\",{\"1\":{\"383\":1}}],[\"负责执行具体操作的对象\",{\"1\":{\"382\":1}}],[\"负责保存备忘录对象\",{\"1\":{\"377\":1}}],[\"负责人类\",{\"1\":{\"377\":1,\"378\":1}}],[\"负责人\",{\"1\":{\"377\":1}}],[\"负责遍历superarray对象中的元素\",{\"1\":{\"366\":1}}],[\"负责对请求进行数据校验\",{\"1\":{\"353\":1}}],[\"负责对请求进行日志处理\",{\"1\":{\"353\":1}}],[\"负责维护具体的状态并在状态变化时通知观察者\",{\"1\":{\"324\":1}}],[\"负责为应用程序提供数据传输服务\",{\"1\":{\"268\":1}}],[\"负责端到端的数据传输\",{\"1\":{\"268\":1}}],[\"负责实现不同网络之间的数据传输\",{\"1\":{\"268\":1}}],[\"负责传输比特流\",{\"1\":{\"268\":1}}],[\"负责接收邮件的进程\",{\"1\":{\"93\":1}}],[\"负责发送邮件的smtp进程\",{\"1\":{\"93\":1}}],[\"负责知道管理\",{\"1\":{\"71\":1}}],[\"负责一个区的域名服务器\",{\"1\":{\"71\":1}}],[\"差分曼彻斯特编码\",{\"1\":{\"238\":2}}],[\"差错报告报文\",{\"1\":{\"301\":1}}],[\"差错报文\",{\"1\":{\"201\":1}}],[\"差错控制常见实现\",{\"1\":{\"576\":1}}],[\"差错控制是什么\",{\"1\":{\"576\":1}}],[\"差错控制中的回退n帧协议和选择重传协议就是基于速率的流量控制\",{\"1\":{\"142\":1,\"576\":1}}],[\"差错控制中的\",{\"1\":{\"141\":1,\"576\":1}}],[\"差错控制与流量控制等方法\",{\"1\":{\"119\":1}}],[\"差错检测\",{\"0\":{\"133\":1},\"1\":{\"119\":1,\"121\":1,\"133\":1,\"268\":1}}],[\"曼彻斯特编码\",{\"1\":{\"238\":2}}],[\"曼彻斯特编码方法\",{\"1\":{\"131\":1}}],[\"麦克风收到声音后转变的电信号\",{\"1\":{\"238\":1}}],[\"全是kpop的歌\",{\"1\":{\"454\":1}}],[\"全是redvelet的歌\",{\"1\":{\"454\":2}}],[\"全局共享数据\",{\"1\":{\"816\":1}}],[\"全局访问点\",{\"1\":{\"418\":1}}],[\"全局性的控制\",{\"1\":{\"296\":1}}],[\"全排列\",{\"1\":{\"316\":1}}],[\"全双工通信\",{\"1\":{\"237\":1,\"582\":1}}],[\"全双工\",{\"1\":{\"237\":1}}],[\"全球仅有\",{\"1\":{\"78\":1}}],[\"及时调用remove\",{\"1\":{\"818\":1}}],[\"及其子类都统称为非受检查异常\",{\"1\":{\"793\":1}}],[\"及其子类\",{\"1\":{\"793\":1}}],[\"及全限定类名\",{\"1\":{\"769\":1}}],[\"及之前版本的\",{\"1\":{\"713\":1}}],[\"及之前版本\",{\"1\":{\"707\":1}}],[\"及每次发送n个比特\",{\"1\":{\"233\":1}}],[\"及数据包从当前路由器开始路由的第一个下一跳\",{\"1\":{\"205\":1}}],[\"地面微波接力通信\",{\"1\":{\"230\":1}}],[\"地球上方100~500千米高空的带电离子层\",{\"1\":{\"230\":1}}],[\"地址不够如何解决\",{\"0\":{\"602\":1}}],[\"地址分配和唯一性\",{\"1\":{\"593\":1}}],[\"地址实现设备间的通信\",{\"1\":{\"580\":1}}],[\"地址将数据包只转发到目标设备所在的端口\",{\"1\":{\"580\":1}}],[\"地址进行数据包的传输\",{\"1\":{\"580\":1}}],[\"地址进行扩展\",{\"1\":{\"579\":1}}],[\"地址进行划分\",{\"1\":{\"579\":1}}],[\"地址对应的\",{\"1\":{\"579\":1}}],[\"地址字段\",{\"1\":{\"575\":1}}],[\"地址转换\",{\"1\":{\"223\":1}}],[\"地址块越小\",{\"1\":{\"221\":1}}],[\"地址掩码\",{\"1\":{\"220\":2}}],[\"地址数量\",{\"1\":{\"220\":2}}],[\"地址解析协议\",{\"1\":{\"196\":1,\"583\":1}}],[\"地址解析协议arp属于tcp\",{\"1\":{\"168\":1,\"583\":1}}],[\"地址即可访问目标web服务器\",{\"1\":{\"81\":1}}],[\"地址告诉本地\",{\"1\":{\"79\":1}}],[\"地址\",{\"0\":{\"601\":2},\"1\":{\"71\":2,\"74\":1,\"77\":1,\"131\":1,\"575\":2,\"579\":2,\"580\":3,\"584\":1,\"804\":1}}],[\"低停顿\",{\"1\":{\"751\":1}}],[\"低位掩码\",{\"1\":{\"694\":1}}],[\"低位在进行位运算时能够更均匀地分布元素到新的数组中\",{\"1\":{\"688\":1}}],[\"低内聚性\",{\"1\":{\"422\":1}}],[\"低通\",{\"1\":{\"240\":3}}],[\"低频和中频频段用地面波传播\",{\"1\":{\"230\":1}}],[\"低电平对在数据比特中是违法的\",{\"1\":{\"131\":1}}],[\"低电平对\",{\"1\":{\"131\":1}}],[\"光强等\",{\"1\":{\"617\":1}}],[\"光\",{\"1\":{\"238\":1}}],[\"光缆\",{\"1\":{\"230\":1}}],[\"光纤等\",{\"1\":{\"618\":1}}],[\"光纤收发器\",{\"1\":{\"240\":1}}],[\"光纤或空气中传输的信号\",{\"1\":{\"239\":1}}],[\"光纤很细\",{\"1\":{\"230\":1}}],[\"光纤\",{\"1\":{\"227\":1,\"229\":1,\"230\":1,\"240\":1,\"619\":1}}],[\"光纤分布数字接口\",{\"1\":{\"158\":1}}],[\"双亲委派机制可能在类加载过程中引入一些性能开销\",{\"1\":{\"758\":1}}],[\"双亲委派机制可以确保不同的类加载器加载不同的类\",{\"1\":{\"758\":1}}],[\"双亲委派机制会限制某些特定的类加载需求\",{\"1\":{\"758\":1}}],[\"双亲委派模型的工作过程\",{\"1\":{\"758\":1}}],[\"双值集合\",{\"0\":{\"684\":1}}],[\"双绞线电缆\",{\"1\":{\"230\":1}}],[\"双方之间的通话就能实现\",{\"1\":{\"239\":1}}],[\"双方\",{\"1\":{\"125\":1}}],[\"宽带同轴电缆\",{\"1\":{\"230\":1}}],[\"数\",{\"1\":{\"764\":2}}],[\"数量\",{\"1\":{\"750\":1}}],[\"数组类型\",{\"1\":{\"847\":2}}],[\"数组越界错误\",{\"1\":{\"793\":1}}],[\"数组的大小\",{\"1\":{\"711\":1}}],[\"数组的初始大小才\",{\"1\":{\"694\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"711\":1}}],[\"数组中key和hash一样就直接替换\",{\"1\":{\"711\":1}}],[\"数组长度\",{\"1\":{\"690\":1,\"694\":1}}],[\"数组定位位置\",{\"1\":{\"688\":1}}],[\"数组大小\",{\"1\":{\"688\":1}}],[\"数组存储每个元素对应一个链表\",{\"1\":{\"685\":2,\"686\":2}}],[\"数组存储对象存在一些不足之处不能动态扩容\",{\"1\":{\"673\":1}}],[\"数组做hash容器\",{\"1\":{\"685\":2,\"686\":2}}],[\"数组可能长度100\",{\"1\":{\"680\":1}}],[\"数组实现\",{\"0\":{\"354\":1}}],[\"数组\",{\"1\":{\"311\":1,\"701\":1,\"714\":1,\"715\":1,\"729\":1}}],[\"数字分析法\",{\"1\":{\"691\":1}}],[\"数字通信中的信息传输速率的上限\",{\"1\":{\"622\":1}}],[\"数字信号在长距离传输时受到噪声和衰减的影响更大\",{\"1\":{\"619\":1}}],[\"数字基带信号\",{\"1\":{\"238\":1}}],[\"数字传输\",{\"1\":{\"230\":1}}],[\"数据不可变\",{\"1\":{\"831\":1}}],[\"数据丢失这个在\",{\"1\":{\"707\":1}}],[\"数据总量和查询次数的关系\",{\"1\":{\"690\":1}}],[\"数据元素通过hash算法也就是散列函数进行定位\",{\"1\":{\"685\":1}}],[\"数据元素存储在物理空间上是分散的\",{\"1\":{\"312\":1}}],[\"数据元素存储在物理空间上是连续的\",{\"1\":{\"312\":1}}],[\"数据是如何变化的\",{\"0\":{\"629\":1}}],[\"数据是在不同设备间进行传输的\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"数据在各层之间是怎么传输的呢\",{\"0\":{\"629\":1}}],[\"数据在传输线路上是串行传输\",{\"1\":{\"232\":1}}],[\"数据定位和传输\",{\"1\":{\"593\":1}}],[\"数据封装\",{\"1\":{\"584\":1}}],[\"数据处理\",{\"1\":{\"580\":1}}],[\"数据和fcs\",{\"1\":{\"575\":1}}],[\"数据部分\",{\"1\":{\"575\":2}}],[\"数据帧是在数据链路层中用于封装和传输数据的基本单位\",{\"1\":{\"575\":1}}],[\"数据帧的结构是怎样的\",{\"0\":{\"575\":1},\"1\":{\"575\":1}}],[\"数据帧的封装\",{\"1\":{\"120\":1}}],[\"数据存储等\",{\"1\":{\"333\":1}}],[\"数据校验\",{\"1\":{\"333\":1}}],[\"数据导入处理\",{\"1\":{\"333\":1}}],[\"数据按照一定顺序排列\",{\"1\":{\"311\":1}}],[\"数据按序交付\",{\"1\":{\"291\":1}}],[\"数据结构\",{\"1\":{\"701\":1}}],[\"数据结构和算法\",{\"2\":{\"319\":1}}],[\"数据结构分类\",{\"0\":{\"310\":1}}],[\"数据结束传送后就关闭\",{\"1\":{\"85\":1}}],[\"数据字段\",{\"1\":{\"302\":1}}],[\"数据单方向传送\",{\"1\":{\"296\":1}}],[\"数据完整性保证\",{\"1\":{\"291\":1}}],[\"数据也能被重新传输\",{\"1\":{\"282\":1}}],[\"数据段\",{\"1\":{\"278\":1}}],[\"数据只在这一线路上传输\",{\"1\":{\"253\":1}}],[\"数据直达\",{\"1\":{\"253\":1}}],[\"数据交换方式\",{\"0\":{\"252\":1}}],[\"数据通信方式\",{\"0\":{\"237\":1},\"1\":{\"237\":1}}],[\"数据块以稳定的比特流形式传输\",{\"1\":{\"236\":1}}],[\"数据编码和解码\",{\"1\":{\"229\":1}}],[\"数据编码\",{\"1\":{\"227\":1}}],[\"数据\",{\"1\":{\"194\":1,\"227\":1,\"238\":1,\"816\":2}}],[\"数据报\",{\"1\":{\"289\":1}}],[\"数据报中协议字段的值用来表名封装的是何种协议数据单元\",{\"1\":{\"280\":1}}],[\"数据报交换方式\",{\"1\":{\"189\":1}}],[\"数据报服务\",{\"1\":{\"184\":1,\"589\":1}}],[\"数据报转发过程中源ip地址和目的ip地址保持不变\",{\"1\":{\"167\":1}}],[\"数据的发送需要经过链路\",{\"1\":{\"168\":1,\"583\":1}}],[\"数据分组\",{\"1\":{\"137\":1}}],[\"数据分组丢失的情况\",{\"1\":{\"137\":1}}],[\"数据分组丢失\",{\"1\":{\"137\":1}}],[\"数据包可能会丢失\",{\"1\":{\"294\":1}}],[\"数据包应该发送到哪个特定的下一跳路由器或接口\",{\"1\":{\"205\":1}}],[\"数据包的传输和网络间的通信\",{\"1\":{\"593\":1}}],[\"数据包的头部包含源节点和目标节点的网络层地址\",{\"1\":{\"186\":1,\"591\":1}}],[\"数据包的帧封装原理\",{\"0\":{\"130\":1}}],[\"数据包封装和解封装\",{\"0\":{\"186\":1,\"591\":1}}],[\"数据包转发过程中源mac地址和目的mac地址\",{\"1\":{\"167\":1}}],[\"数据包转发过程中ip地址与mac地址变换情况\",{\"1\":{\"167\":1}}],[\"数据包\",{\"1\":{\"129\":1,\"593\":1}}],[\"数据传输和同步\",{\"1\":{\"584\":1}}],[\"数据传输和虚电路释放三个过程\",{\"1\":{\"254\":1}}],[\"数据传输速率=码元传输速率\",{\"1\":{\"240\":1}}],[\"数据传输速率=\",{\"1\":{\"240\":1}}],[\"数据传输速率\",{\"1\":{\"227\":2}}],[\"数据传输方式是并行传输\",{\"1\":{\"233\":1}}],[\"数据传输方式\",{\"1\":{\"227\":1}}],[\"数据传输了\",{\"1\":{\"184\":1,\"589\":1}}],[\"数据传输\",{\"1\":{\"125\":1,\"162\":1}}],[\"数据传输差错控制\",{\"1\":{\"120\":1}}],[\"数据链路释放\",{\"1\":{\"125\":1}}],[\"数据链路是由数据链路层中的llc子层通过相应的通信规程\",{\"1\":{\"123\":1}}],[\"数据链路管理\",{\"0\":{\"123\":1}}],[\"数据链路\",{\"1\":{\"119\":1}}],[\"数据链路层实现可靠传输的方式包括错误检测和纠正\",{\"1\":{\"577\":1}}],[\"数据链路层都不对其内容进行解释或处理\",{\"1\":{\"577\":1}}],[\"数据链路层中的封装\",{\"0\":{\"577\":1},\"1\":{\"577\":1}}],[\"数据链路层中与传输介质访问无关的问题都集中在llc子层来解决\",{\"1\":{\"120\":1}}],[\"数据链路层通过流量控制机制\",{\"1\":{\"573\":1}}],[\"数据链路层将来自网络层的数据包封装成数据帧\",{\"1\":{\"573\":1}}],[\"数据链路层将帧的首部和尾部去掉后成为ip数据报\",{\"1\":{\"268\":1}}],[\"数据链路层将帧的首部和尾部去掉后\",{\"1\":{\"268\":1}}],[\"数据链路层将帧交付给物理层\",{\"1\":{\"268\":2}}],[\"数据链路层使用物理地址\",{\"1\":{\"573\":1}}],[\"数据链路层为同一网络中\",{\"1\":{\"274\":1}}],[\"数据链路层给ip数据报添加一个首部和一个尾部\",{\"1\":{\"268\":2}}],[\"数据链路层一般不会出现ack分组迟到的情况\",{\"1\":{\"137\":1}}],[\"数据链路层的主要功能是什么\",{\"0\":{\"573\":1},\"1\":{\"573\":1}}],[\"数据链路层的通信限于同一局域网中\",{\"1\":{\"274\":1}}],[\"数据链路层的服务访问点为帧的\",{\"1\":{\"251\":1}}],[\"数据链路层的提供的服务类型\",{\"1\":{\"124\":1}}],[\"数据链路层的功能\",{\"0\":{\"122\":1},\"1\":{\"119\":1}}],[\"数据链路层主要分为两类\",{\"1\":{\"121\":1}}],[\"数据链路层以帧为单位传输和处理数据\",{\"1\":{\"119\":1}}],[\"数据链路层就是保证我们传输的数据能有序的\",{\"1\":{\"119\":1}}],[\"数据链路层是实现这些规程或协议的硬件和软件加上物理线路\",{\"1\":{\"573\":1}}],[\"数据链路层是接收来自物理层的比特流\",{\"1\":{\"129\":1}}],[\"数据链路层是接收来自网络层的数据分组\",{\"1\":{\"129\":1}}],[\"数据链路层是什么\",{\"1\":{\"119\":1}}],[\"数据链路层是osi模型中的第二层\",{\"1\":{\"117\":1,\"119\":1,\"573\":1}}],[\"数据链路层\",{\"0\":{\"117\":1},\"1\":{\"120\":1,\"162\":2,\"268\":2}}],[\"数据连接端口\",{\"1\":{\"87\":1}}],[\"数据连接会被关闭\",{\"1\":{\"86\":1}}],[\"数据连接的建立方式有两种模式\",{\"1\":{\"85\":1}}],[\"数据连接\",{\"1\":{\"85\":1}}],[\"数据库链接\",{\"1\":{\"866\":1}}],[\"数据库连接池\",{\"1\":{\"858\":1}}],[\"数据库中的数据等\",{\"1\":{\"704\":1}}],[\"数据库操作的具体实现类\",{\"1\":{\"497\":1}}],[\"数据库等\",{\"1\":{\"333\":1,\"355\":1}}],[\"数据库描述\",{\"1\":{\"210\":1}}],[\"数据库服务等\",{\"1\":{\"58\":1}}],[\"数据库\",{\"1\":{\"11\":1,\"37\":1}}],[\"导出堆内存文件快照\",{\"1\":{\"766\":1}}],[\"导出\",{\"1\":{\"762\":1}}],[\"导游\",{\"1\":{\"372\":1}}],[\"导入数据\",{\"1\":{\"333\":1}}],[\"导致性能下降\",{\"1\":{\"855\":1}}],[\"导致性能降低\",{\"1\":{\"751\":1}}],[\"导致不一致的业务行为\",{\"1\":{\"845\":1}}],[\"导致不同线程的操作交错执行\",{\"1\":{\"829\":1}}],[\"导致丢失了更新操作\",{\"1\":{\"829\":1}}],[\"导致错误的结果\",{\"1\":{\"814\":1}}],[\"导致类无法被正确初始化\",{\"1\":{\"793\":1}}],[\"导致类的数量增加\",{\"1\":{\"437\":1}}],[\"导致无法继续执行程序\",{\"1\":{\"793\":1}}],[\"导致大对象进入了老年代\",{\"1\":{\"768\":1}}],[\"导致一些类加载冲突和安全性问题\",{\"1\":{\"758\":1}}],[\"导致一个类承担了多个职责\",{\"1\":{\"461\":1}}],[\"导致用户程序性能下降\",{\"1\":{\"751\":1}}],[\"导致标记和清除两个过程的执行效率都随对象数量增长而降低\",{\"1\":{\"744\":1}}],[\"导致内存泄漏\",{\"1\":{\"731\":1,\"788\":1}}],[\"导致内存被白白占用\",{\"1\":{\"731\":1}}],[\"导致结果不符合预期\",{\"1\":{\"713\":1}}],[\"导致迭代器的\",{\"1\":{\"710\":1}}],[\"导致资源浪费\",{\"1\":{\"697\":1}}],[\"导致时间复杂度进行退化\",{\"1\":{\"690\":1}}],[\"导致修改范围较大\",{\"1\":{\"519\":1}}],[\"导致职责不够单一\",{\"1\":{\"422\":1}}],[\"导致扩展困难\",{\"1\":{\"421\":1}}],[\"导致中介者对象本身难以维护\",{\"1\":{\"410\":1}}],[\"导致对象之间的通信和交互复杂且难以维护时\",{\"1\":{\"405\":1}}],[\"导致代码复杂化\",{\"1\":{\"396\":1}}],[\"导致拥塞\",{\"1\":{\"296\":1}}],[\"导致缓冲区满了\",{\"1\":{\"294\":1}}],[\"导致其缓冲区满了\",{\"1\":{\"294\":1}}],[\"导致服务器有大量挂起等待确认的tcp连接\",{\"1\":{\"285\":1}}],[\"导引型传输媒体\",{\"1\":{\"230\":1}}],[\"导航到服务器的\",{\"1\":{\"8\":1,\"34\":1}}],[\"过高的加载因子会导致哈希碰撞增多\",{\"1\":{\"696\":1}}],[\"过滤器和拦截器就是典型的使用责任链模式的场景\",{\"1\":{\"355\":1}}],[\"过去用于局域网\",{\"1\":{\"230\":1}}],[\"过程特性\",{\"1\":{\"227\":1}}],[\"过期时间\",{\"1\":{\"205\":1}}],[\"固定数目线程的线程池\",{\"1\":{\"859\":1}}],[\"固定字段\",{\"1\":{\"304\":1}}],[\"固定和锁定装置\",{\"1\":{\"227\":1}}],[\"固定部分20字节\",{\"1\":{\"194\":1}}],[\"引用的值在程序编译期是无法确定的\",{\"1\":{\"792\":1}}],[\"引用的对象\",{\"1\":{\"734\":1}}],[\"引用拷贝就是两个不同的引用指向同一个对象\",{\"1\":{\"784\":1}}],[\"引用拷贝\",{\"1\":{\"784\":1}}],[\"引用数据类型不可以\",{\"1\":{\"831\":1}}],[\"引用数据类型\",{\"1\":{\"773\":1}}],[\"引用类型原子类\",{\"1\":{\"847\":1}}],[\"引用类型数组原子类\",{\"1\":{\"847\":1}}],[\"引用类型\",{\"1\":{\"847\":2}}],[\"引用类型字段赋值\",{\"1\":{\"742\":1}}],[\"引用类型默认为\",{\"1\":{\"726\":1}}],[\"引用计数算法\",{\"1\":{\"733\":1}}],[\"引用计数算法和可达性分析算法\",{\"1\":{\"733\":1}}],[\"引用了哪些插件\",{\"1\":{\"539\":1}}],[\"引入的一种机制\",{\"1\":{\"832\":1}}],[\"引入的一种针对性的算法\",{\"1\":{\"744\":1}}],[\"引入红黑树主要是为hashmap集合分布的元素更均匀\",{\"1\":{\"685\":1,\"686\":1}}],[\"引入了红黑树\",{\"1\":{\"685\":1,\"686\":1}}],[\"引入了抽象类和抽象方法\",{\"1\":{\"339\":1}}],[\"引起转发时延\",{\"1\":{\"255\":1}}],[\"引起了转发时延\",{\"1\":{\"254\":1}}],[\"引脚数目和排列\",{\"1\":{\"227\":1}}],[\"引出\",{\"1\":{\"218\":1}}],[\"汽车和飞机等承载货物\",{\"1\":{\"227\":1}}],[\"公平锁会按照线程请求的顺序进行获取锁\",{\"1\":{\"839\":1}}],[\"公平锁\",{\"1\":{\"839\":1}}],[\"公平锁和非公平锁等高级功能\",{\"1\":{\"838\":1}}],[\"公平\",{\"1\":{\"839\":1}}],[\"公平性等\",{\"1\":{\"831\":1}}],[\"公司的监控系统\",{\"1\":{\"768\":1}}],[\"公式为\",{\"1\":{\"764\":1}}],[\"公式描述了信道的容量与带宽\",{\"1\":{\"622\":1}}],[\"公式表达了在受限的带宽内\",{\"1\":{\"622\":1}}],[\"公园\",{\"1\":{\"372\":3}}],[\"公路\",{\"1\":{\"227\":1}}],[\"公网\",{\"1\":{\"161\":1}}],[\"私有的等\",{\"1\":{\"799\":2}}],[\"私有ip地址和公共ip地址\",{\"1\":{\"223\":1}}],[\"私网ipv4地址在不同公司内部的局域网中是可以重复使用的\",{\"1\":{\"217\":1}}],[\"私网ip地址\",{\"1\":{\"217\":1}}],[\"外卖柜\",{\"1\":{\"816\":1}}],[\"外在病症表现可能有\",{\"1\":{\"769\":1}}],[\"外所有命令的功能\",{\"1\":{\"762\":1}}],[\"外部样子不能改变\",{\"1\":{\"780\":1}}],[\"外部状态的共享需要注意线程安全性和正确性\",{\"1\":{\"533\":1}}],[\"外部网关协议\",{\"1\":{\"211\":1}}],[\"外部网关协议等概念\",{\"1\":{\"211\":1}}],[\"外观模式\",{\"1\":{\"490\":1}}],[\"外围设备及用户连接起来\",{\"1\":{\"257\":1}}],[\"外同步\",{\"1\":{\"236\":1}}],[\"外联网vpn允许不同组织之间安全地共享资源和信息\",{\"1\":{\"223\":1}}],[\"外联网vpn\",{\"1\":{\"223\":1}}],[\"办公室或远程员工\",{\"1\":{\"223\":1}}],[\"设备会将数据包发送给默认网关\",{\"1\":{\"597\":1}}],[\"设备通常会在本地维护一个arp缓存表\",{\"1\":{\"583\":1}}],[\"设备能够同时进行发送和接收数据\",{\"1\":{\"582\":1}}],[\"设备需要在发送和接收之间切换\",{\"1\":{\"582\":1}}],[\"设备可以彼此识别并进行通信\",{\"1\":{\"593\":1}}],[\"设备可以同时发送和接收数据\",{\"1\":{\"582\":1}}],[\"设备可以在不同时间段内进行发送和接收数据\",{\"1\":{\"582\":1}}],[\"设备可直接通信\",{\"1\":{\"580\":1}}],[\"设备就可以开始发送数据\",{\"1\":{\"581\":1}}],[\"设备在发送数据之前会监听传输介质\",{\"1\":{\"581\":1}}],[\"设备和协议的差异\",{\"1\":{\"573\":1}}],[\"设备或服务器\",{\"1\":{\"222\":1}}],[\"设计思想\",{\"1\":{\"845\":1}}],[\"设计元素\",{\"1\":{\"539\":1}}],[\"设计不是一个固定的技术\",{\"1\":{\"458\":1}}],[\"设计模式只是提供了一套别人总结好的解决方案\",{\"1\":{\"458\":1}}],[\"设计模式\",{\"1\":{\"490\":1},\"2\":{\"413\":1,\"457\":1,\"492\":1,\"535\":1}}],[\"设输入数据大小为\",{\"1\":{\"316\":1}}],[\"设算法的操作数量是一个关于输入数据大小\",{\"1\":{\"316\":1}}],[\"设每一个报文段100b\",{\"1\":{\"294\":1}}],[\"设为x\",{\"1\":{\"240\":1}}],[\"设置标志仅仅是设置标志\",{\"1\":{\"807\":1}}],[\"设置垃圾回收时间占程序运行时间的百分比\",{\"1\":{\"764\":1}}],[\"设置并发收集器年轻代手机方式为并行收集时\",{\"1\":{\"764\":1}}],[\"设置并发收集器\",{\"1\":{\"764\":1}}],[\"设置并行收集最大的暂停时间\",{\"1\":{\"764\":1}}],[\"设置并行收集器收集时使用的\",{\"1\":{\"764\":1}}],[\"设置并行收集器\",{\"1\":{\"764\":1}}],[\"设置并行年老代收集器\",{\"1\":{\"764\":1}}],[\"设置串行收集器\",{\"1\":{\"764\":1}}],[\"设置持久代大小\",{\"1\":{\"764\":1}}],[\"设置年轻代和年老代的比值\",{\"1\":{\"764\":1}}],[\"设置年轻代大小\",{\"1\":{\"764\":1}}],[\"设置对象头\",{\"1\":{\"726\":1}}],[\"设置方法拦截器\",{\"1\":{\"498\":1}}],[\"设置他的父类\",{\"1\":{\"498\":1}}],[\"设置安全验证密码\",{\"1\":{\"495\":1}}],[\"设置安全组\",{\"1\":{\"3\":1,\"29\":1}}],[\"设置折扣策略\",{\"1\":{\"465\":1}}],[\"设置originator的状态并保存到备忘录\",{\"1\":{\"377\":1}}],[\"设置为增量模式\",{\"1\":{\"764\":1}}],[\"设置为关机状态\",{\"1\":{\"360\":1}}],[\"设置为开机状态\",{\"1\":{\"360\":1}}],[\"设置策略\",{\"1\":{\"343\":2,\"344\":1,\"346\":2}}],[\"设置连接限制或阈值\",{\"1\":{\"285\":1}}],[\"设置配置文件\",{\"0\":{\"8\":1,\"34\":1}}],[\"构造函数默认创建的是非公平锁\",{\"1\":{\"840\":1}}],[\"构造超网\",{\"1\":{\"221\":1}}],[\"构成信号的一种波形\",{\"1\":{\"238\":1}}],[\"构建类型配置块\",{\"1\":{\"539\":1}}],[\"构建更灵活\",{\"1\":{\"474\":1}}],[\"构建者\",{\"1\":{\"448\":1}}],[\"构建数学表达式\",{\"1\":{\"390\":1}}],[\"构建责任链\",{\"1\":{\"350\":1}}],[\"构建出各种到达其他各路由器的最短路径带权有向图\",{\"1\":{\"210\":1}}],[\"构建一个强大的虚拟服务器\",{\"1\":{\"58\":1}}],[\"请自行更改目录\",{\"1\":{\"538\":1}}],[\"请随时提问\",{\"1\":{\"526\":1}}],[\"请注意\",{\"1\":{\"350\":1,\"421\":1,\"450\":1,\"498\":1,\"525\":1,\"793\":1}}],[\"请输入第二个数字\",{\"1\":{\"343\":1,\"346\":1}}],[\"请输入第一个数字\",{\"1\":{\"343\":1,\"346\":1}}],[\"请输入+或\",{\"1\":{\"346\":1}}],[\"请输入+\",{\"1\":{\"343\":1}}],[\"请输入运算符号\",{\"1\":{\"343\":1,\"346\":1}}],[\"请假申请\",{\"1\":{\"333\":1}}],[\"请给出c1dr地址块128\",{\"1\":{\"220\":1}}],[\"请求与保持条件\",{\"1\":{\"848\":1}}],[\"请求头里包含了对象是哪个类的实例\",{\"1\":{\"726\":1}}],[\"请求头部和请求主体\",{\"1\":{\"107\":1}}],[\"请求的过程与原理\",{\"0\":{\"557\":1}}],[\"请求的区别是什么\",{\"0\":{\"555\":1}}],[\"请求和\",{\"0\":{\"555\":1}}],[\"请求和响应在过滤器或拦截器链中依次传递\",{\"1\":{\"355\":1}}],[\"请求降落许可\",{\"1\":{\"403\":3}}],[\"请求日志记录等\",{\"1\":{\"355\":1}}],[\"请求会从责任链的头部\",{\"1\":{\"350\":1}}],[\"请求\",{\"1\":{\"348\":1}}],[\"请求行\",{\"1\":{\"107\":1}}],[\"请求报文\",{\"1\":{\"107\":1}}],[\"请求分配ip地址\",{\"1\":{\"64\":1}}],[\"请求可用的dhcp服务器\",{\"1\":{\"64\":1}}],[\"请求服务\",{\"1\":{\"58\":1}}],[\"请求还是响应\",{\"1\":{\"56\":1}}],[\"斜线后面为20\",{\"1\":{\"220\":1}}],[\"斜线后面的数字\",{\"1\":{\"220\":1}}],[\"斜线记法\",{\"1\":{\"220\":1}}],[\"~\",{\"1\":{\"218\":1,\"774\":1}}],[\"划分为具体的任务如下\",{\"1\":{\"229\":1}}],[\"划分出的子网数量有\",{\"1\":{\"218\":1}}],[\"划分子网ipv4\",{\"0\":{\"218\":1}}],[\"划分子网\",{\"1\":{\"215\":1}}],[\"例子2\",{\"1\":{\"525\":1}}],[\"例子1\",{\"1\":{\"525\":1}}],[\"例子\",{\"0\":{\"461\":1,\"465\":1,\"469\":1,\"473\":1,\"477\":1,\"481\":1,\"485\":1,\"489\":1},\"1\":{\"314\":1,\"809\":1,\"816\":1}}],[\"例\",{\"1\":{\"260\":1,\"294\":1}}],[\"例题\",{\"1\":{\"218\":1,\"220\":1,\"260\":1,\"291\":1,\"294\":1}}],[\"例如刚开局都是500块\",{\"1\":{\"851\":1}}],[\"例如又a\",{\"1\":{\"829\":1}}],[\"例如我们常用mvc架构\",{\"1\":{\"817\":1}}],[\"例如互斥锁和读写锁\",{\"1\":{\"811\":1}}],[\"例如50毫秒\",{\"1\":{\"809\":1}}],[\"例如依赖注入\",{\"1\":{\"800\":1}}],[\"例如插件系统\",{\"1\":{\"800\":1}}],[\"例如java\",{\"1\":{\"798\":1}}],[\"例如平常一个人自己一个人要吃饭\",{\"1\":{\"781\":1}}],[\"例如接口超时报警等\",{\"1\":{\"769\":1}}],[\"例如类\",{\"1\":{\"758\":1}}],[\"例如在java中是java\",{\"1\":{\"799\":1}}],[\"例如在java虚拟机的并发标记\",{\"1\":{\"748\":1}}],[\"例如在使用电路交换打电话前\",{\"1\":{\"253\":1}}],[\"例如它里面有局部变量表存储方法调用过程中的创建的局部变量\",{\"1\":{\"722\":1}}],[\"例如kotlin编译后也是class文件\",{\"1\":{\"719\":1}}],[\"例如先判断某个键是否存在containskey\",{\"1\":{\"713\":1}}],[\"例如十位和百位\",{\"1\":{\"691\":1}}],[\"例如1232放到下标1232的位置\",{\"1\":{\"691\":1}}],[\"例如从\",{\"1\":{\"688\":1}}],[\"例如从使用smtp协议改为使用api调用发送邮件\",{\"1\":{\"461\":1}}],[\"例如电缆就传输电信号\",{\"1\":{\"619\":1}}],[\"例如电子邮件\",{\"1\":{\"56\":1}}],[\"例如双向无线电通信\",{\"1\":{\"582\":1}}],[\"例如集线器\",{\"1\":{\"581\":1}}],[\"例如文件系统\",{\"1\":{\"524\":1}}],[\"例如文本\",{\"1\":{\"96\":1}}],[\"例如添加子节点\",{\"1\":{\"524\":1}}],[\"例如添加一些额外的验证或处理步骤\",{\"1\":{\"461\":1}}],[\"例如渠道名称\",{\"1\":{\"506\":1}}],[\"例如inputstream\",{\"1\":{\"500\":1}}],[\"例如ip地址\",{\"1\":{\"186\":1,\"268\":1,\"591\":1}}],[\"例如大于\",{\"1\":{\"392\":1}}],[\"例如首页\",{\"1\":{\"372\":1}}],[\"例如fileinputstream\",{\"1\":{\"335\":1}}],[\"例如excel文件\",{\"1\":{\"333\":1}}],[\"例如消息队列系统\",{\"1\":{\"326\":1}}],[\"例如mac地址\",{\"1\":{\"268\":1}}],[\"例如数字传输系统和数据通信中\",{\"1\":{\"240\":1}}],[\"例如调制解调器通信系统\",{\"1\":{\"240\":1}}],[\"例如以太网\",{\"1\":{\"229\":1}}],[\"例如串行传输和并行传输\",{\"1\":{\"229\":1}}],[\"例如比特率\",{\"1\":{\"227\":1}}],[\"例如铜线\",{\"1\":{\"227\":1}}],[\"例如ospf或rip\",{\"1\":{\"212\":1}}],[\"例如一所大学\",{\"1\":{\"211\":1}}],[\"例如a\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"例如arp\",{\"1\":{\"159\":1}}],[\"例如图片等\",{\"1\":{\"111\":1}}],[\"例如创建文件夹\",{\"1\":{\"97\":1}}],[\"例如服务器或路由器\",{\"1\":{\"68\":1}}],[\"例如http服务器的默认端口号为80\",{\"1\":{\"58\":1}}],[\"例如配置\",{\"1\":{\"22\":2,\"48\":2}}],[\"例如打包后的dist目录上传到\",{\"1\":{\"22\":1,\"48\":1}}],[\"例如\",{\"1\":{\"3\":1,\"5\":1,\"29\":1,\"31\":1,\"67\":1,\"68\":1,\"85\":1,\"104\":1,\"119\":1,\"131\":2,\"170\":1,\"212\":1,\"221\":1,\"222\":3,\"257\":1,\"316\":3,\"360\":1,\"367\":1,\"372\":4,\"375\":2,\"419\":1,\"421\":1,\"452\":1,\"473\":1,\"485\":1,\"506\":3,\"517\":1,\"538\":1,\"574\":2,\"581\":1,\"721\":1,\"725\":2,\"726\":1,\"769\":1,\"787\":1,\"793\":1,\"807\":1,\"817\":3,\"827\":1,\"832\":1,\"844\":2,\"848\":1,\"851\":2,\"858\":1}}],[\"正在处理任务事务控制\",{\"1\":{\"871\":1}}],[\"正在跑的和正在等待的任务都停下了\",{\"1\":{\"864\":1}}],[\"正要刷回主存\",{\"1\":{\"829\":1}}],[\"正确刷新到内存中\",{\"1\":{\"827\":1}}],[\"正确的选项是\",{\"1\":{\"218\":1}}],[\"正常情况下jvm就不会退出\",{\"1\":{\"810\":1}}],[\"正好是\",{\"1\":{\"694\":1}}],[\"正好相当于一个\",{\"1\":{\"694\":1}}],[\"正交振幅调制\",{\"1\":{\"619\":1}}],[\"正电平代表比特1\",{\"1\":{\"238\":1}}],[\"正文内容\",{\"1\":{\"91\":1}}],[\"正文\",{\"1\":{\"91\":1}}],[\"浪费原有网络号中剩余的大量ipv4地址\",{\"1\":{\"218\":1}}],[\"注重独一无二的性质\",{\"1\":{\"671\":1}}],[\"注册不同版本的反序列化策略\",{\"1\":{\"346\":1}}],[\"注册\",{\"1\":{\"324\":1,\"326\":2}}],[\"注册和购买的\",{\"1\":{\"217\":1}}],[\"注意这里说叶子节点其实是图中的\",{\"1\":{\"698\":1}}],[\"注意事项\",{\"1\":{\"526\":1}}],[\"注意\",{\"1\":{\"0\":1,\"262\":1,\"454\":1,\"709\":1,\"764\":1,\"769\":1,\"777\":1,\"785\":1,\"795\":1}}],[\"打破双亲委派\",{\"1\":{\"759\":1}}],[\"打破双亲委派机制意味着在自定义类加载器中实现一种类加载机制\",{\"1\":{\"759\":1}}],[\"打破双亲委派怎么操作\",{\"0\":{\"759\":1},\"1\":{\"759\":1}}],[\"打包时\",{\"1\":{\"539\":1}}],[\"打印的异常信息一定要有意义\",{\"1\":{\"793\":1}}],[\"打印\",{\"1\":{\"764\":1}}],[\"打印机和其他设备连接到同一个vlan中\",{\"1\":{\"579\":1}}],[\"打印出进程的所有线程信息\",{\"1\":{\"765\":1}}],[\"打印出\",{\"1\":{\"502\":1}}],[\"打印操作\",{\"1\":{\"315\":1}}],[\"打了个合格标签\",{\"1\":{\"502\":4}}],[\"打了进入日志\",{\"1\":{\"353\":2,\"354\":1}}],[\"打开自己的抽屉\",{\"1\":{\"816\":1}}],[\"打开手机\",{\"1\":{\"538\":1}}],[\"打开项目的gradle目录\",{\"1\":{\"538\":1}}],[\"打开流\",{\"1\":{\"335\":1}}],[\"打开文件输入流\",{\"1\":{\"335\":1}}],[\"打开\",{\"1\":{\"212\":1,\"360\":1}}],[\"打标签\",{\"1\":{\"159\":2}}],[\"防环路\",{\"1\":{\"212\":1}}],[\"防止类型不匹配的错误\",{\"1\":{\"797\":1}}],[\"防止过载或丢失数据的情况发生\",{\"1\":{\"573\":1}}],[\"防止过多的数据注入到网络中\",{\"1\":{\"296\":1}}],[\"防止源代码被反编译篡改泄漏\",{\"1\":{\"539\":1}}],[\"防止出现空实现或抛出不支持的操作异常\",{\"1\":{\"474\":1}}],[\"防止服务器端因为未收到客户端的确认报文段导致无法关闭\",{\"1\":{\"286\":1}}],[\"防止网络中的环路\",{\"1\":{\"175\":1}}],[\"防止重复发送\",{\"1\":{\"137\":1}}],[\"防止其与首部尾部的标志位混淆\",{\"1\":{\"132\":1}}],[\"彼此之间不会干扰\",{\"1\":{\"804\":1}}],[\"彼此之间可以直接通信和共享资源\",{\"1\":{\"59\":1}}],[\"彼此称为对方的邻站\",{\"1\":{\"212\":1}}],[\"利用\",{\"1\":{\"839\":1}}],[\"利用扩容后的大小也是2的倍数\",{\"1\":{\"688\":1}}],[\"利用信号的相位变化来表示不同的数字信号\",{\"1\":{\"619\":1}}],[\"利用信号的频率变化来表示不同的数字信号\",{\"1\":{\"619\":1}}],[\"利用信号的振幅变化来表示不同的数字信号\",{\"1\":{\"619\":1}}],[\"利用类与类之间的关系\",{\"1\":{\"493\":1}}],[\"利用率\",{\"0\":{\"266\":1},\"1\":{\"266\":1}}],[\"利用bgp会话交换路由信息\",{\"1\":{\"212\":1}}],[\"利用了tcp的可靠传输特性来确保文件的正确传输\",{\"1\":{\"87\":1}}],[\"经理该怎么办呢\",{\"1\":{\"868\":1}}],[\"经理赶紧出来了\",{\"1\":{\"868\":1}}],[\"经理就让她们接着休息\",{\"1\":{\"868\":1}}],[\"经理一看\",{\"1\":{\"868\":1}}],[\"经理\",{\"1\":{\"861\":1}}],[\"经历了aba变化\",{\"1\":{\"845\":1}}],[\"经过多次复制后达到年龄阈值\",{\"1\":{\"750\":1}}],[\"经过扰动函数处理过后得到\",{\"1\":{\"686\":1}}],[\"经过不同的路由器和网络设备\",{\"1\":{\"593\":1}}],[\"经过了日志处理器\",{\"1\":{\"353\":2,\"354\":2}}],[\"经过调制后的信号被发送到电话线路或者无线信道中\",{\"1\":{\"239\":1}}],[\"经过一段时间后便可将网络中各路由器所获得的距离矢量信息在各路由器上统一起来\",{\"1\":{\"208\":1}}],[\"经济\",{\"1\":{\"212\":1}}],[\"政治\",{\"1\":{\"212\":1}}],[\"度量路由的代价可能不同\",{\"1\":{\"212\":1}}],[\"邻居路由器的链路状态信息\",{\"1\":{\"210\":1}}],[\"中会将竞争共享资源失败的线程添加到一个变体的\",{\"1\":{\"846\":1}}],[\"中会有一些线程执行周期性的任务\",{\"1\":{\"721\":1}}],[\"中文翻译成比较并交换\",{\"1\":{\"845\":1}}],[\"中实现的\",{\"1\":{\"838\":1}}],[\"中用于处理多线程并发访问的关键字\",{\"1\":{\"834\":1}}],[\"中用于排序的接口\",{\"1\":{\"674\":1}}],[\"中最基本的锁机制之一\",{\"1\":{\"832\":1}}],[\"中也给我们提供了一些不可变的一类\",{\"1\":{\"831\":1}}],[\"中断\",{\"1\":{\"809\":1,\"838\":1}}],[\"中断线程\",{\"1\":{\"807\":1}}],[\"中占两个字节\",{\"1\":{\"777\":1}}],[\"中列出的可能原因做排除法\",{\"1\":{\"768\":1}}],[\"中成功拯救自己\",{\"1\":{\"736\":1}}],[\"中引入的一种线程安全的累加器\",{\"1\":{\"855\":1}}],[\"中引入了折扣策略\",{\"1\":{\"465\":1}}],[\"中引用的对象\",{\"1\":{\"734\":1}}],[\"中可作为\",{\"0\":{\"734\":1},\"1\":{\"734\":1}}],[\"中非常频繁\",{\"1\":{\"730\":1}}],[\"中对象的创建\",{\"1\":{\"726\":1}}],[\"中增加了一个双向链表来维护顺序\",{\"1\":{\"714\":1}}],[\"中有\",{\"1\":{\"708\":1}}],[\"中都存在\",{\"1\":{\"707\":1}}],[\"中键的插入和查询操作可能在一定程度上符合这种分布\",{\"1\":{\"696\":1}}],[\"中不能存储重复元素\",{\"1\":{\"683\":1}}],[\"中添加元素时\",{\"1\":{\"683\":1}}],[\"中传输\",{\"1\":{\"619\":1}}],[\"中使用的逻辑地址\",{\"1\":{\"574\":1}}],[\"中使用的硬件地址\",{\"1\":{\"574\":1}}],[\"中\",{\"0\":{\"813\":1},\"1\":{\"500\":1,\"525\":1,\"687\":2,\"707\":2,\"712\":1,\"713\":1,\"714\":1,\"715\":1,\"747\":1,\"754\":1,\"758\":1,\"787\":1,\"793\":1,\"813\":2,\"824\":1,\"827\":1,\"831\":1,\"835\":2}}],[\"中提取前缀\",{\"1\":{\"422\":1,\"436\":1}}],[\"中介者对象可能变得复杂\",{\"1\":{\"410\":1}}],[\"中介者对象可能会变得复杂\",{\"1\":{\"410\":1}}],[\"中介者负责将消息传递给目标用户\",{\"1\":{\"409\":1}}],[\"中介者负责将消息传递给目标飞机\",{\"1\":{\"403\":1,\"404\":1}}],[\"中介者将消息传递给其他用户\",{\"1\":{\"408\":1}}],[\"中介者将负责将消息传递给目标用户\",{\"1\":{\"405\":1}}],[\"中介者设计模式侧重于集中处理对象之间的通信和交互逻辑\",{\"1\":{\"411\":1}}],[\"中介者设计模式中\",{\"1\":{\"411\":1}}],[\"中介者设计模式的目的是简化对象之间的通信和交互\",{\"1\":{\"411\":1}}],[\"中介者设计模式适用于对象之间存在复杂的交互和通信关系的场景\",{\"1\":{\"411\":1}}],[\"中介者设计模式关注的是将多个对象之间的通信和交互逻辑集中处理\",{\"1\":{\"411\":1}}],[\"中介者设计模式\",{\"1\":{\"411\":1}}],[\"中介者设计模式和观察者设计模式是两种不同的设计模式\",{\"1\":{\"411\":1}}],[\"中介者设计模式通过引入中介者对象\",{\"1\":{\"410\":1}}],[\"中介者设计模式可以用于管理用户之间的消息传递\",{\"1\":{\"405\":1}}],[\"中介者设计模式在真实业务场景中经常用于处理复杂的对象间通信和交互关系\",{\"1\":{\"405\":1}}],[\"中介者模式\",{\"1\":{\"490\":1}}],[\"中介者模式旨在降低对象之间的耦合性\",{\"1\":{\"411\":1}}],[\"中介者模式可以简化多个对象之间的通信和交互\",{\"1\":{\"410\":1}}],[\"中介者模式可以用于处理更复杂的对象间通信和交互\",{\"1\":{\"403\":1,\"408\":1}}],[\"中介者模式的核心是\",{\"1\":{\"404\":1,\"409\":1}}],[\"中介者接口\",{\"1\":{\"403\":1,\"408\":1}}],[\"中介者\",{\"1\":{\"400\":1}}],[\"中介设计模式是一种有助于降低对象之间直接通信复杂性的设计模式\",{\"1\":{\"410\":1}}],[\"中介设计模式适用于以下场景\",{\"1\":{\"405\":1}}],[\"中介设计模式的基本流程如下\",{\"1\":{\"400\":1}}],[\"中介设计模式的组成主要包括以下几个元素\",{\"1\":{\"400\":1}}],[\"中介设计模式的核心思想是引入一个中介者对象\",{\"1\":{\"399\":1}}],[\"中介设计模式\",{\"0\":{\"397\":1},\"1\":{\"398\":1}}],[\"中国电信\",{\"1\":{\"249\":1}}],[\"中国移动\",{\"1\":{\"249\":1}}],[\"中继器\",{\"1\":{\"240\":1,\"618\":1}}],[\"中继站把前一阵送来的信号经过放大后再发送到下一站\",{\"1\":{\"230\":1}}],[\"中的队列是\",{\"1\":{\"846\":1}}],[\"中的存储空间\",{\"1\":{\"816\":1}}],[\"中的线程中断是一种线程间的协作模式\",{\"1\":{\"807\":1}}],[\"中的代码一定会执行吗\",{\"0\":{\"796\":1},\"1\":{\"796\":2}}],[\"中的hashmap\",{\"1\":{\"785\":1}}],[\"中的引用有四种\",{\"1\":{\"735\":1}}],[\"中的字符串常量池具有重用相同字符串的特性\",{\"1\":{\"722\":1}}],[\"中的垃圾回收器会有多个线程\",{\"1\":{\"721\":1}}],[\"中的tablesizefor\",{\"1\":{\"706\":1}}],[\"中的两种不同的\",{\"1\":{\"705\":2,\"706\":1}}],[\"中的加载因子\",{\"1\":{\"696\":1}}],[\"中的键和值都可以为\",{\"1\":{\"687\":1}}],[\"中的常数项\",{\"1\":{\"316\":1}}],[\"中的打印操作需要循环\",{\"1\":{\"316\":2}}],[\"中的\",{\"1\":{\"240\":1,\"465\":1,\"683\":2,\"712\":1,\"839\":1}}],[\"中间不会被其他线程打断\",{\"1\":{\"814\":1}}],[\"中间不能有障碍物\",{\"1\":{\"230\":1}}],[\"中间放着一个指针作为分界点的指示器\",{\"1\":{\"727\":1}}],[\"中间计算过程和其他数据\",{\"1\":{\"724\":1}}],[\"中间层的引入使得系统的模块职责更加清晰\",{\"1\":{\"489\":1}}],[\"中间没有经过任何其他设备\",{\"1\":{\"275\":1}}],[\"中间没有任何其他交换结点\",{\"1\":{\"119\":1}}],[\"中发送回去\",{\"1\":{\"210\":1}}],[\"给冲突元素找个空位\",{\"1\":{\"692\":1}}],[\"给谁做代理\",{\"1\":{\"498\":1}}],[\"给定\",{\"1\":{\"316\":1}}],[\"给定三个算法\",{\"1\":{\"316\":1}}],[\"给tcp\",{\"1\":{\"279\":1}}],[\"给邻居路由器发送数据库描述分组\",{\"1\":{\"210\":1}}],[\"给数据帧加上传输序列号等\",{\"1\":{\"120\":1}}],[\"带来的安全性是最直接最纯粹的\",{\"1\":{\"831\":1}}],[\"带来的好处就是\",{\"1\":{\"819\":1}}],[\"带冲突检测的载波侦听多路访问\",{\"1\":{\"578\":1}}],[\"带宽关注的是频率范围的宽度\",{\"1\":{\"620\":1,\"621\":1}}],[\"带宽也可指代在单位时间内传输的数据量或信息量\",{\"1\":{\"620\":1}}],[\"带宽指的是信号传输过程中所占用的频率范围或信号所能传输的最大频率范围\",{\"1\":{\"620\":1}}],[\"带宽1\",{\"1\":{\"262\":1}}],[\"带宽在计算机网络中的意义\",{\"1\":{\"261\":1}}],[\"带宽在摸拟信号系统中的意义\",{\"1\":{\"261\":1}}],[\"带宽\",{\"0\":{\"261\":1},\"1\":{\"264\":1,\"620\":2}}],[\"带宽等\",{\"1\":{\"210\":1}}],[\"带通\",{\"1\":{\"240\":3}}],[\"带通和低通描述了信道允许通过的频率范围\",{\"1\":{\"240\":1}}],[\"带通和低通\",{\"1\":{\"240\":1}}],[\"带确认无连接\",{\"1\":{\"158\":1}}],[\"费用\",{\"1\":{\"210\":1}}],[\"该状态表示线程池彻底终止\",{\"1\":{\"867\":1}}],[\"该状态表明所有的任务已经运行终止\",{\"1\":{\"867\":1}}],[\"该状态的线程不会接收新任务\",{\"1\":{\"867\":1}}],[\"该状态的线程池不会接收新任务\",{\"1\":{\"867\":1}}],[\"该状态的线程池会接收新任务\",{\"1\":{\"867\":1}}],[\"该状态不同于\",{\"1\":{\"808\":1}}],[\"该操作会阻塞进程\",{\"1\":{\"853\":1}}],[\"该资源任意一个时刻只由一个线程占用\",{\"1\":{\"848\":1}}],[\"该线程可以继续获取读锁\",{\"1\":{\"842\":1}}],[\"该线程不能取得写锁\",{\"1\":{\"842\":1}}],[\"该对象或资源仍然能够表现出正确的行为\",{\"1\":{\"814\":1}}],[\"该字符串在内存中存放位置\",{\"1\":{\"777\":1}}],[\"该结构被称为记忆集\",{\"1\":{\"742\":1}}],[\"该结构存储所有景点的引用\",{\"1\":{\"372\":1}}],[\"该文件用于配置编译工程的命令行参数\",{\"1\":{\"539\":1}}],[\"该文件用于描述java代码的混淆规则\",{\"1\":{\"539\":1}}],[\"该文件配置了需要编译哪些模块\",{\"1\":{\"539\":1}}],[\"该文件分为项目级与模块级两种\",{\"1\":{\"539\":1}}],[\"该系统涉及不同类型的商品\",{\"1\":{\"506\":1}}],[\"该代理处理器类负责处理代理对象的方法调用\",{\"1\":{\"497\":1}}],[\"该接口声明了对于组合对象和叶子对象的通用操作\",{\"1\":{\"524\":1}}],[\"该接口是被代理类和代理类共同实现的接口\",{\"1\":{\"496\":1}}],[\"该接口定义了用户参与聊天的方法\",{\"1\":{\"407\":1}}],[\"该接口定义了消息传递的方法\",{\"1\":{\"407\":1}}],[\"该接口定义了飞机参与交通管制系统的方法\",{\"1\":{\"402\":1}}],[\"该接口定义了飞机之间的通信方法\",{\"1\":{\"402\":1}}],[\"该接口定义了解释器的解释方法\",{\"1\":{\"393\":1}}],[\"该类将整数值与引用关联起来\",{\"1\":{\"847\":1}}],[\"该类将\",{\"1\":{\"847\":1}}],[\"该类加载器在此目录里面查找并加载\",{\"1\":{\"756\":1}}],[\"该类所在的classloader已经被回收\",{\"1\":{\"733\":1}}],[\"该类的class对象没有被引用\",{\"1\":{\"733\":1}}],[\"该类的所有实例都已经被回收\",{\"1\":{\"733\":1}}],[\"该类包含一个指向商品和销售渠道的引用\",{\"1\":{\"506\":1}}],[\"该类中包含对方法的增强逻辑\",{\"1\":{\"496\":1}}],[\"该类封装了运行时的环境\",{\"1\":{\"419\":2}}],[\"该类负责创建自己的唯一实例\",{\"1\":{\"418\":1}}],[\"该类实现了参与者接口\",{\"1\":{\"402\":1,\"407\":1}}],[\"该类实现了中介者接口\",{\"1\":{\"402\":1,\"407\":1}}],[\"该类表示规则引擎中的非终结符\",{\"1\":{\"393\":1}}],[\"该类表示规则引擎中的终结符\",{\"1\":{\"393\":1}}],[\"该规则引擎将支持基本的比较操作\",{\"1\":{\"392\":1}}],[\"该设计模式可以使得景点的结构保持稳定\",{\"1\":{\"372\":1}}],[\"该方法如果发现当前线程被中断\",{\"1\":{\"807\":1}}],[\"该方法接收三个参数\",{\"1\":{\"496\":1}}],[\"该方法接收一个\",{\"1\":{\"422\":1}}],[\"该方法会创建一个新的playlist对象\",{\"1\":{\"454\":1}}],[\"该方法将具体的访问者作为参数\",{\"1\":{\"372\":1}}],[\"该方法定义了读取输入流中数据的基本流程\",{\"1\":{\"335\":1}}],[\"该模式允许我们将对象组合成树状结构\",{\"1\":{\"526\":1}}],[\"该模式允许在不改变算法结构的情况下\",{\"1\":{\"330\":1}}],[\"该模式通过创建一个包装器\",{\"1\":{\"501\":1}}],[\"该模式的目标是简化对象的构建过程\",{\"1\":{\"446\":1}}],[\"该模式的核心思想是解耦发布者和订阅者之间的直接依赖关系\",{\"1\":{\"326\":1}}],[\"该尾部的作用是让目的主机检查所接收到的帧是否有误码\",{\"1\":{\"268\":1}}],[\"该首部的作用主要是为了让帧能够在一段链路上或一个网络上传输\",{\"1\":{\"268\":1}}],[\"该链路的度量\",{\"1\":{\"210\":1}}],[\"该链路的端口开销\",{\"1\":{\"210\":1}}],[\"该链路上的所有的相邻路由器\",{\"1\":{\"210\":1}}],[\"该协议中为ip地址\",{\"1\":{\"191\":1}}],[\"该协议是无连接的服务\",{\"1\":{\"189\":1}}],[\"子线程await\",{\"1\":{\"851\":1}}],[\"子线程countdown\",{\"1\":{\"851\":1}}],[\"子线程\",{\"1\":{\"822\":2}}],[\"子加载器才会尝试自己去完成加载\",{\"1\":{\"758\":1}}],[\"子系统的变更不会影响到客户端的代码\",{\"1\":{\"519\":1}}],[\"子系统\",{\"1\":{\"518\":3}}],[\"子系统可以包含多个组件\",{\"1\":{\"516\":1}}],[\"子系统组件\",{\"1\":{\"516\":1}}],[\"子类在首次被访问时\",{\"1\":{\"755\":1}}],[\"子类有不同的实现\",{\"1\":{\"573\":1}}],[\"子类必须遵循父类的行为约定\",{\"1\":{\"470\":1}}],[\"子类必须提供具体的输入流的打开\",{\"1\":{\"335\":1}}],[\"子类对象可以完全替换父类对象\",{\"1\":{\"470\":1}}],[\"子类\",{\"1\":{\"468\":1}}],[\"子类都要实现的方法\",{\"1\":{\"436\":1}}],[\"子类可以复用父类的方法\",{\"1\":{\"782\":1}}],[\"子类可以通过实现抽象方法来覆盖或添加特定步骤\",{\"1\":{\"339\":1}}],[\"子类可以根据需要重写父类中的方法\",{\"1\":{\"330\":1}}],[\"子类继承抽象类\",{\"1\":{\"332\":1}}],[\"子网的大小取决于所需的主机数量\",{\"1\":{\"596\":1}}],[\"子网的作用是指示ip地址中哪些位用于网络标识和哪些位用于主机标识\",{\"1\":{\"596\":1}}],[\"子网划分\",{\"1\":{\"222\":1}}],[\"子网掩码决定了网络部分和主机部分的划分\",{\"1\":{\"596\":1}}],[\"子网掩码是用于划分网络中的主机和子网的重要工具\",{\"1\":{\"595\":1}}],[\"子网掩码是一种用于指示一个ip地址的哪部分用于网络标识\",{\"1\":{\"595\":1}}],[\"子网掩码用于确定数据包的目标网络和主机\",{\"1\":{\"595\":1}}],[\"子网掩码也与ip地址的分类相关\",{\"1\":{\"595\":1}}],[\"子网掩码允许网络管理员将一个网络划分为多个子网\",{\"1\":{\"595\":1}}],[\"子网掩码通过在ip地址中指示哪些位用于网络标识和哪些位用于主机标识\",{\"1\":{\"595\":1}}],[\"子网掩码后两位表示借用的比特位\",{\"1\":{\"218\":1}}],[\"子网掩码255\",{\"1\":{\"218\":1}}],[\"子网掩码为255\",{\"1\":{\"218\":1}}],[\"子网掩码使用连续的比特1来对应网络号和子网号\",{\"1\":{\"218\":1}}],[\"子网掩码中的\",{\"1\":{\"216\":1}}],[\"子网掩码介绍\",{\"0\":{\"216\":1}}],[\"子网掩码\",{\"1\":{\"210\":1,\"216\":1}}],[\"子层\",{\"1\":{\"158\":1}}],[\"子层和媒体接入控制\",{\"1\":{\"158\":1}}],[\"触发更新\",{\"1\":{\"209\":1}}],[\"表明这是该类的⼀个静态资源\",{\"1\":{\"833\":1}}],[\"表明实现该接口的类支持随机访问\",{\"1\":{\"677\":1}}],[\"表中\",{\"1\":{\"579\":1}}],[\"表面调用的是老的支付接口\",{\"1\":{\"510\":1}}],[\"表\",{\"1\":{\"208\":1}}],[\"表示锁被某个线程持有\",{\"1\":{\"839\":1}}],[\"表示锁是自由的\",{\"1\":{\"839\":1}}],[\"表示锁的占用情况\",{\"1\":{\"839\":1}}],[\"表示使用非公平锁\",{\"1\":{\"839\":1}}],[\"表示使用公平锁\",{\"1\":{\"839\":1}}],[\"表示抢锁失败\",{\"1\":{\"837\":1}}],[\"表示进入偏向锁状态\",{\"1\":{\"837\":1}}],[\"表示进⼊同步代码前要获得\",{\"1\":{\"833\":1}}],[\"表示进⼊同步代码库前要获得给定对象的锁\",{\"1\":{\"833\":1}}],[\"表示进行了删除操作的日志记录\",{\"1\":{\"497\":1}}],[\"表示当一个线程修改了共享变量的值时\",{\"1\":{\"814\":1}}],[\"表示当前线程已经执行完毕\",{\"1\":{\"808\":1}}],[\"表示当前状态下的行为\",{\"1\":{\"359\":1}}],[\"表示线程a已经获得了这个偏向锁\",{\"1\":{\"837\":1}}],[\"表示线程进入等待状态\",{\"1\":{\"808\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"808\":1}}],[\"表示java虚拟机发现了内部错误或不一致性\",{\"1\":{\"793\":1}}],[\"表示一个对象具有多种的状态\",{\"1\":{\"782\":1}}],[\"表示年轻代和年老代比值为\",{\"1\":{\"764\":1}}],[\"表示对象已经被访问\",{\"1\":{\"748\":2}}],[\"表示对象尚未被访问\",{\"1\":{\"748\":1}}],[\"表示对象在该状态下的行为\",{\"1\":{\"358\":1}}],[\"表示没有对象或没有引用\",{\"1\":{\"712\":1}}],[\"表示数据的类型\",{\"1\":{\"575\":1}}],[\"表示数据部分为ncp分组\",{\"1\":{\"131\":1}}],[\"表示数据部分为lcp分组\",{\"1\":{\"131\":1}}],[\"表示数据部分为1p数据报\",{\"1\":{\"131\":1}}],[\"表示发送方的mac地址\",{\"1\":{\"575\":1}}],[\"表示发件人地址合法\",{\"1\":{\"94\":1}}],[\"表示只编译app模块\",{\"1\":{\"539\":1}}],[\"表示只能有一个实例的类\",{\"1\":{\"418\":1}}],[\"表示需要被共享的对象\",{\"1\":{\"530\":1}}],[\"表示树状结构中的叶子节点\",{\"1\":{\"525\":1}}],[\"表示树状结构中的叶子节点和组合节点\",{\"1\":{\"525\":1}}],[\"表示组合中的容器节点\",{\"1\":{\"526\":1}}],[\"表示组合中的叶子节点\",{\"1\":{\"526\":1}}],[\"表示组合中的叶子对象\",{\"1\":{\"524\":1}}],[\"表示组合中的组合对象\",{\"1\":{\"524\":1}}],[\"表示实际执行工作的各个组件或类\",{\"1\":{\"516\":1}}],[\"表示实际的飞机\",{\"1\":{\"402\":1}}],[\"表示动物\",{\"1\":{\"469\":1}}],[\"表示最终构建完成的对象\",{\"1\":{\"448\":1}}],[\"表示具体的产品对象\",{\"1\":{\"434\":1}}],[\"表示聊天应用中的用户\",{\"1\":{\"407\":1,\"409\":1}}],[\"表示飞机\",{\"1\":{\"404\":1}}],[\"表示大于和小于条件\",{\"1\":{\"395\":1}}],[\"表示语法规则中的非终结符\",{\"1\":{\"390\":1}}],[\"表示语法规则中的终结符\",{\"1\":{\"390\":1}}],[\"表示状态a和状态b下的行为\",{\"1\":{\"359\":1}}],[\"表示除法\",{\"1\":{\"343\":1,\"346\":1}}],[\"表示函数t\",{\"1\":{\"316\":1}}],[\"表示\",{\"1\":{\"316\":1,\"422\":1,\"764\":1}}],[\"表示在不收到确认信息的情况下可以发送的数据量\",{\"1\":{\"297\":1}}],[\"表示层和应用层\",{\"1\":{\"268\":1}}],[\"表示了声音的波形\",{\"1\":{\"239\":1}}],[\"表示多播地址\",{\"1\":{\"166\":1}}],[\"表示单播地址\",{\"1\":{\"166\":1}}],[\"表示本地管理\",{\"1\":{\"166\":1}}],[\"表示全球管理\",{\"1\":{\"166\":1}}],[\"表示封装的是哪个网络层协议包表示ppp帧的定界符\",{\"1\":{\"131\":1}}],[\"表示文档没有发生变化\",{\"1\":{\"114\":1}}],[\"表示接受请求并主动断开连接\",{\"1\":{\"94\":1}}],[\"表示邮件接收成功\",{\"1\":{\"94\":1}}],[\"表示准备好接收邮件内容\",{\"1\":{\"94\":1}}],[\"表示收件人地址合法\",{\"1\":{\"94\":1}}],[\"表示服务就绪\",{\"1\":{\"94\":1}}],[\"距离\",{\"1\":{\"208\":1,\"210\":1}}],[\"距离向量算法\",{\"1\":{\"206\":1}}],[\"增量更新\",{\"1\":{\"746\":1}}],[\"增强对象的功能\",{\"1\":{\"500\":1}}],[\"增强了代码的可读性\",{\"1\":{\"361\":2}}],[\"增强了代码的灵活性和可扩展性\",{\"1\":{\"355\":1}}],[\"增强可读性\",{\"1\":{\"361\":1}}],[\"增大呈线性增长\",{\"1\":{\"316\":1}}],[\"增加很快\",{\"1\":{\"769\":1}}],[\"增加\",{\"1\":{\"679\":1,\"709\":1}}],[\"增加系统的复杂性\",{\"1\":{\"385\":1}}],[\"增加系统的功能性\",{\"1\":{\"385\":1}}],[\"增加系统的灵活性和可扩展性\",{\"1\":{\"383\":1}}],[\"增加新的判断逻辑\",{\"1\":{\"465\":1}}],[\"增加新的实例需要对现有代码进行修改\",{\"1\":{\"421\":1}}],[\"增加新的操作和功能\",{\"1\":{\"373\":1}}],[\"增加新的路由\",{\"1\":{\"212\":1}}],[\"增加代码复杂性\",{\"1\":{\"361\":1}}],[\"增加代码的可读性和可维护性\",{\"1\":{\"345\":1}}],[\"增加类的数量\",{\"1\":{\"345\":1}}],[\"增加了一些高级功能\",{\"1\":{\"843\":1}}],[\"增加了一个双向链表来维护元素的顺序\",{\"1\":{\"715\":1}}],[\"增加了适应性自旋\",{\"1\":{\"843\":1}}],[\"增加了轮询\",{\"1\":{\"838\":1}}],[\"增加了哈希冲突的概率\",{\"1\":{\"696\":1}}],[\"增加了网络中的冲突和干扰\",{\"1\":{\"580\":1}}],[\"增加了网络的负担\",{\"1\":{\"296\":1}}],[\"增加了额外的功能或责任\",{\"1\":{\"501\":1}}],[\"增加了测试的工作量\",{\"1\":{\"465\":1}}],[\"增加了对象之间的耦合性\",{\"1\":{\"421\":1}}],[\"增加了系统的灵活性和可维护性\",{\"1\":{\"379\":1}}],[\"增加了系统的灵活性和可扩展性\",{\"1\":{\"328\":1}}],[\"增加了系统复杂性\",{\"1\":{\"373\":1}}],[\"增加了访问者类和元素类的数量\",{\"1\":{\"373\":1}}],[\"增加了迭代器类的数量\",{\"1\":{\"367\":1}}],[\"增加了代码的灵活性和可扩展性\",{\"1\":{\"470\":1}}],[\"增加了代码的灵活性和可维护性\",{\"1\":{\"367\":1}}],[\"增加了代码的复杂度\",{\"1\":{\"437\":1}}],[\"增加了代码的复杂性和维护成本\",{\"1\":{\"469\":1}}],[\"增加了代码的复杂性\",{\"1\":{\"339\":1,\"533\":1}}],[\"增加了代码的复用性\",{\"1\":{\"328\":1}}],[\"增加了子类的实现复杂性和代码的理解难度\",{\"1\":{\"339\":1}}],[\"增加了维护成本\",{\"1\":{\"327\":1}}],[\"增加网络空闲时间\",{\"1\":{\"291\":1}}],[\"增加网络负担\",{\"1\":{\"206\":1}}],[\"增删改查\",{\"1\":{\"83\":1}}],[\"按fifo排序任务\",{\"1\":{\"862\":1}}],[\"按fifo排序量\",{\"1\":{\"862\":1}}],[\"按某一顺序申请资源\",{\"1\":{\"848\":1}}],[\"按原大小的1\",{\"1\":{\"677\":1}}],[\"按特定的排队规则来确定先后顺序\",{\"1\":{\"671\":1}}],[\"按照垃圾收集角度\",{\"1\":{\"737\":1}}],[\"按照虚拟机规范\",{\"1\":{\"722\":1}}],[\"按照字节码指令逐行执行\",{\"1\":{\"720\":1}}],[\"按照一定的顺序构建电脑对象\",{\"1\":{\"448\":1}}],[\"按照一定的顺序调用builder的方法来构建对象\",{\"1\":{\"448\":1}}],[\"按照特定的顺序构建对象\",{\"1\":{\"448\":1}}],[\"按照算法优化出路由表\",{\"1\":{\"206\":1}}],[\"按下按钮\",{\"1\":{\"383\":1}}],[\"按序到达但尚未被接受应用程序读取的数据\",{\"1\":{\"282\":1}}],[\"按序到达\",{\"1\":{\"184\":2,\"282\":1}}],[\"特别适用于需要创建大量相似对象的情况\",{\"1\":{\"528\":1}}],[\"特别是公用资源有限的应用场景\",{\"1\":{\"853\":1}}],[\"特别是复合操作\",{\"1\":{\"834\":1}}],[\"特别是当需要处理树状结构的对象时\",{\"1\":{\"526\":1}}],[\"特别是对于现代复杂的网页和应用程序来说\",{\"1\":{\"113\":1}}],[\"特别是在高度竞争情况下\",{\"1\":{\"855\":1}}],[\"特别是在多个web应用程序同时运行的情况下\",{\"1\":{\"759\":1}}],[\"特别是在项目管理或任务追踪中\",{\"1\":{\"375\":1}}],[\"特别是在复杂网络环境中\",{\"1\":{\"222\":1}}],[\"特别是在发送大量的请求头信息时\",{\"1\":{\"113\":1}}],[\"特别是在大型网络环境下\",{\"1\":{\"62\":1}}],[\"特别是万维网服务器往往要同时服务于大量客户的请求\",{\"1\":{\"111\":1}}],[\"特点\",{\"1\":{\"312\":2,\"719\":1}}],[\"特性\",{\"1\":{\"227\":1}}],[\"特定主机路由\",{\"1\":{\"205\":1}}],[\"让一\",{\"1\":{\"852\":1}}],[\"让线程在预期的时间内执行\",{\"1\":{\"813\":1}}],[\"让其他线程占用\",{\"1\":{\"809\":1}}],[\"让出优先权\",{\"1\":{\"807\":1}}],[\"让市场部门内部的设备可以相互通信\",{\"1\":{\"579\":1}}],[\"让设备完成\",{\"1\":{\"573\":1}}],[\"让我对代码进行修正和整理\",{\"1\":{\"870\":1}}],[\"让我们看看遵循迪米特法则的情况下的代码\",{\"1\":{\"489\":1}}],[\"让我们看一下如果不遵循单一责任原则会发生什么\",{\"1\":{\"461\":1}}],[\"让我们以动物类的例子来说明里氏替换原则的好处和坏处\",{\"1\":{\"469\":1}}],[\"让我们使用java来举一个例子\",{\"1\":{\"454\":1}}],[\"让我们结合生活中的一个例子来说明这两种设计模式的区别\",{\"1\":{\"452\":1}}],[\"让我用白话点来解释\",{\"1\":{\"361\":1}}],[\"让对象能够回到之前的状态\",{\"1\":{\"378\":1}}],[\"让代码更易于维护和调试\",{\"1\":{\"361\":1}}],[\"让代码结构更加清晰\",{\"1\":{\"361\":1}}],[\"让它们实现新的`serializer`接口\",{\"1\":{\"346\":1}}],[\"让发送方的发送速率不要太快\",{\"1\":{\"293\":1}}],[\"让路由器记录收到某特定路由信息的接口\",{\"1\":{\"209\":1}}],[\"让该设备决定如何处理这个数据包\",{\"1\":{\"205\":1}}],[\"让主机知道下次应将数据报发送给另外的路由器\",{\"1\":{\"201\":1}}],[\"拓展性强的\",{\"1\":{\"458\":1}}],[\"拓展\",{\"0\":{\"240\":1,\"337\":1},\"1\":{\"205\":1,\"316\":1}}],[\"拓扑变化不大的网络\",{\"1\":{\"205\":1}}],[\"拓扑结构\",{\"1\":{\"121\":1,\"157\":1}}],[\"优先使用自己的\",{\"1\":{\"759\":1}}],[\"优先扩容\",{\"1\":{\"690\":1}}],[\"优先级队列\",{\"1\":{\"862\":1}}],[\"优先级\",{\"1\":{\"575\":1}}],[\"优先级越低越优先\",{\"1\":{\"175\":1}}],[\"优化代码\",{\"1\":{\"767\":1}}],[\"优化和监控\",{\"1\":{\"720\":1}}],[\"优化\",{\"1\":{\"685\":1,\"686\":1}}],[\"优缺点\",{\"1\":{\"312\":2}}],[\"优点和缺点\",{\"1\":{\"253\":1,\"254\":1,\"255\":1,\"430\":1,\"495\":1,\"496\":1}}],[\"优点\",{\"1\":{\"205\":1,\"206\":1,\"253\":1,\"254\":1,\"255\":1,\"312\":2,\"339\":1,\"361\":1,\"367\":1,\"373\":1,\"379\":1,\"385\":1,\"396\":1,\"410\":1,\"421\":1,\"430\":1,\"444\":1,\"495\":1,\"496\":1,\"500\":1,\"519\":1,\"526\":1,\"533\":1,\"751\":1}}],[\"非核心线程闲置下来不干活最多存活时间\",{\"1\":{\"860\":1}}],[\"非核心线程\",{\"1\":{\"860\":1}}],[\"非核心线程数+核心线程数\",{\"1\":{\"860\":1}}],[\"非公平锁让获取锁的时间变得更加不确定\",{\"1\":{\"840\":1}}],[\"非公平锁会有更好的性能\",{\"1\":{\"840\":1}}],[\"非公平锁会直接\",{\"1\":{\"840\":1}}],[\"非公平锁在\",{\"1\":{\"840\":1}}],[\"非公平锁在调用\",{\"1\":{\"840\":1}}],[\"非公平锁和公平锁的两处不同\",{\"1\":{\"840\":1}}],[\"非公平锁允许线程插队\",{\"1\":{\"839\":1}}],[\"非公平锁\",{\"1\":{\"839\":2}}],[\"非阻塞同步的实现方式通常涉及\",{\"1\":{\"831\":1}}],[\"非阻塞同步\",{\"1\":{\"831\":1}}],[\"非\",{\"1\":{\"747\":1,\"827\":1}}],[\"非关系型数据库\",{\"0\":{\"544\":1}}],[\"非常抱歉前面的回答中有些遗漏\",{\"1\":{\"450\":1}}],[\"非终结符表达式\",{\"1\":{\"390\":3,\"394\":2}}],[\"非主导项使用大o计数法表示\",{\"1\":{\"316\":1}}],[\"非线性数据结构中的元素不是按照序列排列的\",{\"1\":{\"311\":1}}],[\"非线性数据结构\",{\"1\":{\"311\":1}}],[\"非导引型传输媒体\",{\"1\":{\"230\":1}}],[\"非自适应路由算法\",{\"1\":{\"205\":1}}],[\"非目标主机直接传走\",{\"1\":{\"153\":1}}],[\"信息\",{\"1\":{\"769\":1}}],[\"信息经过r1时\",{\"1\":{\"201\":1}}],[\"信噪比等因素之间的关系\",{\"1\":{\"622\":1}}],[\"信噪比=10∗log10​\",{\"1\":{\"240\":1}}],[\"信用卡支付\",{\"1\":{\"344\":1}}],[\"信号量本质上是一个计数器\",{\"1\":{\"853\":1}}],[\"信号量机制操作系统中用于实现进程同步和互斥的重要工具\",{\"1\":{\"853\":1}}],[\"信号量\",{\"1\":{\"853\":1}}],[\"信号分发线程\",{\"1\":{\"721\":1}}],[\"信号所占用的频率范围或单位时间内传输的数据量\",{\"1\":{\"620\":1}}],[\"信号所包含的各种不同频率成分所占据的频率范围\",{\"1\":{\"261\":1}}],[\"信号通过传输媒体到达web服务器\",{\"1\":{\"268\":1}}],[\"信号通过传输媒体到达路由器\",{\"1\":{\"268\":1}}],[\"信号通过信道传输\",{\"1\":{\"238\":1}}],[\"信号传输距离\",{\"1\":{\"240\":1}}],[\"信号的频谱可以是连续的\",{\"1\":{\"620\":1}}],[\"信号的极限容量\",{\"1\":{\"240\":1}}],[\"信号的传输方式管理\",{\"1\":{\"229\":1}}],[\"信号可以为电\",{\"1\":{\"238\":1}}],[\"信号\",{\"1\":{\"235\":2,\"238\":2}}],[\"信道预约\",{\"1\":{\"152\":1}}],[\"信道划分介质控制\",{\"0\":{\"145\":1}}],[\"信道划分介质访问控制\",{\"1\":{\"144\":1}}],[\"信道\",{\"1\":{\"144\":1}}],[\"信道利用率较低\",{\"1\":{\"137\":1}}],[\"除此之外\",{\"1\":{\"825\":1}}],[\"除留取余法\",{\"1\":{\"691\":1}}],[\"除数不能为零\",{\"1\":{\"343\":1,\"346\":1}}],[\"除法策略\",{\"1\":{\"343\":1,\"346\":1}}],[\"除去常数\",{\"1\":{\"316\":1}}],[\"除丢弃该ip数据报外\",{\"1\":{\"201\":1}}],[\"除了互斥量本身开销\",{\"1\":{\"837\":1}}],[\"除了原子性\",{\"0\":{\"836\":1}}],[\"除了在加载阶段用户应用程序可以通过自定义类加载器参与之外\",{\"1\":{\"754\":1}}],[\"除了程序计数器外\",{\"1\":{\"731\":1}}],[\"除了第一个和最后一个元素外\",{\"1\":{\"311\":1}}],[\"除了必须建立一条物理线路\",{\"1\":{\"119\":1}}],[\"除了ip地址\",{\"1\":{\"62\":1}}],[\"时被阻塞\",{\"1\":{\"852\":1}}],[\"时为非公平锁\",{\"1\":{\"838\":1}}],[\"时为公平锁\",{\"1\":{\"838\":1}}],[\"时钟部件会以固定的时间间隔\",{\"1\":{\"809\":1}}],[\"时钟中断一一由时钟部件发来的中断信号\",{\"1\":{\"809\":1}}],[\"时没有重写\",{\"1\":{\"788\":3}}],[\"时必须重写\",{\"0\":{\"788\":1},\"1\":{\"788\":2}}],[\"时维护记录数据的正确性\",{\"1\":{\"742\":1}}],[\"时只会改变句柄中的实例数据指针\",{\"1\":{\"730\":1}}],[\"时指定一个合适的初始容量\",{\"1\":{\"685\":1}}],[\"时才会进行日志记录\",{\"1\":{\"497\":1}}],[\"时\",{\"1\":{\"468\":1,\"681\":1,\"686\":1,\"706\":1,\"741\":1,\"742\":1,\"816\":1,\"827\":1,\"845\":1,\"868\":1}}],[\"时比算法\",{\"1\":{\"316\":1}}],[\"时延带宽积\",{\"0\":{\"264\":1},\"1\":{\"264\":2}}],[\"时延时指数据\",{\"1\":{\"263\":1}}],[\"时延\",{\"0\":{\"263\":1},\"1\":{\"263\":1}}],[\"时延小所以实时性强\",{\"1\":{\"253\":1}}],[\"时间等信息\",{\"1\":{\"766\":1}}],[\"时间优势是建立在逻辑分代上\",{\"1\":{\"749\":1}}],[\"时间增长趋势\",{\"1\":{\"316\":1}}],[\"时间复杂度是\",{\"1\":{\"677\":6,\"678\":6}}],[\"时间复杂度也存在一定的局限性\",{\"1\":{\"316\":1}}],[\"时间复杂度的推算方法更简便\",{\"1\":{\"316\":1}}],[\"时间复杂度的特点\",{\"1\":{\"316\":1}}],[\"时间复杂度能够有效评估算法效率\",{\"1\":{\"316\":1}}],[\"时间复杂度\",{\"0\":{\"314\":1},\"1\":{\"316\":2,\"698\":1}}],[\"时间复杂度和空间复杂度\",{\"1\":{\"313\":1}}],[\"时间戳请求和回答\",{\"1\":{\"201\":1}}],[\"时间超过\",{\"1\":{\"201\":1}}],[\"时分多路复用\",{\"0\":{\"148\":1},\"1\":{\"144\":1}}],[\"回收的过程日志信息\",{\"1\":{\"764\":1}}],[\"回收的一个预期时间等等进行评估得到一个指数\",{\"1\":{\"749\":1}}],[\"回收过程\",{\"1\":{\"751\":1}}],[\"回收价值就是说根据region内部垃圾的一个比率\",{\"1\":{\"749\":1}}],[\"回收所有被标记的对象\",{\"1\":{\"744\":1}}],[\"回收\",{\"1\":{\"731\":2}}],[\"回送请求和回答\",{\"1\":{\"201\":1}}],[\"回答报文\",{\"1\":{\"201\":2}}],[\"回退n帧协议是一种常用的滑动窗口协议\",{\"1\":{\"138\":1}}],[\"回退n帧协议是一种滑动窗口协议\",{\"1\":{\"138\":1}}],[\"回退n帧协议\",{\"0\":{\"138\":1},\"1\":{\"138\":1}}],[\"仅标题\",{\"0\":{\"532\":1}}],[\"仅支持单播传输\",{\"1\":{\"282\":1}}],[\"仅在客户进程运行时才动态选择\",{\"1\":{\"279\":1}}],[\"仅使用icmp差错报告报文\",{\"1\":{\"200\":1}}],[\"仅仅起着占位符的作用\",{\"1\":{\"729\":1}}],[\"仅仅知道ip地址是无法在数据链路层实现传输的\",{\"1\":{\"168\":1,\"583\":1}}],[\"仅仅丢弃有误码的帧\",{\"1\":{\"136\":1}}],[\"指一个线程己经持有了至少一个资源\",{\"1\":{\"848\":1}}],[\"指向持有objectmonitor对象的线程\",{\"1\":{\"835\":1}}],[\"指向对象的类元数据类型\",{\"1\":{\"729\":1}}],[\"指目标是收集整个新生代以及部分老年代的垃圾收集\",{\"1\":{\"738\":1}}],[\"指目标只是老年代的垃圾收集\",{\"1\":{\"738\":1}}],[\"指目标只是新生代的垃圾收集\",{\"1\":{\"738\":1}}],[\"指目标不是完整收集整个\",{\"1\":{\"738\":1}}],[\"指针还没有来的及修改\",{\"1\":{\"728\":1}}],[\"指针就会向右移动一个对象\",{\"1\":{\"728\":1}}],[\"指针碰撞\",{\"1\":{\"727\":2}}],[\"指令本身是能够保证原子性的\",{\"1\":{\"845\":1}}],[\"指令\",{\"1\":{\"845\":1}}],[\"指令包含\",{\"1\":{\"845\":1}}],[\"指令则指向同步代码块的结束位置\",{\"1\":{\"835\":1}}],[\"指令指向同步代码块的开始位置\",{\"1\":{\"835\":1}}],[\"指令级并行的重排序\",{\"1\":{\"826\":1}}],[\"指令重排也是有一些限制的\",{\"1\":{\"826\":1}}],[\"指令重排的限制\",{\"1\":{\"826\":1}}],[\"指令重排就是在执行程序时\",{\"1\":{\"826\":1}}],[\"指令重排有限制吗\",{\"0\":{\"826\":1},\"1\":{\"826\":1}}],[\"指令后\",{\"1\":{\"747\":1}}],[\"指令开始\",{\"1\":{\"726\":1}}],[\"指令空间\",{\"1\":{\"317\":1}}],[\"指的是系统能够按照某种线程推进顺序\",{\"1\":{\"848\":1}}],[\"指的是一个特定的并发问题\",{\"1\":{\"845\":1}}],[\"指的是对于涉及多步骤操作的方法或操作\",{\"1\":{\"814\":1}}],[\"指的是子类可以定义与父类中同名\",{\"1\":{\"780\":1}}],[\"指的是在同一个类中可以定义多个方法\",{\"1\":{\"780\":1}}],[\"指的是数组的长度\",{\"1\":{\"686\":1}}],[\"指的是通道允许低频成分通过\",{\"1\":{\"240\":1}}],[\"指的是通道只允许通过一定范围内的频率成分\",{\"1\":{\"240\":1}}],[\"指出在理想条件下\",{\"1\":{\"622\":1}}],[\"指导着我们在给定的条件下设计更有效的通信系统\",{\"1\":{\"622\":1}}],[\"指导者类控制了建造过程\",{\"1\":{\"448\":1}}],[\"指导者\",{\"1\":{\"448\":1}}],[\"指频谱是指信号在频率上的分布情况\",{\"1\":{\"620\":1}}],[\"指示数据的类型或长度\",{\"1\":{\"575\":1}}],[\"指示接收方的mac地址\",{\"1\":{\"575\":1}}],[\"指定加锁对象\",{\"1\":{\"833\":1}}],[\"指定的睡眠时间到了后该函数会正常返回\",{\"1\":{\"807\":1}}],[\"指定位置删除\",{\"1\":{\"677\":1,\"678\":1}}],[\"指定位置插入\",{\"1\":{\"677\":1,\"678\":1}}],[\"指定控制信息\",{\"1\":{\"575\":1}}],[\"指定活动为启动器\",{\"1\":{\"539\":1}}],[\"指定活动为主要入口点\",{\"1\":{\"539\":1}}],[\"指定目标\",{\"1\":{\"539\":1}}],[\"指定全备份规则\",{\"1\":{\"539\":1}}],[\"指定数据提取规则\",{\"1\":{\"539\":1}}],[\"指定项目所需的外部库和依赖关系\",{\"1\":{\"539\":1}}],[\"指定项目类型为\",{\"1\":{\"539\":1}}],[\"指定源代码和目标代码的兼容性\",{\"1\":{\"539\":1}}],[\"指定\",{\"1\":{\"539\":1}}],[\"指定测试运行器\",{\"1\":{\"539\":1}}],[\"指定编译的\",{\"1\":{\"539\":1}}],[\"指定了数据包应该被发送到目标网络中的一个特定主机\",{\"1\":{\"205\":1}}],[\"指定了当路由表中没有适配的路由信息时\",{\"1\":{\"205\":1}}],[\"指代理类在运行时动态生成\",{\"1\":{\"494\":1}}],[\"指代理类在编译时就已经确定\",{\"1\":{\"494\":1}}],[\"指待办事项列表\",{\"1\":{\"375\":1}}],[\"指数阶常出现于递归函数中\",{\"1\":{\"316\":1}}],[\"指在接收主机的传输层将从网络上接收到的数据流分解成多个上层应用程序的数据流\",{\"1\":{\"280\":1}}],[\"指明下一个期待字节的序号\",{\"1\":{\"291\":1}}],[\"指明对于不同功能的各种可能事件的出现顺序\",{\"1\":{\"227\":1}}],[\"指明某条线上出现的某一电平的电压表示何种意义\",{\"1\":{\"227\":1}}],[\"指明在接口电缆的各条线上出现的电压范围\",{\"1\":{\"227\":1}}],[\"指明接口所用接线器的形状和尺寸\",{\"1\":{\"227\":1}}],[\"指明帧的数据部分送交哪个协议处理\",{\"1\":{\"131\":1}}],[\"指网络通不通\",{\"1\":{\"200\":1}}],[\"检测当前线程是否被中断\",{\"1\":{\"807\":2}}],[\"检测整个udp数据报是否有错误\",{\"1\":{\"302\":1}}],[\"检查这个符号引用代表的类是否已被加载\",{\"1\":{\"726\":1}}],[\"检查arp高速缓存\",{\"1\":{\"198\":1}}],[\"检错能力较差\",{\"1\":{\"134\":1,\"576\":1}}],[\"流控制\",{\"1\":{\"577\":1}}],[\"流控制和差错控制是什么\",{\"0\":{\"576\":1}}],[\"流媒体通信等\",{\"1\":{\"301\":1}}],[\"流程知道吗\",{\"1\":{\"695\":1}}],[\"流程审批系统\",{\"1\":{\"333\":1}}],[\"流程描述\",{\"1\":{\"285\":1}}],[\"流程\",{\"0\":{\"695\":1},\"1\":{\"198\":1}}],[\"流量控制常见实现\",{\"1\":{\"576\":1}}],[\"流量控制考虑什么方面\",{\"1\":{\"576\":1}}],[\"流量控制是什么\",{\"1\":{\"576\":1}}],[\"流量控制和差错控制是什么\",{\"1\":{\"576\":1}}],[\"流量控制就是让\",{\"1\":{\"293\":1}}],[\"流量控制实现方法\",{\"1\":{\"140\":1}}],[\"流量控制并不是数据链路层所特有的功能\",{\"1\":{\"140\":1,\"576\":1}}],[\"流量控制\",{\"0\":{\"140\":1},\"1\":{\"119\":1,\"140\":1,\"268\":1,\"282\":1,\"296\":1,\"584\":2}}],[\"完全垃圾回收\",{\"1\":{\"741\":1}}],[\"完全不会对其生存时间构成影响\",{\"1\":{\"735\":1}}],[\"完善hashmap的key\",{\"1\":{\"712\":1}}],[\"完成状态确认\",{\"1\":{\"851\":1}}],[\"完成后\",{\"1\":{\"827\":1}}],[\"完成这项任务的硬件或软件称为传输实体\",{\"1\":{\"274\":1}}],[\"完成主机或路由器ip地址到mac地址的映射\",{\"1\":{\"196\":1}}],[\"完整的dns解析过程有以下几个步骤\",{\"1\":{\"73\":1}}],[\"格式\",{\"1\":{\"194\":1}}],[\"避免频繁地创建和关闭数据库连接\",{\"1\":{\"858\":1}}],[\"避免资源过度占用\",{\"1\":{\"858\":1}}],[\"避免增加创建线程和销毁线程的资源损耗\",{\"1\":{\"857\":1}}],[\"避免死锁就是在资源分配时\",{\"1\":{\"848\":1}}],[\"避免参数传递的麻烦\",{\"1\":{\"817\":1}}],[\"避免类冲突和版本不兼容的问题\",{\"1\":{\"759\":1}}],[\"避免回收时间过长\",{\"1\":{\"750\":1}}],[\"避免二义性\",{\"1\":{\"712\":1}}],[\"避免在迭代器遍历期间对集合进行结构性修改\",{\"1\":{\"710\":1}}],[\"避免在网络中发生拥塞\",{\"1\":{\"296\":1}}],[\"避免继续遍历导致数据不一致或不可预测的结果\",{\"1\":{\"710\":1}}],[\"避免信息丢失或损坏\",{\"1\":{\"622\":1}}],[\"避免混叠\",{\"1\":{\"622\":1}}],[\"避免多个进程同时访问或修改同一资源\",{\"1\":{\"853\":1}}],[\"避免多次arp请求\",{\"1\":{\"583\":1}}],[\"避免多重条件判断\",{\"1\":{\"345\":1}}],[\"避免碰撞并处理任何发生的碰撞情况\",{\"1\":{\"581\":1}}],[\"避免手动编写大量的代理类\",{\"1\":{\"496\":1}}],[\"避免直接访问其他对象的内部细节\",{\"1\":{\"488\":1}}],[\"避免不必要的继承导致的公共接口的暴露\",{\"1\":{\"782\":1}}],[\"避免不必要的复杂性和抽象\",{\"1\":{\"480\":1}}],[\"避免不必要的依赖和复杂性\",{\"1\":{\"474\":1}}],[\"避免过多的复杂性和不必要的抽象\",{\"1\":{\"480\":1}}],[\"避免过度依赖和冗余代码\",{\"1\":{\"474\":1}}],[\"避免过度设计\",{\"1\":{\"373\":1}}],[\"避免一个类承担过多的责任\",{\"1\":{\"474\":1}}],[\"避免将不需要的方法强加给实现类\",{\"1\":{\"474\":1}}],[\"避免状态的频繁转换导致性能问题\",{\"1\":{\"361\":1}}],[\"避免大量的条件语句\",{\"1\":{\"361\":1}}],[\"避免责任链过长或者过于复杂\",{\"1\":{\"355\":1}}],[\"避免使用大量的if\",{\"1\":{\"345\":1}}],[\"避免拥塞发生\",{\"1\":{\"296\":1}}],[\"避免网络拥塞\",{\"1\":{\"296\":1}}],[\"避免网络传输路径中数据的传输延迟或死锁\",{\"1\":{\"187\":1,\"592\":1}}],[\"避免了大量线程竞争同一个变量的情况\",{\"1\":{\"855\":1}}],[\"避免了大量的条件语句\",{\"1\":{\"361\":1}}],[\"避免了线程间的数据不一致问题\",{\"1\":{\"844\":1}}],[\"避免了使用读锁的开销\",{\"1\":{\"832\":1}}],[\"避免了全局类库版本冲突\",{\"1\":{\"760\":1}}],[\"避免了类的冲突和混淆\",{\"1\":{\"758\":1}}],[\"避免了二叉树最坏情况下的o\",{\"1\":{\"698\":1}}],[\"避免了重复的数据库查询操作\",{\"1\":{\"495\":1}}],[\"避免了重复编写相同的代码\",{\"1\":{\"486\":1}}],[\"避免了重复代码的出现\",{\"1\":{\"339\":1}}],[\"避免了不必要的依赖关系\",{\"1\":{\"473\":1}}],[\"避免了不必要的耦合\",{\"1\":{\"461\":1}}],[\"避免了可能的死锁情况\",{\"1\":{\"294\":1}}],[\"避免了建立多个连接的开销\",{\"1\":{\"113\":1}}],[\"去队里加个塞\",{\"1\":{\"868\":1}}],[\"去虚拟化等\",{\"1\":{\"720\":1}}],[\"去哪个仓库下载对应的依赖\",{\"1\":{\"539\":1}}],[\"去下载gradle\",{\"1\":{\"538\":1}}],[\"去执行以下各种操作\",{\"1\":{\"360\":1}}],[\"去掉在数据链路层加上的数据链路层协议控制信息\",{\"1\":{\"186\":1,\"591\":1}}],[\"去标签\",{\"1\":{\"159\":2}}],[\"端到端的控制\",{\"1\":{\"296\":1}}],[\"端到端的服务\",{\"0\":{\"275\":1}}],[\"端到端传输\",{\"1\":{\"275\":1}}],[\"端到端连接是两个终端系统之间的连接\",{\"1\":{\"275\":1}}],[\"端点\",{\"1\":{\"184\":1}}],[\"端口是\",{\"1\":{\"769\":1}}],[\"端口是传输层特定的属性\",{\"1\":{\"277\":1}}],[\"端口不可达\",{\"1\":{\"301\":1}}],[\"端口\",{\"1\":{\"274\":1,\"279\":1}}],[\"端口号长度为16bit\",{\"1\":{\"279\":1}}],[\"端口号只是为了标识本计算机应用层中的各进程\",{\"1\":{\"279\":1}}],[\"端口号只有本地意义\",{\"1\":{\"279\":1}}],[\"端口号的组成和含义\",{\"1\":{\"279\":1}}],[\"端口号\",{\"1\":{\"251\":1,\"279\":2}}],[\"端口号为179\",{\"1\":{\"212\":1}}],[\"端口为520\",{\"1\":{\"208\":1}}],[\"端口规则\",{\"1\":{\"14\":1,\"40\":1}}],[\"端口的反向代理\",{\"1\":{\"8\":1,\"34\":1}}],[\"都在这个变量的版本号上加1\",{\"1\":{\"845\":1}}],[\"都在当前\",{\"1\":{\"827\":1}}],[\"都不需要再进行任何线程安全保障的措施\",{\"1\":{\"831\":1}}],[\"都不是线程安全的\",{\"1\":{\"715\":1}}],[\"都继承自abstractstringbuilder\",{\"1\":{\"789\":1}}],[\"都继承自abstractmap\",{\"1\":{\"705\":1}}],[\"都属于java\",{\"1\":{\"789\":1}}],[\"都涉及到方法\",{\"1\":{\"780\":1}}],[\"都可以协调多线程的结束动作\",{\"1\":{\"852\":1}}],[\"都可以有默认实现的方法\",{\"1\":{\"783\":1}}],[\"都可以用作变量\",{\"1\":{\"773\":1}}],[\"都可以简化记为\",{\"1\":{\"316\":1}}],[\"都由各个类加载器自行去加载的话\",{\"1\":{\"758\":1}}],[\"都会进行加锁\",{\"1\":{\"831\":1,\"832\":1}}],[\"都会回收该对象占用的内存\",{\"1\":{\"818\":1}}],[\"都会回收掉只被弱引用关联的对象\",{\"1\":{\"735\":1}}],[\"都会在请求头中携带一个token\",{\"1\":{\"817\":1}}],[\"都会往自己的threadlocalmap里存\",{\"1\":{\"816\":1}}],[\"都会检测modcount变量是否为expectedmodcount值\",{\"1\":{\"709\":1}}],[\"都初始化为零值\",{\"1\":{\"726\":1}}],[\"都有默认的初始容量和加载因子\",{\"1\":{\"715\":1}}],[\"都有相似的复杂操作用于创建\",{\"1\":{\"422\":1}}],[\"都执行了一次\",{\"1\":{\"707\":1}}],[\"都实现了map接口\",{\"1\":{\"706\":1}}],[\"都能看到当前\",{\"1\":{\"827\":1}}],[\"都能被\",{\"1\":{\"719\":1}}],[\"都能够方便地应用于整个组合对象\",{\"1\":{\"526\":1}}],[\"都能正确地处理子类对象\",{\"1\":{\"470\":1}}],[\"都需要修改现有的代码\",{\"1\":{\"465\":1}}],[\"都需要新增相应的具体产品类和具体工厂类\",{\"1\":{\"437\":1}}],[\"都将参与交通管制系统\",{\"1\":{\"401\":1}}],[\"都将会抛出illegalstateexception异常\",{\"1\":{\"367\":1}}],[\"都是通过工具类excutors创建出来的\",{\"1\":{\"859\":1}}],[\"都是需要资源开销的\",{\"1\":{\"857\":1}}],[\"都是可重入锁\",{\"1\":{\"843\":1}}],[\"都是互斥同步方案保持线程安全的实现方式\",{\"1\":{\"843\":1}}],[\"都是互联网的重要组成构件\",{\"1\":{\"162\":1}}],[\"都是\",{\"1\":{\"834\":1}}],[\"都是乐观锁的例子\",{\"1\":{\"832\":1}}],[\"都是多态的体现\",{\"1\":{\"780\":1}}],[\"都是标记复制算法\",{\"1\":{\"745\":1}}],[\"都是什么意思\",{\"0\":{\"738\":1},\"1\":{\"738\":1}}],[\"都是map接口的子实现类\",{\"1\":{\"715\":1}}],[\"都是进程内的实现方式\",{\"1\":{\"327\":1}}],[\"都包含了足够的控制信息来确定数据的起始和结束\",{\"1\":{\"235\":1}}],[\"都使用了面向连接的虚拟电路服务\",{\"1\":{\"184\":1}}],[\"许多框架和库\",{\"1\":{\"800\":1}}],[\"许多广域分组交换网络\",{\"1\":{\"184\":1}}],[\"许多高层协议中也提供流量控功能\",{\"1\":{\"140\":1,\"576\":1}}],[\"虚引用也称为\",{\"1\":{\"735\":1}}],[\"虚连接\",{\"1\":{\"282\":1}}],[\"虚电路服务\",{\"1\":{\"184\":1,\"589\":1}}],[\"虚拟机即时编译器在运行时\",{\"1\":{\"837\":1}}],[\"虚拟机内存不够错误\",{\"1\":{\"793\":1}}],[\"虚拟机运行错误\",{\"1\":{\"793\":1}}],[\"虚拟机运行时信息查看\",{\"1\":{\"762\":1}}],[\"虚拟机配置查看\",{\"1\":{\"762\":1}}],[\"虚拟机进程查看\",{\"1\":{\"762\":1}}],[\"虚拟机的实现会提供一个扩展库目录\",{\"1\":{\"756\":1}}],[\"虚拟机设计者形象描述为stop\",{\"1\":{\"747\":1}}],[\"虚拟机会在加载类的时候生成相应的class对象\",{\"1\":{\"799\":1}}],[\"虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间\",{\"1\":{\"743\":1}}],[\"虚拟机会根据对象的类型设置对象头信息\",{\"1\":{\"726\":1}}],[\"虚拟机里是通过写屏障技术维护卡表状态的\",{\"1\":{\"742\":1}}],[\"虚拟机并不是永远要求对象的年龄必须达到\",{\"1\":{\"740\":1}}],[\"虚拟机提供了这个参数来设置\",{\"1\":{\"740\":1}}],[\"虚拟机上\",{\"1\":{\"728\":1}}],[\"虚拟机就必须维护一个列表\",{\"1\":{\"727\":1}}],[\"虚拟机将分配到的内存空间\",{\"1\":{\"726\":1}}],[\"虚拟机栈\",{\"1\":{\"722\":1,\"734\":1}}],[\"虚拟机退出线程\",{\"1\":{\"721\":1}}],[\"虚拟机\",{\"1\":{\"719\":1,\"793\":1}}],[\"虚拟机安装宝塔及软件配置\",{\"0\":{\"1\":1,\"27\":1}}],[\"虚拟电路\",{\"1\":{\"184\":1}}],[\"虚拟局域网又称vlan\",{\"1\":{\"159\":1}}],[\"虚拟局域网\",{\"0\":{\"159\":1}}],[\"类继承自\",{\"1\":{\"839\":1}}],[\"类继承关系\",{\"1\":{\"755\":1}}],[\"类加锁\",{\"1\":{\"833\":1}}],[\"类加载数量等\",{\"1\":{\"763\":1}}],[\"类加载可以在以下情况下触发\",{\"1\":{\"755\":1}}],[\"类加载是java虚拟机在运行时将类的字节码文件加载到内存中并转化为可执行的类对象的过程\",{\"1\":{\"755\":1}}],[\"类加载过程和类的生命周期\",{\"0\":{\"754\":1}}],[\"类加载检查通过后\",{\"1\":{\"726\":1}}],[\"类加载\",{\"0\":{\"753\":1},\"1\":{\"720\":1,\"726\":1}}],[\"类加载器在加载类时会委托给父类加载器去尝试加载\",{\"1\":{\"759\":1}}],[\"类加载器有哪些\",{\"0\":{\"756\":1}}],[\"类加载器加载字节码文件\",{\"1\":{\"720\":1}}],[\"类加载器\",{\"1\":{\"496\":1}}],[\"类提供了三个开箱即用的内存屏障相关的方法\",{\"1\":{\"827\":1}}],[\"类定义错误\",{\"1\":{\"793\":1}}],[\"类有两个重要的子类\",{\"1\":{\"793\":1}}],[\"类对该方法进行了重写以用于比较字符串的值是否相等\",{\"1\":{\"785\":1}}],[\"类之间的关系更加灵活\",{\"1\":{\"782\":1}}],[\"类结构过于复杂\",{\"1\":{\"782\":1}}],[\"类名点进行调用\",{\"1\":{\"779\":1}}],[\"类里面\",{\"1\":{\"775\":1}}],[\"类引用\",{\"1\":{\"755\":1}}],[\"类来实现虚引用\",{\"1\":{\"735\":1}}],[\"类来实现弱引用\",{\"1\":{\"735\":1}}],[\"类来实现软引用\",{\"1\":{\"735\":1}}],[\"类常量池是在编译时确定的\",{\"1\":{\"722\":1}}],[\"类常量池是每个类的一部分\",{\"1\":{\"722\":1}}],[\"类常量池\",{\"1\":{\"722\":2,\"723\":2}}],[\"类似我们传参的形参\",{\"1\":{\"816\":1}}],[\"类似\",{\"1\":{\"714\":1}}],[\"类似于数学上的函数\",{\"1\":{\"671\":1}}],[\"类似于高速公路连接不同城市之间的交通流\",{\"1\":{\"182\":1}}],[\"类和\",{\"1\":{\"506\":1}}],[\"类和上下文\",{\"1\":{\"386\":1}}],[\"类通过依赖\",{\"1\":{\"489\":1}}],[\"类发生变化时\",{\"1\":{\"489\":2}}],[\"类直接依赖于\",{\"1\":{\"489\":1}}],[\"类只需依赖于接口\",{\"1\":{\"477\":1}}],[\"类只关注订单的处理逻辑\",{\"1\":{\"461\":1}}],[\"类违反了基类\",{\"1\":{\"469\":1}}],[\"类重写了\",{\"1\":{\"469\":1}}],[\"类都是\",{\"1\":{\"469\":1}}],[\"类不仅负责订单的处理逻辑\",{\"1\":{\"461\":1}}],[\"类专门负责发送电子邮件\",{\"1\":{\"461\":1}}],[\"类负责表示订单\",{\"1\":{\"461\":1}}],[\"类负责根据\",{\"1\":{\"422\":1}}],[\"类也可以看作模块\",{\"1\":{\"460\":1}}],[\"类是一个嵌套类\",{\"1\":{\"450\":1}}],[\"类是一个资源加载器\",{\"1\":{\"422\":1}}],[\"类的本地方法\",{\"1\":{\"812\":1}}],[\"类的静态本地方法\",{\"1\":{\"812\":1}}],[\"类的实现决定\",{\"1\":{\"788\":1}}],[\"类的一个方法\",{\"1\":{\"787\":1}}],[\"类的常见方法有哪些\",{\"0\":{\"785\":1},\"1\":{\"785\":2}}],[\"类的隔离性\",{\"1\":{\"758\":1}}],[\"类的方式自行实现的类加载器\",{\"1\":{\"756\":1}}],[\"类的私有静态成员变量\",{\"1\":{\"722\":1}}],[\"类的子类\",{\"1\":{\"469\":1}}],[\"类的职责既包括根据前缀选择创建资源对象的逻辑\",{\"1\":{\"422\":1}}],[\"类的代码\",{\"1\":{\"343\":1,\"344\":1,\"422\":1,\"489\":2}}],[\"类表示资源对象\",{\"1\":{\"422\":1}}],[\"类实例\",{\"1\":{\"419\":2}}],[\"类实现了参与者接口\",{\"1\":{\"404\":1,\"409\":1}}],[\"类实现了中介者接口的\",{\"1\":{\"404\":1,\"409\":1}}],[\"类为具体的参与者类\",{\"1\":{\"404\":1,\"409\":1}}],[\"类为具体的中介者类\",{\"1\":{\"404\":1,\"409\":1}}],[\"类为非终结符表达式\",{\"1\":{\"395\":1}}],[\"类为终结符表达式\",{\"1\":{\"395\":1}}],[\"类为\",{\"1\":{\"384\":1}}],[\"类\",{\"1\":{\"350\":2,\"359\":3,\"360\":1,\"372\":1,\"393\":3,\"404\":1,\"409\":1,\"454\":2,\"461\":1,\"464\":2,\"466\":1,\"489\":2,\"498\":1,\"506\":1,\"706\":2,\"709\":1,\"733\":1,\"756\":2,\"758\":1,\"782\":1,\"793\":1,\"833\":1}}],[\"类中重复\",{\"1\":{\"485\":1}}],[\"类中的\",{\"1\":{\"497\":1}}],[\"类中的邮件发送逻辑\",{\"1\":{\"461\":1}}],[\"类中的代码\",{\"1\":{\"461\":1}}],[\"类中与订单处理逻辑相关的代码\",{\"1\":{\"461\":1}}],[\"类中包含了一个静态的\",{\"1\":{\"436\":1}}],[\"类中进行大量的条件判断\",{\"1\":{\"360\":1}}],[\"类中\",{\"1\":{\"344\":1,\"353\":1,\"443\":1,\"450\":1}}],[\"类作为上下文类\",{\"1\":{\"344\":1}}],[\"类型安全性\",{\"1\":{\"797\":1}}],[\"类型转换错误\",{\"1\":{\"793\":1}}],[\"类型的成员变量\",{\"1\":{\"846\":1}}],[\"类型的变量和常量做\",{\"1\":{\"792\":2}}],[\"类型的变量和常量做+运算时发生了什么\",{\"0\":{\"792\":1}}],[\"类型的\",{\"1\":{\"783\":1}}],[\"类型的参数传递进去\",{\"1\":{\"469\":1}}],[\"类型被设置成了不可变类型\",{\"1\":{\"731\":1}}],[\"类型默认为\",{\"1\":{\"726\":1}}],[\"类型和资源需求\",{\"1\":{\"355\":1}}],[\"类型\",{\"1\":{\"201\":1,\"251\":1,\"575\":2,\"780\":1}}],[\"类别域名\",{\"1\":{\"69\":1}}],[\"那外部的可见状态永远都不会改变\",{\"1\":{\"831\":1}}],[\"那说说什么是指令重排\",{\"0\":{\"826\":1},\"1\":{\"826\":1}}],[\"那说明是因为对象创建速度快导致内存一直占用很高\",{\"1\":{\"766\":1}}],[\"那原理是什么呢\",{\"1\":{\"822\":1}}],[\"那怎么解决内存泄漏问题呢\",{\"1\":{\"818\":1}}],[\"那为什么key还要设计成弱引用\",{\"1\":{\"818\":1}}],[\"那为什么两个对象有相同的\",{\"1\":{\"787\":1}}],[\"那为什么不只提供\",{\"1\":{\"787\":1}}],[\"那系统中就会出现多个不同的\",{\"1\":{\"758\":1}}],[\"那g1呢\",{\"1\":{\"749\":1}}],[\"那在第二次标记时它就\",{\"1\":{\"736\":1}}],[\"那它将会被第一次标记\",{\"1\":{\"736\":1}}],[\"那还应该有一块用于记录数组长度的数据\",{\"1\":{\"729\":1}}],[\"那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离\",{\"1\":{\"727\":1}}],[\"那可能是之前永久代来实现方法区的决定的设计导致了\",{\"1\":{\"725\":1}}],[\"那如何保证\",{\"1\":{\"713\":1}}],[\"那如何实现\",{\"1\":{\"327\":1}}],[\"那样的键值对映射关系\",{\"1\":{\"704\":1}}],[\"那就重新匹配\",{\"1\":{\"851\":1}}],[\"那就再进行补偿策略\",{\"1\":{\"831\":1,\"832\":1}}],[\"那就直接成功\",{\"1\":{\"831\":1,\"832\":1}}],[\"那就肯定会出现问题\",{\"1\":{\"831\":1,\"832\":1}}],[\"那就接着去找空着的坑\",{\"1\":{\"820\":1}}],[\"那就在常量池中创建一个指向该字符串对象的引用并返回\",{\"1\":{\"791\":1}}],[\"那就会使用\",{\"1\":{\"789\":1}}],[\"那就会触发\",{\"1\":{\"739\":1}}],[\"那就增大新生代空间\",{\"1\":{\"767\":1}}],[\"那就没有办法简单地进行指针碰撞了\",{\"1\":{\"727\":1}}],[\"那就更难搞了\",{\"1\":{\"694\":1}}],[\"那就是大于容量\",{\"1\":{\"696\":1}}],[\"那就是需要引入一个新的系统\",{\"1\":{\"327\":1}}],[\"那就是本层网络层的ip地址\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"那你继续说说hashmap\",{\"1\":{\"690\":1}}],[\"那arraylist怎么序列化呢\",{\"1\":{\"680\":1}}],[\"那有java集合里面有哪些是线程安全的集合\",{\"1\":{\"675\":1}}],[\"那这几个父类接口有什么区别\",{\"0\":{\"671\":1},\"1\":{\"671\":1}}],[\"那我们的请求需要再次进行负载均衡\",{\"1\":{\"817\":1}}],[\"那我们要为每一个子类创建类进行继承\",{\"1\":{\"500\":1}}],[\"那我们就说它职责不够单一\",{\"1\":{\"462\":1}}],[\"那是针对数据链路中点对点传输速率的控制\",{\"1\":{\"187\":1,\"592\":1}}],[\"那么线程池会根据拒绝策略来对应处理\",{\"1\":{\"868\":1}}],[\"那么线程b会先用cas操作试图获得锁\",{\"1\":{\"837\":1}}],[\"那么还是要创建非核心线程立刻运行这个任务\",{\"1\":{\"868\":1}}],[\"那么将这个任务放入队列\",{\"1\":{\"868\":1}}],[\"那么马上创建线程运行这个任务\",{\"1\":{\"868\":1}}],[\"那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制\",{\"1\":{\"846\":1}}],[\"那么就会触发栈溢出\",{\"1\":{\"731\":1}}],[\"那么直接就获取到锁返回了\",{\"1\":{\"840\":1}}],[\"那么释放锁之后\",{\"1\":{\"839\":1}}],[\"那么第一个操作的执行结果将对第二个操作可见\",{\"1\":{\"826\":1}}],[\"那么守护线程和用户线程有什么区别呢\",{\"1\":{\"810\":1}}],[\"那么它将首先在字符串常量池中创建\",{\"1\":{\"791\":1}}],[\"那么它们的\",{\"1\":{\"788\":1}}],[\"那么它们可以被判定为废弃常量\",{\"1\":{\"733\":1}}],[\"那么其子类也能接收\",{\"1\":{\"782\":1}}],[\"那么很可能是因为内存泄露导致内存一直无法被回收\",{\"1\":{\"766\":1}}],[\"那么无法加载多个相同的类\",{\"1\":{\"760\":1}}],[\"那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小\",{\"1\":{\"743\":1}}],[\"那么会选择先进行数组扩容\",{\"1\":{\"686\":1,\"706\":1}}],[\"那么随着对象数量的增加\",{\"1\":{\"731\":1}}],[\"那么对象就真的要被回收了\",{\"1\":{\"736\":1}}],[\"那么对象\",{\"1\":{\"731\":1}}],[\"那么这种重排序并不非法\",{\"1\":{\"826\":1}}],[\"那么这种重复可能是合理的\",{\"1\":{\"486\":1}}],[\"那么这个线程就被停掉\",{\"1\":{\"868\":1}}],[\"那么这个方法还是会因为超时而返回\",{\"1\":{\"807\":1}}],[\"那么这个成员变量是属于类的\",{\"1\":{\"775\":1}}],[\"那么这个外部对象将不能被\",{\"1\":{\"731\":1}}],[\"那么下个月就没东西用力\",{\"1\":{\"731\":1}}],[\"那么你就无法区分这个值是否是真正存储在\",{\"1\":{\"712\":1}}],[\"那么你就无法区分这个键是否存在于\",{\"1\":{\"712\":1}}],[\"那么你就是对的\",{\"1\":{\"458\":1}}],[\"那么为什么选择了0\",{\"1\":{\"696\":1}}],[\"那么为什么还需要设置一个传输层呢\",{\"1\":{\"274\":1}}],[\"那么复制的对象将包含对原始对象引用数据类型成员变量的引用\",{\"1\":{\"454\":1}}],[\"那么常数3可以忽略\",{\"1\":{\"316\":1}}],[\"那么怎么知道当前网络是否出现了拥塞呢\",{\"1\":{\"297\":1}}],[\"那么由于加入了拥塞窗口的概念后\",{\"1\":{\"297\":1}}],[\"那么a到系统e的路由怎样走最好呢\",{\"1\":{\"212\":1}}],[\"那么发送的分组将最终可以正确到达接收方\",{\"1\":{\"184\":1}}],[\"那么发送端连着发了3个帧后\",{\"1\":{\"142\":1,\"576\":1}}],[\"那么\",{\"1\":{\"182\":1,\"706\":1}}],[\"那么最后达到d的数据中的mac地址就是c的mac地址\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"那么必须加入一些填充字节\",{\"1\":{\"152\":1}}],[\"那么在原始帧后面加上n\",{\"1\":{\"135\":1,\"576\":1}}],[\"那么主机访问文档时是否会访问到未修改的文档从而发送错误呢\",{\"1\":{\"114\":1}}],[\"那么请求每一个对象都需要花费2rtt的时间\",{\"1\":{\"111\":1}}],[\"快速失败是java集合的一种错误检测机制\",{\"1\":{\"709\":1}}],[\"快速失败\",{\"0\":{\"709\":1},\"1\":{\"709\":2}}],[\"快速收敛\",{\"1\":{\"175\":1}}],[\"快捷键\",{\"1\":{\"360\":1}}],[\"快恢复\",{\"1\":{\"297\":1,\"299\":1}}],[\"快重传和快恢复\",{\"0\":{\"299\":1},\"1\":{\"299\":1}}],[\"快重传\",{\"1\":{\"297\":1,\"299\":1}}],[\"快播\",{\"1\":{\"59\":1}}],[\"定在初始化动作完成之前\",{\"1\":{\"754\":1}}],[\"定位到table中的位置\",{\"1\":{\"820\":1}}],[\"定位到segment\",{\"1\":{\"711\":1}}],[\"定位在新数组的位置\",{\"1\":{\"701\":1}}],[\"定时及周期执行的线程池\",{\"1\":{\"859\":1}}],[\"定时任务调度\",{\"1\":{\"858\":1}}],[\"定时读取配置文件\",{\"1\":{\"436\":1}}],[\"定时机制\",{\"1\":{\"175\":1}}],[\"定义应用程序的基本信息和配置\",{\"1\":{\"539\":1}}],[\"定义不同构建类型的设置\",{\"1\":{\"539\":1}}],[\"定义项目的命名空间\",{\"1\":{\"539\":1}}],[\"定义享元对象接口\",{\"1\":{\"530\":1}}],[\"定义组合对象和叶子对象的共同接口\",{\"1\":{\"526\":1}}],[\"定义组合中对象的共有接口\",{\"1\":{\"524\":1}}],[\"定义组件接口\",{\"1\":{\"524\":1}}],[\"定义子系统组件\",{\"1\":{\"516\":1}}],[\"定义实现部分接口\",{\"1\":{\"505\":1}}],[\"定义远程服务的接口\",{\"1\":{\"495\":1}}],[\"定义敏感操作的接口\",{\"1\":{\"495\":1}}],[\"定义数据库操作的接口\",{\"1\":{\"495\":1}}],[\"定义代理类和被代理类共同实现的方法\",{\"1\":{\"494\":1,\"495\":1}}],[\"定义构建对象的接口\",{\"1\":{\"448\":1}}],[\"定义产品的接口\",{\"1\":{\"441\":1}}],[\"定义用于创建产品家族的接口\",{\"1\":{\"441\":1}}],[\"定义一系列创建产品的方法\",{\"1\":{\"440\":1}}],[\"定义一个共同的接口\",{\"1\":{\"497\":1}}],[\"定义一个builder接口\",{\"1\":{\"448\":1}}],[\"定义一个创建对象的接口\",{\"1\":{\"433\":1}}],[\"定义一个工厂类\",{\"1\":{\"427\":1}}],[\"定义一个接口\",{\"1\":{\"496\":1}}],[\"定义一个接口用于与各个相关对象通信\",{\"1\":{\"400\":1}}],[\"定义一个接口来封装与context的一个特定状态相关的行为\",{\"1\":{\"359\":1}}],[\"定义一个元素接口\",{\"1\":{\"372\":1}}],[\"定义一个处理请求的接口\",{\"1\":{\"350\":1}}],[\"定义参与者\",{\"1\":{\"402\":1,\"407\":1}}],[\"定义中介者\",{\"1\":{\"402\":1,\"407\":1}}],[\"定义解释器的接口\",{\"1\":{\"390\":1}}],[\"定义命令接口\",{\"1\":{\"383\":1}}],[\"定义对象结构\",{\"1\":{\"371\":1}}],[\"定义具体访问者类\",{\"1\":{\"371\":1}}],[\"定义具体元素类\",{\"1\":{\"371\":1}}],[\"定义具体迭代器类\",{\"1\":{\"365\":1}}],[\"定义抽象部分接口\",{\"1\":{\"505\":1}}],[\"定义抽象工厂接口\",{\"1\":{\"441\":1}}],[\"定义抽象工厂类\",{\"1\":{\"434\":1}}],[\"定义抽象产品类\",{\"1\":{\"434\":1}}],[\"定义抽象表达式\",{\"1\":{\"393\":1}}],[\"定义抽象元素接口\",{\"1\":{\"371\":1}}],[\"定义抽象访问者接口\",{\"1\":{\"371\":1}}],[\"定义抽象类\",{\"1\":{\"332\":1}}],[\"定义接受访问者对象的接口\",{\"1\":{\"371\":1}}],[\"定义访问元素对象的接口\",{\"1\":{\"371\":1}}],[\"定义访问和遍历元素的接口\",{\"1\":{\"365\":1}}],[\"定义作用于该结构中元素的新操作\",{\"1\":{\"369\":1}}],[\"定义迭代器接口\",{\"1\":{\"365\":1}}],[\"定义聚合对象\",{\"1\":{\"365\":1}}],[\"定义客户端感兴趣的接口\",{\"1\":{\"359\":1}}],[\"定义报告生成的基本骨架\",{\"1\":{\"336\":1}}],[\"定义了组合模式中的叶子节点和组合节点的共同操作方法\",{\"1\":{\"524\":1}}],[\"定义了\",{\"1\":{\"510\":2}}],[\"定义了实现部分的接口\",{\"1\":{\"504\":1}}],[\"定义了抽象接口\",{\"1\":{\"504\":1}}],[\"定义了装饰器和具体组件的共同接口\",{\"1\":{\"501\":1}}],[\"定义了产品对象的接口\",{\"1\":{\"434\":1}}],[\"定义了创建对象的接口\",{\"1\":{\"434\":1}}],[\"定义了处理器的基本结构\",{\"1\":{\"353\":1}}],[\"定义了读取输入流中的数据的基本骨架\",{\"1\":{\"335\":1}}],[\"定义了算法的基本骨架\",{\"1\":{\"332\":1}}],[\"定义了一个operation方法\",{\"1\":{\"502\":1}}],[\"定义了一个抽象类myservlet\",{\"1\":{\"338\":1}}],[\"定义了一个模板方法\",{\"1\":{\"330\":1,\"332\":1}}],[\"定义了一个叫做拥塞窗口\",{\"1\":{\"296\":1}}],[\"定义了订阅者的行为\",{\"1\":{\"326\":1}}],[\"定义了接收和处理主题通知的方法\",{\"1\":{\"324\":1}}],[\"定义\",{\"0\":{\"257\":1},\"1\":{\"582\":2}}],[\"定义收发双发的时序关系\",{\"1\":{\"250\":1}}],[\"定义收发双方所要完成的操作\",{\"1\":{\"250\":1}}],[\"定义所交换信息的格式\",{\"1\":{\"250\":1}}],[\"定长子网掩码\",{\"1\":{\"222\":1}}],[\"定期进行数据扫描分析\",{\"1\":{\"81\":1}}],[\"生命周期\",{\"0\":{\"808\":1},\"1\":{\"779\":1,\"808\":1}}],[\"生命周期默认为两分钟\",{\"1\":{\"168\":1,\"583\":1}}],[\"生存时间\",{\"1\":{\"775\":1}}],[\"生存期可知\",{\"1\":{\"724\":1}}],[\"生成\",{\"1\":{\"769\":2}}],[\"生成对应的\",{\"1\":{\"720\":1}}],[\"生成订单号\",{\"1\":{\"518\":1}}],[\"生成报告模板\",{\"0\":{\"336\":1}}],[\"生成树协议\",{\"1\":{\"175\":1}}],[\"生物学的\",{\"1\":{\"316\":1}}],[\"选择不合适的垃圾收集器可能导致过于频繁的minor\",{\"1\":{\"767\":1}}],[\"选择不同算法实现\",{\"1\":{\"342\":1}}],[\"选择新生代\",{\"1\":{\"750\":1}}],[\"选择使用哪种方式取决于具体的场景和需求\",{\"1\":{\"816\":1}}],[\"选择使用取决于具体的需求和情况\",{\"1\":{\"705\":1}}],[\"选择使用命令模式或策略模式可以更好地组织和设计代码\",{\"1\":{\"386\":1}}],[\"选择加载因子为\",{\"1\":{\"696\":1}}],[\"选择合适的方法取决于具体的应用场景和性能要求\",{\"1\":{\"844\":1}}],[\"选择合适的调制方式可以有效地进行数据传输\",{\"1\":{\"619\":1}}],[\"选择合适的子网掩码\",{\"1\":{\"596\":1}}],[\"选择合适的设计模式来组织和管理对象之间的交互关系是很重要的\",{\"1\":{\"411\":1}}],[\"选择传输类型\",{\"1\":{\"538\":1}}],[\"选择机器和版本\",{\"1\":{\"538\":1}}],[\"选择自定义安装customer\",{\"1\":{\"538\":1}}],[\"选择指定端口\",{\"1\":{\"175\":1}}],[\"选择根端口\",{\"1\":{\"175\":1}}],[\"选择根桥后\",{\"1\":{\"175\":1}}],[\"选择根桥\",{\"1\":{\"175\":1}}],[\"选择性地将数据帧转发到特定的接口\",{\"1\":{\"174\":1}}],[\"选择重传协议\",{\"0\":{\"139\":1},\"1\":{\"139\":1}}],[\"盲目转发\",{\"1\":{\"174\":1}}],[\"登记端口号\",{\"1\":{\"279\":1}}],[\"登记的内容包括帧的源mac地址及进入交换机的接口号\",{\"1\":{\"174\":1}}],[\"登录后的用户每次访问接口\",{\"1\":{\"817\":1}}],[\"登录请求经过了日志处理器\",{\"1\":{\"353\":2}}],[\"登录请求\",{\"1\":{\"353\":2,\"354\":1}}],[\"登录\",{\"1\":{\"85\":1}}],[\"随后进行一次筛选\",{\"1\":{\"736\":1}}],[\"随后\",{\"1\":{\"707\":2}}],[\"随着硬件指令级的发展\",{\"1\":{\"831\":1}}],[\"随着方法的调用结束而消亡\",{\"1\":{\"775\":1}}],[\"随着对象状态变化\",{\"1\":{\"729\":1}}],[\"随着类加载到内存中而被创建\",{\"1\":{\"722\":1}}],[\"随着交换机的普及\",{\"1\":{\"618\":1}}],[\"随着系统中对象之间关联关系的增多\",{\"1\":{\"410\":1}}],[\"随着网络中各主机间的通信\",{\"1\":{\"174\":1}}],[\"随机访问速度快\",{\"1\":{\"312\":1}}],[\"随机访问介质控制\",{\"0\":{\"152\":1},\"1\":{\"144\":1}}],[\"随机\",{\"1\":{\"285\":1}}],[\"随机产生\",{\"1\":{\"285\":1}}],[\"随机走动法\",{\"1\":{\"205\":1}}],[\"随机介入控制协议\",{\"1\":{\"144\":1}}],[\"能立即停止线程池\",{\"1\":{\"864\":1}}],[\"能列举一些常见的调制技术吗\",{\"0\":{\"619\":1},\"1\":{\"619\":1}}],[\"能够明显提升系统性能\",{\"1\":{\"842\":1}}],[\"能够提高读操作的并发性能\",{\"1\":{\"832\":1}}],[\"能够提供更好的性能和内存管理效果\",{\"1\":{\"725\":1}}],[\"能够在编译时期提供类型安全性\",{\"1\":{\"797\":1}}],[\"能够在不同端口之间建立直接连接\",{\"1\":{\"580\":1}}],[\"能够允许程序继续执行\",{\"1\":{\"748\":1}}],[\"能够保持插入顺序或者访问顺序\",{\"1\":{\"715\":1}}],[\"能够保持键值对的迭代顺序与插入顺序或访问顺序一致\",{\"1\":{\"714\":1}}],[\"能够及时发现集合结构的修改\",{\"1\":{\"710\":1}}],[\"能够充分的散列\",{\"1\":{\"688\":1}}],[\"能够更好地应对传输中的干扰或噪声\",{\"1\":{\"619\":1}}],[\"能够分隔不同的广播域\",{\"1\":{\"580\":1}}],[\"能够学习设备的\",{\"1\":{\"580\":1}}],[\"能够灵活地遍历聚合对象中的元素\",{\"1\":{\"364\":1}}],[\"能够灵活地扩展和修改其中某些步骤的实现\",{\"1\":{\"333\":1}}],[\"能够被相应的目的主机接收\",{\"1\":{\"268\":1}}],[\"能表示65536个不同的端口号\",{\"1\":{\"279\":1}}],[\"能及时响应链路变化和网络拓扑变化\",{\"1\":{\"206\":1}}],[\"能根据一定的原则和路由选择算法在多个结点的通信子网中选择一条到达目的节点的最佳路径\",{\"1\":{\"185\":1,\"590\":1}}],[\"能同时连通多对接口\",{\"1\":{\"173\":1}}],[\"能进行广播和组播\",{\"1\":{\"156\":1}}],[\"代替了hash值\",{\"1\":{\"688\":1}}],[\"代替\",{\"1\":{\"681\":2}}],[\"代码是单线程执行的\",{\"1\":{\"836\":1}}],[\"代码块\",{\"1\":{\"834\":1}}],[\"代码块之前会获取锁\",{\"1\":{\"834\":1}}],[\"代码示例\",{\"1\":{\"795\":1}}],[\"代码显式调用\",{\"1\":{\"768\":1}}],[\"代码中显式调用了\",{\"1\":{\"768\":1}}],[\"代码中的父类可以作为通用的抽象接口或基类使用\",{\"1\":{\"470\":1}}],[\"代码中的条件逻辑使得测试变得困难\",{\"1\":{\"465\":1}}],[\"代码中的条件逻辑会不断增加\",{\"1\":{\"465\":1}}],[\"代码热点等\",{\"1\":{\"763\":1}}],[\"代码有提示了\",{\"1\":{\"538\":1}}],[\"代码多不是复杂\",{\"1\":{\"482\":1}}],[\"代码也更加简洁和可维护\",{\"1\":{\"481\":1}}],[\"代码复用\",{\"1\":{\"797\":1}}],[\"代码复用性较低\",{\"1\":{\"422\":1}}],[\"代码复杂度高\",{\"1\":{\"481\":1}}],[\"代码更易于理解\",{\"1\":{\"480\":1}}],[\"代码更加简洁\",{\"1\":{\"346\":1}}],[\"代码将变得脆弱\",{\"1\":{\"465\":1}}],[\"代码会变得冗长且难以阅读\",{\"1\":{\"465\":1}}],[\"代码可能会如下所示\",{\"1\":{\"465\":1}}],[\"代码可能会像下面这样实现\",{\"1\":{\"422\":1}}],[\"代码结构清晰\",{\"1\":{\"437\":1}}],[\"代码的脆弱性\",{\"1\":{\"465\":1}}],[\"代码的职责分离使得维护过程更加简化和安全\",{\"1\":{\"461\":1}}],[\"代码的维护和扩展会变得困难\",{\"1\":{\"422\":1}}],[\"代码的时间复杂度\",{\"1\":{\"316\":1}}],[\"代码冗余\",{\"1\":{\"422\":1}}],[\"代码详细解析\",{\"1\":{\"422\":1,\"436\":1,\"443\":1}}],[\"代码实现\",{\"0\":{\"394\":1,\"403\":1,\"408\":1}}],[\"代码审查\",{\"1\":{\"355\":1}}],[\"代码解析\",{\"1\":{\"326\":1}}],[\"代码说明介绍\",{\"1\":{\"326\":1}}],[\"代表非公平锁\",{\"1\":{\"840\":1}}],[\"代表公平锁和非公平锁\",{\"1\":{\"840\":1}}],[\"代表公平锁\",{\"1\":{\"840\":1}}],[\"代表线程抢到了同步锁\",{\"1\":{\"837\":1}}],[\"代表线程b获得了这个偏向锁\",{\"1\":{\"837\":1}}],[\"代表当前锁有一定的竞争\",{\"1\":{\"837\":1}}],[\"代表在链接阶段出现问题\",{\"1\":{\"793\":1}}],[\"代表远程服务\",{\"1\":{\"495\":1}}],[\"代表敏感操作\",{\"1\":{\"495\":1}}],[\"代表数据库操作\",{\"1\":{\"495\":1,\"497\":1}}],[\"代表聊天室中的用户\",{\"1\":{\"325\":1}}],[\"代表\",{\"1\":{\"311\":2,\"312\":2,\"671\":2}}],[\"代表其额定速率是1\",{\"1\":{\"262\":1}}],[\"代表是通过广播自动获取的条目\",{\"1\":{\"168\":1,\"583\":1}}],[\"代价\",{\"1\":{\"210\":1,\"212\":1}}],[\"代理会屏蔽原始对象的访问\",{\"1\":{\"500\":1}}],[\"代理对象本身\",{\"1\":{\"497\":1}}],[\"代理对象可以隐藏被代理对象的具体实现\",{\"1\":{\"495\":1}}],[\"代理处理器中的invoke\",{\"1\":{\"496\":1}}],[\"代理处理器对象\",{\"1\":{\"496\":1}}],[\"代理类附加的是跟原始类无关的功能\",{\"1\":{\"500\":2}}],[\"代理类将负责封装远程通信的逻辑\",{\"1\":{\"495\":1}}],[\"代理类将在调用父类方法之前和之后添加额外的逻辑\",{\"1\":{\"495\":1}}],[\"代理类会进行网络请求和响应的模拟操作\",{\"1\":{\"495\":1}}],[\"代理类会调用实际的数据库操作类执行查询\",{\"1\":{\"495\":1}}],[\"代理类会输出加载图片的信息\",{\"1\":{\"495\":1}}],[\"代理类\",{\"1\":{\"495\":2}}],[\"代理设计模式\",{\"0\":{\"494\":1},\"1\":{\"494\":1,\"500\":1}}],[\"代理模式可以用于实现懒加载\",{\"1\":{\"494\":1}}],[\"代理模式\",{\"1\":{\"490\":1}}],[\"代理服务器会向原始服务器发送一个请求\",{\"1\":{\"114\":1}}],[\"代理服务器会检查缓存中的响应的对象的修改时间和有效日期字段\",{\"1\":{\"114\":1}}],[\"代理服务器将直接返回缓存的响应报文\",{\"1\":{\"114\":1}}],[\"代理和服务器之间采用smtp\",{\"1\":{\"99\":1}}],[\"代理到服务器的http\",{\"1\":{\"8\":1,\"34\":1}}],[\"我急了\",{\"1\":{\"868\":1}}],[\"我用我的\",{\"1\":{\"831\":1}}],[\"我觉得吧\",{\"1\":{\"817\":1}}],[\"我就组合一些最有回收价值的region\",{\"1\":{\"749\":1}}],[\"我记得源码的注释给了解答\",{\"1\":{\"697\":1}}],[\"我应该找到的是32\",{\"1\":{\"689\":1}}],[\"我会将所有的代码整合到一个代码块内\",{\"1\":{\"384\":1}}],[\"我想知道c主机的mac地址是多少\",{\"1\":{\"168\":1,\"583\":1}}],[\"我的理解就是数据链路层要对上层数据是透明的\",{\"1\":{\"577\":1}}],[\"我的mac地址是\",{\"1\":{\"168\":1,\"583\":1}}],[\"我的ip地址是\",{\"1\":{\"168\":1,\"583\":1}}],[\"我们自己的实现就是完成这个核心流程\",{\"1\":{\"870\":1}}],[\"我们银行系统已经瘫痪\",{\"1\":{\"868\":1}}],[\"我们系统瘫痪了\",{\"1\":{\"861\":1}}],[\"我们再来看一个semaphore的用途\",{\"1\":{\"853\":1}}],[\"我们用cyclicbarrier就可以实现\",{\"1\":{\"852\":1}}],[\"我们用cas来实现这种非阻塞同步\",{\"1\":{\"831\":1}}],[\"我们很多人喜欢玩的moba多人竞技游戏\",{\"1\":{\"851\":1}}],[\"我们很难仅凭时间复杂度判断算法效率的高低\",{\"1\":{\"316\":1}}],[\"我们声明一个\",{\"1\":{\"827\":1}}],[\"我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子\",{\"1\":{\"826\":1}}],[\"我们会使用static关键字修饰\",{\"1\":{\"817\":1}}],[\"我们都需要手动\",{\"1\":{\"793\":1}}],[\"我们没办法通过\",{\"1\":{\"793\":1}}],[\"我们重写hashcode\",{\"1\":{\"787\":1}}],[\"我们重写了基础类的\",{\"1\":{\"495\":1}}],[\"我们还是要经过买菜\",{\"1\":{\"781\":1}}],[\"我们发现装箱其实就是调用了包装类的valueof\",{\"1\":{\"773\":1}}],[\"我们从一个\",{\"1\":{\"726\":1}}],[\"我们的系统应用是一个典型的mvc架构\",{\"1\":{\"817\":1}}],[\"我们的java语言会自动进行垃圾回收\",{\"1\":{\"719\":1}}],[\"我们的电商平台支持多种支付方式\",{\"1\":{\"344\":1}}],[\"我们书写的java源代码提供我们的编译器\",{\"1\":{\"719\":1}}],[\"我们到现在已经知道\",{\"1\":{\"692\":1}}],[\"我们利用hash算法可以定位一个元素的位置\",{\"1\":{\"690\":1}}],[\"我们来看看详情\",{\"1\":{\"689\":1}}],[\"我们来看看如何在java中实现这个例子\",{\"1\":{\"384\":1}}],[\"我们调用组合对象的display方法来显示组织架构\",{\"1\":{\"525\":1}}],[\"我们调用组合节点的操作方法\",{\"1\":{\"524\":1}}],[\"我们调用根文件夹的display方法来显示整个文件系统\",{\"1\":{\"525\":1}}],[\"我们构建了一个在线购物平台的订单处理系统\",{\"1\":{\"518\":1}}],[\"我们根据方法名进行判断\",{\"1\":{\"497\":1}}],[\"我们添加了额外的逻辑\",{\"1\":{\"495\":1}}],[\"我们添加了一个shallowcopy\",{\"1\":{\"454\":1}}],[\"我们引入了一个中间层接口\",{\"1\":{\"489\":1}}],[\"我们无法轻松地扩展和添加新的折扣类型\",{\"1\":{\"465\":1}}],[\"我们无法实际运行测试\",{\"1\":{\"408\":1}}],[\"我们不得不修改\",{\"1\":{\"465\":1}}],[\"我们写出来的代码可能并不是完全符合设计模式本身\",{\"1\":{\"458\":1}}],[\"我们已经有了另外的选择\",{\"1\":{\"831\":1}}],[\"我们已经成功地复制了一个与原始活动相似但具有不同日期和部分规则的新促销活动\",{\"1\":{\"455\":1}}],[\"我们已经为每个实体类实现了深拷贝方法\",{\"1\":{\"455\":1}}],[\"我们输出了构建完成的电脑对象的各个属性\",{\"1\":{\"448\":1}}],[\"我们实例化了一个computer对象\",{\"1\":{\"448\":1}}],[\"我们实现了对原有接口的增强\",{\"1\":{\"497\":1}}],[\"我们实现了远程代理的功能\",{\"1\":{\"495\":1}}],[\"我们实现了安全代理的功能\",{\"1\":{\"495\":1}}],[\"我们实现了数据库查询缓存的功能\",{\"1\":{\"495\":1}}],[\"我们实现了类之间的解耦\",{\"1\":{\"489\":1}}],[\"我们实现了高层模块和低\",{\"1\":{\"477\":1}}],[\"我们实现了一个basiccomputerbuilder类\",{\"1\":{\"448\":1}}],[\"我们实现了一个简单的遥控器控制电灯的场景\",{\"1\":{\"383\":1}}],[\"我们实现了一个简单的类似arraylist的集合superarray\",{\"1\":{\"366\":1}}],[\"我们实现了父类中定义的三个抽象方法\",{\"1\":{\"338\":1}}],[\"我们实现了报告生成过程的复用\",{\"1\":{\"336\":1}}],[\"我们对输入数据\",{\"1\":{\"395\":1}}],[\"我们应该根据需求和场景合理应用接口隔离原则\",{\"1\":{\"474\":1}}],[\"我们应该将这个接口拆分成多个更小\",{\"1\":{\"473\":1}}],[\"我们应该注意将命令设计模式与其他设计模式结合使用\",{\"1\":{\"385\":1}}],[\"我们应该先确保迭代器指针还没有到达最后一个元素\",{\"1\":{\"367\":1}}],[\"我们通常使用static关键字修饰threadlocal\",{\"1\":{\"816\":1}}],[\"我们通常会创建一个待办事项列表\",{\"1\":{\"375\":1}}],[\"我们通过链式调用\",{\"1\":{\"450\":1}}],[\"我们通过建造者模式逐步构建了一个电脑对象\",{\"1\":{\"448\":1}}],[\"我们通过调用支付策略对象的\",{\"1\":{\"344\":1}}],[\"我们通过一个例子来加以理解\",{\"1\":{\"316\":1}}],[\"我们模拟了一些页面的访问\",{\"1\":{\"372\":1}}],[\"我们就可以把共享数据的可见范围限制在一个线程之内\",{\"1\":{\"831\":1}}],[\"我们就可以根据记忆集知道哪些对象被老年代对象所引用\",{\"1\":{\"742\":1}}],[\"我们就可以实现旅行团成员在不同景点间游览的行为\",{\"1\":{\"372\":1}}],[\"我们就实现了对继承类功能的增强\",{\"1\":{\"495\":1}}],[\"我们就成功地使用访问者设计模式来模拟了旅行团游览大城市的场景\",{\"1\":{\"372\":1}}],[\"我们为旅行团成员的不同类型创建具体访问者类\",{\"1\":{\"372\":1}}],[\"我们为每个具体状态创建类\",{\"1\":{\"360\":1}}],[\"我们为每个版本创建一个实现`deserializationstrategy`的具体策略类\",{\"1\":{\"346\":1}}],[\"我们定义一个共同的接口\",{\"1\":{\"495\":1}}],[\"我们定义一个歌单\",{\"1\":{\"454\":1}}],[\"我们定义一个歌曲\",{\"1\":{\"454\":1}}],[\"我们定义一个策略接口\",{\"1\":{\"344\":1}}],[\"我们定义了一个名为\",{\"1\":{\"506\":2}}],[\"我们定义了一个折扣策略接口\",{\"1\":{\"465\":1}}],[\"我们定义了一个computerbuilder接口\",{\"1\":{\"448\":1}}],[\"我们定义了一个computer类\",{\"1\":{\"448\":1}}],[\"我们定义了一个简单的状态设计模式\",{\"1\":{\"359\":1}}],[\"我们定义上下文类\",{\"1\":{\"360\":1}}],[\"我们定义抽象状态接口tvstate\",{\"1\":{\"360\":1}}],[\"我们经常需要对请求进行预处理和后处理\",{\"1\":{\"355\":1}}],[\"我们可能无法感知任务出现了异常\",{\"1\":{\"865\":1}}],[\"我们可能需要将日志记录到不同的位置\",{\"1\":{\"355\":1}}],[\"我们可以启动几十个线程并发地读取\",{\"1\":{\"853\":1}}],[\"我们可以把直接抽出为一个对象\",{\"1\":{\"781\":1}}],[\"我们可以把模块看作比类更加抽象的概念\",{\"1\":{\"460\":1}}],[\"我们可以方便地管理和操作复杂的文件系统结构\",{\"1\":{\"525\":1}}],[\"我们可以以统一的方式处理单个对象和组合对象\",{\"1\":{\"524\":1}}],[\"我们可以简化复杂系统的使用\",{\"1\":{\"517\":1}}],[\"我们可以简单地将所有计算操作的执行时间视为相同的\",{\"1\":{\"316\":1}}],[\"我们可以实现不同商品在不同销售渠道上的灵活销售\",{\"1\":{\"506\":1}}],[\"我们可以实现商品和销售渠道之间的解耦\",{\"1\":{\"506\":1}}],[\"我们可以实现解耦请求的发送者和接收者\",{\"1\":{\"381\":1}}],[\"我们可以对接口实现对象的方法进行增强\",{\"1\":{\"495\":1}}],[\"我们可以对它进行修改而不会影响originalevent\",{\"1\":{\"455\":1}}],[\"我们可以减少代码之间的依赖关系\",{\"1\":{\"486\":1}}],[\"我们可以避免在多个地方修改相同的代码\",{\"1\":{\"486\":1}}],[\"我们可以提高代码的可读性\",{\"1\":{\"482\":1}}],[\"我们可以同时考虑和应用这两个原则来构建高质量的软件系统\",{\"1\":{\"474\":1}}],[\"我们可以根据我们的类创建多个对象实例\",{\"1\":{\"804\":1}}],[\"我们可以根据需要组合不同的商品和销售渠道\",{\"1\":{\"506\":1}}],[\"我们可以根据需要为不同类型的机器人实现不同的接口\",{\"1\":{\"473\":1}}],[\"我们可以根据需求和场景来选择实现相应的接口\",{\"1\":{\"473\":1}}],[\"我们可以根据用户选择的支付方式来设置不同的支付策略\",{\"1\":{\"344\":1}}],[\"我们可以为这些功能创建一个统一的接口\",{\"1\":{\"473\":1}}],[\"我们可以引入一个抽象的折扣策略接口\",{\"1\":{\"465\":1}}],[\"我们可以清晰地看到应用单一责任原则的代码更加清晰\",{\"1\":{\"461\":1}}],[\"我们可以通过修改或添加新的抽象部分或实现部分\",{\"1\":{\"504\":1}}],[\"我们可以通过继承的方式实现\",{\"1\":{\"500\":1}}],[\"我们可以通过继承抽象类并实现具体的方法\",{\"1\":{\"335\":1}}],[\"我们可以通过代理类在调用父类方法之前或之后添加额外的逻辑\",{\"1\":{\"495\":1}}],[\"我们可以通过以下方法遵循\",{\"1\":{\"485\":1}}],[\"我们可以通过设置不同的折扣策略来应用不同的折扣类型\",{\"1\":{\"465\":1}}],[\"我们可以通过深拷贝来创建新订单\",{\"1\":{\"455\":1}}],[\"我们可以这样创建一个不可变的\",{\"1\":{\"450\":1}}],[\"我们可以获取到一个完整的电脑对象\",{\"1\":{\"448\":1}}],[\"我们可以看到代码的模块化和职责分离\",{\"1\":{\"461\":1}}],[\"我们可以看到中介者设计模式在实现聊天应用程序等复杂的对象间通信场景中的应用\",{\"1\":{\"409\":1}}],[\"我们可以看到中介者设计模式在实现飞机交通管制系统等复杂的对象间通信场景中的应用\",{\"1\":{\"404\":1}}],[\"我们可以看到飞机成功发送了消息\",{\"1\":{\"403\":1}}],[\"我们可以看到解释器设计模式在实现规则引擎等特定领域的应用\",{\"1\":{\"395\":1}}],[\"我们可以轻松地添加新的商品类型和销售渠道\",{\"1\":{\"506\":1}}],[\"我们可以轻松地添加新的命令和接收者\",{\"1\":{\"383\":1}}],[\"我们可以轻松地针对不同的职责编写独立的单元测试\",{\"1\":{\"461\":1}}],[\"我们可以轻松地实现算法的替换\",{\"1\":{\"343\":1}}],[\"我们可以使用线性探测法\",{\"1\":{\"690\":1}}],[\"我们可以使用桥接设计模式\",{\"1\":{\"506\":1}}],[\"我们可以使用代理类来执行远程任务\",{\"1\":{\"495\":1}}],[\"我们可以使用代理类来执行敏感操作\",{\"1\":{\"495\":1}}],[\"我们可以使用代理类来执行数据库查询\",{\"1\":{\"495\":1}}],[\"我们可以使用代理类来执行操作\",{\"1\":{\"495\":1}}],[\"我们可以使用代理类来显示图片\",{\"1\":{\"495\":1}}],[\"我们可以使用静态代理来实现对继承类的功能增强\",{\"1\":{\"495\":1}}],[\"我们可以使用基类的对象来处理一系列子类对象\",{\"1\":{\"470\":1}}],[\"我们可以使用统一的方法\",{\"1\":{\"469\":1}}],[\"我们可以使用开闭原则对其进行改进\",{\"1\":{\"465\":1}}],[\"我们可以使用深拷贝来实现\",{\"1\":{\"455\":1}}],[\"我们可以使用备忘录设计模式来实现撤销和重做功能\",{\"1\":{\"378\":1}}],[\"我们可以使用策略模式和工厂模式的组合来解耦代码并支持添加新的版本\",{\"1\":{\"346\":1}}],[\"我们可以定义一个名为\",{\"1\":{\"372\":1}}],[\"我们可以定义一个报告生成的抽象类\",{\"1\":{\"336\":1}}],[\"我们可以更好地组织和管理与特定状态相关的代码\",{\"1\":{\"360\":1}}],[\"我们可以进一步优化设计\",{\"1\":{\"346\":1}}],[\"我们可以创建新的\",{\"1\":{\"506\":1}}],[\"我们可以创建并返回一个不可变的\",{\"1\":{\"450\":1}}],[\"我们可以创建\",{\"1\":{\"372\":2}}],[\"我们可以创建一个\",{\"1\":{\"372\":1}}],[\"我们可以创建一个日志记录器链\",{\"1\":{\"355\":1}}],[\"我们可以创建一个工厂类来根据用户输入返回相应的策略对象\",{\"1\":{\"346\":1}}],[\"我们可以创建不同的具体报告类\",{\"1\":{\"336\":1}}],[\"我们可以灵活地设置不同的支付策略\",{\"1\":{\"344\":1}}],[\"我们可以复用通用的处理逻辑\",{\"1\":{\"338\":1}}],[\"我们可以在tomcat的webapp目录下面部署多个应用程序\",{\"1\":{\"760\":1}}],[\"我们可以在代理类中控制对实现接口的对象的访问\",{\"1\":{\"495\":1}}],[\"我们可以在继承关系中对基础类的功能进行增强\",{\"1\":{\"495\":1}}],[\"我们可以在不同的地方调用它们\",{\"1\":{\"486\":1}}],[\"我们可以在构造对象时保证对象的属性值一致和不可变\",{\"1\":{\"450\":1}}],[\"我们可以在游戏中根据角色的状态来执行不同的行为\",{\"1\":{\"360\":1}}],[\"我们可以在模板方法中处理通用的逻辑\",{\"1\":{\"338\":1}}],[\"我们可以在抽象类myservlet中增加对dopost\",{\"1\":{\"338\":1}}],[\"我们可以将其称为\",{\"1\":{\"722\":1}}],[\"我们可以将单个对象和组合对象都视为相同的抽象组件\",{\"1\":{\"526\":1}}],[\"我们可以将请求的发送者和接收者解耦\",{\"1\":{\"383\":1,\"385\":1}}],[\"我们可以将审批流程抽象为模板方法\",{\"1\":{\"333\":1}}],[\"我们可以将关卡设计抽象为模板方法\",{\"1\":{\"333\":1}}],[\"我们可以将订单处理过程抽象为模板方法\",{\"1\":{\"333\":1}}],[\"我们可以将整个数据导入过程定义为一个模板方法\",{\"1\":{\"333\":1}}],[\"我们成功解耦了代码\",{\"1\":{\"346\":1}}],[\"我们修改每个序列化器实现类\",{\"1\":{\"346\":1}}],[\"我们更新`serializer`接口\",{\"1\":{\"346\":1}}],[\"我们将订单处理系统的复杂性封装起来\",{\"1\":{\"518\":1}}],[\"我们将订单的相关信息传递给门面\",{\"1\":{\"518\":1}}],[\"我们将商品和销售渠道分离开来\",{\"1\":{\"506\":1}}],[\"我们将与用户相关的逻辑拆分成了两个独立的类\",{\"1\":{\"481\":1}}],[\"我们将功能拆分成更小的接口\",{\"1\":{\"473\":1}}],[\"我们将\",{\"1\":{\"469\":1}}],[\"我们将属性的值从\",{\"1\":{\"450\":1}}],[\"我们将实现具体的中介者类\",{\"1\":{\"406\":1}}],[\"我们将实现一个中介者\",{\"1\":{\"401\":1,\"406\":1}}],[\"我们将实现一个简单的聊天应用程序\",{\"1\":{\"405\":1}}],[\"我们将实现一个简单的飞机交通管制系统\",{\"1\":{\"400\":1}}],[\"我们将实现一个简单的规则引擎\",{\"1\":{\"391\":1,\"392\":1}}],[\"我们将实现一个简单的数学表达式求值器\",{\"1\":{\"390\":1}}],[\"我们将定义一些基本的规则\",{\"1\":{\"391\":1}}],[\"我们将旅行团成员引导到不同的景点上\",{\"1\":{\"372\":1}}],[\"我们将策略模式应用到序列化器实现类中\",{\"1\":{\"346\":1}}],[\"我们将`registerdeserializationstrategy`方法用于注册不同版本对应的反序列化策略\",{\"1\":{\"346\":1}}],[\"我们将序列化逻辑从序列化器实现类中分离出来\",{\"1\":{\"346\":1}}],[\"我们将线性阶的时间复杂度记为o\",{\"1\":{\"316\":1}}],[\"我们创建\",{\"1\":{\"360\":1}}],[\"我们创建了部门\",{\"1\":{\"525\":1}}],[\"我们创建了文件和文件夹对象\",{\"1\":{\"525\":2}}],[\"我们创建了多个具体的销售渠道类\",{\"1\":{\"506\":1}}],[\"我们创建了具体的商品类\",{\"1\":{\"506\":1}}],[\"我们创建了\",{\"1\":{\"495\":2}}],[\"我们创建了三个具体处理器类\",{\"1\":{\"350\":1}}],[\"我们创建了一个叶子节点和一个组合节点\",{\"1\":{\"524\":1}}],[\"我们创建了一个orderprocessingfacade实例\",{\"1\":{\"518\":1}}],[\"我们创建了一个桥接类\",{\"1\":{\"506\":1}}],[\"我们创建了一个basiccomputerbuilder对象作为建造者\",{\"1\":{\"448\":1}}],[\"我们创建了一个computerdirector类\",{\"1\":{\"448\":1}}],[\"我们创建了一个city对象\",{\"1\":{\"372\":1}}],[\"我们创建了一个聊天室作为中介者\",{\"1\":{\"408\":1,\"409\":1}}],[\"我们创建了一个空中交通管制作为中介者\",{\"1\":{\"404\":1}}],[\"我们创建了一个用于统计网站数据的访问者websitestatsvisitor\",{\"1\":{\"372\":1}}],[\"我们创建了一个网站\",{\"1\":{\"372\":1}}],[\"我们创建了一个superarray对象并添加了一些元素\",{\"1\":{\"366\":1}}],[\"我们创建了一个qqgroup实例作为聊天室\",{\"1\":{\"325\":1}}],[\"我们创建了一个名为chatgroup的主题接口\",{\"1\":{\"325\":1}}],[\"我们创建一个具体的远程服务类\",{\"1\":{\"495\":1}}],[\"我们创建一个具体的敏感操作类\",{\"1\":{\"495\":1}}],[\"我们创建一个具体的数据库操作类\",{\"1\":{\"495\":1}}],[\"我们创建一个具体的接口实现类\",{\"1\":{\"495\":1}}],[\"我们创建一个代理类\",{\"1\":{\"495\":5}}],[\"我们创建一个\",{\"1\":{\"344\":1}}],[\"我们创建三个具体的支付策略类\",{\"1\":{\"344\":1}}],[\"我们并不知道用户会选择哪种支付方式\",{\"1\":{\"344\":1}}],[\"我们需要将支付接口替换为新的支付接口2023\",{\"1\":{\"510\":1}}],[\"我们需要给这个结构包装一下增加一个淘汰策略\",{\"1\":{\"500\":1}}],[\"我们需要定义一个共同的接口\",{\"1\":{\"495\":3}}],[\"我们需要定义一个访问者接口\",{\"1\":{\"372\":1}}],[\"我们需要考虑业务差异和上下文变化\",{\"1\":{\"486\":1}}],[\"我们需要修改现有的代码\",{\"1\":{\"465\":1}}],[\"我们需要创建客户端代码来创建中介者\",{\"1\":{\"408\":1}}],[\"我们需要创建客户端代码来创建中介者和飞机对象\",{\"1\":{\"403\":1}}],[\"我们需要针对电视机当前的状态为每一次操作编写判断逻辑\",{\"1\":{\"360\":1}}],[\"我们需要根据实际情况来判断是否适合使用模板方法\",{\"1\":{\"339\":1}}],[\"我们需要发送用户信息给大数据征信系统\",{\"1\":{\"327\":1}}],[\"我们分别实现了handlegetrequest\",{\"1\":{\"338\":1}}],[\"我们使用synchronized的时候\",{\"1\":{\"835\":1}}],[\"我们使用组合模式来管理组织架构\",{\"1\":{\"525\":1}}],[\"我们使用组合模式来表示文件系统的层次结构\",{\"1\":{\"525\":1}}],[\"我们使用递归方式遍历文件系统的层次结构\",{\"1\":{\"525\":1}}],[\"我们使用抽象类\",{\"1\":{\"485\":1}}],[\"我们使用\",{\"1\":{\"450\":1,\"485\":1}}],[\"我们使用建造者设计模式创建了一个名为\",{\"1\":{\"450\":1}}],[\"我们使用了门面设计模式\",{\"1\":{\"518\":1}}],[\"我们使用了动态代理来为\",{\"1\":{\"497\":1}}],[\"我们使用了new\",{\"1\":{\"454\":1}}],[\"我们使用了一个list来保存多个备忘录\",{\"1\":{\"377\":1}}],[\"我们使用了访问者设计模式来实现旅行团游览大城市的场景\",{\"1\":{\"372\":1}}],[\"我们使用了策略设计模式将加法和除法封装在不同的策略类中\",{\"1\":{\"346\":1}}],[\"我们使用了线程池\",{\"1\":{\"327\":1}}],[\"我们使用策略设计模式将不同的策略封装在不同的类中\",{\"1\":{\"346\":1}}],[\"我们使得myservlet能够处理http的get\",{\"1\":{\"338\":1}}],[\"我们仍然可以沿用之前\",{\"1\":{\"327\":1}}],[\"我们称此算法的时间复杂度为\",{\"1\":{\"316\":1}}],[\"我们在performtask\",{\"1\":{\"495\":1}}],[\"我们在performoperation\",{\"1\":{\"495\":1}}],[\"我们在querydata\",{\"1\":{\"495\":1}}],[\"我们在\",{\"1\":{\"495\":1}}],[\"我们在前面提到过发送窗口\",{\"1\":{\"297\":1}}],[\"我们在为设备配置ip地址时\",{\"1\":{\"216\":1}}],[\"我们有以下几个类\",{\"1\":{\"518\":1,\"524\":1}}],[\"我们有一个基础类\",{\"1\":{\"495\":1}}],[\"我们有时很需要知道双向交互一次所需的时间\",{\"1\":{\"265\":1}}],[\"我们有五个目的网络\",{\"1\":{\"221\":1}}],[\"我们只需要知道这个对象可以为我提供便利\",{\"1\":{\"782\":1}}],[\"我们只需要实现\",{\"1\":{\"473\":1}}],[\"我们只需要创建一个新的实现了\",{\"1\":{\"465\":1}}],[\"我们只需要寄出去\",{\"1\":{\"126\":1}}],[\"我们只需关注与当前对象直接相关的部分\",{\"1\":{\"488\":1}}],[\"我们只需关注\",{\"1\":{\"461\":2}}],[\"我们只能调用一次remove\",{\"1\":{\"367\":1}}],[\"我们只关心可以调制出不同基本波形\",{\"1\":{\"240\":1}}],[\"我们也可以把它分成网络id和主机id两部分\",{\"1\":{\"216\":1}}],[\"我们把这些流程封装为对应的方法\",{\"1\":{\"781\":1}}],[\"我们把\",{\"1\":{\"144\":1}}],[\"我们打电话给某个人时\",{\"1\":{\"125\":1}}],[\"我们买票\",{\"1\":{\"119\":1}}],[\"逐个链路改变\",{\"1\":{\"167\":1}}],[\"逐站传递\",{\"1\":{\"153\":1}}],[\"标记与引用关联起来\",{\"1\":{\"847\":1}}],[\"标记从根对象\",{\"1\":{\"748\":1}}],[\"标记整理\",{\"1\":{\"745\":1}}],[\"标记过程仍然与\",{\"1\":{\"744\":1}}],[\"标记出所有需要回收的对象\",{\"1\":{\"744\":1}}],[\"标记\",{\"1\":{\"744\":6}}],[\"标准库\",{\"1\":{\"485\":1}}],[\"标识出老年代的哪一块内存会存在跨代引用\",{\"1\":{\"742\":1}}],[\"标识上层协议\",{\"1\":{\"304\":1}}],[\"标识此ip数据报发送节点和接收节点的ip地址及控制信息\",{\"1\":{\"192\":1}}],[\"标识同一网络上不同主机\",{\"1\":{\"167\":1}}],[\"标识因特网上数以百万计的网络\",{\"1\":{\"167\":1}}],[\"标志是否等于预期标志\",{\"1\":{\"845\":1}}],[\"标志帧的开始\",{\"1\":{\"575\":2}}],[\"标志帧的起始或结束\",{\"1\":{\"131\":1}}],[\"标志位复位\",{\"1\":{\"153\":1}}],[\"标志\",{\"1\":{\"131\":1}}],[\"约等于2\",{\"1\":{\"166\":1}}],[\"约定好一个生成多项式g\",{\"1\":{\"135\":1,\"576\":1}}],[\"共同点\",{\"1\":{\"780\":1,\"783\":1,\"812\":1}}],[\"共同的接口\",{\"1\":{\"495\":1}}],[\"共同前缀\",{\"1\":{\"221\":1}}],[\"共分为四层\",{\"1\":{\"268\":1}}],[\"共分为七层\",{\"1\":{\"268\":1}}],[\"共22位\",{\"1\":{\"221\":1}}],[\"共48位\",{\"1\":{\"166\":1}}],[\"共享变量的值仍然是a\",{\"1\":{\"845\":1}}],[\"共享变量的内存地址\",{\"1\":{\"845\":1}}],[\"共享锁\",{\"1\":{\"842\":1}}],[\"共享锁和独占锁有什么区别\",{\"1\":{\"842\":1}}],[\"共享内存\",{\"1\":{\"811\":1}}],[\"共享相同的地址空间\",{\"1\":{\"804\":1}}],[\"共享相同的网络资源和广播域\",{\"1\":{\"579\":2}}],[\"共享外部状态\",{\"1\":{\"533\":1}}],[\"共享对象减少了对象的创建和销毁过程\",{\"1\":{\"533\":1}}],[\"共享和使用\",{\"1\":{\"450\":1}}],[\"共享文件\",{\"1\":{\"83\":1}}],[\"共享资源或者服务\",{\"1\":{\"59\":1}}],[\"概念\",{\"0\":{\"165\":1}}],[\"概述\",{\"0\":{\"61\":1,\"66\":1,\"103\":1,\"119\":1,\"144\":1,\"155\":1,\"161\":1,\"173\":1,\"208\":1,\"214\":1,\"220\":1,\"293\":1,\"296\":1}}],[\"资源释放不同\",{\"1\":{\"812\":1}}],[\"资源的分配采用了时间片轮转也就是给每个线程分配一个时间片\",{\"1\":{\"809\":1}}],[\"资源的分配和调度执行任务\",{\"1\":{\"804\":1}}],[\"资源后就可以继续运行\",{\"1\":{\"807\":1}}],[\"资源\",{\"1\":{\"751\":1,\"765\":1,\"804\":2}}],[\"资源加载器实现了抽象工厂设计模式\",{\"1\":{\"436\":1}}],[\"资源共享\",{\"1\":{\"162\":1}}],[\"资源在万维网中的唯一标识\",{\"1\":{\"104\":1}}],[\"范围是\",{\"1\":{\"785\":1}}],[\"范围较小\",{\"1\":{\"162\":1}}],[\"范围很广\",{\"1\":{\"162\":1}}],[\"结果正确\",{\"0\":{\"844\":1}}],[\"结果就是截取了最低的四位值\",{\"1\":{\"694\":1}}],[\"结果\",{\"1\":{\"687\":1}}],[\"结束之后再将原容器的引用指向新容器\",{\"1\":{\"682\":1}}],[\"结束邮件内容\",{\"1\":{\"94\":1}}],[\"结构性修改\",{\"1\":{\"710\":1}}],[\"结构型设计模式就是利用类与类之间的关系\",{\"1\":{\"493\":1}}],[\"结构型设计模式\",{\"0\":{\"493\":1},\"1\":{\"493\":1}}],[\"结构型模式\",{\"1\":{\"490\":1}}],[\"结构如下\",{\"1\":{\"304\":1}}],[\"结合门面设计模式的案例是一个在线购物平台的订单处理系统\",{\"1\":{\"518\":1}}],[\"结合工厂设计模式\",{\"0\":{\"346\":1}}],[\"结合了网络拓扑结构和通信流量两方面的因素进行路由选择\",{\"1\":{\"205\":1}}],[\"结点间的寻址可以通过二层mac地址进行\",{\"1\":{\"191\":1}}],[\"结点之间都是点到点连接\",{\"1\":{\"162\":1}}],[\"结点交换机在单个网络中转发分组\",{\"1\":{\"161\":1}}],[\"结点交换机和路由器都用来转发分组\",{\"1\":{\"161\":1}}],[\"远远比并发标记阶段时间短\",{\"1\":{\"746\":1,\"750\":1}}],[\"远超一个城市的范围\",{\"1\":{\"161\":1}}],[\"远程代理示例代码\",{\"1\":{\"495\":1}}],[\"远程代理\",{\"1\":{\"495\":2}}],[\"远程接入vpn\",{\"1\":{\"223\":1}}],[\"远程登录\",{\"1\":{\"54\":1,\"56\":1}}],[\"远程连接redis\",{\"1\":{\"14\":1,\"40\":1}}],[\"远程\",{\"1\":{\"11\":1,\"37\":1}}],[\"广域网中的一个重要问题是路由选择和分组转发\",{\"1\":{\"162\":1}}],[\"广域网与局域网的比较\",{\"0\":{\"162\":1}}],[\"广域网不等于互联网\",{\"1\":{\"161\":1}}],[\"广域网的通信子网主要使用分组交换技术\",{\"1\":{\"161\":2}}],[\"广域网\",{\"0\":{\"160\":1},\"1\":{\"161\":2,\"162\":1}}],[\"广播域和隔离性\",{\"1\":{\"580\":1}}],[\"广播通信方式\",{\"1\":{\"301\":1}}],[\"广播地址和保留地址\",{\"1\":{\"222\":1}}],[\"广播地址是一个特殊的地址\",{\"1\":{\"166\":1}}],[\"广播地址是用于将数据从一个发送者传递到同一广播信道上的所有设备的地址\",{\"1\":{\"166\":1}}],[\"广播是一种一对所有的通信方式\",{\"1\":{\"166\":1}}],[\"广播\",{\"1\":{\"166\":1,\"282\":1}}],[\"广播风暴\",{\"1\":{\"159\":1}}],[\"广播流量会跨越整个机构网络\",{\"1\":{\"159\":1,\"579\":1}}],[\"广播信道的无线局域网\",{\"1\":{\"152\":1}}],[\"广播信道的有线局域网\",{\"1\":{\"152\":1}}],[\"互斥这个条件我们没有办法破坏\",{\"1\":{\"848\":1}}],[\"互斥条件\",{\"1\":{\"848\":1}}],[\"互斥是方法\",{\"1\":{\"831\":1}}],[\"互斥是因\",{\"1\":{\"831\":1}}],[\"互斥是实现同步的一种手段\",{\"1\":{\"831\":1}}],[\"互斥同步是常见的一种并发正确性的保障手段\",{\"1\":{\"831\":1}}],[\"互斥\",{\"1\":{\"831\":1}}],[\"互不影响\",{\"1\":{\"455\":1}}],[\"互不干扰\",{\"1\":{\"150\":1,\"816\":1}}],[\"互连而成的\",{\"1\":{\"257\":1}}],[\"互连\",{\"1\":{\"257\":1}}],[\"互连的网络都叫internet\",{\"1\":{\"248\":1}}],[\"互连的trunk端口的pvld值不等\",{\"1\":{\"159\":1}}],[\"互连网\",{\"1\":{\"247\":1}}],[\"互联网协议\",{\"1\":{\"593\":1}}],[\"互联网上的信息不仅仅单方向传输而是双向交互的\",{\"1\":{\"265\":1}}],[\"互联网上的主机都必须有ip地址才能通信\",{\"1\":{\"249\":1}}],[\"互联网是网络的网络\",{\"1\":{\"247\":1}}],[\"互联网\",{\"0\":{\"247\":1},\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"互联网可以连接不同类型的网络\",{\"1\":{\"161\":1}}],[\"直至找到空闲的位置\",{\"1\":{\"692\":1}}],[\"直至找到空闲位置\",{\"1\":{\"692\":1}}],[\"直至成功或达到最大重试次数\",{\"1\":{\"578\":1}}],[\"直至所有规则都被执行\",{\"1\":{\"355\":1}}],[\"直至数据发送完毕\",{\"1\":{\"275\":1}}],[\"直到信号量的值大于零为止\",{\"1\":{\"853\":1}}],[\"直到最后一个线程到达屏障时\",{\"1\":{\"852\":1}}],[\"直到满足每个线程对资源的最大需求\",{\"1\":{\"848\":1}}],[\"直到清零释放锁\",{\"1\":{\"836\":1}}],[\"直到计数器清零\",{\"1\":{\"836\":1}}],[\"直到出现没有竞争的共享数据为止\",{\"1\":{\"831\":1,\"832\":1}}],[\"直到被执行\",{\"1\":{\"804\":1}}],[\"直到请求被完全处理\",{\"1\":{\"355\":1}}],[\"直到有一个处理器能够处理该请求\",{\"1\":{\"350\":1}}],[\"直到有一个处理器能够处理它为止\",{\"1\":{\"349\":1}}],[\"直到所有的观察者代码都执行完成之后\",{\"1\":{\"327\":1}}],[\"直到目的端收到数据为止\",{\"1\":{\"275\":1}}],[\"直到接收到正确的分组为止\",{\"1\":{\"138\":1}}],[\"直线传播\",{\"1\":{\"230\":1}}],[\"直连网络的链路状态信息\",{\"1\":{\"210\":1}}],[\"直接去找小姐姐办理业务\",{\"1\":{\"868\":1}}],[\"直接抛出异常\",{\"1\":{\"861\":1}}],[\"直接指针\",{\"1\":{\"730\":1}}],[\"直接返回\",{\"1\":{\"700\":1}}],[\"直接根据key来映射到对应的数组位置\",{\"1\":{\"691\":1}}],[\"直接定址法\",{\"1\":{\"691\":1}}],[\"直接覆盖\",{\"1\":{\"686\":1}}],[\"直接使用数字信号传输可能会面临以下问题\",{\"1\":{\"619\":1}}],[\"直接从缓存中获取结果\",{\"1\":{\"495\":1}}],[\"直接从缓存中返回结果\",{\"1\":{\"495\":1}}],[\"直接跳过此处\",{\"1\":{\"317\":1}}],[\"直接通信是不可行的\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"直接转发\",{\"1\":{\"159\":1}}],[\"直通交换\",{\"1\":{\"173\":1}}],[\"记忆集是抽象的概念\",{\"1\":{\"742\":1}}],[\"记忆集\",{\"1\":{\"742\":1}}],[\"记得勾选android\",{\"1\":{\"538\":1}}],[\"记为t\",{\"1\":{\"316\":1}}],[\"记录的任务数量为0\",{\"1\":{\"867\":1}}],[\"记录线程获取锁的次数\",{\"1\":{\"835\":1}}],[\"记录下栈上和寄存器里哪些位置是引用\",{\"1\":{\"747\":1}}],[\"记录到\",{\"1\":{\"747\":1}}],[\"记录上哪些内存块是可用的\",{\"1\":{\"727\":1}}],[\"记录了不同\",{\"1\":{\"579\":1}}],[\"记录了各个端口号和它对应的vlan号\",{\"1\":{\"159\":1,\"579\":1}}],[\"记录一个当前位置指针\",{\"1\":{\"366\":1}}],[\"记录以及输入等\",{\"1\":{\"215\":1}}],[\"记录有ip地址与mac地址的对应关系\",{\"1\":{\"168\":1,\"583\":1}}],[\"记住\",{\"1\":{\"110\":1}}],[\"频繁创建了大量对象\",{\"1\":{\"768\":1}}],[\"频繁\",{\"0\":{\"767\":1,\"768\":1},\"1\":{\"767\":2,\"768\":1,\"769\":1}}],[\"频繁执行的部分\",{\"1\":{\"720\":1}}],[\"频繁的广播信息\",{\"1\":{\"159\":1}}],[\"频谱展示了信号的频率特征\",{\"1\":{\"621\":1}}],[\"频谱则关注信号中各个频率成分的分布情况\",{\"0\":{\"621\":1}}],[\"频谱指的是信号或波形在频率上的分布情况\",{\"1\":{\"620\":1}}],[\"频谱\",{\"1\":{\"620\":1}}],[\"频率\",{\"1\":{\"617\":1}}],[\"频率带宽\",{\"1\":{\"240\":1}}],[\"频带宽度\",{\"1\":{\"261\":1}}],[\"频分多路复用\",{\"0\":{\"147\":1},\"1\":{\"144\":1}}],[\"潜在的安全问题\",{\"1\":{\"159\":1}}],[\"几乎成为局域网的代名词\",{\"1\":{\"158\":1}}],[\"高一定是某个程序长期占用了\",{\"1\":{\"765\":1}}],[\"高级数据链路控制\",{\"1\":{\"584\":1}}],[\"高效\",{\"1\":{\"578\":1}}],[\"高层模块不受影响\",{\"1\":{\"476\":1}}],[\"高层模块不需要知道低层模块的具体实现\",{\"1\":{\"476\":1}}],[\"高\",{\"1\":{\"316\":1,\"765\":2}}],[\"高频和甚高频靠电离层\",{\"1\":{\"230\":1}}],[\"高速传送4种不同的连接服务类型\",{\"1\":{\"158\":1}}],[\"高电平对和低\",{\"1\":{\"131\":1}}],[\"高电平对\",{\"1\":{\"131\":1}}],[\"组线程到达一个屏障\",{\"1\":{\"852\":1}}],[\"组织结构包括部门和员工\",{\"1\":{\"525\":1}}],[\"组织架构管理\",{\"1\":{\"525\":1}}],[\"组件接口应该定义一组合适的方法\",{\"1\":{\"526\":1}}],[\"组件接口的设计\",{\"1\":{\"526\":1}}],[\"组件接口\",{\"1\":{\"524\":1,\"525\":1}}],[\"组件\",{\"1\":{\"524\":1,\"526\":1}}],[\"组合可以降低类之间的耦合度\",{\"1\":{\"782\":1}}],[\"组合优于继承\",{\"1\":{\"782\":1}}],[\"组合一些region\",{\"1\":{\"749\":1}}],[\"组合对象\",{\"1\":{\"526\":1}}],[\"组合节点\",{\"1\":{\"524\":1}}],[\"组合类\",{\"1\":{\"524\":1,\"525\":1}}],[\"组合类表示组合中的组合节点\",{\"1\":{\"524\":1}}],[\"组合设计模式的基本流程如下\",{\"1\":{\"524\":1}}],[\"组合设计模式的核心思想是将对象组织成树形结构\",{\"1\":{\"523\":1}}],[\"组合设计模式由以下几个主要角色组成\",{\"1\":{\"524\":1}}],[\"组合设计模式是一种结构性设计模式\",{\"1\":{\"522\":1}}],[\"组合设计模式\",{\"0\":{\"521\":1}}],[\"组合模式通过统一处理单个对象和组合对象\",{\"1\":{\"526\":1}}],[\"组合模式在许多场景中都有应用\",{\"1\":{\"526\":1}}],[\"组合模式是一种结构型设计模式\",{\"1\":{\"526\":1}}],[\"组合模式统一了叶子节点和组合节点的处理方式\",{\"1\":{\"525\":1}}],[\"组合模式适用于需要处理树状结构的情况\",{\"1\":{\"524\":1}}],[\"组合模式使得客户端能够以一致的方式处理单个对象以及对象的组合\",{\"1\":{\"522\":1}}],[\"组合模式\",{\"1\":{\"490\":1}}],[\"组合\",{\"1\":{\"166\":1,\"493\":2,\"524\":1,\"782\":1}}],[\"组帧和拆卸帧\",{\"1\":{\"158\":1}}],[\"组成的操作\",{\"1\":{\"713\":1}}],[\"组成和基本流程\",{\"0\":{\"324\":1,\"332\":1,\"343\":1,\"350\":1,\"359\":1,\"365\":1,\"371\":1,\"377\":1,\"383\":1,\"390\":1,\"400\":1,\"418\":1,\"434\":1,\"441\":1,\"448\":1,\"516\":1,\"524\":1,\"530\":1}}],[\"组成格式\",{\"1\":{\"202\":1}}],[\"组成资源和信息共享的计算机互联网络\",{\"1\":{\"155\":1}}],[\"组成结构\",{\"0\":{\"120\":1}}],[\"组成方式\",{\"1\":{\"104\":1}}],[\"组成\",{\"0\":{\"93\":1,\"104\":1,\"166\":1,\"426\":1},\"1\":{\"166\":1,\"246\":1,\"365\":1,\"377\":1,\"383\":1,\"443\":2,\"574\":1}}],[\"铜缆和光纤等多种传输介质\",{\"1\":{\"158\":1}}],[\"④星形和总线形结合的复合型结构\",{\"1\":{\"158\":1}}],[\"③网络故障\",{\"1\":{\"205\":1}}],[\"③分段与重组\",{\"0\":{\"193\":1}}],[\"③总线形结构\",{\"1\":{\"158\":1}}],[\"③当其他站要发送数据\",{\"1\":{\"152\":1}}],[\"②不同物理机之间当然可以传输比特流\",{\"1\":{\"573\":1}}],[\"②还原报文\",{\"1\":{\"254\":1}}],[\"②转发分组\",{\"1\":{\"254\":1}}],[\"②发送分组\",{\"1\":{\"254\":1}}],[\"②减少相邻导线的电磁干扰\",{\"1\":{\"230\":1}}],[\"②聚合了不存在的网络\",{\"1\":{\"205\":1}}],[\"②数据报的封装\",{\"0\":{\"192\":1}}],[\"②无连接的网络服务\",{\"1\":{\"184\":1,\"589\":1}}],[\"②环形结构\",{\"1\":{\"158\":1}}],[\"②为什么目的站接收到帧后还需要等到sifs时间才返回ack确认帧呢\",{\"1\":{\"152\":1}}],[\"①这里就会出现不同传输介质\",{\"1\":{\"573\":1}}],[\"①接收分组\",{\"1\":{\"254\":1}}],[\"①缓存分组\",{\"1\":{\"254\":1}}],[\"①构建分组\",{\"1\":{\"254\":1}}],[\"①抵御部分来自外界的电磁波干扰\",{\"1\":{\"230\":1}}],[\"①寻址\",{\"0\":{\"191\":1}}],[\"①面向连接的网络服务\",{\"1\":{\"184\":1,\"589\":1}}],[\"①星形结构\",{\"1\":{\"158\":1}}],[\"①为什么源站检测到信道空闲后\",{\"1\":{\"152\":1}}],[\"同参数列表的方法\",{\"1\":{\"780\":1}}],[\"同学可能喊阿三\",{\"1\":{\"594\":1}}],[\"同b再包装一层\",{\"1\":{\"502\":2}}],[\"同a包装一下\",{\"1\":{\"502\":2}}],[\"同理一个程序可以启动多个进程\",{\"1\":{\"804\":1}}],[\"同理\",{\"1\":{\"327\":1}}],[\"同理系数2也可以忽略\",{\"1\":{\"316\":1}}],[\"同样是输出\",{\"1\":{\"769\":1}}],[\"同样是无序的\",{\"1\":{\"706\":1}}],[\"同样有三个明显的缺点\",{\"1\":{\"751\":1}}],[\"同样通过哈希码来确定存储位置\",{\"1\":{\"706\":1}}],[\"同样地\",{\"1\":{\"579\":1}}],[\"同样实现上述接口\",{\"1\":{\"495\":1}}],[\"同样更新fastjson2serializer\",{\"1\":{\"346\":1}}],[\"同样\",{\"1\":{\"316\":1,\"712\":1,\"755\":1}}],[\"同一对网络实体间的用户应用进程可能有多个\",{\"1\":{\"277\":1}}],[\"同一时间\",{\"1\":{\"277\":1}}],[\"同一系统内\",{\"1\":{\"251\":1}}],[\"同步队列\",{\"1\":{\"862\":1}}],[\"同步锁会升级至重量级锁\",{\"1\":{\"837\":1}}],[\"同步方法代码块\",{\"1\":{\"832\":1}}],[\"同步是目的\",{\"1\":{\"831\":1}}],[\"同步是果\",{\"1\":{\"831\":1}}],[\"同步是指在多个线程并发访问共享数据时\",{\"1\":{\"831\":1}}],[\"同步\",{\"1\":{\"250\":1,\"584\":1}}],[\"同步传输是指数据的传输是在发送端和接收端之间保持时钟同步的情况下进行的\",{\"1\":{\"236\":1}}],[\"同步传输\",{\"0\":{\"236\":1},\"1\":{\"234\":1,\"236\":1}}],[\"同轴电缆价格较贵且布线不够灵活和方便\",{\"1\":{\"230\":1}}],[\"同轴电缆\",{\"1\":{\"230\":1,\"618\":1}}],[\"同轴电缆等连接介质互相连接起来\",{\"1\":{\"155\":1}}],[\"同时避免了频繁创建和销毁线程所带来的开销\",{\"1\":{\"858\":1}}],[\"同时避免不必要的连接中断\",{\"1\":{\"294\":1}}],[\"同时又可以保证有写入操作时的线程安全\",{\"1\":{\"842\":2}}],[\"同时该等待线程进入\",{\"1\":{\"835\":1}}],[\"同时还提供了互斥访问共享资源的能力\",{\"1\":{\"834\":1}}],[\"同时还要负责维护用户的邮箱\",{\"1\":{\"90\":1}}],[\"同时呢\",{\"1\":{\"749\":1}}],[\"同时开启\",{\"1\":{\"746\":1,\"750\":1}}],[\"同时工作\",{\"1\":{\"746\":1}}],[\"同时进行年龄计数\",{\"1\":{\"741\":1}}],[\"同时进行\",{\"1\":{\"707\":1}}],[\"同时提供一个负载因子\",{\"1\":{\"690\":1}}],[\"同时利用振幅和相位来表示多个数字信号\",{\"1\":{\"619\":1}}],[\"同时将模拟信号还原为数字数据\",{\"1\":{\"618\":1}}],[\"同时将该结果反馈给客户端\",{\"1\":{\"81\":1}}],[\"同时与上层的数据链路层建立了桥梁\",{\"1\":{\"617\":1}}],[\"同时降低了客户端与子系统的耦合度\",{\"1\":{\"518\":1}}],[\"同时使得代码更加清晰和易于理解\",{\"1\":{\"422\":1}}],[\"同时也可以在创建锁构造函数中传入具体参数创建公平锁\",{\"1\":{\"840\":1}}],[\"同时也可隔离冲突域的交换机\",{\"1\":{\"171\":1}}],[\"同时也使得代码更具有通用性和复用性\",{\"1\":{\"797\":1}}],[\"同时也提供了一种灵活的方式来扩展和处理组合对象的层次结构\",{\"1\":{\"526\":1}}],[\"同时也有助于代码的可读性和可测试性\",{\"1\":{\"490\":1}}],[\"同时也能提升代码的可测试性和可复用性\",{\"1\":{\"478\":1}}],[\"同时也能很容易地增加新的页面类型\",{\"1\":{\"372\":1}}],[\"同时也降低了类之间的耦合性\",{\"1\":{\"472\":1}}],[\"同时也增加了系统的复杂度\",{\"1\":{\"444\":1}}],[\"同时旅行团成员可以根据自己的类型执行不同的访问行为\",{\"1\":{\"372\":1}}],[\"同时不需要修改景点的结构\",{\"1\":{\"372\":1}}],[\"同时我们在代码时\",{\"1\":{\"360\":1}}],[\"同时保持了各个处理器之间的解耦\",{\"1\":{\"355\":1}}],[\"同时为不同类型的请求提供灵活的特定处理实现\",{\"1\":{\"338\":1}}],[\"同时\",{\"1\":{\"333\":1,\"367\":1,\"385\":1,\"465\":1,\"481\":1,\"485\":1,\"486\":1,\"488\":1,\"495\":1,\"506\":1,\"689\":1,\"720\":1,\"746\":1,\"776\":1,\"789\":1}}],[\"同时在对象锁mark\",{\"1\":{\"837\":1}}],[\"同时在其中定义一个被代理类的对象作为成员变量\",{\"1\":{\"494\":1}}],[\"同时在子类中提供具体步骤的灵活实现\",{\"1\":{\"331\":1}}],[\"同时在请求头部中包含一个名为\",{\"1\":{\"114\":1}}],[\"同时拥有通信线路以及路由器等连网设备\",{\"1\":{\"249\":1}}],[\"同时它也接收每个邻居结点发来的距离矢量表\",{\"1\":{\"208\":1}}],[\"同时它又可隔离冲突域\",{\"1\":{\"171\":1}}],[\"同时把所有节点集中在以它为中心的节点上\",{\"1\":{\"170\":1}}],[\"同时允许接收方接收乱序的分组\",{\"1\":{\"139\":1}}],[\"同时做好妥善的应急备份准备\",{\"1\":{\"81\":1}}],[\"内核的切换\",{\"1\":{\"804\":1}}],[\"内存屏障\",{\"1\":{\"828\":1}}],[\"内存系统的重排序\",{\"1\":{\"826\":1}}],[\"内存大小\",{\"1\":{\"769\":1}}],[\"内存空间真不足\",{\"1\":{\"767\":1}}],[\"内存空间的碎片化问题\",{\"1\":{\"744\":1}}],[\"内存飚高如果是发生在\",{\"1\":{\"766\":1}}],[\"内存飙高问题怎么排查\",{\"0\":{\"766\":1},\"1\":{\"766\":1}}],[\"内存映像\",{\"1\":{\"762\":1}}],[\"内存都将在方法区中进行分配\",{\"1\":{\"754\":1}}],[\"内存布局\",{\"1\":{\"751\":1}}],[\"内存不足才会被回收\",{\"1\":{\"735\":1}}],[\"内存不够了\",{\"1\":{\"731\":1}}],[\"内存泄漏最可能的罪魁祸首之一\",{\"1\":{\"770\":1}}],[\"内存泄漏和内存溢出二者关系非常密切\",{\"1\":{\"770\":1}}],[\"内存泄漏是内在病源\",{\"1\":{\"769\":1}}],[\"内存泄漏导致空间不足\",{\"1\":{\"767\":1}}],[\"内存泄漏\",{\"1\":{\"731\":2,\"768\":2}}],[\"内存泄露主要和threadlocalmap中使用的\",{\"1\":{\"818\":1}}],[\"内存泄露是怎么回事\",{\"1\":{\"818\":1}}],[\"内存泄露可能会导致内存溢出\",{\"1\":{\"731\":1}}],[\"内存泄露\",{\"0\":{\"818\":1},\"1\":{\"731\":1}}],[\"内存溢出可能会有很多原因导致\",{\"1\":{\"770\":1}}],[\"内存溢出\",{\"1\":{\"731\":3}}],[\"内存溢出和内存泄漏是什么意思\",{\"0\":{\"731\":1},\"1\":{\"731\":1}}],[\"内存分配的方式有几种\",{\"0\":{\"727\":1},\"1\":{\"727\":1}}],[\"内存分配完成之后\",{\"1\":{\"726\":1}}],[\"内存区域有什么变化\",{\"0\":{\"723\":1}}],[\"内存区域最简单粗暴的划分可以分为堆和栈\",{\"1\":{\"722\":1}}],[\"内存区域\",{\"0\":{\"718\":1}}],[\"内存是放不下的\",{\"1\":{\"694\":1}}],[\"内存地址等\",{\"1\":{\"690\":1}}],[\"内存没以前贵\",{\"1\":{\"317\":1}}],[\"内具体的实现\",{\"1\":{\"366\":1}}],[\"内没有收到确认就要重传已发送的报文段\",{\"1\":{\"291\":1}}],[\"内同步\",{\"1\":{\"236\":1}}],[\"内联网vpn通常用于建立企业内部的安全通信网络\",{\"1\":{\"223\":1}}],[\"内联网vpn\",{\"1\":{\"223\":1}}],[\"内部正在跑的任务和队列里等待的任务\",{\"1\":{\"864\":1}}],[\"内部的状态变量\",{\"1\":{\"839\":1}}],[\"内部的帧交换表是空的\",{\"1\":{\"174\":1}}],[\"内部类的\",{\"1\":{\"839\":2}}],[\"内部类来实现同步功能\",{\"1\":{\"839\":1}}],[\"内部同时还启动了很多守护线程\",{\"1\":{\"810\":1}}],[\"内部维护的是char数组\",{\"1\":{\"789\":1}}],[\"内部维护的是一个private\",{\"1\":{\"789\":1}}],[\"内部逻辑可以改变\",{\"1\":{\"780\":1}}],[\"内部定义了一个对象锁\",{\"1\":{\"708\":1}}],[\"内部数据结构\",{\"1\":{\"704\":1,\"705\":1}}],[\"内部广播域是连通的\",{\"1\":{\"580\":1}}],[\"内部状态可被共享\",{\"1\":{\"530\":1}}],[\"内部网关协议igp\",{\"1\":{\"211\":1}}],[\"内部网关协议\",{\"1\":{\"211\":1}}],[\"内容如下\",{\"1\":{\"168\":1,\"583\":1}}],[\"内\",{\"1\":{\"155\":1}}],[\"沿着环\",{\"1\":{\"153\":1}}],[\"单机线程池执行断电了应该怎么处理\",{\"0\":{\"871\":1},\"1\":{\"871\":1}}],[\"单线程的线程池\",{\"1\":{\"859\":1}}],[\"单线程的程序能保证最终结果是有序的\",{\"1\":{\"836\":1}}],[\"单线程程序的执行结果不能被改变\",{\"1\":{\"826\":1}}],[\"单线程下可以认为程序是有序的\",{\"1\":{\"825\":1}}],[\"单值集合\",{\"0\":{\"676\":1}}],[\"单元测试\",{\"1\":{\"539\":1}}],[\"单一职责原则\",{\"1\":{\"460\":1,\"474\":1}}],[\"单一原则\",{\"0\":{\"459\":1}}],[\"单例对象在初始化后会以静态变量的方式在\",{\"1\":{\"731\":1}}],[\"单例模式\",{\"1\":{\"490\":1}}],[\"单例模式只允许存在一个实例对象\",{\"1\":{\"421\":1}}],[\"单例模式的构造方法被私有化\",{\"1\":{\"421\":1}}],[\"单例模式常用于需要在整个系统中共享一个共享资源或管理共享状态的情况下\",{\"1\":{\"416\":1}}],[\"单例存在的其它问题\",{\"1\":{\"421\":2}}],[\"单例类\",{\"1\":{\"418\":1}}],[\"单例设计模式在需要全局访问点和唯一实例的情况下非常有用\",{\"1\":{\"421\":1}}],[\"单例设计模式通过确保一个类只有一个实例\",{\"1\":{\"421\":1}}],[\"单例设计模式通常由以下组成部分构成\",{\"1\":{\"418\":1}}],[\"单例设计模式适用于以下场景\",{\"1\":{\"419\":1}}],[\"单例设计模式的优点和缺点\",{\"1\":{\"421\":1}}],[\"单例设计模式的基本流程如下\",{\"1\":{\"418\":1}}],[\"单例设计模式的核心思想是确保一个类只有一个实例\",{\"1\":{\"417\":1}}],[\"单例设计模式\",{\"0\":{\"415\":1},\"1\":{\"416\":1}}],[\"单次迭代\",{\"1\":{\"367\":1}}],[\"单位时间\",{\"1\":{\"316\":1}}],[\"单位\",{\"1\":{\"261\":2}}],[\"单工需要一条信道\",{\"1\":{\"237\":1}}],[\"单工通信\",{\"1\":{\"237\":1}}],[\"单工\",{\"1\":{\"237\":1}}],[\"单靠数据链路层的mac地址寻址是不够的\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"单播地址是用于将数据从一个发送者传递到一个特定的接收者的地址\",{\"1\":{\"166\":1}}],[\"单播\",{\"1\":{\"166\":2,\"174\":1}}],[\"单点故障\",{\"1\":{\"153\":2}}],[\"单个标号的长度不超过36个字符\",{\"1\":{\"69\":1}}],[\"邀请\",{\"1\":{\"153\":1}}],[\"​\",{\"1\":{\"152\":3,\"189\":1,\"501\":1}}],[\"还额外有cas操作的开销\",{\"1\":{\"837\":1}}],[\"还确保了原子性和有序性\",{\"1\":{\"834\":1}}],[\"还经常遇到这样一种情况\",{\"1\":{\"831\":1}}],[\"还提供了join\",{\"1\":{\"811\":1}}],[\"还包含了两个指针用于维护双向链表的结构\",{\"1\":{\"714\":1}}],[\"还包含了发送电子邮件的逻辑\",{\"1\":{\"461\":1}}],[\"还有一种情况是这两个线程同时\",{\"1\":{\"707\":1}}],[\"还可以利用图形化工具\",{\"1\":{\"849\":1}}],[\"还可以节省内存空间\",{\"1\":{\"680\":1}}],[\"还可以对mac地址进行分区\",{\"1\":{\"171\":1}}],[\"还能访问包装后的对象\",{\"1\":{\"500\":1}}],[\"还复制对象所引用的所有子对象\",{\"1\":{\"455\":1}}],[\"还需要存储到数据库中\",{\"1\":{\"853\":1}}],[\"还需要提供\",{\"1\":{\"787\":1}}],[\"还需要更新相关的测试代码\",{\"1\":{\"465\":1}}],[\"还需要使用下面一层所提供的服务\",{\"1\":{\"251\":1}}],[\"还需要等待difs时间才将帧发送呢\",{\"1\":{\"152\":1}}],[\"还必须把它交给目的主机的应用进程\",{\"1\":{\"274\":1}}],[\"还必须运行自己所在自治系统所使用的内部网关协议igp\",{\"1\":{\"212\":1}}],[\"还必须有一些规程或协议来控制这些数据的传输\",{\"1\":{\"119\":1}}],[\"还要做最后一次审计\",{\"1\":{\"736\":1}}],[\"还要\",{\"0\":{\"601\":1}}],[\"还要根据路径中各段链路的状态来计算最佳路由路径\",{\"1\":{\"210\":1}}],[\"还要向源点发送时间超过报文\",{\"1\":{\"201\":1}}],[\"还是自己定义的\",{\"1\":{\"729\":1}}],[\"还是因为找不到对应的键而返回的\",{\"1\":{\"712\":1}}],[\"还是根本没有这个键\",{\"1\":{\"712\":1}}],[\"还是使用了反向\",{\"1\":{\"673\":1}}],[\"还是\",{\"1\":{\"477\":1,\"790\":2}}],[\"还是交换机都会有一个用来缓存同一网段设备ip地址和mac地址的arp映射表\",{\"1\":{\"198\":1}}],[\"还是会进行分组之后再发送\",{\"1\":{\"180\":1,\"587\":1}}],[\"还原成数字数据\",{\"1\":{\"229\":1}}],[\"还原成原来的大的数据报的问题\",{\"1\":{\"193\":1}}],[\"还原出原来的数据包格式\",{\"1\":{\"186\":1,\"591\":1}}],[\"还存在一张vlan表\",{\"1\":{\"159\":1,\"579\":1}}],[\"衍生问题\",{\"1\":{\"152\":1}}],[\"由操作系统来负责线程间的调度和线程的状态变更\",{\"1\":{\"837\":1}}],[\"由jvm指定\",{\"1\":{\"724\":1}}],[\"由java虚拟机的自动垃圾回收器来管理\",{\"1\":{\"724\":1}}],[\"由默认网关将数据包路由到目标网络\",{\"1\":{\"597\":1}}],[\"由具体工厂类根据传入的\",{\"1\":{\"436\":1}}],[\"由多个终结符表达式和非终结符表达式组成\",{\"1\":{\"390\":1}}],[\"由子类实现特定的put请求处理逻辑\",{\"1\":{\"338\":1}}],[\"由子类实现特定的post请求处理逻辑\",{\"1\":{\"338\":1}}],[\"由子类实现特定的get请求处理逻辑\",{\"1\":{\"338\":1}}],[\"由子类实现特定的处理逻辑\",{\"1\":{\"338\":3}}],[\"由子类实现具体的报告导出\",{\"1\":{\"336\":1}}],[\"由子类实现具体的报告内容填充\",{\"1\":{\"336\":1}}],[\"由子类实现具体的输入流关闭逻辑\",{\"1\":{\"335\":1}}],[\"由子类实现具体的输入流打开逻辑\",{\"1\":{\"335\":1}}],[\"由子类实现具体的数据查询\",{\"1\":{\"336\":1}}],[\"由子类实现具体的数据处理逻辑\",{\"1\":{\"335\":1}}],[\"由子类实现具体的数据读取逻辑\",{\"1\":{\"335\":1}}],[\"由子类实现\",{\"1\":{\"332\":1}}],[\"由美国国防部高级研究计划局\",{\"1\":{\"268\":1}}],[\"由国际标准化组织\",{\"1\":{\"268\":1}}],[\"由若干结点\",{\"1\":{\"246\":1}}],[\"由信源\",{\"1\":{\"238\":1}}],[\"由ip地址网络号可知\",{\"1\":{\"218\":1}}],[\"由1和0组成\",{\"1\":{\"216\":1}}],[\"由此达到跟踪路由器的目的\",{\"1\":{\"200\":1}}],[\"由主机发送出去的数据包中的生存时间字段ttl由1开始逐渐增加\",{\"1\":{\"200\":1}}],[\"由arp协议通过arp报文自动生成和维护\",{\"1\":{\"198\":1}}],[\"由arp协议获得\",{\"1\":{\"167\":1}}],[\"由各站网卡检测\",{\"1\":{\"170\":1}}],[\"由两部分信息构成\",{\"1\":{\"167\":1}}],[\"由6个字节组成\",{\"1\":{\"166\":1}}],[\"由过长的mac帧分片后的数据帧\",{\"1\":{\"152\":1}}],[\"由于线程被无限期地阻塞\",{\"1\":{\"848\":1}}],[\"由于线程调度的不确定性\",{\"1\":{\"814\":1}}],[\"由于某种情况\",{\"1\":{\"845\":1}}],[\"由于处理器使用缓存和读\",{\"1\":{\"826\":1}}],[\"由于继承关系\",{\"1\":{\"813\":1}}],[\"由于反射的运行时性能开销相对较高\",{\"1\":{\"800\":1}}],[\"由于反射的操作是在运行时进行的\",{\"1\":{\"799\":1}}],[\"由于哈希码计算错误\",{\"1\":{\"788\":1}}],[\"由于并发环境中\",{\"1\":{\"748\":1}}],[\"由于对象修改之后的\",{\"1\":{\"731\":1}}],[\"由于对象访问在\",{\"1\":{\"730\":1}}],[\"由于对象之间的依赖关系更加简化和清晰\",{\"1\":{\"490\":1}}],[\"由于对象之间的关系简单明确\",{\"1\":{\"488\":1}}],[\"由于这些变量大小可知\",{\"1\":{\"724\":1}}],[\"由于不需要额外维护顺序\",{\"1\":{\"715\":1}}],[\"由于不可能避免所有的碰撞\",{\"1\":{\"152\":1}}],[\"由于迭代时是对原集合的拷贝进行遍历\",{\"1\":{\"709\":1}}],[\"由于之前已经进行过\",{\"1\":{\"707\":1}}],[\"由于时间片耗尽挂起\",{\"1\":{\"707\":2}}],[\"由于使用红黑树存储\",{\"1\":{\"705\":1}}],[\"由于是一种链表的数据结构\",{\"1\":{\"678\":1}}],[\"由于是一种动态数组的数据结构\",{\"1\":{\"677\":1}}],[\"由于接口2022已过时或者有其他限制\",{\"1\":{\"510\":1}}],[\"由于\",{\"1\":{\"469\":1,\"706\":1,\"842\":1}}],[\"由于没有重写\",{\"1\":{\"788\":1}}],[\"由于没有使用抽象和多态来定义折扣策略\",{\"1\":{\"465\":1}}],[\"由于没有统一度量\",{\"1\":{\"212\":1}}],[\"由于单一责任原则使得代码更加模块化和职责清晰\",{\"1\":{\"461\":1}}],[\"由于每轮缩减到一半\",{\"1\":{\"316\":1}}],[\"由于绝大多数的网络应用都是使用运输层协议tcp或udp来传送数据\",{\"1\":{\"223\":1}}],[\"由于网络本身不提供端到端的可靠传输服务\",{\"1\":{\"184\":1}}],[\"由于网络层上可能有许多种通信协议同时存在\",{\"1\":{\"120\":1}}],[\"由于传统的局域网缺乏流量隔离\",{\"1\":{\"159\":1}}],[\"由于以太网在局域网市场中取得垄断地位\",{\"1\":{\"158\":1}}],[\"由于无线信道的传输条件特殊\",{\"1\":{\"152\":1}}],[\"由于数据链路层主要分为两类\",{\"1\":{\"144\":1}}],[\"由于停止\",{\"1\":{\"137\":1}}],[\"点击jconsole线程面板的检测到死锁按钮\",{\"1\":{\"849\":1}}],[\"点击运行\",{\"1\":{\"538\":1}}],[\"点击运行的按钮运行\",{\"1\":{\"538\":1}}],[\"点击确定允许usb调试\",{\"1\":{\"538\":1}}],[\"点的技巧\",{\"1\":{\"316\":1}}],[\"点和第\",{\"1\":{\"316\":1}}],[\"点对点传输\",{\"1\":{\"275\":1}}],[\"点对点连接的协议\",{\"1\":{\"575\":1}}],[\"点对点连接就是通信双方直接通过电缆进行的连接\",{\"1\":{\"275\":1}}],[\"点对点连接和端到端连接的区分\",{\"1\":{\"275\":1}}],[\"点对点无线传输\",{\"1\":{\"230\":1}}],[\"点对点的数据链路层\",{\"1\":{\"121\":1,\"144\":1}}],[\"点分十进制表示\",{\"1\":{\"220\":3}}],[\"点分十进制表示192\",{\"1\":{\"215\":1}}],[\"点分十进制标识180\",{\"1\":{\"218\":1}}],[\"点协调功能pcf\",{\"1\":{\"152\":1}}],[\"站点等待总线转为空闲96比特时间后\",{\"1\":{\"152\":1}}],[\"站点会边发送边监听总线\",{\"1\":{\"152\":1}}],[\"立即停止发送\",{\"1\":{\"152\":1}}],[\"早期的双绞线\",{\"1\":{\"152\":1}}],[\"早期以太网\",{\"1\":{\"121\":1}}],[\"更强大\",{\"1\":{\"838\":1}}],[\"更适合复杂的并发控制和临界区同步\",{\"1\":{\"834\":1}}],[\"更适合简单的状态标记和某些特定的场景\",{\"1\":{\"834\":1}}],[\"更适合较高的传输速率\",{\"1\":{\"238\":1}}],[\"更容易地管理线程特定的数据\",{\"1\":{\"816\":1}}],[\"更好的封装\",{\"1\":{\"782\":1}}],[\"更灵活\",{\"1\":{\"782\":1,\"838\":1}}],[\"更常见\",{\"1\":{\"706\":1}}],[\"更合适\",{\"1\":{\"705\":1}}],[\"更快地扩容\",{\"1\":{\"701\":1}}],[\"更多的是一种兜底的策略\",{\"1\":{\"697\":1}}],[\"更有效的方法来存储多个数据对象\",{\"1\":{\"673\":1}}],[\"更加直观\",{\"1\":{\"502\":1}}],[\"更专注的接口\",{\"1\":{\"473\":1}}],[\"更具体的接口\",{\"1\":{\"472\":1}}],[\"更改命令为关闭电灯\",{\"1\":{\"383\":1}}],[\"更改面板设置\",{\"0\":{\"5\":1,\"31\":1}}],[\"更慢\",{\"1\":{\"316\":2}}],[\"更新对应的值\",{\"1\":{\"704\":1}}],[\"更新网络设备\",{\"1\":{\"596\":1}}],[\"更新网络设备配置\",{\"1\":{\"596\":1}}],[\"更新完后\",{\"1\":{\"538\":1}}],[\"更新库存\",{\"1\":{\"518\":4}}],[\"更新\",{\"1\":{\"208\":2,\"212\":1}}],[\"更确切地应该称为多点接入\",{\"1\":{\"150\":1}}],[\"多核处理器系统中\",{\"1\":{\"828\":1}}],[\"多了\",{\"1\":{\"785\":1}}],[\"多态具体实现\",{\"1\":{\"782\":1}}],[\"多态\",{\"1\":{\"782\":2}}],[\"多态是指同一个方法名可以在不同的类或者同一个类的不同方法中以不同的方式实现\",{\"1\":{\"780\":1}}],[\"多线程程序的执行结果不能被改变\",{\"1\":{\"826\":1}}],[\"多线程操作导致死循环问题\",{\"1\":{\"713\":1}}],[\"多线程环境下会产生环\",{\"1\":{\"701\":1}}],[\"多点接入\",{\"1\":{\"581\":1}}],[\"多对多的场景\",{\"1\":{\"504\":1}}],[\"多对一和多对多的方式\",{\"1\":{\"301\":1}}],[\"多个实例对象都有各自的实例方法\",{\"1\":{\"779\":1}}],[\"多个线程同时被阻塞\",{\"1\":{\"848\":1}}],[\"多个线程同时访问\",{\"1\":{\"706\":1}}],[\"多个线程需要共享数据\",{\"1\":{\"831\":1}}],[\"多个线程按照一定的顺序执行时\",{\"1\":{\"814\":1}}],[\"多个线程共享同一块内存区域\",{\"1\":{\"811\":1}}],[\"多个线程对\",{\"1\":{\"707\":1,\"829\":1}}],[\"多个键值对可能会被分配到同一个桶\",{\"1\":{\"707\":1}}],[\"多个域名指向同一个ip地址的服务器\",{\"1\":{\"594\":1}}],[\"多个域名对应同一个ip\",{\"1\":{\"594\":1}}],[\"多个设备共享同一个传输介质\",{\"1\":{\"581\":1}}],[\"多个类组成一个模块\",{\"1\":{\"460\":1}}],[\"多个对象不再直接相互通信\",{\"1\":{\"399\":1}}],[\"多个网络还可以通过路由器互连起来\",{\"1\":{\"247\":1}}],[\"多个站点连接在一条总线上\",{\"1\":{\"152\":1}}],[\"多则可包括数百根\",{\"1\":{\"230\":1}}],[\"多位同时传输\",{\"1\":{\"227\":1}}],[\"多播或广播\",{\"1\":{\"174\":1}}],[\"多播通信是一对多的通信方式\",{\"1\":{\"166\":1}}],[\"多播地址的范围是在特定的范围内\",{\"1\":{\"166\":1}}],[\"多播地址是一种特殊的地址\",{\"1\":{\"166\":1}}],[\"多播地址是用于将数据从一个发送者传递到一组特定的接收者的地址\",{\"1\":{\"166\":1}}],[\"多播\",{\"1\":{\"166\":1}}],[\"多播和广播mac地址是用于在以太网网络中标识设备的特殊地址类型\",{\"1\":{\"166\":1}}],[\"多址是不需要的\",{\"1\":{\"150\":1}}],[\"多址\",{\"1\":{\"150\":1}}],[\"多路复用\",{\"1\":{\"144\":1,\"619\":1}}],[\"复合操作的原子性呢\",{\"1\":{\"713\":1}}],[\"复合操作是指由多个基本操作\",{\"1\":{\"713\":1}}],[\"复制算法会把整个区域内的对象拷贝走\",{\"1\":{\"749\":1}}],[\"复制算法\",{\"1\":{\"744\":1,\"750\":2}}],[\"复制一份初始内容作为参考\",{\"1\":{\"455\":1}}],[\"复制\",{\"1\":{\"453\":1}}],[\"复制外网面板地址\",{\"1\":{\"3\":1,\"29\":1}}],[\"复杂性增加\",{\"1\":{\"533\":1}}],[\"复杂性\",{\"1\":{\"396\":1}}],[\"复杂度分析仍然是评判算法效率最有效且常用的方法\",{\"1\":{\"316\":1}}],[\"复杂度为\",{\"1\":{\"316\":1}}],[\"复用和拓展\",{\"1\":{\"320\":1}}],[\"复用和分用是在传输层中确保多个应用程序能够同时使用网络传输层服务的重要机制\",{\"1\":{\"280\":1}}],[\"复用和分用\",{\"0\":{\"280\":1},\"1\":{\"280\":1}}],[\"复用允许多个应用程序的数据流合并为一个传输层数据流\",{\"1\":{\"280\":1}}],[\"复用允许多个应用程序同时使用网络传输层服务\",{\"1\":{\"280\":1}}],[\"复用可以通过端口号来实现\",{\"1\":{\"280\":1}}],[\"复用\",{\"0\":{\"334\":1},\"1\":{\"150\":1,\"280\":1}}],[\"复用与多址的区别\",{\"1\":{\"150\":1}}],[\"且当前散列数组中entry的数量已经达到了列表的扩容阈值\",{\"1\":{\"821\":1}}],[\"且承担调度执行的任务\",{\"1\":{\"804\":1}}],[\"且链表的长度大于8的时候\",{\"1\":{\"697\":1}}],[\"且被randomaccess\",{\"1\":{\"677\":1}}],[\"且无法同时进行数据传输\",{\"1\":{\"580\":1}}],[\"且无须向ip地址管理机构申请\",{\"1\":{\"217\":1}}],[\"且代码文件也没有显示\",{\"1\":{\"538\":1}}],[\"且它们都重写了\",{\"1\":{\"469\":1}}],[\"且该语言的文法规则相对稳定\",{\"1\":{\"391\":1}}],[\"且希望避免这些操作对元素类的污染时\",{\"1\":{\"372\":1}}],[\"且不再需要时\",{\"1\":{\"725\":1}}],[\"且不希望修改现有类的结构时\",{\"1\":{\"372\":1}}],[\"且不会丢失或重复\",{\"1\":{\"184\":1}}],[\"且指针下移\",{\"1\":{\"366\":1}}],[\"且需要预先分配连续的内存空间\",{\"1\":{\"312\":1}}],[\"且各自的长度与ipv4地址的网络id和主机id部分对应相等\",{\"1\":{\"216\":1}}],[\"且长度也是32位\",{\"1\":{\"216\":1}}],[\"且这些路由表项会自动更新维护\",{\"1\":{\"206\":1}}],[\"且保证无差错\",{\"1\":{\"184\":1}}],[\"且地理范围和站点数目均有限\",{\"1\":{\"156\":1}}],[\"且其自身的内积为1\",{\"1\":{\"150\":1}}],[\"且丢包率较低的情况\",{\"1\":{\"138\":1}}],[\"码元数量\",{\"1\":{\"240\":1}}],[\"码元和比特的关系\",{\"1\":{\"240\":1}}],[\"码元传输速率\",{\"1\":{\"240\":2}}],[\"码元开始处电平是否发生变化表示数据\",{\"1\":{\"238\":1}}],[\"码元的中间时刻既表示时钟\",{\"1\":{\"238\":1}}],[\"码元\",{\"1\":{\"238\":1,\"240\":3}}],[\"码片直接发送代表1\",{\"1\":{\"150\":1}}],[\"码分多址\",{\"1\":{\"150\":1}}],[\"码分多路复用\",{\"0\":{\"150\":1},\"1\":{\"144\":1}}],[\"原子更新引用类型里的字段\",{\"1\":{\"847\":1}}],[\"原子更新长整型字段的更新器\",{\"1\":{\"847\":1}}],[\"原子更新整型字段的更新器\",{\"1\":{\"847\":1}}],[\"原子更新带有版本号的引用类型\",{\"1\":{\"847\":1}}],[\"原子更新带有标记的引用类型\",{\"1\":{\"847\":1}}],[\"原子类类型\",{\"1\":{\"847\":1}}],[\"原子性操作\",{\"1\":{\"844\":1}}],[\"原子性是指一个操作是不可中断的\",{\"1\":{\"829\":1}}],[\"原子性指的是一个操作是不可分割\",{\"1\":{\"825\":1}}],[\"原子性\",{\"1\":{\"814\":1,\"825\":1,\"834\":1}}],[\"原语和signal\",{\"1\":{\"853\":1}}],[\"原语\",{\"1\":{\"809\":1,\"853\":3}}],[\"原理很简单\",{\"1\":{\"822\":1}}],[\"原理就是子线程被创建的时候会将父线程的threadlocalmap复制给子线程\",{\"1\":{\"822\":1}}],[\"原理和\",{\"1\":{\"768\":1}}],[\"原理\",{\"1\":{\"709\":2,\"839\":1,\"845\":1}}],[\"原理类似于光的频分多路复用\",{\"1\":{\"149\":1}}],[\"原型模式\",{\"1\":{\"490\":1}}],[\"原型设计模式\",{\"0\":{\"453\":1},\"1\":{\"453\":1}}],[\"原则可以帮助我们编写更高质量的代码\",{\"1\":{\"485\":1}}],[\"原则\",{\"1\":{\"485\":1}}],[\"原因\",{\"1\":{\"296\":1,\"701\":4}}],[\"原因如下\",{\"1\":{\"152\":1}}],[\"原始快照\",{\"1\":{\"746\":1,\"750\":1}}],[\"原始节点作为新节点的后继节点\",{\"1\":{\"701\":1}}],[\"原始促销活动\",{\"1\":{\"455\":1}}],[\"原始对象和复制对象将共享相同的引用数据类型的实例\",{\"1\":{\"454\":1}}],[\"原始帧\",{\"1\":{\"135\":1,\"576\":1}}],[\"原始服务器会返回一个状态码为304的响应\",{\"1\":{\"114\":1}}],[\"原始服务器会返回一个状态码为304\",{\"1\":{\"114\":1}}],[\"原始服务器将返回最新版本的文档\",{\"1\":{\"114\":1}}],[\"统一各线程动作开始的时机\",{\"1\":{\"851\":1}}],[\"统一转换为我司可用的短信数据格式\",{\"1\":{\"511\":1}}],[\"统一的行为约定\",{\"1\":{\"470\":1}}],[\"统一资源定位符url\",{\"1\":{\"104\":1}}],[\"统计方法的执行时间\",{\"1\":{\"495\":1}}],[\"统计增长趋势\",{\"0\":{\"316\":1}}],[\"统计算法的运行时间既不合理也不现实\",{\"1\":{\"315\":1}}],[\"统计代码中所有的计算操作\",{\"1\":{\"315\":1}}],[\"统计具体时间\",{\"0\":{\"315\":1}}],[\"统计时分复用\",{\"1\":{\"148\":1}}],[\"改成了\",{\"1\":{\"789\":1}}],[\"改为一次\",{\"1\":{\"701\":1}}],[\"改变引用指向\",{\"1\":{\"677\":1}}],[\"改变路由\",{\"1\":{\"201\":1}}],[\"改变网页内容等\",{\"1\":{\"104\":1}}],[\"改进\",{\"1\":{\"148\":1}}],[\"各玩家的初始状态必须一致\",{\"1\":{\"851\":1}}],[\"各玩家线程通过countdownlatch\",{\"1\":{\"851\":1}}],[\"各种报警\",{\"1\":{\"769\":1}}],[\"各种报文类型的语法\",{\"1\":{\"56\":1}}],[\"各种网络\",{\"0\":{\"245\":1},\"1\":{\"245\":1}}],[\"各个对象的职责明确\",{\"1\":{\"437\":1}}],[\"各个主机使用本机构内部可自由分配的专用地址进行通信\",{\"1\":{\"223\":1}}],[\"各个用户分配不同的频带\",{\"1\":{\"147\":1}}],[\"各bgp发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由\",{\"1\":{\"212\":1}}],[\"各路由器的lsdb最终达到一致\",{\"1\":{\"210\":1}}],[\"各站共享总线资源\",{\"1\":{\"170\":1}}],[\"各站为平等关系而非主从关系\",{\"1\":{\"156\":1}}],[\"本质实现就是一个threadlocal\",{\"1\":{\"816\":1}}],[\"本质都是stringbuilder的append\",{\"1\":{\"790\":1}}],[\"本质上是将广播信号变为多个点对点链路\",{\"1\":{\"144\":1}}],[\"本次垃圾收集无法处理浮动垃圾\",{\"1\":{\"751\":1}}],[\"本路由器和哪些路由器相邻\",{\"1\":{\"210\":1}}],[\"本地内存是jmm的\",{\"1\":{\"824\":1}}],[\"本地内存中存储了该线程以读\",{\"1\":{\"824\":1}}],[\"本地方法栈的引用对象\",{\"1\":{\"746\":1}}],[\"本地方法栈中\",{\"1\":{\"734\":1}}],[\"本地方法栈与虚拟机栈所发挥的作用是非常相似的\",{\"1\":{\"722\":1}}],[\"本地方法栈\",{\"1\":{\"722\":1}}],[\"本地域名服务器把返回的结果保存到缓存\",{\"1\":{\"81\":1}}],[\"本地域名服务器亲自动手\",{\"1\":{\"72\":1}}],[\"本地域名服务器的查询请求层层转发到根服务器\",{\"1\":{\"72\":1}}],[\"本地域名服务器并上述的树状结构的dns域名服务器\",{\"1\":{\"71\":1}}],[\"本地域名服务器\",{\"1\":{\"71\":1}}],[\"本地访问47\",{\"1\":{\"22\":2,\"48\":2}}],[\"本地访问效果\",{\"1\":{\"8\":1,\"34\":1}}],[\"本地\",{\"1\":{\"11\":1,\"37\":1,\"791\":1}}],[\"到底如何做呢\",{\"1\":{\"848\":1}}],[\"到了初始化阶段\",{\"1\":{\"754\":1}}],[\"到从内存中卸载\",{\"1\":{\"754\":1}}],[\"到显示主页的过程\",{\"0\":{\"631\":1}}],[\"到时间则发送一个零窗口的探测报文段\",{\"1\":{\"294\":1}}],[\"到该帧的最后一个比特发送完毕所需的时间\",{\"1\":{\"263\":1}}],[\"到达目的网络\",{\"1\":{\"208\":4}}],[\"到达目的站点所经过的路由器数\",{\"1\":{\"208\":1}}],[\"到达目的节点所需时间或距离\",{\"1\":{\"208\":1}}],[\"到达目的节点的最佳输出线路\",{\"1\":{\"208\":1}}],[\"到达后又要将比特流封装成数据帧\",{\"1\":{\"131\":1}}],[\"到期会被删除\",{\"1\":{\"174\":1}}],[\"到目的后再分离为多个信号\",{\"1\":{\"144\":1}}],[\"又或者使用synchronized修饰\",{\"1\":{\"817\":1}}],[\"又或者是一个接口有多个实现类\",{\"1\":{\"782\":1}}],[\"又可以分为\",{\"1\":{\"793\":1}}],[\"又可以连接广域网\",{\"1\":{\"161\":1}}],[\"又引用了这个指针来分配内存\",{\"1\":{\"728\":1}}],[\"又包含了与用户相关的邮件服务逻辑\",{\"1\":{\"481\":1}}],[\"又包括资源对象的创建过程\",{\"1\":{\"422\":1}}],[\"又使用不同格式的进程标识符\",{\"1\":{\"279\":1}}],[\"又表示数据\",{\"1\":{\"238\":1}}],[\"又称状态模式\",{\"1\":{\"357\":1}}],[\"又称局域网专用ip地址或者专用网络地址\",{\"1\":{\"217\":1}}],[\"又称为路由环路或距离无穷计数问题\",{\"1\":{\"209\":1}}],[\"又称为电子邮件客户端软件\",{\"1\":{\"90\":1}}],[\"又称外网\",{\"1\":{\"161\":1}}],[\"又要等待确认\",{\"1\":{\"142\":1,\"576\":1}}],[\"再放回池子\",{\"1\":{\"857\":1}}],[\"再判断版本号就会发现此时的a已经被改过了\",{\"1\":{\"845\":1}}],[\"再比如说咱们的java字符串儿\",{\"1\":{\"831\":1}}],[\"再执行当前\",{\"1\":{\"827\":1}}],[\"再着看rehash\",{\"1\":{\"821\":1}}],[\"再搭配我们小心使用\",{\"1\":{\"818\":1}}],[\"再吃饭\",{\"1\":{\"781\":1}}],[\"再查对其的引用\",{\"1\":{\"769\":1}}],[\"再对步骤\",{\"1\":{\"768\":1}}],[\"再对序列化后的二进制流\",{\"1\":{\"455\":1}}],[\"再定位到代码去查看\",{\"1\":{\"767\":1}}],[\"再找到创建该对象的业务代码位置\",{\"1\":{\"766\":1}}],[\"再打印出对应线程的堆栈信息\",{\"1\":{\"765\":1}}],[\"再引入一个公共类加载器加载tomcat本身的\",{\"1\":{\"759\":1}}],[\"再将结果写回\",{\"1\":{\"829\":1}}],[\"再将整个区域清空\",{\"1\":{\"749\":1}}],[\"再将令牌发送出去\",{\"1\":{\"153\":1}}],[\"再重写扫描一遍\",{\"1\":{\"746\":1}}],[\"再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性\",{\"1\":{\"742\":1}}],[\"再尝试购买\",{\"1\":{\"728\":1}}],[\"再遍历链表定位到具体的元素上\",{\"1\":{\"711\":1}}],[\"再插入\",{\"1\":{\"701\":1}}],[\"再建一个数组\",{\"1\":{\"692\":1}}],[\"再哈希法\",{\"1\":{\"692\":1}}],[\"再通过迭代器进行遍历\",{\"1\":{\"702\":1}}],[\"再通过\",{\"1\":{\"688\":1}}],[\"再举一个例子\",{\"1\":{\"525\":1}}],[\"再调用父类的operation方法\",{\"1\":{\"502\":2}}],[\"再包装一下添加一个刷新机制\",{\"1\":{\"500\":1}}],[\"再见\",{\"1\":{\"343\":1,\"346\":1}}],[\"再次扫描有没有删除\",{\"1\":{\"746\":1}}],[\"再次调用原始对象component的operation方法\",{\"1\":{\"502\":1}}],[\"再次调用原有对象\",{\"1\":{\"502\":2}}],[\"再次调用request方法来执行状态b下的行为\",{\"1\":{\"359\":1}}],[\"再次撤销到之前的状态\",{\"1\":{\"378\":1}}],[\"再次恢复originator的状态到之前的备忘录\",{\"1\":{\"377\":1}}],[\"再次向你表示抱歉\",{\"1\":{\"335\":1}}],[\"再次使用arp协议确认ip地址是否可用\",{\"1\":{\"64\":1}}],[\"再等到时间等待计时器设置的2msl\",{\"1\":{\"286\":1}}],[\"再转发\",{\"1\":{\"159\":1}}],[\"再发送下一个帧\",{\"1\":{\"152\":1}}],[\"再发送两个帧\",{\"1\":{\"142\":1,\"576\":1}}],[\"向高层用户屏蔽了下面网络核心的细节\",{\"1\":{\"273\":1}}],[\"向邻居路由器请求发送某些链路状态项目的详细信息\",{\"1\":{\"210\":1}}],[\"向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息\",{\"1\":{\"210\":1}}],[\"向所有与之相邻的结点中随机选择出一个将分组转发出去\",{\"1\":{\"205\":1}}],[\"向发送端发送返回确认帧等\",{\"1\":{\"140\":1}}],[\"向dhcp服务器发送续约请求\",{\"1\":{\"64\":1}}],[\"与按happens\",{\"1\":{\"826\":1}}],[\"与不使用\",{\"1\":{\"816\":1}}],[\"与编译时异常和运行时异常不同\",{\"1\":{\"793\":1}}],[\"与数据库操作相关的异常\",{\"1\":{\"793\":1}}],[\"与方法同级\",{\"1\":{\"775\":1}}],[\"与自己遍历过程中所记录的修改次数不一致\",{\"1\":{\"710\":1}}],[\"与集合实际的\",{\"1\":{\"710\":1}}],[\"与容量的乘积时\",{\"1\":{\"685\":1}}],[\"与其他vlan隔离开来\",{\"1\":{\"579\":1}}],[\"与\",{\"0\":{\"566\":1},\"1\":{\"694\":3,\"714\":1,\"807\":1}}],[\"与适配器设计模式的区别\",{\"0\":{\"520\":1}}],[\"与静态代理不同\",{\"1\":{\"496\":1}}],[\"与之不同\",{\"1\":{\"452\":1}}],[\"与udp类似\",{\"1\":{\"288\":1}}],[\"与arp协议不同\",{\"1\":{\"200\":1}}],[\"与access端口相似\",{\"1\":{\"159\":1}}],[\"与trunk端口不同\",{\"1\":{\"159\":1}}],[\"与trunk端口相似\",{\"1\":{\"159\":4}}],[\"与传输媒体无关\",{\"1\":{\"158\":1}}],[\"与接入传输媒体有关的内容都放在mac子层\",{\"1\":{\"158\":1}}],[\"与①同理\",{\"1\":{\"152\":1}}],[\"与线路信道带宽有关\",{\"1\":{\"140\":1,\"576\":1}}],[\"与各种传输介质访问有关的问题都放在\",{\"1\":{\"120\":1}}],[\"允许多个线程同时读取共享资源\",{\"1\":{\"831\":1,\"832\":1}}],[\"允许多个装饰器嵌套使用\",{\"1\":{\"500\":1}}],[\"允许线程发送和接收消息\",{\"1\":{\"811\":1}}],[\"允许在方法的定义中使用类型参数\",{\"1\":{\"797\":1}}],[\"允许在接口的定义中使用一个或多个类型参数\",{\"1\":{\"797\":1}}],[\"允许在类的定义中使用一个或多个类型参数\",{\"1\":{\"797\":1}}],[\"允许在同一传输介质中传输多个信号\",{\"1\":{\"619\":1}}],[\"允许有一个\",{\"1\":{\"706\":1}}],[\"允许一个线程二次请求自己持有对象锁的临界资源\",{\"1\":{\"836\":1}}],[\"允许一个\",{\"1\":{\"705\":1}}],[\"允许一条路径最多只能包含15个路由器\",{\"1\":{\"208\":1}}],[\"允许添加\",{\"1\":{\"687\":1}}],[\"允许并发读\",{\"1\":{\"682\":1}}],[\"允许发送方根据接收方的能力来控制数据的发送速率\",{\"1\":{\"584\":1}}],[\"允许实时的双向通信\",{\"1\":{\"582\":1}}],[\"允许不同的\",{\"1\":{\"579\":1}}],[\"允许备份应用数据\",{\"1\":{\"539\":1}}],[\"允许相同的构建过程创建不同的表示形式\",{\"1\":{\"446\":1}}],[\"允许用户输入不同的符号来选择不同的策略进行计算\",{\"1\":{\"343\":1}}],[\"允许用户在邮件服务器上进行邮件管理\",{\"1\":{\"98\":1}}],[\"允许数据在传输过程中有部分丢失\",{\"1\":{\"301\":1}}],[\"允许数据包在这些网络之间传输\",{\"1\":{\"178\":1,\"180\":1,\"587\":1}}],[\"允许连接\",{\"1\":{\"285\":1}}],[\"允许个人用户或远程办公者通过公共网络\",{\"1\":{\"223\":1}}],[\"允许同时传输多个信号\",{\"1\":{\"150\":1}}],[\"允许接收方接收乱序的分组\",{\"1\":{\"139\":1}}],[\"充分利用了网络带宽\",{\"1\":{\"138\":1,\"139\":1}}],[\"超过一定的时间\",{\"1\":{\"868\":1}}],[\"超过一定次数\",{\"1\":{\"845\":1}}],[\"超过了花呗已使用额度就用不了\",{\"1\":{\"731\":1}}],[\"超过则扩容\",{\"1\":{\"695\":1}}],[\"超时\",{\"1\":{\"838\":1}}],[\"超时等待状态\",{\"1\":{\"808\":1}}],[\"超时后会重新发送相应的分组\",{\"1\":{\"139\":1}}],[\"超时后会重新发送窗口内的所有分组\",{\"1\":{\"138\":1}}],[\"超时计时器设置的重传时间应仔细选择\",{\"1\":{\"137\":1}}],[\"超时重传等机制是tcp使用的手段\",{\"1\":{\"287\":1}}],[\"超时重传\",{\"1\":{\"137\":1,\"138\":1,\"139\":1,\"291\":1}}],[\"超文本传输协议http\",{\"0\":{\"105\":1},\"1\":{\"104\":1,\"106\":1}}],[\"超文本标记语言html\",{\"1\":{\"104\":1}}],[\"停止接收外部submit的任务\",{\"1\":{\"864\":1}}],[\"停止使用慢开始算法而改用拥塞避免算法\",{\"1\":{\"299\":1}}],[\"停止发送数据\",{\"1\":{\"286\":1}}],[\"停止位\",{\"1\":{\"235\":1}}],[\"停止\",{\"0\":{\"137\":1},\"1\":{\"137\":1,\"141\":1,\"152\":1,\"576\":2}}],[\"反编译一段synchronized修饰代码块代码\",{\"1\":{\"835\":1}}],[\"反之没有必要\",{\"1\":{\"866\":1}}],[\"反之\",{\"1\":{\"758\":1}}],[\"反之就尾插法\",{\"1\":{\"711\":1}}],[\"反之有差错\",{\"1\":{\"135\":1,\"576\":1}}],[\"反过来也是一样\",{\"1\":{\"742\":1}}],[\"反过来\",{\"1\":{\"540\":1}}],[\"反序列化\",{\"1\":{\"346\":1}}],[\"反映网络当前容量\",{\"1\":{\"294\":1}}],[\"反射是一种非常强大的机制\",{\"1\":{\"800\":1}}],[\"反射的应用场景有哪些\",{\"0\":{\"800\":1},\"1\":{\"800\":2}}],[\"反射的原理是依赖于底层虚拟机的机制的和在运行时通过反射api\",{\"1\":{\"799\":1}}],[\"反射的原理是什么\",{\"0\":{\"799\":1},\"1\":{\"799\":2}}],[\"反射会带来一定的性能损耗\",{\"1\":{\"799\":1}}],[\"反射可以用于创建动态代理\",{\"1\":{\"800\":1}}],[\"反射可以动态地调用类的方法\",{\"1\":{\"799\":1}}],[\"反射可以通过class对象来创建类的实例\",{\"1\":{\"799\":1}}],[\"反射api提供了方法来访问类的成员\",{\"1\":{\"799\":1}}],[\"反射api来获取和操作\",{\"1\":{\"799\":1}}],[\"反射api就是在这个基础上提供了一系列的方法来访问和操作这些信息\",{\"1\":{\"799\":1}}],[\"反射让程序可以在运行时检查和修改自己的结构和行为\",{\"1\":{\"798\":1}}],[\"反射就是一种让程序在运行时\",{\"1\":{\"798\":1}}],[\"反射允许程序在运行时获取类的信息\",{\"1\":{\"798\":1}}],[\"反射获取classname\",{\"1\":{\"757\":1}}],[\"反射\",{\"1\":{\"230\":1,\"755\":1,\"798\":1}}],[\"反码发送代表0\",{\"1\":{\"150\":1}}],[\"反向域名\",{\"1\":{\"69\":1}}],[\"反向代理\",{\"1\":{\"8\":1,\"34\":1}}],[\"假如一段时间发现他们可以不用接着营业\",{\"1\":{\"868\":1}}],[\"假如有一个需求\",{\"1\":{\"853\":1}}],[\"假如key被设计成强引用\",{\"1\":{\"818\":1}}],[\"假如我们有一个学生类\",{\"1\":{\"787\":1}}],[\"假如我们正在开发一个电子商务系统\",{\"1\":{\"506\":1}}],[\"假如老王去拉车\",{\"1\":{\"747\":1}}],[\"假如大量对象在minor\",{\"1\":{\"743\":1}}],[\"假如要现在进行一次只局限于新生代区域内的收集\",{\"1\":{\"742\":1}}],[\"假如在\",{\"1\":{\"740\":1}}],[\"假如发生碰撞\",{\"1\":{\"697\":1}}],[\"假如\",{\"1\":{\"694\":1}}],[\"假如输入n的数趋近于∞\",{\"1\":{\"316\":1}}],[\"假如加法操作\",{\"1\":{\"315\":1}}],[\"假如服务器地址为47\",{\"1\":{\"21\":1,\"47\":1}}],[\"假设一个用户发起支付\",{\"1\":{\"845\":1}}],[\"假设获得\",{\"1\":{\"707\":1}}],[\"假设\",{\"1\":{\"702\":3,\"727\":1,\"728\":1}}],[\"假设有以下需求\",{\"1\":{\"481\":1}}],[\"假设你要定制一份复杂的披萨\",{\"1\":{\"452\":1}}],[\"假设你要制作一份披萨\",{\"1\":{\"452\":1}}],[\"假设你要带领一个旅行团游览一个大城市\",{\"1\":{\"372\":1}}],[\"假设我们正在开发一个机器人程序\",{\"1\":{\"473\":1}}],[\"假设我们需要修改订单处理逻辑\",{\"1\":{\"461\":1}}],[\"假设我们需要为不同的商品创建相似的促销活动\",{\"1\":{\"455\":1}}],[\"假设我们要模拟一个简易的电视遥控器\",{\"1\":{\"360\":1}}],[\"假设我们有一个组织架构管理系统\",{\"1\":{\"525\":1}}],[\"假设我们有一个电商平台\",{\"1\":{\"510\":1}}],[\"假设我们有一个订单处理系统\",{\"1\":{\"489\":1}}],[\"假设我们有一个基类\",{\"1\":{\"469\":1}}],[\"假设我们有一个名为\",{\"1\":{\"455\":1}}],[\"假设我们有一个简单的文本编辑器\",{\"1\":{\"378\":1}}],[\"假设我们有一个网站\",{\"1\":{\"372\":1}}],[\"假设我们有一个网络聊天室应用程序\",{\"1\":{\"325\":1}}],[\"假设我们有一个迭代器iterator\",{\"1\":{\"367\":1}}],[\"假设我们有一个报告生成系统\",{\"1\":{\"336\":1}}],[\"假设我们有一个数据导入系统\",{\"1\":{\"333\":1}}],[\"假设clazz为目标类的class对象\",{\"1\":{\"346\":1}}],[\"假设bytes为序列化后的字节数组\",{\"1\":{\"346\":1}}],[\"假设报文传入的版本号为2\",{\"1\":{\"346\":1}}],[\"假设输入数据大小为\",{\"1\":{\"316\":1}}],[\"假设此时b知道c的ip地址\",{\"1\":{\"168\":1,\"583\":1}}],[\"假设发送端缓存空间大小为3个帧\",{\"1\":{\"142\":1,\"576\":1}}],[\"假设比特串为n位\",{\"1\":{\"135\":1,\"576\":1}}],[\"=new\",{\"1\":{\"735\":1}}],[\"=expectedmodcount\",{\"1\":{\"709\":1}}],[\"=key\",{\"1\":{\"691\":1}}],[\"=2n2+7n+3\",{\"1\":{\"316\":1}}],[\"=2+5n+2n\",{\"1\":{\"316\":1}}],[\"=3+2n\",{\"1\":{\"316\":2}}],[\"=\",{\"1\":{\"135\":1,\"166\":4,\"194\":1,\"196\":1,\"220\":3,\"240\":5,\"260\":16,\"263\":1,\"264\":1,\"297\":1,\"299\":1,\"314\":4,\"315\":4,\"316\":11,\"325\":8,\"326\":16,\"327\":7,\"335\":1,\"343\":9,\"344\":5,\"346\":21,\"350\":8,\"353\":10,\"354\":2,\"359\":3,\"360\":9,\"365\":5,\"366\":10,\"372\":10,\"377\":6,\"378\":9,\"383\":7,\"384\":8,\"390\":9,\"394\":11,\"403\":5,\"408\":6,\"422\":3,\"429\":2,\"436\":18,\"443\":20,\"448\":8,\"450\":19,\"454\":29,\"455\":20,\"461\":8,\"465\":7,\"469\":2,\"481\":4,\"489\":13,\"495\":18,\"497\":13,\"498\":13,\"502\":7,\"506\":9,\"510\":6,\"511\":4,\"518\":5,\"524\":6,\"525\":23,\"576\":1,\"683\":1,\"689\":4,\"693\":1,\"694\":1,\"695\":6,\"702\":10,\"703\":4,\"735\":12,\"745\":1,\"791\":2,\"797\":1,\"819\":2,\"821\":5,\"822\":5,\"827\":1,\"829\":1,\"832\":4,\"835\":5,\"838\":1,\"840\":3,\"844\":5,\"847\":1,\"860\":3,\"863\":2,\"867\":5,\"870\":16}}],[\"==\",{\"0\":{\"786\":1},\"1\":{\"21\":1,\"47\":1,\"104\":1,\"326\":1,\"343\":1,\"346\":2,\"353\":2,\"422\":1,\"429\":1,\"436\":1,\"443\":1,\"693\":1,\"695\":3,\"786\":2,\"821\":1,\"840\":1,\"844\":1}}],[\"漏检\",{\"1\":{\"134\":1,\"576\":1}}],[\"问候\",{\"1\":{\"210\":1}}],[\"问题分析\",{\"1\":{\"765\":1}}],[\"问题\",{\"1\":{\"134\":1,\"238\":3,\"316\":1,\"576\":1,\"845\":1,\"847\":2}}],[\"问一下看是不是打错了\",{\"1\":{\"125\":1}}],[\"要闹\",{\"1\":{\"868\":1}}],[\"要读取几万个文件的数据\",{\"1\":{\"853\":1}}],[\"要保证这种情况下的原子性操作\",{\"1\":{\"829\":1}}],[\"要么完全不执行\",{\"1\":{\"829\":1}}],[\"要么就全不执行\",{\"1\":{\"825\":1}}],[\"要么不执行\",{\"1\":{\"814\":1}}],[\"要么全部执行并且执行的过程不会被任何因素打断\",{\"1\":{\"825\":1}}],[\"要么全部执行成功\",{\"1\":{\"814\":1,\"829\":1}}],[\"要么全部不执行\",{\"1\":{\"814\":1}}],[\"要么是黑色\",{\"1\":{\"698\":1}}],[\"要分配内存的线程\",{\"1\":{\"728\":1}}],[\"要是只取最后几位的话\",{\"1\":{\"694\":1}}],[\"要继承谁\",{\"1\":{\"498\":1}}],[\"要注意避免过度设计\",{\"1\":{\"488\":1}}],[\"要注意不要过度优化\",{\"1\":{\"485\":1}}],[\"要选择简洁直接的方法来解决问题\",{\"1\":{\"480\":1}}],[\"要设计粒度小\",{\"1\":{\"462\":1}}],[\"要开全球巡回演唱会了\",{\"1\":{\"326\":1}}],[\"要求一个类或模块只负责一项职责或功能\",{\"1\":{\"474\":1}}],[\"要求接收方不用等待自己发送数据时才进行捎带确认\",{\"1\":{\"299\":1}}],[\"要求其规格化内积等于0\",{\"1\":{\"150\":1}}],[\"要让接收方来得及接收\",{\"1\":{\"293\":1}}],[\"要经过许多路由器\",{\"1\":{\"263\":1}}],[\"要经过b\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"要实现本层协议\",{\"1\":{\"251\":1}}],[\"要到达某个网络所要经过的一系列自治系统\",{\"1\":{\"212\":1}}],[\"要视所采用的是偶校验还是奇校验\",{\"1\":{\"134\":1,\"576\":1}}],[\"要在一条通信线路上传送数据\",{\"1\":{\"119\":1}}],[\"根引用和类加载器\",{\"1\":{\"733\":1}}],[\"根节点永远是黑色的\",{\"1\":{\"698\":1}}],[\"根据指定的执行时间从小到大排序\",{\"1\":{\"862\":1}}],[\"根据实际对象的类型来决定调用哪个方法\",{\"1\":{\"780\":1}}],[\"根据实现字符同步的方式不同\",{\"1\":{\"234\":1}}],[\"根据进行垃圾回收的不同地点\",{\"1\":{\"745\":1}}],[\"根据判断对象引用\",{\"1\":{\"724\":1}}],[\"根据构造函数的不同而定\",{\"1\":{\"714\":1}}],[\"根据键的自然顺序或者自定义的比较器进行排序\",{\"1\":{\"705\":1}}],[\"根据哈希值计算下标\",{\"1\":{\"695\":1}}],[\"根据所需的子网数量和主机数量选择合适的子网掩码\",{\"1\":{\"596\":1}}],[\"根据提示\",{\"1\":{\"538\":1}}],[\"根据需要自行修改\",{\"1\":{\"538\":1}}],[\"根据需求选择合适的接口实现\",{\"1\":{\"473\":1}}],[\"根据类型获取适配器\",{\"1\":{\"511\":1}}],[\"根据类型获取对应获取适配器\",{\"1\":{\"511\":1}}],[\"根据不同时期生成的代理对象\",{\"1\":{\"494\":1}}],[\"根据不同的通信需求和传输介质特性\",{\"1\":{\"619\":1}}],[\"根据不同的方法名来决定是否进行日志记录\",{\"1\":{\"497\":1}}],[\"根据不同的参数返回相应的产品对象\",{\"1\":{\"430\":1}}],[\"根据不同的参数返回相应的对象实例\",{\"1\":{\"424\":1}}],[\"根据不同的前缀\",{\"1\":{\"422\":1}}],[\"根据不同的状态委派请求给对应的状态类处理\",{\"1\":{\"358\":1}}],[\"根据对象的实际类型\",{\"1\":{\"469\":1}}],[\"根据复杂的配置项进行定制化构建\",{\"1\":{\"451\":1}}],[\"根据url的前缀来创建不同类型的资源对象\",{\"1\":{\"429\":1}}],[\"根据传入的参数类型来决定调用哪个方法\",{\"1\":{\"780\":1}}],[\"根据传入的参数返回相应的产品对象\",{\"1\":{\"426\":1}}],[\"根据传入策略不同\",{\"1\":{\"342\":1}}],[\"根据给定的\",{\"1\":{\"422\":1,\"713\":1}}],[\"根据前缀的不同\",{\"1\":{\"422\":1}}],[\"根据前缀匹配\",{\"1\":{\"422\":1,\"429\":1}}],[\"根据其前缀进行匹配\",{\"1\":{\"422\":1}}],[\"根据其首部中的检验和字段发现首部在传输过程中出现了误码\",{\"1\":{\"201\":1}}],[\"根据具体的业务需求和设计目标\",{\"1\":{\"411\":1}}],[\"根据任务的优先级\",{\"1\":{\"355\":1}}],[\"根据事件类型找到相应的订阅者列表\",{\"1\":{\"326\":1}}],[\"根据以上方法\",{\"1\":{\"315\":1}}],[\"根据应答报文大小来扩大拥塞窗口\",{\"1\":{\"298\":1}}],[\"根据应用需求的不同\",{\"1\":{\"273\":1}}],[\"根据\",{\"1\":{\"293\":1,\"580\":1,\"703\":1}}],[\"根据跳变方向决定数据为0还是1\",{\"1\":{\"238\":1}}],[\"根据正负跳变来区分比特\",{\"1\":{\"238\":1}}],[\"根据物理层在体系结构中的功能\",{\"1\":{\"229\":1}}],[\"根据帧的目的mac地址和交换机的帧交换表对帧进行转发\",{\"1\":{\"174\":1}}],[\"根据帧内的fcs来进行校验的\",{\"1\":{\"135\":1,\"576\":1}}],[\"根据接收帧的端口的pvid给帧\",{\"1\":{\"159\":2}}],[\"根据被传输的一组二进制代码的数位中\",{\"1\":{\"134\":1}}],[\"根域名收到请求后会查看区域文件记录\",{\"1\":{\"78\":1}}],[\"根域名服务器知道所有顶级域名服务器的域名和\",{\"1\":{\"71\":1}}],[\"根域名服务器是最高层次的域名服务器\",{\"1\":{\"71\":1}}],[\"根域名服务器\",{\"1\":{\"71\":1}}],[\"控制并发度\",{\"1\":{\"858\":1}}],[\"控制字段以及帧校验序列等\",{\"1\":{\"584\":1}}],[\"控制字段\",{\"1\":{\"575\":1}}],[\"控制对象的创建过程\",{\"1\":{\"421\":1}}],[\"控制电灯关闭的命令\",{\"1\":{\"383\":1}}],[\"控制电灯开启的命令\",{\"1\":{\"383\":1}}],[\"控制数据的发送速率\",{\"1\":{\"296\":1}}],[\"控制的目的就是避免\",{\"1\":{\"296\":1}}],[\"控制简单\",{\"1\":{\"253\":1}}],[\"控制两个对等实体进行逻辑通信的规则的集合\",{\"1\":{\"250\":1}}],[\"控制消息\",{\"1\":{\"200\":1}}],[\"控制由多个节点分散执行\",{\"1\":{\"153\":1}}],[\"控制\",{\"1\":{\"131\":1}}],[\"控制连接负责传输控制信息\",{\"1\":{\"87\":1}}],[\"控制连接和数据连接共同构成了ftp会话\",{\"1\":{\"87\":1}}],[\"控制连接端口\",{\"1\":{\"87\":1}}],[\"控制连接会被关闭\",{\"1\":{\"86\":1}}],[\"控制连接是持久的\",{\"1\":{\"85\":1}}],[\"控制连接\",{\"1\":{\"85\":1}}],[\"保护现有代码\",{\"1\":{\"512\":1}}],[\"保护敏感操作的安全性\",{\"1\":{\"495\":1}}],[\"保存一些业务内存\",{\"1\":{\"817\":1}}],[\"保存位置\",{\"1\":{\"538\":1}}],[\"保存\",{\"1\":{\"376\":1}}],[\"保存结果至缓存\",{\"0\":{\"81\":1}}],[\"保持与运算\",{\"1\":{\"688\":1}}],[\"保持代码的简洁和可维护性\",{\"1\":{\"373\":1}}],[\"保持每次迭代操作的一致性\",{\"1\":{\"367\":1}}],[\"保持连接状态\",{\"1\":{\"294\":1}}],[\"保证的是对一个变量执行操作的原子性\",{\"1\":{\"845\":1}}],[\"保证共享数据在同一时刻只被一个线程使用\",{\"1\":{\"831\":1}}],[\"保证可见性和有序性\",{\"1\":{\"827\":1}}],[\"保证了对\",{\"1\":{\"834\":1}}],[\"保证了临界区的代码在同一时刻只能有一个线程执行\",{\"1\":{\"834\":1}}],[\"保证了变量的可见性\",{\"1\":{\"834\":1}}],[\"保证了他们各自书本的独立性和安全性\",{\"1\":{\"816\":1}}],[\"保证了数据在不同设备之间的传输的正确性和可靠性\",{\"1\":{\"617\":1}}],[\"保证\",{\"1\":{\"758\":1}}],[\"保证最终都是委派给处于模型最顶端的启动类加载器进行加载\",{\"1\":{\"758\":1}}],[\"保证线程安全有什么方案\",{\"0\":{\"831\":1}}],[\"保证线程安全\",{\"1\":{\"711\":1,\"728\":1}}],[\"保证一定获取锁成功\",{\"1\":{\"711\":1}}],[\"保证极端情况下的查找效率\",{\"1\":{\"697\":1}}],[\"保证arraylist的线程安全可以通过这些方案\",{\"1\":{\"681\":1}}],[\"保证数据的完整性\",{\"1\":{\"573\":1}}],[\"保证数据的及时传输\",{\"1\":{\"294\":1}}],[\"保证操作的原子性和一致性\",{\"1\":{\"495\":1}}],[\"保证公平性\",{\"1\":{\"296\":1}}],[\"保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的\",{\"1\":{\"287\":1}}],[\"保证网络拓扑是一个树形结构\",{\"1\":{\"175\":1}}],[\"保留软引用\",{\"1\":{\"735\":3}}],[\"保留了元素插入的顺序\",{\"1\":{\"703\":1}}],[\"保留原来报文的边界\",{\"1\":{\"301\":1}}],[\"保留地址\",{\"1\":{\"222\":1}}],[\"保留字段\",{\"1\":{\"131\":1}}],[\"保活计时器有什么用\",{\"0\":{\"647\":1}}],[\"保活\",{\"1\":{\"212\":1}}],[\"目录结构有颜色了\",{\"1\":{\"538\":1}}],[\"目标是客户端所期望的接口\",{\"1\":{\"508\":1}}],[\"目标\",{\"1\":{\"508\":1,\"539\":1,\"575\":1}}],[\"目标ip地址\",{\"1\":{\"304\":1}}],[\"目标主机将数据部分复制副本\",{\"1\":{\"153\":1}}],[\"目的不同\",{\"1\":{\"411\":1}}],[\"目的进程的端口号\",{\"1\":{\"302\":1}}],[\"目的端口号\",{\"1\":{\"302\":1}}],[\"目的端口不可达\",{\"1\":{\"201\":1}}],[\"目的网络\",{\"1\":{\"221\":1}}],[\"目的网络位置\",{\"1\":{\"201\":1}}],[\"目的协议不可达\",{\"1\":{\"201\":1}}],[\"目的主机未知等13种错误\",{\"1\":{\"201\":1}}],[\"目的主机不可达\",{\"1\":{\"201\":1}}],[\"目的主机收到请求后就向源主机单播一个arp响应分组\",{\"1\":{\"198\":1}}],[\"目的主机的地址会被使用来建立连接\",{\"1\":{\"184\":1}}],[\"目的\",{\"1\":{\"192\":1,\"280\":2}}],[\"目的地址为b的mac地址\",{\"1\":{\"168\":1,\"583\":1}}],[\"目的地址为广播地址ff\",{\"1\":{\"168\":1,\"583\":1}}],[\"目的地址为广播地址\",{\"1\":{\"64\":2}}],[\"目的地址为广播地址255\",{\"1\":{\"64\":2}}],[\"目的地址部分包含的是接收者的mac地址\",{\"1\":{\"166\":1}}],[\"目前无法直接保证操作的原子性的\",{\"1\":{\"845\":1}}],[\"目前只有\",{\"1\":{\"738\":1}}],[\"目前只有cms\",{\"1\":{\"738\":1}}],[\"目前正在使用老的支付接口2022进行支付操作\",{\"1\":{\"510\":1}}],[\"目前主要用于有线电视\",{\"1\":{\"230\":1}}],[\"目前使用范围最广的局域网\",{\"1\":{\"158\":1}}],[\"目前没有特定作用\",{\"1\":{\"131\":2}}],[\"值也必须相等\",{\"1\":{\"788\":1}}],[\"值确定存储位置\",{\"1\":{\"788\":1}}],[\"值不同\",{\"1\":{\"731\":1}}],[\"值和存储进容器时的\",{\"1\":{\"731\":1}}],[\"值改变\",{\"1\":{\"731\":1}}],[\"值发生变化\",{\"1\":{\"731\":1}}],[\"值本身就是\",{\"1\":{\"712\":1}}],[\"值没有在集合中\",{\"1\":{\"712\":1}}],[\"值随机插入\",{\"1\":{\"703\":1}}],[\"值范围为\",{\"1\":{\"694\":1}}],[\"值以及\",{\"1\":{\"686\":1}}],[\"值\",{\"1\":{\"686\":1,\"705\":2,\"706\":1,\"777\":1,\"787\":2,\"838\":1}}],[\"值是与端口所属vlan的vid相同\",{\"1\":{\"159\":1}}],[\"值为0x03\",{\"1\":{\"131\":1}}],[\"值为0xff\",{\"1\":{\"131\":1}}],[\"值固定为01111110\",{\"1\":{\"131\":1}}],[\"ⅴ\",{\"1\":{\"131\":1}}],[\"ⅳ\",{\"0\":{\"150\":1,\"187\":1,\"592\":1},\"1\":{\"131\":1}}],[\"来动态修改线程池参数\",{\"1\":{\"869\":1}}],[\"来选择使用其中一个计数器\",{\"1\":{\"855\":1}}],[\"来选择网络中的根桥\",{\"1\":{\"175\":1}}],[\"来为每个线程分配所需资源\",{\"1\":{\"848\":1}}],[\"来看看具体的cas操作\",{\"1\":{\"847\":1}}],[\"来确保对\",{\"1\":{\"844\":1}}],[\"来确定数据传输的正确性\",{\"1\":{\"134\":1,\"576\":1}}],[\"来表示同步状态\",{\"1\":{\"839\":1,\"846\":1}}],[\"来管理等待队列和同步状态\",{\"1\":{\"839\":1}}],[\"来将多条指令重叠执行\",{\"1\":{\"826\":1}}],[\"来操作消息队列\",{\"1\":{\"811\":1}}],[\"来操作程序的元信息\",{\"1\":{\"799\":1}}],[\"来进行捕获不建议通过catch捕获\",{\"1\":{\"793\":1}}],[\"来进行捕获\",{\"1\":{\"793\":1}}],[\"来获取它\",{\"1\":{\"756\":1}}],[\"来获取相应的资源实例\",{\"1\":{\"429\":1}}],[\"来加载\",{\"1\":{\"756\":1}}],[\"来决定是否进行full\",{\"1\":{\"743\":1}}],[\"来清理新生代\",{\"1\":{\"739\":1}}],[\"来维护元素的顺序\",{\"1\":{\"715\":1}}],[\"来维护键值对的顺序\",{\"1\":{\"714\":1}}],[\"来存储键值对\",{\"1\":{\"714\":1,\"715\":1}}],[\"来计算一个新的\",{\"1\":{\"713\":1}}],[\"来计算收到的数据是否产生了误码\",{\"1\":{\"135\":1,\"576\":1}}],[\"来模拟一个只有\",{\"1\":{\"683\":1}}],[\"来搜索的专家\",{\"1\":{\"671\":1}}],[\"来执行基础类的功能\",{\"1\":{\"495\":1}}],[\"来处理不同类型的动物对象\",{\"1\":{\"469\":1}}],[\"来处理相应的请求逻辑\",{\"1\":{\"338\":1}}],[\"来复制歌曲列表的引用\",{\"1\":{\"454\":1}}],[\"来创建代理对象\",{\"1\":{\"496\":1}}],[\"来创建一个对应的\",{\"1\":{\"422\":1}}],[\"来创建不同类型的输入流\",{\"1\":{\"335\":1}}],[\"来移除上一个元素\",{\"1\":{\"367\":1}}],[\"来触发处理器链的执行\",{\"1\":{\"353\":1}}],[\"来完成\",{\"1\":{\"333\":1}}],[\"来实现这个机制\",{\"1\":{\"843\":1}}],[\"来实现歌名排序和歌星名排序\",{\"1\":{\"674\":1}}],[\"来实现多个设备在同一信道上进行数据传输\",{\"1\":{\"578\":1}}],[\"来实现更灵活的变化和扩展\",{\"1\":{\"504\":1}}],[\"来实现对特定问题领域的解释和处理\",{\"1\":{\"388\":1}}],[\"来实现灵活的算法替换和扩展\",{\"1\":{\"341\":1}}],[\"来实现\",{\"1\":{\"327\":1}}],[\"来实现异步非阻塞的通知\",{\"1\":{\"327\":1}}],[\"来标识网络设备\",{\"1\":{\"573\":1}}],[\"来标识一个数据帧的起始与结束\",{\"1\":{\"131\":1}}],[\"来标注通信双方\",{\"1\":{\"277\":1}}],[\"来保持一个相对较稳定的时间复杂度\",{\"1\":{\"690\":1}}],[\"来保持拓扑信息的更新\",{\"1\":{\"175\":1}}],[\"来保证数据被正确接收\",{\"1\":{\"152\":1}}],[\"来解决\",{\"1\":{\"120\":1}}],[\"怎么办\",{\"1\":{\"767\":1,\"768\":1}}],[\"怎么解决只能保证一个变量的原子操作问题\",{\"1\":{\"845\":1}}],[\"怎么解决循环性能开销问题\",{\"1\":{\"845\":1}}],[\"怎么解决aba问题\",{\"1\":{\"845\":1}}],[\"怎么解决\",{\"0\":{\"649\":1}}],[\"怎么理解网络层\",{\"1\":{\"182\":1}}],[\"怎么理解\",{\"0\":{\"182\":1}}],[\"怎么区分不同帧之间的定界问题\",{\"1\":{\"131\":1}}],[\"怎样向万维网服务器请求万维网文档\",{\"1\":{\"106\":1}}],[\"帧校验序列\",{\"1\":{\"575\":2}}],[\"帧起始标志\",{\"1\":{\"575\":2}}],[\"帧\",{\"1\":{\"278\":1,\"575\":2}}],[\"帧中继fr\",{\"1\":{\"184\":1}}],[\"帧交换表中的每条记录都有自己的有效时间\",{\"1\":{\"174\":1}}],[\"帧满即发送出去\",{\"1\":{\"148\":1}}],[\"帧检验序列\",{\"1\":{\"131\":1}}],[\"帧尾3个\",{\"1\":{\"131\":1}}],[\"帧头帧尾有标志位用来划分一个个帧\",{\"1\":{\"132\":1}}],[\"帧头5个\",{\"1\":{\"131\":1}}],[\"帧头和帧尾就是作为帧的起始和结束标志\",{\"1\":{\"130\":1}}],[\"帧同步方法\",{\"1\":{\"131\":1}}],[\"帧同步问题\",{\"1\":{\"131\":1}}],[\"帧封装流程\",{\"1\":{\"130\":1}}],[\"帧的mac地址是不断变化的\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"帧的两种转发方式\",{\"1\":{\"173\":1}}],[\"帧的差错控制\",{\"1\":{\"120\":1}}],[\"帧的接收与发送\",{\"1\":{\"120\":1}}],[\"帧的寻址和识别\",{\"1\":{\"120\":1}}],[\"把任务放入队列\",{\"1\":{\"870\":1}}],[\"把任务提交给线程池运行\",{\"1\":{\"870\":1}}],[\"把元素放到空的槽中\",{\"1\":{\"820\":1}}],[\"把封装的请求存入本地线程\",{\"1\":{\"817\":1}}],[\"把请求往其他服务器发送\",{\"1\":{\"817\":1}}],[\"把id当hashcode\",{\"1\":{\"787\":1}}],[\"把成员变量和具体的方法执行逻辑封装到一个具体类里面\",{\"1\":{\"782\":1}}],[\"把线程\",{\"1\":{\"765\":1}}],[\"把一个豆腐切成小块\",{\"1\":{\"749\":1}}],[\"把删除的引用记录下路\",{\"1\":{\"746\":1}}],[\"把所有存活标记\",{\"1\":{\"746\":1}}],[\"把survivor无法容纳的对象放到老年代\",{\"1\":{\"743\":1}}],[\"把\",{\"1\":{\"740\":1}}],[\"把冲突的元素放进去\",{\"1\":{\"692\":2}}],[\"把局域网进行流量隔离\",{\"1\":{\"579\":1}}],[\"把app的界面设计与代码逻辑分开\",{\"1\":{\"540\":1}}],[\"把数据传到接收端\",{\"1\":{\"275\":1}}],[\"把数据包从一个网络中的主机传送到位于另一网络中的目的主机上\",{\"1\":{\"274\":1}}],[\"把数据帧作为帧的数据部分\",{\"1\":{\"130\":1}}],[\"把两根互相绝缘的铜导线并排放在一起\",{\"1\":{\"230\":1}}],[\"把那些被拆分的分段重新组合起来\",{\"1\":{\"193\":1}}],[\"把实现通信协议的硬件和软件加到链路上\",{\"1\":{\"119\":1}}],[\"第\",{\"0\":{\"642\":1}}],[\"第三层\",{\"1\":{\"580\":1}}],[\"第三步\",{\"1\":{\"268\":2}}],[\"第二种场景\",{\"1\":{\"817\":1}}],[\"第二部分是类型指针\",{\"1\":{\"729\":1}}],[\"第二次增加2^2\",{\"1\":{\"692\":1}}],[\"第二次握手传回了\",{\"0\":{\"641\":1}}],[\"第二次执行相同的查询时\",{\"1\":{\"495\":1}}],[\"第二次执行相同的查询\",{\"1\":{\"495\":1}}],[\"第二层\",{\"1\":{\"580\":1}}],[\"第二步和第三步就可能会重排序\",{\"1\":{\"826\":1}}],[\"第二步\",{\"1\":{\"130\":1,\"268\":2}}],[\"第六步\",{\"1\":{\"268\":2}}],[\"第五步\",{\"1\":{\"268\":2}}],[\"第四步\",{\"1\":{\"268\":2}}],[\"第一种场景\",{\"1\":{\"817\":1}}],[\"第一部分存储对象自身的运行时数据\",{\"1\":{\"729\":1}}],[\"第一部安卓手机\",{\"1\":{\"537\":1}}],[\"第一次增加1^2个位置\",{\"1\":{\"692\":1}}],[\"第一次执行查询时\",{\"1\":{\"495\":1}}],[\"第一次执行查询\",{\"1\":{\"495\":1}}],[\"第一次握手的syn数据包\",{\"1\":{\"285\":1}}],[\"第一次数据跳变的时间记录下来\",{\"1\":{\"238\":1}}],[\"第一个应用\",{\"1\":{\"536\":1}}],[\"第一个可用的网络\",{\"1\":{\"217\":1}}],[\"第一个字节的次高位\",{\"1\":{\"166\":1}}],[\"第一个字节的最高位\",{\"1\":{\"166\":1}}],[\"第一步\",{\"1\":{\"130\":1,\"268\":2}}],[\"第一时间响应解决\",{\"1\":{\"81\":1}}],[\"前23bit记录抢到锁的线程id\",{\"1\":{\"837\":1}}],[\"前24位是由ieee注册管理机构分配的组织唯一标识符\",{\"1\":{\"166\":1}}],[\"前两种面向字节\",{\"1\":{\"811\":1}}],[\"前提是老年代得有足够空间来容纳这些对象\",{\"1\":{\"743\":1}}],[\"前提需要实现serializable接口\",{\"1\":{\"455\":1}}],[\"前导码\",{\"1\":{\"575\":1}}],[\"前导码的作用是为了让目的主机做好接收帧的准备\",{\"1\":{\"268\":1}}],[\"前言\",{\"0\":{\"458\":1}}],[\"前面的类加载过程\",{\"1\":{\"754\":1}}],[\"前面的两个场景\",{\"1\":{\"327\":1}}],[\"前面的流量控制是避免\",{\"1\":{\"296\":1}}],[\"前面例子的实现方式\",{\"1\":{\"327\":1}}],[\"前置扫盲\",{\"0\":{\"309\":1}}],[\"前置知识\",{\"0\":{\"243\":1}}],[\"前景好\",{\"1\":{\"230\":1}}],[\"前7个为时间同步码\",{\"1\":{\"129\":1}}],[\"前端进行编译打包\",{\"1\":{\"22\":1,\"48\":1}}],[\"前端部署\",{\"0\":{\"22\":1,\"48\":1}}],[\"无锁的思路就是先尝试\",{\"1\":{\"845\":1}}],[\"无锁\",{\"1\":{\"837\":1}}],[\"无锁编程\",{\"1\":{\"831\":1}}],[\"无同步方案\",{\"1\":{\"831\":1}}],[\"无用类判断\",{\"1\":{\"733\":1}}],[\"无序性不等于随机性\",{\"1\":{\"672\":1}}],[\"无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加\",{\"1\":{\"672\":1}}],[\"无序性和不可重复性的含义是什么\",{\"1\":{\"672\":1}}],[\"无序性和不可重复性\",{\"0\":{\"672\":1}}],[\"无论共享的数据是否真的出现\",{\"1\":{\"831\":1,\"832\":1}}],[\"无论多少人共用同一个书柜\",{\"1\":{\"816\":1}}],[\"无论当前内存是否足够\",{\"1\":{\"735\":1}}],[\"无论任何情况下\",{\"1\":{\"735\":1}}],[\"无论传输的是文本\",{\"1\":{\"577\":1}}],[\"无论是对象的方法实现还是方法的调用者\",{\"1\":{\"831\":1}}],[\"无论是\",{\"1\":{\"827\":3}}],[\"无论是否捕获或处理异常\",{\"1\":{\"795\":1}}],[\"无论是方法传递的参数还是当中成员变量\",{\"1\":{\"773\":1}}],[\"无论是从父类继承的\",{\"1\":{\"729\":1}}],[\"无论是遍历\",{\"1\":{\"526\":1}}],[\"无论是使用\",{\"1\":{\"477\":1}}],[\"无论是主机\",{\"1\":{\"198\":1}}],[\"无效输入\",{\"1\":{\"343\":1,\"346\":1}}],[\"无需关心处理的是单个对象还是对象的组合\",{\"1\":{\"523\":1}}],[\"无需了解子系统的内部结构和组件\",{\"1\":{\"519\":1}}],[\"无需直接与子系统组件进行交互\",{\"1\":{\"516\":1}}],[\"无需直接与子系统的组件进行通信\",{\"1\":{\"516\":1}}],[\"无需直接实例化具体产品类\",{\"1\":{\"430\":1}}],[\"无需改变整体结构\",{\"1\":{\"339\":1}}],[\"无需建立连接\",{\"1\":{\"254\":1,\"255\":1}}],[\"无需建立网络层连接\",{\"1\":{\"184\":1}}],[\"无穷和2倍无穷不还是无穷吗\",{\"1\":{\"316\":1}}],[\"无穷\",{\"1\":{\"316\":1}}],[\"无关\",{\"1\":{\"316\":2}}],[\"无法重复利用\",{\"1\":{\"852\":1}}],[\"无法正确地删除对象\",{\"1\":{\"788\":1}}],[\"无法正确地检索对象\",{\"1\":{\"788\":1}}],[\"无法容纳的对象直接送入老年代\",{\"1\":{\"740\":1}}],[\"无法被\",{\"1\":{\"731\":1,\"756\":1}}],[\"无法同时说话\",{\"1\":{\"582\":1}}],[\"无法代理具体类\",{\"1\":{\"496\":1}}],[\"无法再修改\",{\"1\":{\"450\":1}}],[\"无法支持面向对象编程\",{\"1\":{\"421\":1}}],[\"无法及时处理新的数据\",{\"1\":{\"294\":1}}],[\"无法发送数据\",{\"1\":{\"294\":1}}],[\"无法用于多播\",{\"1\":{\"282\":1}}],[\"无应用层数据\",{\"1\":{\"285\":2}}],[\"无差错\",{\"1\":{\"282\":1}}],[\"无屏蔽双绞线utp电缆\",{\"1\":{\"230\":1}}],[\"无分类编址ipv4\",{\"0\":{\"219\":1}}],[\"无分类编址\",{\"1\":{\"215\":1}}],[\"无碰撞\",{\"1\":{\"173\":1}}],[\"无线信道\",{\"1\":{\"619\":1}}],[\"无线电广播\",{\"1\":{\"237\":1}}],[\"无线电波\",{\"1\":{\"230\":1}}],[\"无线电波等\",{\"1\":{\"227\":1,\"229\":1,\"240\":1}}],[\"无线网卡\",{\"1\":{\"165\":1}}],[\"无线网卡上接收到的信号强度往往会远远小于发送信号的强度\",{\"1\":{\"152\":1}}],[\"无线局域网\",{\"1\":{\"158\":1}}],[\"无确认的无连接服务\",{\"0\":{\"127\":1}}],[\"无连接的udp\",{\"1\":{\"273\":1}}],[\"无连接的数据报服务\",{\"1\":{\"184\":1}}],[\"无连接\",{\"1\":{\"72\":1}}],[\"送快递的路线早就建立好了\",{\"1\":{\"126\":1}}],[\"所谓的公平锁就是先等待的线程先获得锁\",{\"1\":{\"843\":1}}],[\"所谓的monitor其实是一种同步工具\",{\"1\":{\"835\":1}}],[\"所谓黑洞路由\",{\"1\":{\"205\":1}}],[\"所修饰\",{\"1\":{\"775\":2}}],[\"所占的空间大小也不同\",{\"1\":{\"773\":1}}],[\"所创建\",{\"1\":{\"722\":1}}],[\"所得余数为地址\",{\"1\":{\"691\":1}}],[\"所属者不同\",{\"1\":{\"812\":1}}],[\"所属设备\",{\"1\":{\"537\":1}}],[\"所属公司\",{\"1\":{\"537\":1}}],[\"所采用的路由选择协议等\",{\"1\":{\"273\":1}}],[\"所做的工作\",{\"1\":{\"239\":1}}],[\"所对应的接口或ip地址\",{\"1\":{\"205\":1}}],[\"所取代\",{\"1\":{\"171\":1}}],[\"所覆盖的范围从几十公里到几千公里\",{\"1\":{\"161\":1}}],[\"所用比特数量与数据分组编号所用比特数量一样\",{\"1\":{\"137\":1}}],[\"所以线程池的所有任务完成后\",{\"1\":{\"868\":1}}],[\"所以无法响应中断的任务可能永远无法终止\",{\"1\":{\"864\":1}}],[\"所以无法找到存入的对象\",{\"1\":{\"731\":1}}],[\"所以当前线程会被阻塞\",{\"1\":{\"848\":1}}],[\"所以这两个线程就会互相等待而进入死锁状态\",{\"1\":{\"848\":1}}],[\"所以这个算法里会跟踪记录这些发生引用更新的地方\",{\"1\":{\"746\":1,\"750\":1}}],[\"所以synchronized保证的有序是执行结果的有序性\",{\"1\":{\"836\":1}}],[\"所以synchronized保证同一时刻\",{\"1\":{\"836\":1}}],[\"所以使用了threadlocal在发送请求前\",{\"1\":{\"817\":1}}],[\"所以基本对于用户是无感知的\",{\"1\":{\"805\":1}}],[\"所以超时的时间还需要加上\",{\"1\":{\"785\":1}}],[\"所以分析排查内存泄漏问题首先还得从查看\",{\"1\":{\"769\":1}}],[\"所以到这呢\",{\"1\":{\"749\":1}}],[\"所以垃圾收集频率较低\",{\"1\":{\"737\":1}}],[\"所以静态集合引用的对象不能被释放\",{\"1\":{\"731\":1}}],[\"所以get是不需要加锁的\",{\"1\":{\"711\":1}}],[\"所以平衡二叉树插入和删除的效率比红黑树要低\",{\"1\":{\"698\":1}}],[\"所以转红黑树\",{\"1\":{\"697\":1}}],[\"所以传入17\",{\"1\":{\"689\":1}}],[\"所以调制是为了在传输过程中将数字信号转换成适合在特定传输介质中传输的模拟信号\",{\"1\":{\"619\":1}}],[\"所以csma\",{\"1\":{\"581\":1}}],[\"所以就抽离出了一条用于数据传输的逻辑通道\",{\"1\":{\"573\":1}}],[\"所以它的作用就是记录当前线程执行到哪了\",{\"1\":{\"722\":1}}],[\"所以它的传输是不可靠的\",{\"1\":{\"301\":1}}],[\"所以它是通过装饰器设计模式来解决的\",{\"1\":{\"500\":1}}],[\"所以在遍历过程中对原集合所作的修改并不能被迭代器检测到\",{\"1\":{\"709\":1}}],[\"所以在运行时\",{\"1\":{\"469\":1}}],[\"所以在串行数据通信中数据的同步问题非常重要\",{\"1\":{\"234\":1}}],[\"所以也会简化代码编写\",{\"1\":{\"360\":1}}],[\"所以此时状态设计模式就要登场了\",{\"1\":{\"360\":1}}],[\"所以此时会广播一个arp请求报文\",{\"1\":{\"168\":1,\"583\":1}}],[\"所以代码看起来也不是很复杂\",{\"1\":{\"360\":1}}],[\"所以对时间复杂度不产生影响\",{\"1\":{\"316\":1}}],[\"所以最终时间复杂度表示为\",{\"1\":{\"316\":1}}],[\"所以统计的为最差情况的时间复杂度\",{\"1\":{\"316\":1}}],[\"所以说g1对象内存模型中\",{\"1\":{\"749\":1}}],[\"所以说每个都维护了一个隐藏属性\",{\"1\":{\"749\":1}}],[\"所以说每个region都可能会产生垃圾他都是回收的目标\",{\"1\":{\"749\":1}}],[\"所以说整个新生代可能不是一块连续的物理地址\",{\"1\":{\"749\":1}}],[\"所以说我们只要写出优雅的\",{\"1\":{\"458\":1}}],[\"所以说真正的传输层地址其实就是具体应用所占用的端口\",{\"1\":{\"277\":1}}],[\"所以说当源端和目的端位于不同网络的时候\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"所以物理层还会给该比特流前面添加前导码\",{\"1\":{\"268\":2}}],[\"所以接收方只要在信号归零后进行采样即可\",{\"1\":{\"238\":1}}],[\"所以作比喻的话\",{\"1\":{\"227\":1}}],[\"所以通过icmp告知主机1\",{\"1\":{\"201\":1}}],[\"所以通常是要使发送端的发送速率略小于接收端的数据处理能力\",{\"1\":{\"140\":1}}],[\"所以icmp报文中要封装ip头部\",{\"1\":{\"200\":1}}],[\"所以arp报文在向数据链路层传输时不需要经过ip协议的封装\",{\"1\":{\"197\":1}}],[\"所以需要一个从ip地址到物理地址的映射\",{\"1\":{\"196\":1}}],[\"所以封装后形成的是ip数据报\",{\"1\":{\"192\":1}}],[\"所以我们也可以通过组合的方式来实现代码复用\",{\"1\":{\"782\":1}}],[\"所以我们只需要关注迭代器结合\",{\"1\":{\"366\":1}}],[\"所以我们需要一个不变的地址\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"所以我们采方法使得数据当中可能出现的控制字符\",{\"1\":{\"132\":1,\"577\":1}}],[\"所以不会触发concurrent\",{\"1\":{\"709\":1}}],[\"所以不会进行日志记录\",{\"1\":{\"497\":1}}],[\"所以不能直接得到最佳路由\",{\"1\":{\"212\":1}}],[\"所以不予理会\",{\"1\":{\"168\":1,\"583\":1}}],[\"所以不用另外建立\",{\"1\":{\"126\":1}}],[\"所以\",{\"1\":{\"165\":1,\"296\":1,\"596\":1,\"722\":1,\"746\":1,\"750\":1,\"760\":1}}],[\"所以引入了vlan\",{\"1\":{\"159\":1,\"579\":1}}],[\"所以一般只用于本身误码率较低的环境\",{\"1\":{\"134\":1,\"576\":1}}],[\"所以奇偶校验方法只可以用来检查单个码元错误\",{\"1\":{\"134\":1,\"576\":1}}],[\"所以数据传输仍然是非常可靠的\",{\"1\":{\"127\":1}}],[\"所有被屏障拦截的线程才会继续运行\",{\"1\":{\"852\":1}}],[\"所有被使用过的内存都被放在一边\",{\"1\":{\"727\":1}}],[\"所有设计成弱引用\",{\"1\":{\"818\":1}}],[\"所有设备连接到同一个共享传输介质\",{\"1\":{\"581\":1}}],[\"所有设备都能看到并处理这些数据包\",{\"1\":{\"580\":1}}],[\"所有设备处于同一个广播域\",{\"1\":{\"159\":1}}],[\"所有对象都隐式地继承自顶级父类object\",{\"1\":{\"813\":1}}],[\"所有方法的调用都是通过栈帧来进行的\",{\"1\":{\"724\":1}}],[\"所有此时会直接进行插入\",{\"1\":{\"707\":1}}],[\"所有遍历都是基于这个\",{\"1\":{\"702\":1}}],[\"所有数据包都会被广播到所有端口\",{\"1\":{\"580\":1}}],[\"所有数据结构都是基于数组\",{\"1\":{\"312\":1}}],[\"所有这些文件和文件夹都被组织在根文件夹\",{\"1\":{\"525\":1}}],[\"所有依赖它的观察者对象都会得到通知并更新自己的状态\",{\"1\":{\"411\":1}}],[\"所有具体表达式都必须实现该接口\",{\"1\":{\"390\":1}}],[\"所有具体策略类都需要实现该接口\",{\"1\":{\"343\":1}}],[\"所有用户都知道\",{\"1\":{\"279\":1}}],[\"所有的异常都有一个共同的祖先\",{\"1\":{\"793\":1}}],[\"所有的子类都重写这个方法\",{\"1\":{\"785\":1}}],[\"所有的方法都是同步的\",{\"1\":{\"706\":1}}],[\"所有的叶子节点都是是黑色的\",{\"1\":{\"698\":1}}],[\"所有的路由会周期性交换信息\",{\"1\":{\"208\":1}}],[\"所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧\",{\"1\":{\"152\":1}}],[\"所有站点共享较高的总带宽\",{\"1\":{\"156\":1}}],[\"所有站点被连接成一个环形网络\",{\"1\":{\"153\":1}}],[\"所有站点通过竞争随机地在信道上发送数据\",{\"1\":{\"152\":1}}],[\"所有主机共享通信介质\",{\"1\":{\"121\":1}}],[\"所有节点都能够直接与其他节点通信\",{\"1\":{\"59\":1}}],[\"所有ip都可以访问\",{\"1\":{\"14\":2,\"40\":2}}],[\"接下来设置对象头\",{\"1\":{\"726\":1}}],[\"接下来虚拟机将为新生对象分配内存\",{\"1\":{\"726\":1}}],[\"接下来\",{\"1\":{\"344\":1,\"346\":1,\"360\":2,\"372\":1,\"454\":1,\"495\":5,\"502\":1,\"506\":1}}],[\"接口或私有构造函数时抛出\",{\"1\":{\"793\":1}}],[\"接口主要用于对类的行为进行约束\",{\"1\":{\"783\":1}}],[\"接口中的成员变量只能是\",{\"1\":{\"783\":1}}],[\"接口让\",{\"1\":{\"705\":1}}],[\"接口标记了\",{\"1\":{\"677\":1}}],[\"接口则是在外部独立定义的排序方式\",{\"1\":{\"674\":1}}],[\"接口定义了对象自身的排序方式\",{\"1\":{\"674\":1}}],[\"接口实际上是出自java\",{\"1\":{\"674\":1}}],[\"接口实现类\",{\"1\":{\"495\":1}}],[\"接口实现代理设计模式示例代码\",{\"1\":{\"495\":1}}],[\"接口指定规范\",{\"1\":{\"573\":1}}],[\"接口生成了一个代理类\",{\"1\":{\"497\":1}}],[\"接口来获取用户信息和库存信息\",{\"1\":{\"489\":1}}],[\"接口来发送数据\",{\"1\":{\"327\":1}}],[\"接口应该精确地定义只与特定功能相关的方法\",{\"1\":{\"474\":1}}],[\"接口隔离原则通过细化接口的设计\",{\"1\":{\"474\":1}}],[\"接口隔离原则降低了代码的耦合性\",{\"1\":{\"474\":1}}],[\"接口隔离原则提高了代码的内聚性\",{\"1\":{\"474\":1}}],[\"接口隔离原则\",{\"0\":{\"471\":1},\"1\":{\"472\":1,\"474\":2}}],[\"接口的抽象方法\",{\"1\":{\"783\":1}}],[\"接口的实现类也会在首次被访问时加载\",{\"1\":{\"755\":1}}],[\"接口的方法\",{\"1\":{\"510\":2}}],[\"接口的具体折扣策略类\",{\"1\":{\"465\":1}}],[\"接口的ip地址\",{\"1\":{\"210\":1}}],[\"接口和抽象类都可以包含抽象方法\",{\"1\":{\"783\":1}}],[\"接口和抽象类都不能被实例化\",{\"1\":{\"783\":1}}],[\"接口和抽象类是java中两种用于实现多态性和封装的重要概念\",{\"1\":{\"783\":1}}],[\"接口和抽象类有什么共同点和区别\",{\"0\":{\"783\":1},\"1\":{\"783\":2}}],[\"接口和\",{\"1\":{\"404\":1,\"409\":1,\"706\":1}}],[\"接口为参与者\",{\"1\":{\"404\":1,\"409\":1}}],[\"接口为中介者\",{\"1\":{\"404\":1,\"409\":1}}],[\"接口为抽象表达式\",{\"1\":{\"395\":1}}],[\"接口类型等问题\",{\"1\":{\"268\":1}}],[\"接口\",{\"1\":{\"262\":1,\"326\":2,\"327\":1,\"350\":1,\"359\":1,\"360\":1,\"383\":1,\"386\":1,\"393\":1,\"401\":1,\"402\":2,\"406\":1,\"407\":2,\"436\":1,\"443\":1,\"455\":1,\"473\":1,\"495\":2,\"498\":1,\"506\":2,\"670\":3,\"704\":1,\"705\":1,\"706\":2,\"782\":1,\"797\":1,\"806\":1,\"838\":1}}],[\"接口转发该帧\",{\"1\":{\"174\":1}}],[\"接着又发起相同金额的支付请求\",{\"1\":{\"845\":1}}],[\"接着看看具体的resize\",{\"1\":{\"821\":1}}],[\"接着参与\",{\"1\":{\"807\":1}}],[\"接着\",{\"1\":{\"325\":1,\"346\":1,\"359\":1,\"448\":1}}],[\"接着返回给arp响应报文\",{\"1\":{\"168\":1,\"583\":1}}],[\"接着等待difs时间\",{\"1\":{\"152\":1}}],[\"接到消息后但凡看到转义字符开头就会去掉转义字符并且对其后一个字符不做特殊处理\",{\"1\":{\"132\":1}}],[\"接收第三方发送的报文\",{\"1\":{\"511\":1}}],[\"接收一个支付接口对象\",{\"1\":{\"510\":1}}],[\"接收远程服务器的响应\",{\"1\":{\"495\":1}}],[\"接收者\",{\"1\":{\"382\":1,\"383\":1}}],[\"接收到事件后\",{\"1\":{\"326\":1}}],[\"接收到的信号需要被解调回原始的模拟信号\",{\"1\":{\"239\":1}}],[\"接收缓存\",{\"1\":{\"282\":1}}],[\"接收主机根据数据包中的目标端口号来将数据分发给相应的应用程序\",{\"1\":{\"280\":1}}],[\"接收\",{\"1\":{\"159\":3}}],[\"接收方使用crc校验算法验证接收到的数据是否存在损坏\",{\"1\":{\"576\":1}}],[\"接收方使用确认号来指示下一个期望接收的序列号\",{\"1\":{\"289\":1}}],[\"接收方总是有足够大的缓存空间\",{\"1\":{\"296\":1}}],[\"接收方可能希望控制数据的接收速率\",{\"1\":{\"294\":1}}],[\"接收方可以检测到任何丢失或损坏的数据\",{\"1\":{\"291\":1}}],[\"接收方可以选择性地确认分组\",{\"1\":{\"139\":3}}],[\"接收方主动控制接收速率\",{\"1\":{\"294\":1}}],[\"接收方为了保证数据的完整性可能会将窗口大小设为零\",{\"1\":{\"294\":1}}],[\"接收方的应用程序可能正在处理大量任务\",{\"1\":{\"294\":1}}],[\"接收方的处理能力可能不足以及时处理收到的数据\",{\"1\":{\"294\":1}}],[\"接收方应用程序忙碌\",{\"1\":{\"294\":1}}],[\"接收方处理能力不足\",{\"1\":{\"294\":1}}],[\"接收方一直等待发送方发送新数据\",{\"1\":{\"294\":1}}],[\"接收方根据自己的缓冲区大小\",{\"1\":{\"294\":1}}],[\"接收方收到5\",{\"1\":{\"291\":1}}],[\"接收方收到4\",{\"1\":{\"291\":1}}],[\"接收方收到3\",{\"1\":{\"291\":1}}],[\"接收方收到1\",{\"1\":{\"291\":1}}],[\"接收方收到后返回的确认号为9\",{\"1\":{\"290\":1}}],[\"接收方收到报文段后\",{\"1\":{\"290\":1}}],[\"接收方将确认字段捎带在自己要发送的数据中\",{\"1\":{\"290\":1}}],[\"接收方接收\",{\"1\":{\"268\":2}}],[\"接收方接收时将每5个连续的比特1后面的0剔除即可\",{\"1\":{\"132\":1}}],[\"接收方只能发送最后一个正确接收的分组的确认\",{\"1\":{\"138\":1}}],[\"接收方窗口为零表示接收方暂时无法接收更多的数据\",{\"1\":{\"294\":1}}],[\"接收方窗口大小为n\",{\"1\":{\"139\":1}}],[\"接收方窗口大小为1\",{\"1\":{\"138\":1}}],[\"接收方窗口\",{\"1\":{\"138\":1,\"139\":1}}],[\"接收方按序接收分组\",{\"1\":{\"138\":2,\"139\":1}}],[\"接收方\",{\"1\":{\"132\":1,\"135\":1,\"254\":1,\"293\":1,\"296\":1,\"576\":1}}],[\"接收端确认接收成功\",{\"1\":{\"275\":1}}],[\"接收端在每个比特信号的中间时刻进行检测\",{\"1\":{\"236\":1}}],[\"接收端在接收到的每一个数据帧时不需要向发送端确认\",{\"1\":{\"127\":1}}],[\"接收端在接收到的每一个数据帧时都向发送端确认\",{\"1\":{\"126\":1}}],[\"接收端才能从传输线路上正确地取出被传送的数据\",{\"1\":{\"234\":1}}],[\"接收端必须识别信息的开始和结束\",{\"1\":{\"234\":1}}],[\"接收端对传输过来的信号进行解码\",{\"1\":{\"229\":1}}],[\"接收端会再向发送端发送一个xon控制字符\",{\"1\":{\"141\":1,\"576\":1}}],[\"接收端会向发送端发送一个xoff控制字符\",{\"1\":{\"141\":1,\"576\":1}}],[\"接收端认为不能继续接收数据时\",{\"1\":{\"141\":1,\"576\":1}}],[\"接收端检测到数据分组有误码时\",{\"1\":{\"137\":1}}],[\"接收端就收到什么\",{\"1\":{\"136\":1}}],[\"接收端拿到数据后\",{\"1\":{\"135\":1,\"576\":1}}],[\"接收端\",{\"1\":{\"134\":1,\"576\":1}}],[\"接收端通过对该特殊字符的识别从比特流中区分出每个帧的起始\",{\"1\":{\"131\":1}}],[\"接收端的物理层把比特流向数据链路层传输\",{\"1\":{\"131\":1}}],[\"接受针对以\",{\"1\":{\"8\":1,\"34\":1}}],[\"接受针对根路径的访问会被导航到此处\",{\"1\":{\"8\":1,\"34\":1}}],[\"释放资源则反序释放\",{\"1\":{\"848\":1}}],[\"释放锁\",{\"1\":{\"843\":2}}],[\"释放悲观读锁\",{\"1\":{\"832\":1}}],[\"释放读锁\",{\"1\":{\"832\":1}}],[\"释放内存\",{\"1\":{\"741\":1}}],[\"释放内存空间\",{\"1\":{\"720\":1}}],[\"释放相关的内存空间\",{\"1\":{\"725\":1}}],[\"释放相应的内存空间\",{\"1\":{\"720\":1}}],[\"释放连接\",{\"1\":{\"253\":1}}],[\"释放虚拟电路\",{\"1\":{\"184\":1}}],[\"释放了链路后\",{\"1\":{\"125\":1}}],[\"释放tcp连接\",{\"1\":{\"108\":1}}],[\"只拷贝当前对象\",{\"1\":{\"784\":1}}],[\"只回收一部分\",{\"1\":{\"749\":1}}],[\"只被软引用关联着的对象\",{\"1\":{\"735\":1}}],[\"只锁定当前链表或红黑二叉树的首节点\",{\"1\":{\"711\":1}}],[\"只不过实现不同锁语义\",{\"1\":{\"840\":1}}],[\"只不过它的底层实现是基于一个entry数组\",{\"1\":{\"816\":1}}],[\"只不过该方法一直等待\",{\"1\":{\"785\":1}}],[\"只不过每个region是一快一块的\",{\"1\":{\"749\":1}}],[\"只不过是先定位到具体的segment\",{\"1\":{\"711\":1}}],[\"只不过流量控制的对象不同而已\",{\"1\":{\"140\":1,\"576\":1}}],[\"只存储对象的唯一值\",{\"1\":{\"704\":1}}],[\"只将数据包发送到目标设备\",{\"1\":{\"580\":1}}],[\"只会输出方法调用前的提示信息和参数信息\",{\"1\":{\"497\":1}}],[\"只会确认已经正确接收的分组\",{\"1\":{\"139\":1}}],[\"只与自己的直接朋友对象进行交互\",{\"1\":{\"488\":1}}],[\"只是关闭了提交通道\",{\"1\":{\"864\":1}}],[\"只是代表不断的重试\",{\"1\":{\"837\":1}}],[\"只是保证了对变量的读写操作具有可见性\",{\"1\":{\"829\":1}}],[\"只是会麻烦一些\",{\"1\":{\"827\":1}}],[\"只是从整体的吞吐量来考量\",{\"1\":{\"744\":1}}],[\"只是在mark\",{\"1\":{\"837\":1}}],[\"只是在\",{\"1\":{\"714\":1}}],[\"只是多了一个1参与运算\",{\"1\":{\"688\":1}}],[\"只是日期不一样\",{\"1\":{\"455\":1}}],[\"只是向邻居路由器通告它的一些链路状态\",{\"1\":{\"210\":1}}],[\"只保留低位值\",{\"1\":{\"694\":1}}],[\"只保留\",{\"1\":{\"384\":1}}],[\"只包含8个字节\",{\"1\":{\"301\":1}}],[\"只支持一对一的单播方式\",{\"1\":{\"301\":1}}],[\"只要不去做正确的同步措施\",{\"1\":{\"831\":1}}],[\"只要不断创建不可被回收的对象\",{\"1\":{\"731\":1}}],[\"只要一个不可变的对象被正确的构建出来\",{\"1\":{\"831\":1}}],[\"只要垃圾回收机制一运行\",{\"1\":{\"818\":1}}],[\"只要有一个用户线程还没结束\",{\"1\":{\"810\":1}}],[\"只要重新与引用链上的任何一个对象建立关联即可\",{\"1\":{\"736\":1}}],[\"只要强引用关系还存在\",{\"1\":{\"735\":1}}],[\"只要没有触碰到进程可用内存的上限\",{\"1\":{\"725\":1}}],[\"只要其他平台有java虚拟机那就能运行java语言\",{\"1\":{\"719\":1}}],[\"只要哈希函数映射得比较均匀松散\",{\"1\":{\"694\":1}}],[\"只要我们的hash算法不垃圾\",{\"1\":{\"690\":1}}],[\"只要输入数据大小\",{\"1\":{\"316\":1}}],[\"只要网络中没有出现拥塞\",{\"1\":{\"297\":1}}],[\"只要tcp连接的一方收到对方的零窗口通知\",{\"1\":{\"294\":1}}],[\"只要连接所建立的物理通路中的任何一点出现了故障\",{\"1\":{\"253\":1}}],[\"只确认到第一个丢失为止的字节\",{\"1\":{\"290\":1}}],[\"只知道自己到直连网络的距离为1\",{\"1\":{\"208\":1}}],[\"只能完成自己的任务\",{\"1\":{\"852\":1}}],[\"只能保证一个变量的原子操作\",{\"1\":{\"845\":1}}],[\"只能有一个线程处于方法或者同步块中\",{\"1\":{\"811\":1}}],[\"只能在平地上停下来擦擦汗\",{\"1\":{\"747\":1}}],[\"只能通过公共的方法访问\",{\"1\":{\"366\":1}}],[\"只能将其通过除进入交换机的接口外的其他所有接口转发\",{\"1\":{\"174\":1}}],[\"只能跨链路\",{\"1\":{\"168\":1,\"583\":1}}],[\"只能属于一个vlan\",{\"1\":{\"159\":1}}],[\"只能按序接收分组\",{\"1\":{\"138\":1}}],[\"只有自己使用完毕后才释放资源\",{\"1\":{\"848\":1}}],[\"只有写锁没有被当前线程占用的情况才会获取失败\",{\"1\":{\"842\":1}}],[\"只有读读不互斥\",{\"1\":{\"842\":1}}],[\"只有获取锁的线程才能执行\",{\"1\":{\"834\":1}}],[\"只有⼀份\",{\"1\":{\"833\":1}}],[\"只有一个执行\",{\"1\":{\"805\":1}}],[\"只有一条活动路径\",{\"1\":{\"175\":1}}],[\"只有包含了跨代引用的小块内存里的对象才会被加入到\",{\"1\":{\"742\":1}}],[\"只有连接被关闭后\",{\"1\":{\"731\":1}}],[\"只有本地缓冲区用完了\",{\"1\":{\"728\":1}}],[\"只有经过它才能在不同的子网之间进行通信\",{\"1\":{\"580\":1}}],[\"只有当内存中地址\",{\"1\":{\"845\":1}}],[\"只有当父加载器反馈自己无法完成这个加载请求时\",{\"1\":{\"758\":1}}],[\"只有当设备停止发送并切换到接收模式时\",{\"1\":{\"582\":1}}],[\"只有当方法名是\",{\"1\":{\"497\":1}}],[\"只有当输入的密码与预设密码匹配时\",{\"1\":{\"495\":1}}],[\"只有当链路状态发生变化时\",{\"1\":{\"210\":1}}],[\"只有直接依赖它的对象需要进行相应的修改\",{\"1\":{\"490\":1}}],[\"只有能够处理该请求的处理器会进行处理\",{\"1\":{\"350\":1}}],[\"只有\",{\"1\":{\"316\":1}}],[\"只有在对象实例化之后才存在\",{\"1\":{\"778\":1}}],[\"只有在计算检验和时才出现\",{\"1\":{\"304\":1}}],[\"只有在当前数据传输完成\",{\"1\":{\"125\":1}}],[\"只有建立了连接才能开始通信\",{\"1\":{\"282\":1}}],[\"只有这样\",{\"1\":{\"234\":1}}],[\"只有接收到令牌的站点才有权发送数据\",{\"1\":{\"153\":1}}],[\"只有被轮询到的站点才能发送数据\",{\"1\":{\"153\":1}}],[\"只需在新生代上建立一个全局的数据结构\",{\"1\":{\"742\":1}}],[\"只需在运行时设置不同的状态类\",{\"1\":{\"361\":1}}],[\"只需修改对应的实现类\",{\"1\":{\"489\":1}}],[\"只需依赖于抽象接口\",{\"1\":{\"476\":1}}],[\"只需要针对相应的接口进行扩展即可\",{\"1\":{\"473\":1}}],[\"只需要调用命令对象的方法即可\",{\"1\":{\"386\":1}}],[\"只需要替换相应的策略对象\",{\"1\":{\"342\":1}}],[\"只需要使用其网络的物理地址\",{\"1\":{\"162\":1}}],[\"只需要使用通用的万维网浏览器\",{\"1\":{\"99\":1}}],[\"只需将\",{\"1\":{\"317\":1}}],[\"只需1个比特编号就够了\",{\"1\":{\"137\":1}}],[\"只需提供相应的访问权限即可\",{\"1\":{\"83\":1}}],[\"逻辑操作业务处理等\",{\"1\":{\"866\":1}}],[\"逻辑\",{\"1\":{\"821\":1}}],[\"逻辑上独立的子网\",{\"1\":{\"579\":1}}],[\"逻辑上独立的子网络\",{\"1\":{\"579\":1}}],[\"逻辑结构揭示了数据元素之间的逻辑关系\",{\"1\":{\"311\":1}}],[\"逻辑结构\",{\"0\":{\"311\":1}}],[\"逻辑端口\",{\"1\":{\"279\":1}}],[\"逻辑链路控制\",{\"1\":{\"158\":1}}],[\"逻辑链路控制子层提供了抽象和服务\",{\"1\":{\"120\":1}}],[\"逻辑链路控制子层\",{\"1\":{\"120\":1}}],[\"逻辑拓扑是环形结构\",{\"1\":{\"158\":2}}],[\"逻辑拓扑是总线形结构\",{\"1\":{\"158\":1}}],[\"逻辑总线型\",{\"1\":{\"121\":1}}],[\"星型\",{\"1\":{\"121\":1}}],[\"确实是多了一些代码\",{\"1\":{\"450\":1}}],[\"确保操作的完整性\",{\"1\":{\"853\":1}}],[\"确保结果的正确性\",{\"1\":{\"844\":1}}],[\"确保结果的正确性通常需要考虑并确保以下几个方面\",{\"1\":{\"844\":1}}],[\"确保一个线程对\",{\"1\":{\"844\":1}}],[\"确保对\",{\"1\":{\"844\":1}}],[\"确保同一时间只有一个线程可以访问共享资源\",{\"1\":{\"832\":1}}],[\"确保同一时间只有一个线程可以访问被\",{\"1\":{\"832\":1}}],[\"确保同时只有一个线程能够访问共享资源\",{\"1\":{\"811\":1}}],[\"确保读取的是主内存中最新的值\",{\"1\":{\"828\":1}}],[\"确保写操作将数据立即刷新到主内存\",{\"1\":{\"828\":1}}],[\"确保其他核心读取时能够获取到最新的值\",{\"1\":{\"828\":1}}],[\"确保当前\",{\"1\":{\"827\":3}}],[\"确保\",{\"1\":{\"754\":1}}],[\"确保类变量被正确初始化\",{\"1\":{\"720\":1}}],[\"确保字节码符合\",{\"1\":{\"720\":1}}],[\"确保能够准确地重建原始信号\",{\"1\":{\"622\":1}}],[\"确保能够满足每个子网的需求\",{\"1\":{\"596\":1}}],[\"确保数字化的信号能够被有效地还原和解码\",{\"1\":{\"622\":1}}],[\"确保数据正确地传输到目标地址\",{\"1\":{\"593\":1}}],[\"确保数据帧被正确发送到目标设备\",{\"1\":{\"573\":1}}],[\"确保数据的可靠传输\",{\"1\":{\"291\":1}}],[\"确保数据能够可靠地发送和接收\",{\"1\":{\"282\":1}}],[\"确保数据能够在介质中有效传输\",{\"1\":{\"229\":1}}],[\"确保数据能够在物理层上以正确的方式进行传输\",{\"1\":{\"227\":1}}],[\"确保设备能够正确地路由数据包到其他网络或互联网上\",{\"1\":{\"597\":1}}],[\"确保网络通信正常\",{\"1\":{\"596\":1}}],[\"确保网络设备正确地识别和处理新的子网\",{\"1\":{\"596\":1}}],[\"确保通信的可靠性和有效性\",{\"1\":{\"584\":1}}],[\"确保通信双方的状态同步和连接的可靠性\",{\"1\":{\"282\":1}}],[\"确保发送方和接收方之间的数据传输速率匹配\",{\"1\":{\"573\":1}}],[\"确保只有具有合适权限的客户端可以访问被代理对象\",{\"1\":{\"495\":1}}],[\"确保每个web应用程序都能独立加载和管理类库\",{\"1\":{\"759\":1}}],[\"确保每个子网的地址范围不会与其他子网重叠\",{\"1\":{\"596\":1}}],[\"确保每个子网拥有足够的ip地址空间来容纳所需的主机数量\",{\"1\":{\"596\":1}}],[\"确保每个子对象都是独立的副本\",{\"1\":{\"455\":1}}],[\"确保每次重置都回到初始状态\",{\"1\":{\"455\":1}}],[\"确保在访问共享资源时的互斥性\",{\"1\":{\"853\":1}}],[\"确保在多线程环境下对\",{\"1\":{\"844\":1}}],[\"确保在当前\",{\"1\":{\"827\":1}}],[\"确保在任何使用父类对象的地方\",{\"1\":{\"470\":1}}],[\"确保在整个系统中只存在一个实例\",{\"1\":{\"421\":1}}],[\"确保在特定场景下使用中介者模式能够带来实际的优势\",{\"1\":{\"410\":1}}],[\"确保在正确的时机调用并避免多次调用\",{\"1\":{\"367\":1}}],[\"确保它们在空中安全地航行\",{\"1\":{\"400\":1}}],[\"确保迭代器指针没有到达最后一个元素\",{\"1\":{\"367\":1}}],[\"确保了对临界区的互斥访问\",{\"1\":{\"834\":1}}],[\"确保了自增操作的原子性\",{\"1\":{\"829\":1}}],[\"确保了这些公共步骤在所有子类中的一致性实现\",{\"1\":{\"339\":1}}],[\"确保了数据的完整性和可靠性\",{\"1\":{\"287\":1}}],[\"确保不同设备之间的互操作性和兼容性\",{\"1\":{\"229\":1}}],[\"确定程序语义是否正确\",{\"1\":{\"754\":1}}],[\"确定每个子网的起始地址和结束地址\",{\"1\":{\"596\":1}}],[\"确定每个子网可以容纳的主机数量\",{\"1\":{\"596\":1}}],[\"确定每个子网中可用的ip地址范围\",{\"1\":{\"222\":1}}],[\"确定子网的大小\",{\"1\":{\"596\":1}}],[\"确定子系统中的各个组件或类\",{\"1\":{\"516\":1}}],[\"确定网络中需要多少个子网\",{\"1\":{\"596\":1}}],[\"确定网络和主机部分\",{\"1\":{\"595\":1}}],[\"确定所需的子网数量\",{\"1\":{\"596\":1}}],[\"确定运行平台\",{\"1\":{\"315\":1}}],[\"确定转发端口\",{\"1\":{\"268\":1}}],[\"确定和控制数据传输的速率\",{\"1\":{\"229\":1}}],[\"确定数据传输的速率和时序\",{\"1\":{\"227\":1}}],[\"确定哪些地址用于特定目的\",{\"1\":{\"222\":1}}],[\"确定目的主机问题\",{\"1\":{\"121\":1}}],[\"确认字段中的确认号为下一个期望收到的起始字节编号\",{\"1\":{\"290\":1}}],[\"确认号\",{\"0\":{\"290\":1},\"1\":{\"287\":1}}],[\"确认和重传机制\",{\"1\":{\"282\":1}}],[\"确认分组\",{\"1\":{\"138\":1,\"139\":1}}],[\"确认分组进行编号\",{\"1\":{\"137\":1}}],[\"确认分组超时的情况\",{\"1\":{\"137\":1}}],[\"确认分组超时\",{\"1\":{\"137\":1}}],[\"确认分组丢失\",{\"1\":{\"137\":2}}],[\"确认不是打错的电话后\",{\"1\":{\"125\":1}}],[\"确认成功后将该ip地址应用\",{\"1\":{\"64\":1}}],[\"没有多线程的情况下\",{\"1\":{\"857\":1}}],[\"没有锁的竞争和线程阻塞\",{\"1\":{\"834\":1}}],[\"没有在指定的\",{\"1\":{\"807\":1}}],[\"没有在规定时间内接收到\",{\"1\":{\"297\":1}}],[\"没有超时时间这个概念\",{\"1\":{\"785\":1}}],[\"没有方法体的方法\",{\"1\":{\"783\":1}}],[\"没有方法获取到\",{\"1\":{\"366\":1}}],[\"没有分代的概念\",{\"1\":{\"751\":1}}],[\"没有其他类需要加载\",{\"1\":{\"733\":1}}],[\"没有特别含义\",{\"1\":{\"729\":1}}],[\"没有红黑树优化\",{\"1\":{\"706\":1}}],[\"没有这样的机制\",{\"1\":{\"706\":1}}],[\"没有\",{\"1\":{\"683\":1}}],[\"没有包装\",{\"1\":{\"502\":2}}],[\"没有满足条件\",{\"1\":{\"497\":1}}],[\"没有使用单一责任原则的代码示例\",{\"1\":{\"461\":1}}],[\"没有使用工厂设计模式的代码实现不够灵活\",{\"1\":{\"422\":1}}],[\"没有使用工厂设计模式\",{\"1\":{\"422\":1}}],[\"没有处理器能够处理该请求\",{\"1\":{\"350\":2}}],[\"没有新的确认信息\",{\"1\":{\"294\":1}}],[\"没有冲突\",{\"1\":{\"253\":1}}],[\"没有通过运输层的tcp或udp\",{\"1\":{\"200\":1}}],[\"没有则用目的mac地址为ff\",{\"1\":{\"198\":1}}],[\"没有传递完则需要等待下一轮循环到自己再继续发送\",{\"1\":{\"153\":1}}],[\"没有中心控制站点\",{\"1\":{\"152\":1}}],[\"没有第三者\",{\"1\":{\"121\":1}}],[\"没有明确的服务提供者和请求者的区分\",{\"1\":{\"59\":1}}],[\"封装出一个\",{\"1\":{\"708\":1}}],[\"封装是指将来自更高层的数据添加到数据链路层的帧中的过程\",{\"1\":{\"577\":1}}],[\"封装\",{\"1\":{\"577\":1,\"782\":2}}],[\"封装了对子系统的访问\",{\"1\":{\"516\":1}}],[\"封装远程通信的逻辑\",{\"1\":{\"495\":1}}],[\"封装成一个对象\",{\"1\":{\"386\":1}}],[\"封装成帧功能解决了帧同步问题\",{\"1\":{\"133\":1}}],[\"封装成帧功能的含义\",{\"0\":{\"129\":1}}],[\"封装成帧大多指\",{\"1\":{\"129\":1}}],[\"封装成帧和透明传输\",{\"0\":{\"128\":1}}],[\"封装成帧\",{\"1\":{\"121\":1}}],[\"封装流程\",{\"1\":{\"278\":1}}],[\"封装过程\",{\"1\":{\"202\":1}}],[\"封装在mac帧中\",{\"1\":{\"168\":2,\"583\":2}}],[\"封面图片\",{\"1\":{\"0\":1}}],[\"介质和协议的差异\",{\"1\":{\"573\":1}}],[\"介质分为导引型和非导引型传输媒体\",{\"1\":{\"230\":1}}],[\"介质为光纤\",{\"1\":{\"149\":1}}],[\"介质访问控制方式\",{\"1\":{\"157\":1}}],[\"介质访问控制\",{\"0\":{\"143\":1}}],[\"介质访问控制子层和辑链路控制子层\",{\"1\":{\"120\":1}}],[\"介质访问控制子层\",{\"1\":{\"120\":1,\"144\":1}}],[\"介质访问冲突控制等\",{\"1\":{\"120\":1}}],[\"介绍reentrantlock\",{\"0\":{\"838\":1}}],[\"介绍一下java里面常见的锁\",{\"0\":{\"832\":1},\"1\":{\"832\":1}}],[\"介绍一下java内存模型\",{\"1\":{\"824\":1}}],[\"介绍一下常见工作在物理层的设备有哪些\",{\"0\":{\"618\":1},\"1\":{\"618\":1}}],[\"介绍一下\",{\"0\":{\"559\":1}}],[\"介绍和组成\",{\"0\":{\"102\":1}}],[\"介绍\",{\"0\":{\"85\":1,\"322\":1,\"330\":1,\"341\":1,\"348\":1,\"357\":1,\"363\":1,\"369\":1,\"375\":1,\"381\":1,\"388\":1,\"392\":1,\"398\":1,\"401\":1,\"406\":1,\"416\":1,\"424\":1,\"432\":1,\"439\":1,\"514\":1,\"522\":1,\"528\":1},\"1\":{\"537\":1}}],[\"从jdk1\",{\"1\":{\"837\":1}}],[\"从jdk6开始\",{\"1\":{\"837\":1}}],[\"从java锁实现来看\",{\"1\":{\"832\":1}}],[\"从java程序来看\",{\"1\":{\"722\":1}}],[\"从前往后依次执行\",{\"1\":{\"825\":1}}],[\"从用户系统获取到的用户名\",{\"1\":{\"817\":1}}],[\"从此可以理解为sleep是属于线程级别的\",{\"1\":{\"813\":1}}],[\"从操作系统的角度来看\",{\"1\":{\"805\":1}}],[\"从变量在内存中的生存时间上看\",{\"1\":{\"775\":1}}],[\"从变量在内存中的存储方式来看\",{\"1\":{\"775\":1}}],[\"从变量是否有默认值来看\",{\"1\":{\"775\":1}}],[\"从字节码中\",{\"1\":{\"773\":1}}],[\"从菜单\",{\"1\":{\"769\":1}}],[\"从代码和业务场景中定位具体问题\",{\"1\":{\"766\":1}}],[\"从代码逻辑中找到问题所在\",{\"1\":{\"765\":1}}],[\"从打印出来的线程信息中找到上一步转换为\",{\"1\":{\"765\":1}}],[\"从两个地方都分配内存\",{\"1\":{\"724\":1}}],[\"从垃圾回收角度来看\",{\"1\":{\"722\":1}}],[\"从结构上说\",{\"1\":{\"711\":1}}],[\"从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点\",{\"1\":{\"698\":1}}],[\"从冲突的位置x开始\",{\"1\":{\"692\":1}}],[\"从冲突的位置开始\",{\"1\":{\"692\":1}}],[\"从浏览器地址栏输入\",{\"0\":{\"631\":1}}],[\"从缓存中获取结果\",{\"1\":{\"495\":1}}],[\"从购物车移除商品\",{\"1\":{\"384\":1}}],[\"从源端到目的端所建立的虚拟传输连接才能\",{\"1\":{\"275\":1}}],[\"从虚拟的传输连接角度来讲的\",{\"1\":{\"275\":1}}],[\"从物理的网络连接角度来讲的\",{\"1\":{\"275\":1}}],[\"从中提取目的网络地址\",{\"1\":{\"268\":1}}],[\"从网络\",{\"1\":{\"263\":1}}],[\"从主叫端到被叫端就建立了一条连接\",{\"1\":{\"253\":1}}],[\"从通信资源分配角度来看\",{\"1\":{\"253\":1}}],[\"从而消耗大量的系统资源\",{\"1\":{\"837\":1}}],[\"从而使用共享变量时需要从主内存中重新读取最新的值\",{\"1\":{\"836\":1}}],[\"从而使得客户端代码无需区分处理单个对象还是组合对象\",{\"1\":{\"526\":1}}],[\"从而使得构建过程更加灵活和可控\",{\"1\":{\"447\":1}}],[\"从而使得我们可以将不同的请求参数化\",{\"1\":{\"381\":1}}],[\"从而使得算法的变化独立于使用算法的客户端\",{\"1\":{\"341\":1}}],[\"从而导致每个对象都有释放锁的能力\",{\"1\":{\"813\":1}}],[\"从而导致内存泄漏\",{\"1\":{\"788\":1}}],[\"从而动态地创建对象或调用方法\",{\"1\":{\"800\":1}}],[\"从而动态地改变对象的行为\",{\"1\":{\"386\":1}}],[\"从而产生哈希冲突\",{\"1\":{\"788\":1}}],[\"从而更好地控制访问权限\",{\"1\":{\"782\":1}}],[\"从而避免竞态条件和数据不一致的问题\",{\"1\":{\"853\":1}}],[\"从而避免竞争条件\",{\"1\":{\"811\":1}}],[\"从而避免了类冲突和版本不一致的问题\",{\"1\":{\"759\":1}}],[\"从而避免数据包在网络中无限循环\",{\"1\":{\"175\":1}}],[\"从而确保数据的一致性和完整性\",{\"1\":{\"853\":1}}],[\"从而确保即使引用关系变化\",{\"1\":{\"748\":1}}],[\"从而确定目的主机所在的网络\",{\"1\":{\"216\":1}}],[\"从而影响数据的完整性和可靠性\",{\"1\":{\"619\":1}}],[\"从而让多个域名可以访问同一台服务器上的不同网站或服务\",{\"1\":{\"594\":1}}],[\"从而让上层感知不到下层差异\",{\"1\":{\"573\":1}}],[\"从而减少了竞争\",{\"1\":{\"855\":1}}],[\"从而减少了网络中不必要的广播和冲突\",{\"1\":{\"580\":1}}],[\"从而减少重复代码\",{\"1\":{\"485\":1}}],[\"从而形成层次关系\",{\"1\":{\"526\":1}}],[\"从而简化了客户端代码\",{\"1\":{\"526\":1}}],[\"从而简化了客户端的代码\",{\"1\":{\"524\":1}}],[\"从而简化设计和管理\",{\"1\":{\"268\":1}}],[\"从而保证线程安全\",{\"1\":{\"831\":1}}],[\"从而保护现有代码的稳定性和完整性\",{\"1\":{\"512\":1}}],[\"从而保持连接的活跃状态\",{\"1\":{\"294\":1}}],[\"从而保持了端到端的通信\",{\"1\":{\"280\":1}}],[\"从而允许你在执行原始对象的操作之前或之后添加自定义的行为\",{\"1\":{\"501\":1}}],[\"从而允许您参数化客户端与接收者之间的关系\",{\"1\":{\"386\":1}}],[\"从而为项目的成功和可持续发展奠定坚实基础\",{\"1\":{\"482\":1}}],[\"从而降低对象之间的耦合性\",{\"1\":{\"410\":1}}],[\"从而增加系统的灵活性和可扩展性\",{\"1\":{\"381\":1}}],[\"从而增强了系统的灵活性和可扩展性\",{\"1\":{\"351\":1}}],[\"从而可以实现不同的操作\",{\"1\":{\"370\":1}}],[\"从而提高了并发更新性能\",{\"1\":{\"855\":1}}],[\"从而提高了操作的效率\",{\"1\":{\"787\":1}}],[\"从而提高了代码的可维护性和可扩展性\",{\"1\":{\"477\":1}}],[\"从而提高代码的可维护性\",{\"1\":{\"474\":1}}],[\"从而提高代码的可靠性和安全性\",{\"1\":{\"455\":1}}],[\"从而提高代码的可读性和可维护性\",{\"1\":{\"361\":1}}],[\"从而提高系统的灵活性和可维护性\",{\"1\":{\"411\":1}}],[\"从而提高系统的灵活性和可扩展性\",{\"1\":{\"385\":1}}],[\"从而提高系统的松耦合性和可扩展性\",{\"1\":{\"404\":1,\"409\":1}}],[\"从而提高对象之间的松耦合性\",{\"1\":{\"398\":1}}],[\"从而提供了对算法中特定步骤的具体实现\",{\"1\":{\"332\":1}}],[\"从而提供了一种代码复用和扩展的方法\",{\"1\":{\"330\":1}}],[\"从而改变对象的行为\",{\"1\":{\"358\":1}}],[\"从而依次处理请求\",{\"1\":{\"353\":1}}],[\"从而实现多任务并发执行\",{\"1\":{\"809\":1}}],[\"从而实现许多灵活和高级的功能\",{\"1\":{\"800\":1}}],[\"从而实现类的隔离\",{\"1\":{\"758\":1}}],[\"从而实现重置操作\",{\"1\":{\"455\":1}}],[\"从而实现了线程隔离\",{\"1\":{\"816\":1}}],[\"从而实现了按需添加日志记录功能的动态代理类\",{\"1\":{\"497\":1}}],[\"从而实现了撤销和重做的功能\",{\"1\":{\"375\":1}}],[\"从而实现了网络协议的标准化和互操作性\",{\"1\":{\"268\":1}}],[\"从而实现访问者对景点的访问\",{\"1\":{\"372\":1}}],[\"从而实现对类型的参数化\",{\"1\":{\"797\":1}}],[\"从而实现对被代理对象的代理\",{\"1\":{\"496\":1}}],[\"从而实现对特定领域的解释和处理\",{\"1\":{\"391\":1}}],[\"从而实现对元素的功能扩展\",{\"1\":{\"373\":1}}],[\"从而实现对元素的新功能扩展\",{\"1\":{\"369\":1}}],[\"从而实现对请求的预处理和后处理\",{\"1\":{\"352\":1}}],[\"从而实现责任链的执行\",{\"1\":{\"354\":1}}],[\"从而实现不同的处理逻辑和扩展\",{\"1\":{\"353\":1}}],[\"从而实现灵活的处理流程\",{\"1\":{\"351\":1}}],[\"从而实现算法的动态切换\",{\"1\":{\"346\":1}}],[\"从而将\",{\"1\":{\"316\":1}}],[\"从而得到运行时间\",{\"1\":{\"315\":1}}],[\"从而及时恢复数据的传输\",{\"1\":{\"294\":1}}],[\"从而在网络上传输它们的数据\",{\"1\":{\"280\":1}}],[\"从而节约公共ip地址的使用\",{\"1\":{\"223\":1}}],[\"从本结点起\",{\"1\":{\"208\":1}}],[\"从传输层到达的数据段都需要经过ip协议进行重新封装的\",{\"1\":{\"192\":1}}],[\"从互联网的角度上看\",{\"1\":{\"162\":1}}],[\"从属结点发送数据\",{\"1\":{\"153\":1}}],[\"从媒体的整体频带资源上看\",{\"1\":{\"150\":1}}],[\"从发送方到接收方的平均往返时间\",{\"1\":{\"137\":1}}],[\"从一个结点到相邻结点的一段物理线路\",{\"1\":{\"119\":1}}],[\"从简单的文本到复杂的多媒体内容\",{\"1\":{\"96\":1}}],[\"链地址法\",{\"1\":{\"692\":1}}],[\"链式调用方法以及build\",{\"1\":{\"450\":1}}],[\"链式\",{\"1\":{\"312\":1}}],[\"链表写入和hashmap的方式一样\",{\"1\":{\"711\":1}}],[\"链表同样操作\",{\"1\":{\"711\":1}}],[\"链表的插入方式从头插法改成了尾插法\",{\"1\":{\"701\":1}}],[\"链表的节点\",{\"1\":{\"690\":1}}],[\"链表插入方式\",{\"1\":{\"701\":1}}],[\"链表过长转为红黑树\",{\"1\":{\"701\":1}}],[\"链表或红黑树\",{\"1\":{\"701\":1}}],[\"链表或二者的组合实现的\",{\"1\":{\"312\":1}}],[\"链表改成了数组\",{\"1\":{\"701\":1}}],[\"链表里的节点符合泊松分布\",{\"1\":{\"697\":1}}],[\"链表长度超过一定阈值时\",{\"1\":{\"711\":1}}],[\"链表长度超过8就转换成红黑树\",{\"1\":{\"711\":1}}],[\"链表长度变长\",{\"1\":{\"696\":1}}],[\"链表长度大于等于8\",{\"1\":{\"695\":1}}],[\"链表节点\",{\"1\":{\"690\":1}}],[\"链表法等来解决hash碰撞的问题\",{\"1\":{\"690\":1}}],[\"链表实现\",{\"0\":{\"353\":1}}],[\"链表\",{\"1\":{\"311\":1,\"714\":1,\"715\":1}}],[\"链路的时延带宽积又称为以北比特为单位的链路长度\",{\"1\":{\"264\":1}}],[\"链路状态确认\",{\"1\":{\"210\":1}}],[\"链路状态更新\",{\"1\":{\"210\":1}}],[\"链路状态请求信息\",{\"1\":{\"210\":1}}],[\"链路状态路由算法的基本思想是\",{\"1\":{\"210\":1}}],[\"链路状态路由算法\",{\"1\":{\"206\":1,\"210\":1}}],[\"链路释放\",{\"0\":{\"124\":1}}],[\"链路保持\",{\"0\":{\"124\":1}}],[\"链路建立后\",{\"1\":{\"275\":1}}],[\"链路建立\",{\"0\":{\"124\":1}}],[\"链路\",{\"1\":{\"119\":1}}],[\"链接\",{\"1\":{\"104\":1,\"754\":1}}],[\"比\",{\"1\":{\"843\":1}}],[\"比例是\",{\"1\":{\"737\":1}}],[\"比方说\",{\"1\":{\"579\":1}}],[\"比较并交换\",{\"1\":{\"832\":1}}],[\"比较方式也不同\",{\"1\":{\"773\":1}}],[\"比较输入密码和预设密码是否匹配\",{\"1\":{\"495\":1}}],[\"比较麻烦\",{\"1\":{\"254\":1}}],[\"比曼彻斯特变化少\",{\"1\":{\"238\":1}}],[\"比当时的集线器\",{\"1\":{\"171\":1}}],[\"比特\",{\"1\":{\"260\":1}}],[\"比特传输\",{\"1\":{\"229\":1}}],[\"比特传输差错检测\",{\"1\":{\"158\":1}}],[\"比特填充的首尾定界符法\",{\"1\":{\"131\":1}}],[\"比特流的帧组装原理\",{\"0\":{\"131\":1}}],[\"比特流的分界线\",{\"1\":{\"119\":1}}],[\"比如变量命名\",{\"1\":{\"870\":1}}],[\"比如数据库连接\",{\"1\":{\"853\":1}}],[\"比如有玩家超时未确认\",{\"1\":{\"851\":1}}],[\"比如jconsole\",{\"1\":{\"849\":1}}],[\"比如java字符串\",{\"1\":{\"831\":1}}],[\"比如java中的hashmap的实现\",{\"1\":{\"690\":1}}],[\"比如java中有取余\",{\"1\":{\"690\":1}}],[\"比如银行家算法\",{\"1\":{\"848\":1}}],[\"比如发货\",{\"1\":{\"845\":1}}],[\"比如线程间的状态控制\",{\"1\":{\"834\":1}}],[\"比如说咱们的threadlocal\",{\"1\":{\"831\":1}}],[\"比如说我们可以制定她在一个小时内发生stw时间不超过一分钟\",{\"1\":{\"749\":1}}],[\"比如使用final修饰的基础数据类型\",{\"1\":{\"831\":1}}],[\"比如使用cglib\",{\"1\":{\"731\":1}}],[\"比如final关键字修饰的基础数据类型\",{\"1\":{\"831\":1}}],[\"比如每次来都new新的\",{\"1\":{\"817\":1}}],[\"比如可能当前的服务器关闭了\",{\"1\":{\"817\":1}}],[\"比如对共享变量的读写操作要么完整地执行\",{\"1\":{\"814\":1}}],[\"比如垃圾回收线程\",{\"1\":{\"810\":1}}],[\"比如锁还是持有不让出的\",{\"1\":{\"807\":1}}],[\"比如spring\",{\"1\":{\"800\":1}}],[\"比如获取和设置属性的值\",{\"1\":{\"799\":1}}],[\"比如类名\",{\"1\":{\"798\":1}}],[\"比如计数器\",{\"1\":{\"776\":1}}],[\"比如一些应用可能需要在运行时动态加载一些类\",{\"1\":{\"758\":1}}],[\"比如一次要回收240个region\",{\"1\":{\"750\":1}}],[\"比如一个\",{\"1\":{\"674\":1}}],[\"比如我这次要回收新生代\",{\"1\":{\"749\":1}}],[\"比如我们去银行窗口取款\",{\"1\":{\"868\":1}}],[\"比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水\",{\"1\":{\"854\":1}}],[\"比如我们可以创建一个arraylist集合\",{\"1\":{\"731\":1}}],[\"比如我们object类的wait\",{\"1\":{\"722\":1}}],[\"比如我叫张阿三\",{\"1\":{\"594\":1}}],[\"比如执行周期性的垃圾回收或者其他后台任务\",{\"1\":{\"721\":1}}],[\"比如内联\",{\"1\":{\"720\":1}}],[\"比如将类和方法的引用转换为内存地址的引用\",{\"1\":{\"720\":1}}],[\"比如copyonwritearraylist类\",{\"1\":{\"709\":1}}],[\"比如arraylist\",{\"1\":{\"709\":1}}],[\"比如a系统路由选择度量是距离\",{\"1\":{\"212\":1}}],[\"比如去重\",{\"1\":{\"704\":1}}],[\"比如存储缓存\",{\"1\":{\"704\":1}}],[\"比如hash碰撞\",{\"1\":{\"690\":1}}],[\"比如向容器中添加一个元素\",{\"1\":{\"682\":1}}],[\"比如光纤\",{\"1\":{\"619\":1}}],[\"比如qam\",{\"1\":{\"619\":1}}],[\"比如在新生代里面存放着老年代对新生代对象的每一个引用\",{\"1\":{\"742\":1}}],[\"比如在某些类型的电缆或光纤中\",{\"1\":{\"619\":1}}],[\"比如在防火墙配置中\",{\"1\":{\"205\":1}}],[\"比如电缆\",{\"1\":{\"618\":1}}],[\"比如电压\",{\"1\":{\"617\":1}}],[\"比如mac地址\",{\"1\":{\"573\":1}}],[\"比如性能监控\",{\"1\":{\"496\":1}}],[\"比如先转为json\",{\"1\":{\"455\":1}}],[\"比如博物馆\",{\"1\":{\"372\":1}}],[\"比如直接调用集合的add\",{\"1\":{\"367\":1}}],[\"比如加入换台\",{\"1\":{\"360\":1}}],[\"比如首先需要进行数据查询\",{\"1\":{\"336\":1}}],[\"比如请假申请需要额外的日期计算\",{\"1\":{\"333\":1}}],[\"比如退货订单需要额外进行退款处理\",{\"1\":{\"333\":1}}],[\"比如合作伙伴\",{\"1\":{\"223\":1}}],[\"比如网络地址\",{\"1\":{\"222\":1}}],[\"比如最短路径或者最快路径\",{\"1\":{\"182\":1}}],[\"比如\",{\"1\":{\"140\":1,\"327\":1,\"497\":1,\"768\":2,\"785\":1,\"797\":1,\"853\":1}}],[\"比如你用的是电信的网络\",{\"1\":{\"77\":1}}],[\"比如管理\",{\"1\":{\"71\":1}}],[\"路由和数据包传输\",{\"1\":{\"595\":1}}],[\"路由选择问题\",{\"1\":{\"296\":1}}],[\"路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由\",{\"1\":{\"162\":1}}],[\"路由越具体\",{\"1\":{\"221\":1}}],[\"路由聚合\",{\"0\":{\"221\":1},\"1\":{\"221\":1}}],[\"路由更新快\",{\"1\":{\"206\":1}}],[\"路由更新慢\",{\"1\":{\"205\":1}}],[\"路由环路\",{\"1\":{\"205\":1}}],[\"路由环路解决\",{\"1\":{\"205\":1}}],[\"路由环路问题展示\",{\"1\":{\"205\":1}}],[\"路由算法分类\",{\"0\":{\"204\":1}}],[\"路由算法和路由协议\",{\"0\":{\"203\":1}}],[\"路由其实是一种网络层中进行数据报分组交换从而进行路径选择行为的功能\",{\"1\":{\"203\":1}}],[\"路由是否可用等网络本身的消息\",{\"1\":{\"200\":1}}],[\"路由器发生拥挤\",{\"1\":{\"294\":1}}],[\"路由器转发\",{\"1\":{\"268\":1}}],[\"路由器只需要存储其他每个区域的一条记录\",{\"1\":{\"211\":1}}],[\"路由器被分成很多组\",{\"1\":{\"211\":1}}],[\"路由器使用这种分组将其链路状态进行洪泛发送\",{\"1\":{\"210\":1}}],[\"路由器才向所有路由器洪泛发送此信息\",{\"1\":{\"210\":1}}],[\"路由器通过输出端口向所有相邻的路由器发送信息\",{\"1\":{\"210\":1}}],[\"路由器刚开始工作时\",{\"1\":{\"208\":1}}],[\"路由器会向所有邻居结点发送它到每个目的节点的距离表\",{\"1\":{\"208\":1}}],[\"路由器到非直连网络的距离定义为所经过的路由器数+1\",{\"1\":{\"208\":1}}],[\"路由器到直连网络的距离定义为1\",{\"1\":{\"208\":1}}],[\"路由器彼此交换信息\",{\"1\":{\"206\":1}}],[\"路由器把改变路由报文发送给主机\",{\"1\":{\"201\":1}}],[\"路由器之间传递控制消息\",{\"1\":{\"200\":1}}],[\"路由器可以相对简单\",{\"1\":{\"184\":1}}],[\"路由器\",{\"1\":{\"182\":1,\"254\":1,\"574\":1,\"580\":3}}],[\"路由器在多个网络构成的互联网中转发分组\",{\"1\":{\"161\":1}}],[\"路\",{\"1\":{\"119\":1}}],[\"最好的做法是让程序终止并记录错误信息以便调查\",{\"1\":{\"793\":1}}],[\"最主要的优点在名字上已经体现出来\",{\"1\":{\"751\":1}}],[\"最极端情况为内存回收后新生代中所有对象均存活\",{\"1\":{\"743\":1}}],[\"最差可能是o\",{\"1\":{\"690\":1}}],[\"最差情况是o\",{\"1\":{\"685\":1}}],[\"最差情况判断\",{\"1\":{\"316\":1}}],[\"最⼩的那个2进制数值\",{\"1\":{\"689\":1}}],[\"最终又恢复为之前的状态\",{\"1\":{\"845\":1}}],[\"最终产生错误的结果\",{\"1\":{\"829\":1}}],[\"最终生成可执行的类对象\",{\"1\":{\"755\":1}}],[\"最终标记\",{\"1\":{\"750\":1}}],[\"最终到达目标地址\",{\"1\":{\"593\":1}}],[\"最终通过\",{\"1\":{\"498\":1}}],[\"最终\",{\"1\":{\"448\":1,\"733\":1}}],[\"最终调用builder的一个方法返回构建完成的对象\",{\"1\":{\"448\":1}}],[\"最终使这条数据通信之\",{\"1\":{\"119\":1}}],[\"最高阶的项将发挥主导作用\",{\"1\":{\"316\":1}}],[\"最高数据率\",{\"1\":{\"261\":2}}],[\"最长报文段寿命\",{\"1\":{\"286\":1}}],[\"最长前缀匹配\",{\"1\":{\"221\":1}}],[\"最小支持的\",{\"1\":{\"539\":1}}],[\"最小地址\",{\"1\":{\"220\":2}}],[\"最小帧长为64字节\",{\"1\":{\"152\":1}}],[\"最新消息\",{\"1\":{\"208\":1}}],[\"最短路径法\",{\"1\":{\"205\":1}}],[\"最大长度为integer\",{\"1\":{\"862\":1}}],[\"最大堆大小\",{\"1\":{\"764\":1}}],[\"最大并发度是\",{\"1\":{\"711\":2}}],[\"最大可靠地传输信息的极限\",{\"1\":{\"622\":1}}],[\"最大地址\",{\"1\":{\"220\":2}}],[\"最大网络数\",{\"1\":{\"217\":1}}],[\"最大传输单元\",{\"1\":{\"193\":1}}],[\"最大的缺点是可能存在单点故障问题\",{\"1\":{\"153\":1}}],[\"最大帧长为1518\",{\"1\":{\"152\":1}}],[\"最后当有空闲时\",{\"1\":{\"870\":1}}],[\"最后系统恢复了之前被撤销的支付\",{\"1\":{\"845\":1}}],[\"最后又修改回a\",{\"1\":{\"845\":1}}],[\"最后可能引发内存溢出\",{\"1\":{\"818\":1}}],[\"最后引发\",{\"1\":{\"768\":1}}],[\"最后导致\",{\"1\":{\"768\":1}}],[\"最后根据线程的堆栈信息定位到具体业务方法\",{\"1\":{\"765\":1}}],[\"最后调用的方法最先执行完成并退出栈\",{\"1\":{\"724\":1}}],[\"最后调用本地网络协议将数据报传送给下一个网关或目的计算机\",{\"1\":{\"189\":1}}],[\"最后所有元素处理完成后\",{\"1\":{\"695\":1}}],[\"最后把结果加1再返回即可\",{\"1\":{\"689\":1}}],[\"最后打印出加载的资源的\",{\"1\":{\"436\":1}}],[\"最后\",{\"1\":{\"344\":1,\"346\":1,\"372\":1,\"448\":2,\"450\":1,\"495\":6,\"502\":1,\"525\":2}}],[\"最后一个可用网络\",{\"1\":{\"217\":1}}],[\"最后的余数就是fcs校验码\",{\"1\":{\"135\":1,\"576\":1}}],[\"最后得到所找域名的ip地址\",{\"1\":{\"72\":1}}],[\"买票\",{\"1\":{\"119\":1}}],[\"出于追求速度的原因\",{\"1\":{\"724\":1}}],[\"出于效率的考虑\",{\"1\":{\"680\":1}}],[\"出现线程死锁以后\",{\"1\":{\"849\":1}}],[\"出现节点个数的概率是递减的\",{\"1\":{\"697\":1}}],[\"出现下列问题\",{\"1\":{\"538\":1}}],[\"出现传输错误时\",{\"1\":{\"268\":1}}],[\"出现了自治系统\",{\"1\":{\"211\":1}}],[\"出现故障\",{\"1\":{\"81\":1}}],[\"出站都要经历铁路部门的规则\",{\"1\":{\"119\":1}}],[\"火车\",{\"1\":{\"119\":1}}],[\"采样频率必须至少是信号带宽的两倍\",{\"1\":{\"622\":1}}],[\"采取差错检测\",{\"1\":{\"119\":1}}],[\"采用ab岗两人进行录入\",{\"1\":{\"854\":1}}],[\"采用的是复制算法\",{\"1\":{\"749\":1}}],[\"采用的是后进先出的数据结构\",{\"1\":{\"724\":1}}],[\"采用拉链法结合红黑树\",{\"1\":{\"711\":1}}],[\"采用拉链法\",{\"1\":{\"711\":1}}],[\"采用安全失败机制的集合容器\",{\"1\":{\"709\":1}}],[\"采用更简单的判断逻辑\",{\"1\":{\"701\":1}}],[\"采用了一种读写分离的并发策略\",{\"1\":{\"682\":1}}],[\"采用\",{\"0\":{\"663\":1},\"1\":{\"711\":2,\"728\":1}}],[\"采用洪泛法发送\",{\"1\":{\"210\":1}}],[\"采用基于硬件的交叉矩阵\",{\"1\":{\"173\":1}}],[\"采用基于tcp连接的客户\",{\"1\":{\"97\":1,\"98\":1}}],[\"采用ieee\",{\"1\":{\"158\":1}}],[\"采用tcp协议\",{\"1\":{\"109\":1}}],[\"作用于当前对象实例加锁\",{\"1\":{\"833\":1}}],[\"作用域不同\",{\"1\":{\"816\":1}}],[\"作用都是用于暂停线程的执行\",{\"1\":{\"812\":1}}],[\"作用\",{\"1\":{\"175\":1,\"193\":1,\"580\":1,\"583\":1,\"595\":1,\"719\":1,\"722\":1}}],[\"作用是什么\",{\"1\":{\"119\":1}}],[\"作为一条\",{\"1\":{\"845\":1}}],[\"作为方法参数传递\",{\"1\":{\"816\":1}}],[\"作为编码方案\",{\"1\":{\"789\":1}}],[\"作为该类的数据访问入口\",{\"1\":{\"754\":1}}],[\"作为初始的存活对象合集\",{\"1\":{\"733\":1}}],[\"作为值\",{\"1\":{\"712\":1}}],[\"作为键\",{\"1\":{\"712\":1}}],[\"作为键或值放入\",{\"1\":{\"706\":1}}],[\"作为映射的位置\",{\"1\":{\"691\":1}}],[\"作为订阅者接收到这个事件并进行处理\",{\"1\":{\"326\":1}}],[\"作为度量来寻找最佳路由是不行的\",{\"1\":{\"212\":1}}],[\"作为这个结点的路由表\",{\"1\":{\"205\":1}}],[\"作为与\",{\"1\":{\"120\":1}}],[\"作为结束符\",{\"1\":{\"94\":1}}],[\"实习的时候中午吃饭点外卖\",{\"1\":{\"816\":1}}],[\"实质在于将一系列\",{\"1\":{\"733\":1}}],[\"实施子网划分并进行测试\",{\"1\":{\"596\":1}}],[\"实施和测试\",{\"1\":{\"596\":1}}],[\"实例化时\",{\"1\":{\"865\":1}}],[\"实例化相应的具体产品对象\",{\"1\":{\"427\":1}}],[\"实例对象结构里有对象头\",{\"1\":{\"835\":1}}],[\"实例可以在整个类中直接访问\",{\"1\":{\"816\":1}}],[\"实例可以被类的所有实例和方法直接访问\",{\"1\":{\"816\":1}}],[\"实例是类级别的\",{\"1\":{\"816\":1}}],[\"实例\",{\"1\":{\"816\":2}}],[\"实例在整个类中都是共享的\",{\"1\":{\"816\":1}}],[\"实例被垃圾回收器回收的时候触发的操作\",{\"1\":{\"785\":1}}],[\"实例都可以调用\",{\"1\":{\"779\":1}}],[\"实例方法需要创建实例对象\",{\"1\":{\"779\":1}}],[\"实例方法需要创建对应的实例对象才能调用\",{\"1\":{\"779\":1}}],[\"实例变量将会在对象实例化时随着对象一起分配在\",{\"1\":{\"754\":1}}],[\"实例数据用来存储对象真正的有效信息\",{\"1\":{\"729\":1}}],[\"实例数据\",{\"1\":{\"729\":1}}],[\"实例传递给它\",{\"1\":{\"326\":1}}],[\"实体店渠道\",{\"1\":{\"506\":1}}],[\"实体店等\",{\"1\":{\"506\":1}}],[\"实体看得见相邻下层所提供的服务\",{\"1\":{\"251\":1}}],[\"实体\",{\"1\":{\"250\":1}}],[\"实体和对等实体\",{\"1\":{\"250\":2}}],[\"实体和协议\",{\"0\":{\"250\":1}}],[\"实际就是在暗示线程调度器当前线程请求让出自己的cpu\",{\"1\":{\"807\":1}}],[\"实际新生代的收集不是按照这个比例\",{\"1\":{\"744\":1}}],[\"实际直接使用两个流objectoutputstream和objectinputstream来进行序列化和反序列化\",{\"1\":{\"680\":1}}],[\"实际传输的数据\",{\"1\":{\"575\":1}}],[\"实际要传输的数据\",{\"1\":{\"575\":1}}],[\"实际案例\",{\"0\":{\"511\":1}}],[\"实际上\",{\"1\":{\"787\":1}}],[\"实际上也是破坏了双亲委派模型的\",{\"1\":{\"760\":1}}],[\"实际上就是相当于每个segment都是一个hashmap\",{\"1\":{\"711\":1}}],[\"实际上是通过\",{\"1\":{\"792\":1}}],[\"实际上是将这些元素作为\",{\"1\":{\"683\":1}}],[\"实际上是主机中的浏览器应用进程与web服务器中的web服务器应用进程之间基于网络的通信\",{\"1\":{\"268\":1}}],[\"实际上在内部调用的是新的支付接口实现的方法\",{\"1\":{\"510\":1}}],[\"实际\",{\"1\":{\"240\":1}}],[\"实际应用中没有固定的公式\",{\"1\":{\"866\":1}}],[\"实际应用\",{\"1\":{\"184\":1}}],[\"实现互斥同步\",{\"1\":{\"832\":1}}],[\"实现线程安全的方法通常包括\",{\"1\":{\"831\":1}}],[\"实现一个线程修改一个对象的值\",{\"1\":{\"811\":2}}],[\"实现一些自定义的功能\",{\"1\":{\"352\":1}}],[\"实现callable接口\",{\"1\":{\"806\":2}}],[\"实现command接口\",{\"1\":{\"383\":1}}],[\"实现runnable接口\",{\"1\":{\"806\":1}}],[\"实现在运行时动态地生成代理类\",{\"1\":{\"800\":1}}],[\"实现反射通常涉及以下几个步骤\",{\"1\":{\"799\":1}}],[\"实现上面除了\",{\"1\":{\"762\":1}}],[\"实现上述接口\",{\"1\":{\"495\":4}}],[\"实现接口\",{\"1\":{\"704\":1}}],[\"实现的\",{\"1\":{\"683\":1,\"704\":2,\"842\":1,\"846\":1}}],[\"实现的动态代理示例\",{\"1\":{\"497\":1}}],[\"实现的动态代理\",{\"0\":{\"497\":1,\"498\":1}}],[\"实现排队功能的叫号机\",{\"1\":{\"671\":1}}],[\"实现网络间的通信\",{\"1\":{\"597\":1}}],[\"实现跨网络的数据传输\",{\"1\":{\"593\":1}}],[\"实现组合对象的操作\",{\"1\":{\"524\":1}}],[\"实现组件接口\",{\"1\":{\"524\":2,\"525\":4}}],[\"实现叶子对象的操作\",{\"1\":{\"524\":1}}],[\"实现灵活的销售策略\",{\"1\":{\"506\":1}}],[\"实现实现部分的具体逻辑\",{\"1\":{\"504\":1}}],[\"实现部分接口通常是与抽象部分接口相对应的\",{\"1\":{\"505\":1}}],[\"实现部分接口定义了实现部分的接口和功能\",{\"1\":{\"505\":1}}],[\"实现部分\",{\"1\":{\"504\":1}}],[\"实现部分包含低层的具体实现\",{\"1\":{\"504\":1}}],[\"实现对对象功能的动态扩展\",{\"1\":{\"502\":1}}],[\"实现对被代理类方法的增强或修改\",{\"1\":{\"495\":1}}],[\"实现各种输入和输出操作\",{\"1\":{\"500\":1}}],[\"实现远程服务的具体类\",{\"1\":{\"495\":1}}],[\"实现敏感操作的具体类\",{\"1\":{\"495\":1}}],[\"实现数据库操作的具体类\",{\"1\":{\"495\":1}}],[\"实现功能的灵活扩展\",{\"1\":{\"495\":1}}],[\"实现这个接口\",{\"1\":{\"494\":1}}],[\"实现这些规程或协议的硬件和软件加上物理线路就构成了数据链路层\",{\"1\":{\"119\":1}}],[\"实现工作功能\",{\"1\":{\"473\":1}}],[\"实现行走功能\",{\"1\":{\"473\":1}}],[\"实现不同网络之间的通信\",{\"1\":{\"580\":1}}],[\"实现不同的功能\",{\"1\":{\"383\":1}}],[\"实现不可变对象\",{\"1\":{\"449\":1}}],[\"实现builder接口\",{\"1\":{\"448\":2}}],[\"实现产品的创建方法\",{\"1\":{\"441\":1}}],[\"实现具体的销售逻辑\",{\"1\":{\"506\":2}}],[\"实现具体的参与者类\",{\"1\":{\"402\":1,\"407\":1}}],[\"实现具体的中介者类\",{\"1\":{\"402\":1,\"407\":1}}],[\"实现中介者接口\",{\"1\":{\"400\":1}}],[\"实现非终结符表达式\",{\"1\":{\"393\":1}}],[\"实现终结符表达式\",{\"1\":{\"393\":1}}],[\"实现步骤\",{\"0\":{\"393\":1,\"402\":1,\"407\":1}}],[\"实现更加灵活的命令组合\",{\"1\":{\"385\":1}}],[\"实现游览过程\",{\"1\":{\"372\":1}}],[\"实现访问者接口中的方法\",{\"1\":{\"372\":1}}],[\"实现抽象产品接口\",{\"1\":{\"441\":2}}],[\"实现抽象产品类的接口\",{\"1\":{\"434\":1}}],[\"实现抽象工厂接口\",{\"1\":{\"441\":2}}],[\"实现抽象工厂类\",{\"1\":{\"434\":1}}],[\"实现抽象访问者接口\",{\"1\":{\"371\":1}}],[\"实现抽象访问者定义的接口\",{\"1\":{\"371\":1}}],[\"实现抽象元素接口\",{\"1\":{\"371\":1}}],[\"实现抽象元素定义的接口\",{\"1\":{\"371\":1}}],[\"实现抽象方法\",{\"1\":{\"332\":1,\"335\":4,\"338\":3}}],[\"实现遍历逻辑\",{\"1\":{\"365\":1}}],[\"实现迭代器接口\",{\"1\":{\"365\":1}}],[\"实现状态切换\",{\"1\":{\"359\":1}}],[\"实现state接口\",{\"1\":{\"359\":1}}],[\"实现处理器接口\",{\"1\":{\"350\":1}}],[\"实现fastjson2的序列化方法\",{\"1\":{\"346\":1}}],[\"实现hessian的序列化方法\",{\"1\":{\"346\":1}}],[\"实现版本2的反序列化逻辑\",{\"1\":{\"346\":1}}],[\"实现版本1的反序列化逻辑\",{\"1\":{\"346\":1}}],[\"实现算法的灵活替换\",{\"1\":{\"345\":2}}],[\"实现个性化的功能扩展\",{\"1\":{\"339\":1}}],[\"实现word报告的导出逻辑\",{\"1\":{\"336\":1}}],[\"实现word报告的内容填充逻辑\",{\"1\":{\"336\":1}}],[\"实现word报告的数据查询逻辑\",{\"1\":{\"336\":1}}],[\"实现pdf报告的导出逻辑\",{\"1\":{\"336\":1}}],[\"实现pdf报告的内容填充逻辑\",{\"1\":{\"336\":1}}],[\"实现pdf报告的数据查询逻辑\",{\"1\":{\"336\":1}}],[\"实现特定申请的审批逻辑\",{\"1\":{\"333\":1}}],[\"实现特定关卡的设计\",{\"1\":{\"333\":1}}],[\"实现特定类型订单的处理逻辑\",{\"1\":{\"333\":1}}],[\"实现了独占锁的功能\",{\"1\":{\"839\":1}}],[\"实现了数据的并行传输\",{\"1\":{\"580\":1}}],[\"实现了旧的支付接口\",{\"1\":{\"510\":1}}],[\"实现了component接口的操作\",{\"1\":{\"524\":2}}],[\"实现了component接口\",{\"1\":{\"502\":1,\"524\":2}}],[\"实现了command接口\",{\"1\":{\"382\":1}}],[\"实现了额外的功能\",{\"1\":{\"501\":1}}],[\"实现了客户端和被代理对象的解耦\",{\"1\":{\"495\":1}}],[\"实现了对被代理类的增强或修改\",{\"1\":{\"494\":1}}],[\"实现了对象的创建和使用的解耦\",{\"1\":{\"437\":1}}],[\"实现了对象行为的动态改变\",{\"1\":{\"361\":1}}],[\"实现了多态的特性\",{\"1\":{\"470\":1}}],[\"实现了代码的松耦合\",{\"1\":{\"470\":1}}],[\"实现了\",{\"1\":{\"436\":1,\"495\":1,\"498\":1,\"510\":2,\"706\":2,\"842\":1}}],[\"实现了抽象组件接口\",{\"1\":{\"501\":1}}],[\"实现了抽象方法\",{\"1\":{\"436\":1}}],[\"实现了抽象产品类\",{\"1\":{\"434\":1}}],[\"实现了抽象工厂类\",{\"1\":{\"434\":1}}],[\"实现了开闭原则\",{\"1\":{\"432\":1}}],[\"实现了请求的动态分发和处理\",{\"1\":{\"350\":1}}],[\"实现了算法和客户端的解耦\",{\"1\":{\"342\":1}}],[\"实现了模板方法设计模式的思想\",{\"1\":{\"338\":1}}],[\"实现了具体的数据读取逻辑\",{\"1\":{\"335\":1}}],[\"实现了在抽象类中定义的抽象方法\",{\"1\":{\"332\":1}}],[\"实现了群聊的功能\",{\"1\":{\"325\":1}}],[\"实现了接收和处理主题通知的方法\",{\"1\":{\"324\":1}}],[\"实现方式\",{\"0\":{\"294\":1,\"297\":1},\"1\":{\"280\":2}}],[\"实现方法\",{\"1\":{\"200\":1}}],[\"实现两个主机之间的通信\",{\"1\":{\"165\":1}}],[\"实现简单\",{\"1\":{\"147\":1}}],[\"实现原理\",{\"1\":{\"137\":1,\"138\":1,\"139\":1,\"855\":1}}],[\"实现\",{\"1\":{\"134\":1,\"135\":1,\"159\":1,\"360\":1,\"576\":1,\"705\":3,\"706\":1,\"806\":1,\"839\":1}}],[\"实时调整\",{\"1\":{\"294\":1}}],[\"实时性强\",{\"1\":{\"253\":1}}],[\"实时关注dns运行状态\",{\"1\":{\"81\":1}}],[\"实时通信等\",{\"1\":{\"59\":1}}],[\"之所以\",{\"1\":{\"836\":1}}],[\"之所以不用平衡二叉树\",{\"1\":{\"698\":1}}],[\"之所以不用二叉树\",{\"1\":{\"698\":1}}],[\"之中\",{\"1\":{\"758\":1}}],[\"之前关闭\",{\"1\":{\"796\":1}}],[\"之前虚拟机被终止运行的话\",{\"1\":{\"796\":1}}],[\"之前程序所在的线程死亡\",{\"1\":{\"796\":1}}],[\"之前物理划分的时候\",{\"1\":{\"749\":1}}],[\"之前谈到过是基于分代回收\",{\"1\":{\"749\":1}}],[\"之前检查老年代\",{\"1\":{\"739\":1}}],[\"之前没有检查元素\",{\"1\":{\"367\":1}}],[\"之前没有调用iterator\",{\"1\":{\"367\":1}}],[\"之后对象的移区操作中增加\",{\"1\":{\"740\":1}}],[\"之后有一批对象需要放入老年代\",{\"1\":{\"739\":1}}],[\"之后老年代空间不足\",{\"1\":{\"739\":1}}],[\"之后每次扩充\",{\"1\":{\"706\":2}}],[\"之后\",{\"1\":{\"448\":1,\"502\":4,\"740\":2}}],[\"之后按照先后顺序填充stdm帧\",{\"1\":{\"148\":1}}],[\"之后始终使用相同的频带进行通信\",{\"1\":{\"147\":1}}],[\"之外\",{\"1\":{\"119\":1,\"742\":1}}],[\"之间的共享和访问\",{\"1\":{\"816\":1}}],[\"之间的文件传输能力\",{\"1\":{\"83\":1}}],[\"之间具有相同的地位\",{\"1\":{\"59\":1}}],[\"会执行完\",{\"1\":{\"864\":1}}],[\"会将所有分段的计数器值进行累加\",{\"1\":{\"855\":1}}],[\"会将所有分段的计数器值累加起来得到最终的结果\",{\"1\":{\"855\":1}}],[\"会将其存入字符串常量池\",{\"1\":{\"792\":1}}],[\"会将其扩充为\",{\"1\":{\"706\":1}}],[\"会将其生存时间ttl字段值减1\",{\"1\":{\"201\":1}}],[\"会有一个自旋次数的限制\",{\"1\":{\"845\":1}}],[\"会有一个专门的线程执行垃圾回收\",{\"1\":{\"721\":1}}],[\"会给cpu带来非常大的执行开销\",{\"1\":{\"845\":1}}],[\"会随着线程获取锁后\",{\"1\":{\"836\":1}}],[\"会被加入到队列中等待锁的释放\",{\"1\":{\"839\":1}}],[\"会被加入到该列表\",{\"1\":{\"835\":1}}],[\"会被加入到\",{\"1\":{\"835\":1}}],[\"会被移动到年老代\",{\"1\":{\"741\":1}}],[\"会作⽤于类的所有对象实例\",{\"1\":{\"833\":1}}],[\"会插入读屏障\",{\"1\":{\"828\":1}}],[\"会插入写屏障\",{\"1\":{\"828\":1}}],[\"会在适当的地方插入内存屏障指令\",{\"1\":{\"828\":1}}],[\"会在指令序列中插入内存屏障来禁止特定类型的处理器重排序\",{\"1\":{\"827\":1}}],[\"会在帧交换表中查找帧的目的mac地址对应的接口号\",{\"1\":{\"174\":1}}],[\"会从主内存重新获取最新值\",{\"1\":{\"827\":1}}],[\"会使cpu由用户态变为内核态\",{\"1\":{\"809\":1}}],[\"会使得类过于庞大\",{\"1\":{\"782\":1}}],[\"会继续往下执行\",{\"1\":{\"807\":1}}],[\"会唤醒一个在这个共享变量上调用\",{\"1\":{\"807\":1}}],[\"会创建\",{\"1\":{\"791\":1}}],[\"会触发新的垃圾回收\",{\"1\":{\"751\":1}}],[\"会触发一次年轻代gc\",{\"1\":{\"741\":1}}],[\"会产生所谓的理\",{\"1\":{\"751\":1}}],[\"会分八次\",{\"1\":{\"750\":1}}],[\"会把堆空间分为新生代和老年代\",{\"1\":{\"749\":1}}],[\"会把这些对象列进回收范围之中进行第二次回收\",{\"1\":{\"735\":1}}],[\"会涉及对象的移动\",{\"1\":{\"747\":1}}],[\"会涉及到编译器线程\",{\"1\":{\"721\":1}}],[\"会考虑这些废弃常量并将其回收\",{\"1\":{\"733\":1}}],[\"会\",{\"1\":{\"728\":1}}],[\"会因永久代的原因而导致不同虚拟机下有不同的表现\",{\"1\":{\"725\":1}}],[\"会同步生成一个栈帧\",{\"1\":{\"722\":1}}],[\"会按照插入顺序或访问顺序\",{\"1\":{\"715\":1}}],[\"会记录当前集合的修改次数值\",{\"1\":{\"710\":1}}],[\"会抛出\",{\"1\":{\"706\":1}}],[\"会直接使用你给定的大小\",{\"1\":{\"706\":1}}],[\"会根据锁的公平性策略进行后续等待队列的处理\",{\"1\":{\"839\":1}}],[\"会根据键的顺序进行排序存储\",{\"1\":{\"705\":1}}],[\"会根据实际存储的元素动态地扩容或缩容\",{\"1\":{\"677\":1}}],[\"会根据页面类型进行相应的计数\",{\"1\":{\"372\":1}}],[\"会让类结构爆炸\",{\"1\":{\"500\":1}}],[\"会输出方法调用的前后日志和结果\",{\"1\":{\"498\":1}}],[\"会先输出\",{\"1\":{\"497\":1}}],[\"会调用\",{\"1\":{\"839\":1}}],[\"会调用父类的构造器进行父类的初始化\",{\"1\":{\"783\":1}}],[\"会调用实际的数据库操作类执行查询\",{\"1\":{\"495\":1}}],[\"会调用相应子类的\",{\"1\":{\"469\":1}}],[\"会调用具体元素的accept方法\",{\"1\":{\"372\":1}}],[\"会导致创建过多的\",{\"1\":{\"790\":1}}],[\"会导致迭代器的状态不一致\",{\"1\":{\"367\":1}}],[\"会导致窗口内的所有分组都需要重传\",{\"1\":{\"138\":1}}],[\"会增加一些运行时的开销\",{\"1\":{\"742\":1}}],[\"会增加代码量和维护成本\",{\"1\":{\"495\":1}}],[\"会增加代码量\",{\"1\":{\"451\":1}}],[\"会增加客户端的复杂性\",{\"1\":{\"345\":1}}],[\"会增加类的数量\",{\"1\":{\"345\":1}}],[\"会增加其他路由器中路由表记录的数量\",{\"1\":{\"218\":1}}],[\"会发出信号通知其他核心的缓存失效\",{\"1\":{\"828\":1}}],[\"会发生链表和红黑树的不断转换\",{\"1\":{\"697\":1}}],[\"会发送arp请求广播以获取对应的mac地址\",{\"1\":{\"583\":1}}],[\"会发送一个带有\",{\"1\":{\"114\":1}}],[\"会发布一个\",{\"1\":{\"326\":1}}],[\"会打印出相应的消息内容\",{\"1\":{\"325\":1}}],[\"会自我牺牲\",{\"1\":{\"296\":1}}],[\"会连带着修改发送方的允许发送窗口大小\",{\"1\":{\"294\":1}}],[\"会话层\",{\"1\":{\"268\":1}}],[\"会重新选择另一条线路\",{\"1\":{\"255\":1}}],[\"会带来以下弊端\",{\"1\":{\"218\":1}}],[\"会拥有更多的mac地址\",{\"1\":{\"165\":1}}],[\"会向客户端发送dhcp提供消息\",{\"1\":{\"64\":1}}],[\"然后重新执行整个阻塞队列\",{\"1\":{\"871\":1}}],[\"然后逐个调用线程的interrupt方法来中断线程\",{\"1\":{\"864\":1}}],[\"然后逐步遍历灰色对象的引用\",{\"1\":{\"748\":1}}],[\"然后table引用指向newtab\",{\"1\":{\"821\":1}}],[\"然后放到新的newtab\",{\"1\":{\"821\":1}}],[\"然后遍历老的table数组\",{\"1\":{\"821\":1}}],[\"然后还要根据条件判断size\",{\"1\":{\"821\":1}}],[\"然后判断该槽位entry对象中的key是否和get的key一致\",{\"1\":{\"820\":1}}],[\"然后和table数组长度减一\",{\"1\":{\"819\":1}}],[\"然后进行相应的操作\",{\"1\":{\"811\":2}}],[\"然后进行退避\",{\"1\":{\"152\":1}}],[\"然后用对象执行方法的方式解决问题\",{\"1\":{\"781\":1}}],[\"然后用户可以输入规则条件\",{\"1\":{\"391\":1}}],[\"然后实例对象点进行调用\",{\"1\":{\"779\":1}}],[\"然后分析\",{\"1\":{\"768\":1}}],[\"然后分别用游客和导游进行游览\",{\"1\":{\"372\":1}}],[\"然后stw\",{\"1\":{\"750\":1}}],[\"然后就会将region分为新生代\",{\"1\":{\"749\":1}}],[\"然后直接清理掉边界以外的内存\",{\"1\":{\"744\":1}}],[\"然后从该合集出发\",{\"1\":{\"733\":1}}],[\"然后从路由表再构造出转发分组的转发表\",{\"1\":{\"162\":1}}],[\"然后我们的java虚拟机提供它的指定的字节码文件规范进行解释\",{\"1\":{\"719\":1}}],[\"然后我们派生出两个子类\",{\"1\":{\"469\":1}}],[\"然后根据比较结果来尝试获取锁\",{\"1\":{\"839\":1}}],[\"然后根据锁的地址找到持有锁的线程\",{\"1\":{\"765\":1}}],[\"然后根据找到对应进行里哪个线程占用\",{\"1\":{\"765\":1}}],[\"然后根据结果进行插入或更新put\",{\"1\":{\"713\":1}}],[\"然后根据查询结果填充报告内容\",{\"1\":{\"336\":1}}],[\"然后让hashcode的高16位和低16位进行异或操作\",{\"1\":{\"693\":1}}],[\"然后把它们的叠加和作为映射的位置\",{\"1\":{\"691\":1}}],[\"然后操作包装后的\",{\"1\":{\"681\":1}}],[\"然后copy赋值\",{\"1\":{\"677\":1}}],[\"然后执行一种退避算法\",{\"1\":{\"581\":1}}],[\"然后传递给网络层\",{\"1\":{\"573\":1}}],[\"然后点击try\",{\"1\":{\"538\":1}}],[\"然后一直next\",{\"1\":{\"538\":1}}],[\"然后一直next即可\",{\"1\":{\"538\":1}}],[\"然后门面负责协调并调用库存管理\",{\"1\":{\"518\":1}}],[\"然后使用适配器\",{\"1\":{\"510\":1}}],[\"然后使用迭代器遍历聚合对象的元素\",{\"1\":{\"365\":1}}],[\"然后在其他线程修改该变量为b\",{\"1\":{\"845\":1}}],[\"然后在堆空间中创建\",{\"1\":{\"791\":1}}],[\"然后在新副本上执行写操作\",{\"1\":{\"682\":1}}],[\"然后在订单类中使用策略模式来计算折扣金额\",{\"1\":{\"465\":1}}],[\"然后在上下文类中持有一个策略对象\",{\"1\":{\"342\":1}}],[\"然后创建了三个用户参与者\",{\"1\":{\"408\":1}}],[\"然后创建具体访问者对象\",{\"1\":{\"371\":1}}],[\"然后输入数据\",{\"1\":{\"395\":1}}],[\"然后调用\",{\"1\":{\"495\":1}}],[\"然后调用其\",{\"1\":{\"436\":1}}],[\"然后调用规则引擎进行解释和处理\",{\"1\":{\"393\":1}}],[\"然后调用request方法来执行当前状态的行为\",{\"1\":{\"359\":1}}],[\"然后将文件移动至\",{\"1\":{\"538\":1}}],[\"然后将数据传递给下一个规则\",{\"1\":{\"355\":1}}],[\"然后将邮件传递给下一个处理器\",{\"1\":{\"355\":1}}],[\"然后将请求传递给下一个处理器\",{\"1\":{\"355\":1}}],[\"然后将请求传递给下一个记录器\",{\"1\":{\"355\":1}}],[\"然后每种申请类型对应一个具体子类\",{\"1\":{\"333\":1}}],[\"然后每种订单类型对应一个具体子类\",{\"1\":{\"333\":1}}],[\"然后每个具体关卡对应一个子类\",{\"1\":{\"333\":1}}],[\"然后\",{\"1\":{\"325\":1,\"326\":1,\"336\":1,\"344\":1,\"346\":2,\"353\":1,\"366\":1,\"372\":1,\"406\":1,\"422\":1,\"448\":1,\"495\":5,\"498\":1,\"502\":2,\"506\":2,\"524\":1,\"741\":1}}],[\"然后给主机发回响应报文\",{\"1\":{\"268\":1}}],[\"然后去掉前导码后成为帧\",{\"1\":{\"268\":1}}],[\"然后去掉前导码后\",{\"1\":{\"268\":1}}],[\"然后按照一定规则绞合起来就构成了双绞线\",{\"1\":{\"230\":1}}],[\"然后通过reentrantlock去操作而已\",{\"1\":{\"711\":1}}],[\"然后通过\",{\"1\":{\"686\":1}}],[\"然后通过指导者来构建电脑对象\",{\"1\":{\"448\":1}}],[\"然后通过指定备忘录的索引来恢复到相应的状态\",{\"1\":{\"377\":1}}],[\"然后通过具体工厂对象调用\",{\"1\":{\"443\":1}}],[\"然后通过相邻路由器之间的距离矢量通告进行距离矢量表的更新\",{\"1\":{\"208\":1}}],[\"然后通过该接口转发帧\",{\"1\":{\"173\":1,\"174\":1}}],[\"然后发数据给网关后\",{\"1\":{\"198\":1}}],[\"然后再呈现给你\",{\"1\":{\"870\":1}}],[\"然后再从主内存获取最新值\",{\"1\":{\"827\":1}}],[\"然后再使用\",{\"1\":{\"788\":1}}],[\"然后再把已使用过的内存空间一次清理掉\",{\"1\":{\"744\":1}}],[\"然后再把这些分段依次传输出去\",{\"1\":{\"193\":1}}],[\"然后再反序列化为新的对象\",{\"1\":{\"455\":1}}],[\"然后再到数据链路层封装成帧\",{\"1\":{\"197\":1}}],[\"然后为了适应不同网络对分组大小的要求\",{\"1\":{\"189\":1}}],[\"然后对方拿起电话\",{\"1\":{\"125\":1}}],[\"然后选择极速安装即可\",{\"1\":{\"7\":1,\"10\":1,\"13\":1,\"33\":1,\"36\":1,\"39\":1}}],[\"然而\",{\"1\":{\"114\":1,\"367\":1,\"421\":1,\"422\":1,\"430\":1,\"437\":1,\"451\":1,\"473\":1,\"519\":1,\"533\":1,\"581\":1,\"618\":1,\"787\":1,\"800\":1}}],[\"但会处理阻塞队列中的任务\",{\"1\":{\"867\":1}}],[\"但会尽最大努力进行交付\",{\"1\":{\"301\":1}}],[\"但线程池中总线程数\",{\"1\":{\"860\":1}}],[\"但阻塞的同时并不释放自己已经获取的资源\",{\"1\":{\"848\":1}}],[\"但又提出了新的资源请求\",{\"1\":{\"848\":1}}],[\"但又不希望破坏现有的代码结构\",{\"1\":{\"512\":1}}],[\"但系统记录了两次支付成功\",{\"1\":{\"845\":1}}],[\"但并不能保证复合操作的原子性\",{\"1\":{\"829\":1,\"844\":1}}],[\"但并不知道实现该服务的具体协议\",{\"1\":{\"251\":1}}],[\"但每个人只能打开和操作自己的抽屉\",{\"1\":{\"816\":1}}],[\"但每个关卡的地图\",{\"1\":{\"333\":1}}],[\"但还有其他重载方法\",{\"1\":{\"812\":1}}],[\"但还没有调用start\",{\"1\":{\"808\":1}}],[\"但你可以在使用的时候告诉它具体装的是什么\",{\"1\":{\"797\":1}}],[\"但你又不希望这些对象紧密耦合在一起时\",{\"1\":{\"325\":1}}],[\"但提供的url格式不正确时抛出\",{\"1\":{\"793\":1}}],[\"但提供了按照插入顺序或访问顺序访问键值对的能力\",{\"1\":{\"715\":1}}],[\"但被另一个线程中断时抛出\",{\"1\":{\"793\":1}}],[\"但stringbuilder不是线程安全的\",{\"1\":{\"789\":1}}],[\"但由于\",{\"1\":{\"788\":2}}],[\"但由于无线电波传播的特殊性\",{\"1\":{\"152\":1}}],[\"但\",{\"1\":{\"788\":2}}],[\"但却可以实现多个\",{\"1\":{\"783\":1}}],[\"但子加载器加载的类对父加载器不可见\",{\"1\":{\"758\":1}}],[\"但其引用的其他对象还未被访问\",{\"1\":{\"748\":1}}],[\"但其中的具体步骤由子类实现\",{\"1\":{\"336\":1}}],[\"但其中某些步骤的具体实现可能会变化时\",{\"1\":{\"333\":1}}],[\"但后续步骤不是直接对可回收对象进行清理\",{\"1\":{\"744\":1}}],[\"但一共有多少对象在内存回收后存活下来是不可预知的\",{\"1\":{\"743\":1}}],[\"但一个字符内的每一位还是同步的\",{\"1\":{\"235\":1}}],[\"但这存在一个对象消失问题\",{\"1\":{\"746\":1}}],[\"但这次minor\",{\"1\":{\"743\":1}}],[\"但这足以保持元素的均匀性\",{\"1\":{\"688\":1}}],[\"但比起收集时扫描整个老年代来说仍然是划算的\",{\"1\":{\"742\":1}}],[\"但无疑会为内存回收带来很大的性能负担\",{\"1\":{\"742\":1}}],[\"但新生代中的对象是完全有可能被老年代所引用的\",{\"1\":{\"742\":1}}],[\"但非必须的对象\",{\"1\":{\"735\":1}}],[\"但同样地\",{\"1\":{\"709\":1}}],[\"但性能相对较低\",{\"1\":{\"706\":1}}],[\"但允许\",{\"1\":{\"705\":1}}],[\"但只允许一个线程写入共享资源\",{\"1\":{\"831\":1,\"832\":1}}],[\"但只能有一个\",{\"1\":{\"704\":1}}],[\"但只针对加入了特定多播组的设备\",{\"1\":{\"166\":1}}],[\"但过高的加载因子可能导致哈希表过度填充\",{\"1\":{\"696\":1}}],[\"但问题是一个\",{\"1\":{\"694\":1}}],[\"但hashmap的实际容量是32\",{\"1\":{\"689\":1}}],[\"但实际上已经发生了变化\",{\"1\":{\"845\":1}}],[\"但实际只用了50\",{\"1\":{\"680\":1}}],[\"但实际运行时间差别很大\",{\"1\":{\"316\":1}}],[\"但与其他vlan中的设备隔离\",{\"1\":{\"579\":1}}],[\"但通过vlan\",{\"1\":{\"579\":1}}],[\"但侧重点和应用场景略有不同\",{\"1\":{\"474\":1}}],[\"但需要重新填写新订单的其他信息\",{\"1\":{\"455\":1}}],[\"但需要高可靠性的网络通信场景\",{\"1\":{\"138\":1}}],[\"但将具体对象的创建延迟到子类中实现\",{\"1\":{\"432\":1}}],[\"但可以独立地变化\",{\"1\":{\"505\":1}}],[\"但可以通过\",{\"1\":{\"419\":1}}],[\"但可能会造成ip地址的浪费\",{\"1\":{\"222\":1}}],[\"但对于复杂的文法规则\",{\"1\":{\"396\":1}}],[\"但对于误码率较高的点对点链路\",{\"1\":{\"137\":1}}],[\"但根据不同的需求和应用场景\",{\"1\":{\"386\":1}}],[\"但之后由于某种原因\",{\"1\":{\"845\":1}}],[\"但之后发现撤销的部分是错误的\",{\"1\":{\"375\":1}}],[\"但之后在传输过程中\",{\"1\":{\"184\":1}}],[\"但也需要谨慎使用\",{\"1\":{\"355\":1}}],[\"但具体的处理对象在运行时才能确定时\",{\"1\":{\"351\":1}}],[\"但某些步骤的具体实现由子类决定\",{\"1\":{\"330\":1}}],[\"但在获取最终结果时\",{\"1\":{\"855\":1}}],[\"但在运行时找不到类的定义时抛出\",{\"1\":{\"793\":1}}],[\"但在\",{\"1\":{\"788\":1}}],[\"但在这个阶段结束\",{\"1\":{\"746\":1,\"750\":1}}],[\"但在维护顺序方面会带来额外的开销\",{\"1\":{\"715\":1}}],[\"但在单线程环境下具有较好的性能\",{\"1\":{\"706\":1}}],[\"但在信道负载较高时容易发生冲突\",{\"1\":{\"578\":1}}],[\"但在目的和使用方式上存在一些区别\",{\"1\":{\"452\":1}}],[\"但在简单情况下\",{\"1\":{\"451\":1}}],[\"但在实际开发中被广泛应用\",{\"1\":{\"430\":1}}],[\"但在某些情况下仍然是有用的设计模式\",{\"1\":{\"421\":1}}],[\"但在软件开发中与项目管理密切相关\",{\"1\":{\"375\":1}}],[\"但在使用时\",{\"1\":{\"373\":1}}],[\"但在输入数据大小\",{\"1\":{\"316\":1}}],[\"但在不同网络之间\",{\"1\":{\"191\":1}}],[\"但udp支持各种通信方式\",{\"1\":{\"301\":1}}],[\"但udp报文传输到网络层后\",{\"1\":{\"301\":1}}],[\"但网络中出现了拥塞\",{\"1\":{\"297\":1}}],[\"但分组在进入路由器后要先在输入队列中排队等待处理\",{\"1\":{\"263\":1}}],[\"但有呼叫建立\",{\"1\":{\"254\":1}}],[\"但它并不能保证原子性\",{\"1\":{\"829\":1}}],[\"但它并不能保证对象的唯一性\",{\"1\":{\"787\":1}}],[\"但它仅仅是一个计算哈希码的方法\",{\"1\":{\"787\":1}}],[\"但它提供了有序性和额外的方法来处理有序映射\",{\"1\":{\"705\":1}}],[\"但它们有着不同的作用和使用场景\",{\"1\":{\"834\":1}}],[\"但它们都是用于实现对象之间的解耦和通信\",{\"1\":{\"411\":1}}],[\"但它们提供了通信系统设计和理论分析的重要基础\",{\"1\":{\"240\":1}}],[\"但它带来的好处远远超过了这些额外的开销\",{\"1\":{\"385\":1}}],[\"但它与输入数据大小n\",{\"1\":{\"316\":1}}],[\"但它是建立在可靠的通信线路基础之上的\",{\"1\":{\"127\":1}}],[\"但不包括对象头\",{\"1\":{\"726\":1}}],[\"但不提供像\",{\"1\":{\"704\":1}}],[\"但不对备忘录对象的内容进行操作\",{\"1\":{\"377\":1}}],[\"但不同类型的订单\",{\"1\":{\"333\":1}}],[\"但不同的数据来源可能需要不同的数据解析和校验逻辑\",{\"1\":{\"333\":1}}],[\"但不拆分\",{\"1\":{\"301\":1}}],[\"但不完成后续的握手过程\",{\"1\":{\"285\":1}}],[\"但不能同时进行发送和接收\",{\"1\":{\"582\":1}}],[\"但不能同时进行\",{\"1\":{\"237\":1}}],[\"但不检查是否有差错\",{\"1\":{\"173\":1}}],[\"但双方在数据传输速率上是同步的\",{\"1\":{\"235\":1}}],[\"但因为网桥只有两个端口\",{\"1\":{\"171\":1}}],[\"但为了提高网络的可靠性\",{\"1\":{\"162\":1}}],[\"但为什么等待了difs时间后还要退避一段随机时间呢\",{\"1\":{\"152\":1}}],[\"但如果令牌丢失或损坏\",{\"1\":{\"153\":1}}],[\"但代理服务器中仍然有缓存\",{\"1\":{\"114\":1}}],[\"但代理服务器中仍然保留了旧版本的缓存\",{\"1\":{\"114\":1}}],[\"但是风险也比较大\",{\"1\":{\"864\":1}}],[\"但是为什么要有cyclicbarrier\",{\"1\":{\"852\":1}}],[\"但是可以设置超时时间\",{\"1\":{\"851\":1}}],[\"但是可以反推\",{\"1\":{\"596\":1}}],[\"但是各自又不释放自身的资源\",{\"1\":{\"848\":1}}],[\"但是jdk6开始\",{\"1\":{\"843\":1}}],[\"但是公平锁会判断等待队列是否有线程处于等待状态\",{\"1\":{\"840\":1}}],[\"但是mark\",{\"1\":{\"837\":1}}],[\"但是否偏向锁那一位改成1\",{\"1\":{\"837\":1}}],[\"但是被检测到不可能存在共享数据竞争的锁进行消除\",{\"1\":{\"837\":1}}],[\"但是互斥同步是一种\",{\"1\":{\"831\":1}}],[\"但是因为多线程进行交错执行\",{\"1\":{\"829\":1}}],[\"但是因特网上的计算机并不是使用统一的操作系统\",{\"1\":{\"279\":1}}],[\"但是我b已经进行了自增\",{\"1\":{\"829\":1}}],[\"但是经过了编译器的指令重排序\",{\"1\":{\"826\":1}}],[\"但是后续两者就没啥关系了\",{\"1\":{\"822\":1}}],[\"但是结构还是和hashmap比较类似的\",{\"1\":{\"819\":1}}],[\"但是并发时有可能会发生指令重排\",{\"1\":{\"825\":1}}],[\"但是并发上不来\",{\"1\":{\"817\":1}}],[\"但是并不知道网络的中发生了什么\",{\"1\":{\"296\":1}}],[\"但是到这里我们并没有原来请求的rpc报文\",{\"1\":{\"817\":1}}],[\"但是dao层需要\",{\"1\":{\"817\":1}}],[\"但是线程调度器可以无条件忽略这个暗示\",{\"1\":{\"807\":1}}],[\"但是线程a所拥有的监视器资源\",{\"1\":{\"807\":1}}],[\"但是一个时间段内\",{\"1\":{\"805\":1}}],[\"但是一重传就会导致网络的负担更重\",{\"1\":{\"296\":1}}],[\"但是会执行\",{\"1\":{\"795\":1}}],[\"但是会自动隐藏\",{\"1\":{\"8\":1,\"34\":1}}],[\"但是用处不同\",{\"1\":{\"790\":1}}],[\"但是stringbuffer的所有方法都是synchronized修饰的同步方法\",{\"1\":{\"789\":1}}],[\"但是没有提供\",{\"1\":{\"789\":1}}],[\"但是equals却不相等\",{\"1\":{\"787\":1}}],[\"但是姓名却不同\",{\"1\":{\"787\":1}}],[\"但是接口可以继承多个接口\",{\"1\":{\"783\":1}}],[\"但是只能继承一个\",{\"1\":{\"783\":1}}],[\"但是只要它的思想和理念和某个设计模式相同\",{\"1\":{\"458\":1}}],[\"但是方法的参数列表必须不同\",{\"1\":{\"780\":1}}],[\"但是无法被回收\",{\"1\":{\"768\":1}}],[\"但是无论从什么角度看\",{\"1\":{\"722\":1}}],[\"但是他还保存了新生代和老年代的概念\",{\"1\":{\"749\":1}}],[\"但是老王不能在上坡或者下坡休息\",{\"1\":{\"747\":1}}],[\"但是如果读到内存后\",{\"1\":{\"853\":1}}],[\"但是如果没有抓住这个机会\",{\"1\":{\"736\":1}}],[\"但是如果线多了呢\",{\"1\":{\"573\":1}}],[\"但是它的版本号已经变了\",{\"1\":{\"845\":1}}],[\"但是它的强度比软引用更弱一些\",{\"1\":{\"735\":1}}],[\"但是它对域名系统非常重要\",{\"1\":{\"71\":1}}],[\"但是在使用的时候\",{\"1\":{\"797\":1}}],[\"但是在解决哈希冲突时\",{\"1\":{\"706\":1}}],[\"但是在用户提交订单时\",{\"1\":{\"344\":1}}],[\"但是需要注意的是treemap它还实现了navigablemap接口和sortedmap\",{\"1\":{\"705\":1}}],[\"但是新的问题来了\",{\"1\":{\"694\":1}}],[\"但是值可以重复\",{\"1\":{\"687\":1}}],[\"但是实现这就要保证\",{\"1\":{\"577\":1}}],[\"但是实际传输还是通过信号传输\",{\"1\":{\"238\":1}}],[\"但是使用时会进行动态的选择\",{\"1\":{\"573\":1}}],[\"但是这些数据又可以在单独的线程当中计算\",{\"1\":{\"831\":1}}],[\"但是这个对象的引用却是在堆栈中分配\",{\"1\":{\"724\":1}}],[\"但是这个还是通过组合的方式实现的\",{\"1\":{\"368\":1}}],[\"但是这里就有问题\",{\"1\":{\"573\":1}}],[\"但是内部实现确实调用新的支付接口\",{\"1\":{\"510\":1}}],[\"但是假如我们要给每一个inputstream的的子类做增强呢\",{\"1\":{\"500\":1}}],[\"但是也要结合具体的业务\",{\"1\":{\"462\":1}}],[\"但是大部分货的信息都一样\",{\"1\":{\"455\":1}}],[\"但是状态如果变多了呢\",{\"1\":{\"360\":1}}],[\"但是不保证不会指令重排\",{\"1\":{\"836\":1}}],[\"但是不同版本的类库中某一个类的全路径名可能是一样的\",{\"1\":{\"760\":1}}],[\"但是不同的应用程序可能会依赖同一个第三方类库的不同版本\",{\"1\":{\"760\":1}}],[\"但是不是统计具体的算法运行时间和使用空间\",{\"1\":{\"313\":1}}],[\"但是不可靠\",{\"1\":{\"275\":1}}],[\"但是nat构建的局域网不能充当服务器\",{\"1\":{\"223\":1}}],[\"但是仅仅有ip地址是不够的\",{\"1\":{\"196\":1}}],[\"但是由于不知道c的mac地址\",{\"1\":{\"168\":1,\"583\":1}}],[\"但是发现此时信道正忙时就会退避一段时间\",{\"1\":{\"152\":1}}],[\"但是还没有解决数据正确传输的两方面问题\",{\"1\":{\"133\":1}}],[\"但是代理服务器中仍然有缓存\",{\"1\":{\"114\":1}}],[\"但是\",{\"1\":{\"111\":1,\"690\":1,\"707\":1,\"713\":1,\"760\":2,\"775\":1,\"829\":1,\"837\":1}}],[\"此值是用来初始化线程池中核心线程数\",{\"1\":{\"860\":1}}],[\"此后当发生\",{\"1\":{\"742\":1}}],[\"此后每过一个码元的时间就进行检测\",{\"1\":{\"238\":1}}],[\"此示例代码演示了责任链设计模式的基本实现方式\",{\"1\":{\"353\":1}}],[\"此算法的时间复杂度被称为\",{\"1\":{\"316\":1}}],[\"此时计数器\",{\"1\":{\"835\":1}}],[\"此时会释放\",{\"1\":{\"835\":1}}],[\"此时其他线程内的变量副本刷新\",{\"1\":{\"829\":1}}],[\"此时就会线性向后查找\",{\"1\":{\"820\":1}}],[\"此时就需要由网络层解决\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"此时调用在内存中还不存在的非静态成员\",{\"1\":{\"778\":1}}],[\"此时必须立即触发一次\",{\"1\":{\"739\":1}}],[\"此时老年代就是没有足够的内存空间存放这些对象了\",{\"1\":{\"739\":1}}],[\"此时读操作在原数组上\",{\"1\":{\"682\":1}}],[\"此时发送窗口的值是swnd\",{\"1\":{\"297\":1}}],[\"此时接收方返回的确认号为4\",{\"1\":{\"290\":1}}],[\"此时\",{\"1\":{\"170\":1,\"852\":1}}],[\"此时缓存空间又满了\",{\"1\":{\"142\":1,\"576\":1}}],[\"此时代理服务器会使用它本地的缓存\",{\"1\":{\"114\":2}}],[\"此外\",{\"1\":{\"113\":1,\"729\":1,\"827\":1}}],[\"此处选中是7\",{\"1\":{\"13\":1,\"39\":1}}],[\"此处选中是5\",{\"1\":{\"10\":1,\"36\":1}}],[\"此处选中是nginx1\",{\"1\":{\"7\":1,\"33\":1}}],[\"技术部门也有自己的vlan\",{\"1\":{\"579\":1}}],[\"技术部门vlan\",{\"1\":{\"579\":1}}],[\"技术\",{\"1\":{\"113\":2}}],[\"存活下来的对象会被移动到这两个survivor区域之一\",{\"1\":{\"737\":1}}],[\"存放在堆\",{\"1\":{\"775\":1}}],[\"存放在堆上\",{\"1\":{\"723\":1}}],[\"存放xml\",{\"1\":{\"539\":1}}],[\"存放静态资源\",{\"1\":{\"539\":1}}],[\"存放java源代码\",{\"1\":{\"539\":1}}],[\"存放jdk\",{\"1\":{\"18\":1,\"44\":1}}],[\"存储entry类型的元素\",{\"1\":{\"819\":1}}],[\"存储数据\",{\"1\":{\"724\":1}}],[\"存储数据null\",{\"1\":{\"706\":1}}],[\"存储了编译时期生成的字面量常量\",{\"1\":{\"722\":1}}],[\"存储顺序\",{\"1\":{\"705\":2}}],[\"存储唯一的元素集合\",{\"1\":{\"704\":1}}],[\"存储键值对\",{\"1\":{\"704\":1}}],[\"存储方式\",{\"1\":{\"775\":1}}],[\"存储方式不同\",{\"1\":{\"773\":1}}],[\"存储方式和特性\",{\"1\":{\"704\":1}}],[\"存储方式是键值对存储\",{\"1\":{\"685\":1}}],[\"存储的元素不可重复的\",{\"1\":{\"671\":1}}],[\"存储的元素是有序的\",{\"1\":{\"671\":2}}],[\"存储不同前缀对应的具体工厂对象\",{\"1\":{\"443\":1}}],[\"存储所有景点\",{\"1\":{\"372\":1}}],[\"存储效率高\",{\"1\":{\"312\":1}}],[\"存储\",{\"1\":{\"268\":1,\"671\":1}}],[\"存储转发\",{\"1\":{\"173\":1}}],[\"存储用户信息\",{\"1\":{\"109\":1}}],[\"存在比较明显的缺陷\",{\"1\":{\"790\":1}}],[\"存在空间的浪费\",{\"1\":{\"744\":1}}],[\"存在两种情况\",{\"1\":{\"712\":1}}],[\"存在一个具体的工厂类\",{\"1\":{\"430\":1}}],[\"存在一个消息总线或事件系统作为中介\",{\"1\":{\"326\":1}}],[\"存在\",{\"1\":{\"209\":1}}],[\"存在问题\",{\"0\":{\"209\":1}}],[\"存在隐蔽站的问题\",{\"1\":{\"152\":1}}],[\"存在的问题\",{\"1\":{\"137\":1}}],[\"状态变为未支付\",{\"1\":{\"845\":1}}],[\"状态变量\",{\"1\":{\"839\":1}}],[\"状态下\",{\"1\":{\"765\":1}}],[\"状态过多会导致什么问题\",{\"0\":{\"649\":1}}],[\"状态码有哪些\",{\"0\":{\"559\":1}}],[\"状态码+短语\",{\"1\":{\"107\":1}}],[\"状态的转换可能较为复杂\",{\"1\":{\"361\":1}}],[\"状态之间的切换变得灵活可控\",{\"1\":{\"361\":1}}],[\"状态切换更加灵活\",{\"1\":{\"361\":1}}],[\"状态模式\",{\"1\":{\"490\":1}}],[\"状态模式会增加类的数量\",{\"1\":{\"361\":1}}],[\"状态模式为处理具有不同状态的对象提供了一种优雅的解决方案\",{\"1\":{\"361\":1}}],[\"状态模式可以让每个状态类只包含特定状态下的逻辑\",{\"1\":{\"361\":1}}],[\"状态模式可以将不同状态的行为拆分成独立的类\",{\"1\":{\"360\":1}}],[\"状态模式能够将每个状态的处理逻辑独立起来\",{\"1\":{\"361\":1}}],[\"状态模式让我们将每种状态的处理逻辑封装在独立的类中\",{\"1\":{\"361\":1}}],[\"状态模式的关键在于将对象的状态封装成独立的类\",{\"1\":{\"357\":1}}],[\"状态\",{\"1\":{\"359\":2,\"808\":1}}],[\"状态设计模式在一些需要根据状态改变行为的场景中是很有用的设计模式\",{\"1\":{\"361\":1}}],[\"状态设计模式通过将对象的状态封装成独立的类\",{\"1\":{\"361\":1}}],[\"状态设计模式适用于以下场景\",{\"1\":{\"360\":1}}],[\"状态设计模式由以下几个要素组成\",{\"1\":{\"359\":1}}],[\"状态设计模式的核心思想是将对象的状态抽象成独立的类\",{\"1\":{\"358\":1}}],[\"状态设计模式\",{\"0\":{\"356\":1},\"1\":{\"357\":1}}],[\"状态行\",{\"1\":{\"107\":1}}],[\"响应头部和响应主体\",{\"1\":{\"107\":1}}],[\"响应报文\",{\"1\":{\"107\":1}}],[\"即多个线程的哈希码映射到同一个计数器\",{\"1\":{\"855\":1}}],[\"即多个键可以对应相同的值\",{\"1\":{\"687\":1}}],[\"即同一时间只有一个线程可以修改\",{\"1\":{\"844\":1}}],[\"即线程变量\",{\"1\":{\"811\":1}}],[\"即本文中的案例\",{\"1\":{\"768\":1}}],[\"即本征vlan\",{\"1\":{\"159\":1}}],[\"即从根节点出发还没有遍历到的对象\",{\"1\":{\"748\":1}}],[\"即该类的classloader没有存在的必要\",{\"1\":{\"733\":1}}],[\"即没有任何代码通过反射调用该类的方法或访问其字段\",{\"1\":{\"733\":1}}],[\"即没有任何对象是该类的实例\",{\"1\":{\"733\":1}}],[\"即根据构造器的实际内容为对象的成员变量赋值\",{\"1\":{\"726\":1}}],[\"即对象可能被添加或删除引用\",{\"1\":{\"748\":1}}],[\"即对象代表哪个类\",{\"1\":{\"729\":1}}],[\"即对象的成员变量在此阶段都为默认值\",{\"1\":{\"726\":1}}],[\"即对扩展开放\",{\"1\":{\"500\":1}}],[\"即int\",{\"1\":{\"724\":1}}],[\"即相同内容的字符串在常量池中只有一份拷贝\",{\"1\":{\"722\":1}}],[\"即相同的\",{\"1\":{\"687\":1}}],[\"即将暂时获取不到锁的线程加入到队列中\",{\"1\":{\"846\":1}}],[\"即将关闭时注册的关闭钩子\",{\"1\":{\"721\":1}}],[\"即将复杂的网络处理功能放在网络边缘\",{\"1\":{\"184\":1}}],[\"即时编译器编译后的代码缓存等数据\",{\"1\":{\"722\":1}}],[\"即时编译\",{\"1\":{\"720\":1}}],[\"即扩容时的阈值\",{\"1\":{\"715\":1}}],[\"即扩容因子\",{\"1\":{\"696\":1}}],[\"即键值对\",{\"1\":{\"714\":1}}],[\"即键和值都可以为\",{\"1\":{\"706\":1}}],[\"即迭代器快速失败\",{\"1\":{\"710\":1}}],[\"即采样速率应大于信号带宽的两倍\",{\"1\":{\"622\":1}}],[\"即设备能够在同一时间内进行双向通信\",{\"1\":{\"582\":1}}],[\"即可\",{\"1\":{\"538\":1,\"789\":1}}],[\"即可以是一对一\",{\"1\":{\"301\":1}}],[\"即原始对象并没有发生改变\",{\"1\":{\"502\":1}}],[\"即被装饰的原始对象\",{\"1\":{\"501\":1}}],[\"即增加缓存功能\",{\"1\":{\"500\":1}}],[\"即一个类应该只有一个引起它变化的原因\",{\"1\":{\"474\":1}}],[\"即一次发一个完整报文\",{\"1\":{\"301\":1}}],[\"即分别输出\",{\"1\":{\"469\":1}}],[\"即基于多个终结符条件的组合条件\",{\"1\":{\"393\":1}}],[\"即用户输入的条件\",{\"1\":{\"393\":1}}],[\"即用洪泛法对全网更新链路状态\",{\"1\":{\"210\":1}}],[\"即包含其他表达式的表达式\",{\"1\":{\"390\":1}}],[\"即不再包含其他表达式的表达式\",{\"1\":{\"390\":1}}],[\"即具体元素\",{\"1\":{\"372\":1}}],[\"即模板方法\",{\"1\":{\"331\":1}}],[\"即复用分用和差错检测功能\",{\"1\":{\"301\":1}}],[\"即等于新的ssthresh+3\",{\"1\":{\"299\":1}}],[\"即发送方窗口大小仍然为0\",{\"1\":{\"294\":1}}],[\"即nsap\",{\"1\":{\"277\":1}}],[\"即端口号\",{\"1\":{\"279\":1}}],[\"即端口vlan\",{\"1\":{\"159\":1}}],[\"即端到端是指在用户看来两端的连接是直接进行的\",{\"1\":{\"275\":1}}],[\"即端到端是指网络通信的双方不是在同一链路上\",{\"1\":{\"275\":1}}],[\"即使它们在逻辑上是相等的\",{\"1\":{\"788\":1}}],[\"即使它们的内容相同\",{\"1\":{\"787\":1}}],[\"即使两个对象的哈希码相同\",{\"1\":{\"787\":1}}],[\"即使创建多个对象\",{\"1\":{\"776\":1}}],[\"即使不设置也有默认大小\",{\"1\":{\"725\":1}}],[\"即使\",{\"1\":{\"579\":1}}],[\"即使这些子网络可能跨越不同的物理位置\",{\"1\":{\"579\":1}}],[\"即使订单类中使用的是旧的支付接口对象\",{\"1\":{\"510\":1}}],[\"即使收到了失序的报文段\",{\"1\":{\"299\":1}}],[\"即使数据包乱序到达\",{\"1\":{\"291\":1}}],[\"即使出错也只需要重传出错的这一小部分即可\",{\"1\":{\"254\":1}}],[\"即使能够在硬件上实现无线局域网的碰撞检测功能\",{\"1\":{\"152\":1}}],[\"即因特网服务的提供者\",{\"1\":{\"249\":1}}],[\"即互联网\",{\"1\":{\"247\":1}}],[\"即半个码元的时间\",{\"1\":{\"238\":1}}],[\"即信号\",{\"1\":{\"238\":1}}],[\"即指每个字符之间是异步的\",{\"1\":{\"235\":1}}],[\"即光源作为信号源\",{\"1\":{\"230\":1}}],[\"即在执行增加操作时\",{\"1\":{\"844\":1}}],[\"即在加载web应用程序的类时\",{\"1\":{\"759\":1}}],[\"即在迭代器遍历过程中进行了集合的结构性修改\",{\"1\":{\"710\":1}}],[\"即在ipv4地址后面加上斜线\",{\"1\":{\"220\":1}}],[\"即在发送帧之前先对传输媒体进行载波监听\",{\"1\":{\"152\":1}}],[\"即构建各自的路由表\",{\"1\":{\"210\":1}}],[\"即\",{\"1\":{\"209\":2,\"316\":1,\"469\":1,\"709\":1}}],[\"即路由器应该丢弃的路由\",{\"1\":{\"205\":1}}],[\"即向它所有接口\",{\"1\":{\"205\":1}}],[\"即物理地址\",{\"1\":{\"196\":1}}],[\"即网络层地址\",{\"1\":{\"196\":1}}],[\"即地址解析\",{\"1\":{\"168\":1,\"583\":1}}],[\"即插入4字节vlan标记字段\",{\"1\":{\"159\":2}}],[\"即较高的数据传输速率\",{\"1\":{\"156\":1}}],[\"即512比特\",{\"1\":{\"152\":1}}],[\"即冲突\",{\"1\":{\"152\":1}}],[\"即编号0和1\",{\"1\":{\"137\":1}}],[\"即数据链路建立\",{\"1\":{\"125\":1}}],[\"即浏览器在收到http的响应报文之前就能够连续发送多个请求报文\",{\"1\":{\"112\":1}}],[\"即万维网进程\",{\"1\":{\"106\":1}}],[\"即应用服务集在网络中比客户计算机少得多的服务器计算机上由于一台服务器计算机要为多个客户机提供服务\",{\"1\":{\"58\":1}}],[\"颜色\",{\"1\":{\"104\":1}}],[\"文析结果中查找存在大量的对象\",{\"1\":{\"769\":1}}],[\"文字或者其他东西\",{\"1\":{\"797\":1}}],[\"文字排列顺序布局\",{\"1\":{\"539\":1}}],[\"文字编辑器中的字符对象\",{\"1\":{\"532\":1}}],[\"文本资源组共有方法\",{\"1\":{\"443\":1}}],[\"文本编辑器\",{\"1\":{\"378\":1}}],[\"文本状态\",{\"1\":{\"378\":1}}],[\"文章页\",{\"1\":{\"372\":3}}],[\"文档审查等流程可能需要多个审批者按顺序审批\",{\"1\":{\"355\":1}}],[\"文档\",{\"1\":{\"104\":1}}],[\"文件句柄等\",{\"1\":{\"804\":1}}],[\"文件较大的话\",{\"1\":{\"769\":1}}],[\"文件分析\",{\"1\":{\"769\":1}}],[\"文件进行离线分析\",{\"1\":{\"766\":1}}],[\"文件格式验证\",{\"1\":{\"754\":1}}],[\"文件类\",{\"1\":{\"525\":1}}],[\"文件和文件夹都实现了filesystemcomponent接口\",{\"1\":{\"525\":1}}],[\"文件夹类\",{\"1\":{\"525\":1}}],[\"文件夹\",{\"1\":{\"525\":10}}],[\"文件中\",{\"1\":{\"498\":1}}],[\"文件的规范\",{\"1\":{\"754\":1}}],[\"文件的字节流中的信息不回危害到虚拟机\",{\"1\":{\"754\":1}}],[\"文件的数据会通过数据连接传输\",{\"1\":{\"86\":1}}],[\"文件的上传\",{\"1\":{\"83\":1}}],[\"文件管理\",{\"1\":{\"83\":1}}],[\"文件上传和下载\",{\"1\":{\"83\":1}}],[\"文件传输完成后\",{\"1\":{\"86\":1}}],[\"文件传输协议ftp\",{\"0\":{\"82\":1}}],[\"文件传输\",{\"1\":{\"54\":1,\"56\":1}}],[\"文件\",{\"1\":{\"19\":1,\"45\":1,\"75\":1,\"355\":1,\"525\":17,\"760\":1,\"769\":4}}],[\"联机式的信息储藏所\",{\"1\":{\"103\":1}}],[\"万维网缓冲与代理服务器\",{\"0\":{\"114\":1}}],[\"万维网服务器在发送响应后仍然保持这条连接\",{\"1\":{\"112\":1}}],[\"万维网服务器怎样把万维网文档传送给浏览器\",{\"1\":{\"106\":1}}],[\"万维网组成\",{\"1\":{\"104\":1}}],[\"万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网\",{\"1\":{\"103\":1}}],[\"万维网并非某种特殊的计算机网络\",{\"1\":{\"103\":1}}],[\"万维网\",{\"0\":{\"101\":1},\"1\":{\"103\":1}}],[\"总共有六个窗口\",{\"1\":{\"868\":1}}],[\"总共8个字节\",{\"1\":{\"131\":1}}],[\"总不能为了某个玩家等到天荒地老\",{\"1\":{\"851\":1}}],[\"总容量触及最大堆的容量限制后就会产生oom\",{\"1\":{\"731\":1}}],[\"总是使用\",{\"1\":{\"706\":1}}],[\"总而言之\",{\"1\":{\"482\":1,\"512\":1}}],[\"总之\",{\"1\":{\"361\":1,\"461\":1,\"470\":1,\"474\":1}}],[\"总体来说\",{\"1\":{\"580\":1,\"595\":1,\"714\":1,\"804\":1,\"834\":1}}],[\"总体而言\",{\"1\":{\"339\":1,\"355\":1,\"361\":1,\"421\":1,\"430\":1,\"519\":1,\"533\":1}}],[\"总体式路由算法\",{\"1\":{\"206\":1}}],[\"总操作数量等于外层循环和内层循环操作数量之积\",{\"1\":{\"316\":1}}],[\"总时延\",{\"1\":{\"263\":1}}],[\"总线型\",{\"1\":{\"121\":1}}],[\"总结一下\",{\"1\":{\"452\":1}}],[\"总结就是取消了物理的分代\",{\"1\":{\"749\":1}}],[\"总结就是\",{\"1\":{\"430\":1,\"437\":1,\"444\":1}}],[\"总结起来\",{\"1\":{\"114\":1,\"477\":1,\"502\":1,\"510\":1}}],[\"总结\",{\"0\":{\"100\":1,\"328\":1,\"339\":1,\"345\":1,\"355\":1,\"361\":1,\"367\":1,\"373\":1,\"379\":1,\"385\":1,\"396\":1,\"410\":1,\"421\":1,\"430\":1,\"437\":1,\"444\":1,\"451\":1,\"462\":1,\"466\":1,\"470\":1,\"474\":1,\"478\":1,\"482\":1,\"486\":1,\"490\":1,\"512\":1,\"519\":1,\"526\":1,\"533\":1},\"1\":{\"137\":1,\"138\":1,\"139\":1,\"227\":1,\"238\":1,\"299\":1,\"316\":1,\"320\":1,\"367\":1,\"396\":1,\"410\":1,\"422\":1,\"789\":1}}],[\"总的来说\",{\"1\":{\"56\":1,\"87\":1,\"96\":1,\"240\":1,\"280\":1,\"294\":1,\"296\":1,\"328\":1,\"345\":1,\"437\":1,\"451\":1,\"526\":1,\"584\":1,\"593\":1,\"696\":1,\"759\":1,\"787\":1,\"788\":2,\"797\":1,\"800\":1,\"816\":1}}],[\"阅读和管理电子邮件\",{\"1\":{\"99\":1}}],[\"收集器设置\",{\"1\":{\"764\":1}}],[\"收集器是一种主打的就是并发和减少回收停顿时间为目标的收集器\",{\"1\":{\"746\":1}}],[\"收集器会有这种行为\",{\"1\":{\"738\":1}}],[\"收集器会有单独收集老年代的行为\",{\"1\":{\"738\":1}}],[\"收集整个\",{\"1\":{\"738\":1}}],[\"收集程序运行的信息\",{\"1\":{\"720\":1}}],[\"收到的数据包会广播给所有端口\",{\"1\":{\"580\":1}}],[\"收到发布订阅的消息\",{\"1\":{\"326\":2}}],[\"收到消息\",{\"1\":{\"325\":1,\"403\":1,\"408\":1}}],[\"收到链路状态更新分组后\",{\"1\":{\"210\":1}}],[\"收到数据库描述分组后\",{\"1\":{\"210\":1}}],[\"收到此报文的主机必须给源主机或路由器发送icmp回送回答报文\",{\"1\":{\"201\":1}}],[\"收到帧后进行登记\",{\"1\":{\"174\":1}}],[\"收到帧后会广播到除本身接口外的各个接口\",{\"1\":{\"170\":1}}],[\"收发不能同时进行\",{\"1\":{\"170\":1}}],[\"收发双方相同层次中的实体\",{\"1\":{\"250\":1}}],[\"收发双方维持收发窗口n\",{\"1\":{\"142\":1,\"576\":1}}],[\"收发双方\",{\"1\":{\"135\":1,\"576\":1}}],[\"收发\",{\"1\":{\"99\":1}}],[\"收件人确认\",{\"1\":{\"94\":1}}],[\"浏览器访问\",{\"1\":{\"769\":1}}],[\"浏览器通常会建立多个并行的tcp连接同时请求多个对象\",{\"1\":{\"111\":1}}],[\"浏览器显示\",{\"1\":{\"108\":1}}],[\"浏览器发出取文件命令\",{\"1\":{\"108\":1}}],[\"浏览器与服务器建立tcp连接\",{\"1\":{\"108\":1}}],[\"浏览器向dns请求解析ip地址\",{\"1\":{\"108\":1}}],[\"浏览器分析url\",{\"1\":{\"108\":1}}],[\"浏览器\",{\"1\":{\"99\":1,\"106\":1,\"112\":1}}],[\"浏览器首先会在自己的缓存中查找是否有该域名对应的\",{\"1\":{\"74\":1}}],[\"不行你看改一天\",{\"1\":{\"868\":1}}],[\"不设置的话\",{\"1\":{\"862\":1}}],[\"不剥夺条件\",{\"1\":{\"848\":1}}],[\"不擅技术\",{\"1\":{\"822\":1}}],[\"不一定要在类或接口中定义\",{\"1\":{\"797\":1}}],[\"不一致\",{\"1\":{\"710\":1}}],[\"不支持的操作错误比如重复创建同一用户\",{\"1\":{\"793\":1}}],[\"不支持快速的随机访问\",{\"1\":{\"312\":1}}],[\"不适合用于复合操作\",{\"1\":{\"834\":1}}],[\"不适合在多线程环境下使用\",{\"1\":{\"789\":1}}],[\"不适用于大网络\",{\"1\":{\"205\":1}}],[\"不提供确切的对象比较\",{\"1\":{\"787\":1}}],[\"不提供线程安全性\",{\"1\":{\"706\":1}}],[\"不提供线程同步\",{\"1\":{\"706\":1}}],[\"不增加或增加缓慢\",{\"1\":{\"769\":1}}],[\"不应再为了少量的跨代引用去扫描整个老年代\",{\"1\":{\"742\":1}}],[\"不得不在固定的\",{\"1\":{\"742\":1}}],[\"不再需要把线程阻塞挂起\",{\"1\":{\"831\":1}}],[\"不再委托给父类加载器\",{\"1\":{\"759\":1}}],[\"不再严格遵循传统的双亲委派模型\",{\"1\":{\"759\":1}}],[\"不再受固定大小的永久代限制\",{\"1\":{\"723\":1}}],[\"不再是拘于物理层和数据链路层的局域网了\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"不受检查异常\",{\"1\":{\"793\":1}}],[\"不受其他web应用程序的影响\",{\"1\":{\"759\":1}}],[\"不受其他不相关接口的影响\",{\"1\":{\"473\":1}}],[\"不受添加顺序或者访问顺序影响\",{\"1\":{\"715\":1}}],[\"不仅保证了可见性\",{\"1\":{\"834\":1}}],[\"不仅保存了键值对信息\",{\"1\":{\"714\":1}}],[\"不仅复制对象本身\",{\"1\":{\"455\":1}}],[\"不存在就再插入链表\",{\"1\":{\"711\":1}}],[\"不存在失序问题\",{\"1\":{\"253\":1}}],[\"不保证元素的顺序\",{\"1\":{\"705\":1,\"706\":1}}],[\"不允许键或值为\",{\"1\":{\"706\":1}}],[\"不允许\",{\"1\":{\"705\":1}}],[\"不允许重复\",{\"1\":{\"687\":1,\"704\":1}}],[\"不允许用户在邮件服务器上进行邮件管理\",{\"1\":{\"97\":1}}],[\"不相等\",{\"1\":{\"788\":2}}],[\"不相同就通过拉链法解决冲突\",{\"1\":{\"686\":1}}],[\"不相交\",{\"1\":{\"152\":1}}],[\"不推荐使用\",{\"1\":{\"706\":1}}],[\"不推荐\",{\"1\":{\"681\":1}}],[\"不进行调制可能导致数据传输过程中的信号衰减\",{\"1\":{\"619\":1}}],[\"不进行碰撞检测\",{\"1\":{\"170\":1}}],[\"不具备数据过滤能力\",{\"1\":{\"580\":1}}],[\"不知道目的地\",{\"1\":{\"573\":1}}],[\"不然还是调用原方法\",{\"1\":{\"497\":1,\"498\":1}}],[\"不会被其他线程中断或者同时执行其他操作\",{\"1\":{\"844\":1}}],[\"不会被其他线程中断或交错执行\",{\"1\":{\"829\":2}}],[\"不会发⽣互斥现象\",{\"1\":{\"833\":1}}],[\"不会产生不确定的结果或出现数据损坏等问题\",{\"1\":{\"814\":1}}],[\"不会释放锁\",{\"1\":{\"812\":1}}],[\"不会互相影响\",{\"1\":{\"759\":1}}],[\"不会出现竞态条件等问题\",{\"1\":{\"844\":1}}],[\"不会出现数据不一致的情况\",{\"1\":{\"713\":1}}],[\"不会出现争用物理通道的问题\",{\"1\":{\"253\":1}}],[\"不会影响\",{\"1\":{\"687\":1}}],[\"不会对数据内容进行修改或解释\",{\"1\":{\"577\":1}}],[\"不会对其他对象产生连锁影响\",{\"1\":{\"488\":1}}],[\"不依赖于具体子类的实现细节\",{\"1\":{\"469\":1}}],[\"不符合里氏替换原则的情况下\",{\"1\":{\"469\":2}}],[\"不要在\",{\"1\":{\"795\":1}}],[\"不要把异常定义为静态变量\",{\"1\":{\"793\":1}}],[\"不要违背其他设计原则或增加不必要的复杂性\",{\"1\":{\"488\":1}}],[\"不要花里胡哨\",{\"1\":{\"480\":1}}],[\"不要过度设计和增加复杂性\",{\"1\":{\"480\":1}}],[\"不要设计大而全的类\",{\"1\":{\"462\":1}}],[\"不要使用集合的其他修改方法\",{\"1\":{\"367\":1}}],[\"不涉及到对象类\",{\"1\":{\"813\":1}}],[\"不涉及与电子邮件发送相关的代码\",{\"1\":{\"461\":1}}],[\"不涉及实际的交互或外部依赖\",{\"1\":{\"408\":1}}],[\"不可中断锁\",{\"1\":{\"841\":1}}],[\"不可中断的\",{\"1\":{\"825\":1}}],[\"不可达才会被回收\",{\"1\":{\"735\":1}}],[\"不可以通过索引进行访问\",{\"1\":{\"678\":1}}],[\"不可重复性是指添加的元素按照\",{\"1\":{\"672\":1}}],[\"不可重复的\",{\"1\":{\"671\":1}}],[\"不可变对象还可以更容易地进行缓存\",{\"1\":{\"450\":1}}],[\"不可靠传输服务\",{\"1\":{\"136\":1}}],[\"不将创建资源的过程耦合到此处代码\",{\"1\":{\"429\":1}}],[\"不合法\",{\"1\":{\"422\":1}}],[\"不难发现\",{\"1\":{\"419\":1}}],[\"不在购物车中\",{\"1\":{\"384\":1}}],[\"不影响originator对象的封装性\",{\"1\":{\"379\":1}}],[\"不只是http请求\",{\"1\":{\"348\":1}}],[\"不就是多态吗\",{\"1\":{\"342\":1}}],[\"不利于代码的维护\",{\"1\":{\"339\":1}}],[\"不变的放在模板里\",{\"1\":{\"330\":1}}],[\"不包括伪首部\",{\"1\":{\"304\":1}}],[\"不向下传送也不向上递交\",{\"1\":{\"304\":1}}],[\"不做处理\",{\"1\":{\"301\":1}}],[\"不恰当的路由选择可能导致某些路径过于拥挤\",{\"1\":{\"296\":1}}],[\"不均衡的流量\",{\"1\":{\"296\":1}}],[\"不按序到达的数据\",{\"1\":{\"282\":1}}],[\"不重复\",{\"1\":{\"282\":1}}],[\"不丢失\",{\"1\":{\"282\":1}}],[\"不丢失和不重复\",{\"1\":{\"184\":1}}],[\"不管读锁是不是被当前线程持有\",{\"1\":{\"842\":1}}],[\"不管\",{\"1\":{\"833\":1}}],[\"不管怎么重排序\",{\"1\":{\"826\":1}}],[\"不管jvm的内存空间是否充足\",{\"1\":{\"818\":1}}],[\"不管是同步阻塞实现方式还是异步非阻塞实现方式\",{\"1\":{\"327\":1}}],[\"不管使用何种协议封装的报文\",{\"1\":{\"280\":1}}],[\"不管采用何种调制技术\",{\"1\":{\"240\":1}}],[\"不是原子操作\",{\"1\":{\"834\":1}}],[\"不是必须被捕获或抛出的\",{\"1\":{\"793\":1}}],[\"不是实际链路\",{\"1\":{\"282\":1}}],[\"不是点对点连接的\",{\"1\":{\"275\":1}}],[\"不是包含关系\",{\"1\":{\"162\":1}}],[\"不过其他三个条件都是有办法破坏掉的\",{\"1\":{\"848\":1}}],[\"不过\",{\"1\":{\"273\":1,\"327\":1,\"838\":1,\"868\":1}}],[\"不过对报文没有限制大小\",{\"1\":{\"255\":1}}],[\"不归零编码\",{\"1\":{\"238\":2}}],[\"不更新\",{\"1\":{\"208\":1}}],[\"不发送icmp的情况\",{\"1\":{\"200\":1}}],[\"不需要为每个请求创建一个新线程\",{\"1\":{\"858\":1}}],[\"不需要挂起线程\",{\"1\":{\"845\":1}}],[\"不需要一直等到获取锁之后\",{\"1\":{\"841\":1}}],[\"不需要手动加锁解锁\",{\"1\":{\"832\":1}}],[\"不需要通过对象实例来获取\",{\"1\":{\"816\":1}}],[\"不需要将\",{\"1\":{\"816\":1}}],[\"不需要添加abstract\",{\"1\":{\"783\":1}}],[\"不需要重新通过哈希函数计算位置\",{\"1\":{\"701\":1}}],[\"不需要了解和管理子系统的细节\",{\"1\":{\"518\":1}}],[\"不需要了解其他对象的具体实现细节\",{\"1\":{\"490\":1}}],[\"不需要直接依赖具体产品的创建过程\",{\"1\":{\"430\":1}}],[\"不需要修改原有代码\",{\"1\":{\"361\":1}}],[\"不需要持有下一个处理器的引用\",{\"1\":{\"350\":1}}],[\"不需要连续的内存空间\",{\"1\":{\"312\":1}}],[\"不需要事先建立专门的传输连接的\",{\"1\":{\"301\":1}}],[\"不需要单独的时钟信号\",{\"1\":{\"238\":1}}],[\"不需要提前建立连接\",{\"1\":{\"184\":1}}],[\"不需要建立专门的数据链路\",{\"1\":{\"126\":1,\"127\":1}}],[\"不像虚拟电路通信\",{\"1\":{\"184\":1}}],[\"不使用csma\",{\"1\":{\"173\":1}}],[\"不停地发送帧\",{\"1\":{\"170\":1}}],[\"不接入因特网\",{\"1\":{\"167\":1}}],[\"不用了\",{\"1\":{\"158\":1}}],[\"不用关心快递运送的路线\",{\"1\":{\"126\":1}}],[\"不能解决\",{\"1\":{\"847\":1}}],[\"不能保证操作的原子性\",{\"1\":{\"834\":1}}],[\"不能被继承\",{\"1\":{\"789\":1}}],[\"不能被修改且必须有初始值\",{\"1\":{\"783\":1}}],[\"不能通过new关键字进行实例化\",{\"1\":{\"783\":1}}],[\"不能回收\",{\"1\":{\"742\":1}}],[\"不能为\",{\"1\":{\"712\":1}}],[\"不能在多线程下发生并发修改\",{\"1\":{\"709\":1}}],[\"不能依赖于这个异常是否抛出而进行并发操作的编程\",{\"1\":{\"709\":1}}],[\"不能包含重复元素\",{\"1\":{\"704\":1}}],[\"不能是四次握手\",{\"0\":{\"639\":1}}],[\"不能误读\",{\"1\":{\"577\":1}}],[\"不能忽略网络上发生的事\",{\"1\":{\"296\":1}}],[\"不能仅靠网络实体地址\",{\"1\":{\"277\":1}}],[\"不能直接用私网ip地址访问\",{\"1\":{\"217\":1}}],[\"不能及时适应网络状态的变化\",{\"1\":{\"205\":1}}],[\"不能全链路\",{\"1\":{\"168\":1,\"583\":1}}],[\"不能使用碰撞检测cd\",{\"1\":{\"152\":1}}],[\"不能检查出误码\",{\"1\":{\"134\":1,\"576\":1}}],[\"不能传送其他非英语国家的文字\",{\"1\":{\"95\":1}}],[\"不同对象之间的数据是隔离的\",{\"1\":{\"816\":1}}],[\"不同对象实例间和不同线程间可以共享同一个\",{\"1\":{\"816\":1}}],[\"不同线程之间\",{\"1\":{\"811\":1}}],[\"不同于在共享变量上调用\",{\"1\":{\"807\":1}}],[\"不同点\",{\"1\":{\"773\":1,\"780\":1,\"843\":1}}],[\"不同\",{\"1\":{\"580\":1}}],[\"不同作用范围的单例\",{\"1\":{\"421\":1}}],[\"不同关卡的设计可能有一些相似的元素\",{\"1\":{\"333\":1}}],[\"不同数据来源对应的子类\",{\"1\":{\"333\":1}}],[\"不同速率的终端很难互相进行通信\",{\"1\":{\"253\":1}}],[\"不同规格\",{\"1\":{\"253\":1}}],[\"不同类型线程池的参数配置\",{\"1\":{\"866\":1}}],[\"不同类型的申请\",{\"1\":{\"333\":1}}],[\"不同类型\",{\"1\":{\"253\":1}}],[\"不同自治系统的bgp发言人要交换路由信息\",{\"1\":{\"212\":1}}],[\"不同下一跳\",{\"1\":{\"208\":3}}],[\"不同操作系统下的生命周期不同\",{\"1\":{\"168\":1,\"583\":1}}],[\"不同组的vlan之间通过将帧上附加相应的vlan标签进行通信\",{\"1\":{\"159\":1}}],[\"不同的线程更新不同的部分\",{\"1\":{\"855\":1}}],[\"不同的线程会被分配到不同的计数器上进行操作\",{\"1\":{\"855\":1}}],[\"不同的线程可能在不同的时间片获得\",{\"1\":{\"707\":1}}],[\"不同的核心有自己的缓存\",{\"1\":{\"828\":1}}],[\"不同的是\",{\"1\":{\"807\":1}}],[\"不同的是用户计算机无需安装专门的用户代理程序\",{\"1\":{\"99\":1}}],[\"不同的垃圾收集器对于minor\",{\"1\":{\"767\":1}}],[\"不同的数据链路层协议有不同的帧结构\",{\"1\":{\"575\":1}}],[\"不同的操作系统\",{\"1\":{\"279\":1}}],[\"不同的tsap标识不同的会话或应用进程\",{\"1\":{\"277\":1}}],[\"不同的通信双方拥有不同的信道\",{\"1\":{\"253\":1}}],[\"不同的介质具有不同的特性和传输速度\",{\"1\":{\"240\":1}}],[\"不同的补0\",{\"1\":{\"221\":1}}],[\"不同的子网\",{\"1\":{\"159\":1,\"580\":1}}],[\"不同的用户在同样的时间占用不同的带宽\",{\"1\":{\"147\":1}}],[\"不同节点之间通过介质\",{\"1\":{\"144\":1}}],[\"不同网络类型下不同\",{\"1\":{\"130\":1}}],[\"不同协议建立的数据链路\",{\"1\":{\"124\":1}}],[\"邮局协议3\",{\"1\":{\"97\":1}}],[\"邮件归类等\",{\"1\":{\"355\":1}}],[\"邮件内容格式标准化\",{\"1\":{\"96\":1}}],[\"邮件接收确认\",{\"1\":{\"94\":1}}],[\"邮件客户端\",{\"1\":{\"94\":1}}],[\"邮件发送\",{\"1\":{\"94\":1}}],[\"邮件发送协议\",{\"1\":{\"90\":1}}],[\"邮件读取协议\",{\"1\":{\"90\":1}}],[\"邮件服务器网站通常都提供非常强大和方便的邮件管理功能\",{\"1\":{\"99\":1}}],[\"邮件服务器万维网网站就可以撰写\",{\"1\":{\"99\":1}}],[\"邮件服务器之间的通信协议仍然为smtp\",{\"1\":{\"99\":1}}],[\"邮件服务器\",{\"1\":{\"90\":2,\"99\":1}}],[\"附件\",{\"1\":{\"96\":1}}],[\"俄文以及带有重音符号的法文或德文等\",{\"1\":{\"96\":1}}],[\"字体\",{\"1\":{\"532\":1}}],[\"字节单位\",{\"1\":{\"769\":1}}],[\"字节码验证\",{\"1\":{\"754\":1}}],[\"字节流传输使tcp更加灵活\",{\"1\":{\"282\":1}}],[\"字节之间没有间隔\",{\"1\":{\"236\":1}}],[\"字节间的时间间隔不是固定的\",{\"1\":{\"235\":1}}],[\"字节计数法\",{\"1\":{\"131\":2}}],[\"字段和方法\",{\"1\":{\"799\":1}}],[\"字段和一个公共的构造函数\",{\"1\":{\"422\":1}}],[\"字段中的vid取值与端口的pvid取值相等\",{\"1\":{\"159\":2}}],[\"字段\",{\"1\":{\"131\":6,\"251\":1,\"422\":1,\"436\":1}}],[\"字段的名称和描述符\",{\"1\":{\"722\":1}}],[\"字段的请求给原始服务器\",{\"1\":{\"114\":1}}],[\"字段的语义\",{\"1\":{\"56\":1}}],[\"字符串转换为数字格式错误\",{\"1\":{\"793\":1}}],[\"字符串拼接用\",{\"1\":{\"790\":2}}],[\"字符串拼接用+还是\",{\"0\":{\"790\":1}}],[\"字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池\",{\"1\":{\"792\":1}}],[\"字符串常量占若干个字节\",{\"1\":{\"777\":1}}],[\"字符串常量代表一个地址值\",{\"1\":{\"777\":1}}],[\"字符串常量是双引号引起的\",{\"1\":{\"777\":1}}],[\"字符串常量池是\",{\"1\":{\"722\":1}}],[\"字符串常量池是运行时常量池的一部分\",{\"1\":{\"722\":1}}],[\"字符串常量池\",{\"1\":{\"722\":2,\"723\":1}}],[\"字符常量只占\",{\"1\":{\"777\":1}}],[\"字符常量相当于一个整型值\",{\"1\":{\"777\":1}}],[\"字符常量是单引号引起的一个字符\",{\"1\":{\"777\":1}}],[\"字符型常量和字符串常量的区别\",{\"0\":{\"777\":1},\"1\":{\"777\":2}}],[\"字符的链路\",{\"1\":{\"132\":1}}],[\"字符填充的首尾定界符法\",{\"1\":{\"131\":2}}],[\"字符编码\",{\"1\":{\"96\":1}}],[\"图床图片\",{\"1\":{\"543\":1,\"544\":1,\"545\":1}}],[\"图标\",{\"1\":{\"539\":1}}],[\"图等\",{\"1\":{\"312\":1}}],[\"图\",{\"1\":{\"311\":1,\"312\":1}}],[\"图示右边为首部\",{\"1\":{\"268\":1}}],[\"图片资源组共有方法\",{\"1\":{\"443\":1}}],[\"图片\",{\"1\":{\"104\":1,\"238\":1}}],[\"图像等元素\",{\"1\":{\"104\":1}}],[\"图像等\",{\"1\":{\"96\":1}}],[\"图像\",{\"1\":{\"96\":1,\"577\":1}}],[\"图例\",{\"1\":{\"0\":1,\"71\":1,\"72\":2,\"86\":1,\"99\":1,\"107\":2,\"110\":1,\"243\":1,\"245\":1,\"249\":1,\"250\":2,\"252\":1,\"253\":1,\"254\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"285\":1,\"286\":1,\"294\":1,\"298\":1,\"299\":1,\"301\":1,\"302\":1,\"304\":1,\"311\":1,\"312\":1}}],[\"传入自己的threadfactory设置thread\",{\"1\":{\"865\":1}}],[\"传入一个\",{\"1\":{\"838\":1}}],[\"传入的基础数据类型参数\",{\"1\":{\"722\":1}}],[\"传入的值不是2的倍数\",{\"0\":{\"689\":1},\"1\":{\"689\":1}}],[\"传入的策略是一个接口\",{\"1\":{\"342\":1}}],[\"传统的垃圾回收方式主要针对对象实例的回收\",{\"1\":{\"725\":1}}],[\"传统局域网带来的问题\",{\"1\":{\"159\":1}}],[\"传的不是2的倍数时\",{\"1\":{\"689\":1}}],[\"传递给invoker\",{\"1\":{\"383\":1}}],[\"传播时延\",{\"1\":{\"263\":2,\"264\":1}}],[\"传导信号的东西摸不到\",{\"1\":{\"230\":1}}],[\"传送数据或视频信号\",{\"1\":{\"257\":1}}],[\"传送0和1\",{\"1\":{\"229\":1}}],[\"传送二进制和多媒体数据\",{\"1\":{\"96\":1}}],[\"传输单位为数据段\",{\"1\":{\"282\":1}}],[\"传输协议数据单元\",{\"1\":{\"276\":1}}],[\"传输服务访问点\",{\"1\":{\"276\":1}}],[\"传输实体可能位于操作系统的内核\",{\"1\":{\"274\":1}}],[\"传输距离限制\",{\"1\":{\"619\":1}}],[\"传输距离\",{\"1\":{\"268\":1}}],[\"传输距离短\",{\"1\":{\"230\":1}}],[\"传输层提供了哪两种主要的协议\",{\"0\":{\"636\":1}}],[\"传输层从网络层收到数据后交付指明的应用进程\",{\"1\":{\"280\":1}}],[\"传输层使用端口号区分不同进程\",{\"1\":{\"280\":1}}],[\"传输层数据\",{\"1\":{\"278\":1}}],[\"传输层的主要功能是什么\",{\"0\":{\"635\":1}}],[\"传输层的主要作用就是为它的上层提供端到端的数据传输服务\",{\"1\":{\"275\":1}}],[\"传输层的主要任务是与下面的三层一起共同构建进行网络通信所需的线路和数据传输通道\",{\"1\":{\"273\":1}}],[\"传输层的主要任务为运行在不同主机上的上层应用进程提供直接的通信服务\",{\"1\":{\"271\":1}}],[\"传输层的数据单元是数据段\",{\"1\":{\"273\":1}}],[\"传输层的任务是什么\",{\"1\":{\"273\":1}}],[\"传输层和应用层\",{\"1\":{\"268\":1}}],[\"传输层\",{\"0\":{\"271\":1},\"1\":{\"268\":1,\"274\":1}}],[\"传输和处理的一种技术体系\",{\"1\":{\"257\":1}}],[\"传输模式\",{\"0\":{\"234\":1}}],[\"传输方式\",{\"0\":{\"231\":1}}],[\"传输速率\",{\"1\":{\"268\":1}}],[\"传输速率低\",{\"1\":{\"230\":1}}],[\"传输速率控制\",{\"1\":{\"229\":1}}],[\"传输媒体介质\",{\"1\":{\"618\":1}}],[\"传输媒体质量\",{\"1\":{\"240\":1}}],[\"传输媒体\",{\"0\":{\"230\":1}}],[\"传输媒体的能力\",{\"1\":{\"227\":1}}],[\"传输介质兼容性\",{\"1\":{\"619\":1}}],[\"传输介质管理\",{\"1\":{\"229\":1}}],[\"传输介质\",{\"1\":{\"157\":1,\"227\":1,\"240\":1}}],[\"传输编码\",{\"1\":{\"96\":1}}],[\"传输控制信息\",{\"1\":{\"87\":1}}],[\"传输文件\",{\"1\":{\"86\":1,\"538\":1}}],[\"传输过程中分组可能会遭受误码\",{\"1\":{\"184\":1}}],[\"传输过程\",{\"0\":{\"86\":1}}],[\"传输完成后再关闭\",{\"1\":{\"85\":1}}],[\"传输\",{\"1\":{\"72\":1,\"239\":1,\"301\":1,\"584\":1}}],[\"ⅲ\",{\"0\":{\"95\":1,\"139\":1,\"149\":1,\"186\":1,\"591\":1},\"1\":{\"131\":1}}],[\"发生下面几种情况才会返回\",{\"1\":{\"807\":1}}],[\"发生引用关系变化\",{\"1\":{\"750\":1}}],[\"发生了对集合结构的并发修改操作时抛出\",{\"1\":{\"710\":1}}],[\"发生\",{\"1\":{\"701\":1,\"780\":1}}],[\"发生概率仅为0\",{\"1\":{\"697\":1}}],[\"发展历程\",{\"0\":{\"537\":1}}],[\"发货处理\",{\"1\":{\"518\":1}}],[\"发货等\",{\"1\":{\"333\":1}}],[\"发起人类\",{\"1\":{\"377\":1,\"378\":1}}],[\"发起人\",{\"1\":{\"377\":1}}],[\"发布事件\",{\"1\":{\"326\":1}}],[\"发布者和订阅者之间的解耦\",{\"1\":{\"326\":1}}],[\"发布者和订阅者之间的交互通过消息的发布和订阅来完成\",{\"1\":{\"326\":1}}],[\"发布者不需要知道订阅者的存在\",{\"1\":{\"326\":1}}],[\"发布者\",{\"1\":{\"326\":1}}],[\"发布\",{\"1\":{\"326\":2}}],[\"发布订阅模式\",{\"0\":{\"326\":1}}],[\"发回响应报文的步骤和之前过程类似\",{\"1\":{\"268\":1}}],[\"发出的原始电信号称为基带信号\",{\"1\":{\"238\":1}}],[\"发往组播地址224\",{\"1\":{\"210\":1}}],[\"发现没有空闲的窗口\",{\"1\":{\"868\":1}}],[\"发现有空间的在营业的窗口\",{\"1\":{\"868\":1}}],[\"发现被占用的锁是重量级锁\",{\"1\":{\"837\":1}}],[\"发现不用自己去lock和unlock\",{\"1\":{\"835\":1}}],[\"发现老年代可用的连续内存空间\",{\"1\":{\"739\":1}}],[\"发现了新的网络\",{\"1\":{\"208\":1}}],[\"发现这个ip地址正是自己\",{\"1\":{\"168\":1,\"583\":1}}],[\"发现b问的不是他\",{\"1\":{\"168\":1,\"583\":1}}],[\"发挥它本来的作用\",{\"1\":{\"119\":1}}],[\"发件人确认\",{\"1\":{\"94\":1}}],[\"发送一个时钟中断信号给cpu\",{\"1\":{\"809\":1}}],[\"发送一个冗余ack\",{\"1\":{\"291\":1}}],[\"发送设备在停止发送后\",{\"1\":{\"578\":1}}],[\"发送设备在发送数据的同时持续侦听信道\",{\"1\":{\"578\":1}}],[\"发送设备在发送数据前先侦听信道\",{\"1\":{\"578\":1}}],[\"发送设备若检测到信道上有冲突\",{\"1\":{\"578\":1}}],[\"发送请求到远程服务器\",{\"1\":{\"495\":1}}],[\"发送电子邮件的逻辑\",{\"1\":{\"461\":2}}],[\"发送消息\",{\"1\":{\"325\":1,\"403\":6,\"408\":5}}],[\"发送缓存\",{\"1\":{\"282\":1}}],[\"发送过程的封装正好是反着来\",{\"1\":{\"268\":1}}],[\"发送时延\",{\"1\":{\"263\":2}}],[\"发送周期为10秒\",{\"1\":{\"210\":1}}],[\"发送的信息就是与本路由器相邻的所有路由器的链路状态\",{\"1\":{\"210\":1}}],[\"发送信息时占用全部带宽\",{\"1\":{\"152\":1}}],[\"发送确认\",{\"1\":{\"138\":1,\"139\":1}}],[\"发送端就已经发送了时延带宽积个比特\",{\"1\":{\"264\":1}}],[\"发送端将时钟同步信号编码到发送数据中一起传输\",{\"1\":{\"236\":1}}],[\"发送端将前两个帧从缓存空间中删去\",{\"1\":{\"142\":1,\"576\":1}}],[\"发送端和接收端通过共享一个时钟信号来保持同步\",{\"1\":{\"236\":1}}],[\"发送端一位一位地把信息通过介质发往接收端\",{\"1\":{\"234\":1}}],[\"发送端与接收端之间只用1条数据传输线即可\",{\"1\":{\"232\":1}}],[\"发送端收到这个控制字符后就知道可以恢复数据发送了\",{\"1\":{\"141\":1,\"576\":1}}],[\"发送端的数据发送速度要与线路上的承载速率\",{\"1\":{\"140\":1,\"576\":1}}],[\"发送端的数据发送速度与接收端的数据接收速度要匹配\",{\"1\":{\"140\":1,\"576\":1}}],[\"发送端\",{\"1\":{\"134\":1,\"576\":1}}],[\"发送端以比特位方式一位位地传输到接收端的物理层\",{\"1\":{\"131\":1}}],[\"发送邮件内容\",{\"1\":{\"94\":1}}],[\"发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半\",{\"1\":{\"299\":1}}],[\"发送方将数据分割成小的报文段\",{\"1\":{\"289\":1}}],[\"发送方一旦收到3个重复确认\",{\"1\":{\"299\":1}}],[\"发送方一旦收到3个连续的重复确认\",{\"1\":{\"299\":1}}],[\"发送方不会出现超时重传\",{\"1\":{\"299\":1}}],[\"发送方可以通过发送零窗口探测报文来主动询问接收方的窗口是否已经变为非零\",{\"1\":{\"294\":1}}],[\"发送方可以连续发送多个分组\",{\"1\":{\"138\":2,\"139\":2}}],[\"发送方根据自己估算的网络拥塞程度而设置的窗口值\",{\"1\":{\"294\":1}}],[\"发送方根据接收到的确认信息移动发送窗口\",{\"1\":{\"138\":1,\"139\":1}}],[\"发送方认定2丢失\",{\"1\":{\"291\":1}}],[\"发送方收到3个对于报文段1的冗余ack\",{\"1\":{\"291\":1}}],[\"发送方已发送1\",{\"1\":{\"291\":1}}],[\"发送方重新发送4\",{\"1\":{\"290\":1}}],[\"发送方的某些应用进程所发送的不同应用报文\",{\"1\":{\"280\":1}}],[\"发送方发送完窗口内数据后需要等到确认报文才会滑动窗口并继续发送\",{\"1\":{\"294\":1}}],[\"发送方发送\",{\"1\":{\"268\":2}}],[\"发送方和接收方都需要维护更复杂的状态信息\",{\"1\":{\"139\":1}}],[\"发送方为每个分组设置独立的定时器\",{\"1\":{\"139\":1}}],[\"发送方连续发送窗口内的分组\",{\"1\":{\"138\":1,\"139\":1}}],[\"发送方设置定时器\",{\"1\":{\"138\":1}}],[\"发送方窗口大小取接收窗口rwnd和拥塞窗口cwnd的最小值\",{\"1\":{\"294\":1}}],[\"发送方窗口\",{\"1\":{\"138\":1,\"139\":1}}],[\"发送方每发送一个数据分组后\",{\"1\":{\"137\":1}}],[\"发送方\",{\"1\":{\"94\":1,\"132\":2,\"135\":1,\"254\":1,\"293\":1,\"296\":3,\"297\":1,\"576\":1}}],[\"发送给客户端\",{\"1\":{\"64\":1}}],[\"告知准备断开连接\",{\"1\":{\"94\":1}}],[\"告知准备发送邮件内容\",{\"1\":{\"94\":1}}],[\"告知服务器邮件内容发送完毕\",{\"1\":{\"94\":1}}],[\"告知自己的smtp服务器域名\",{\"1\":{\"94\":1}}],[\"告诉本地\",{\"1\":{\"78\":1}}],[\"身份确认\",{\"1\":{\"94\":1}}],[\"ⅱ\",{\"0\":{\"94\":1,\"135\":1,\"138\":1,\"142\":1,\"148\":1,\"153\":1,\"185\":1,\"590\":1},\"1\":{\"131\":1,\"576\":1}}],[\"ⅰ\",{\"0\":{\"93\":1,\"134\":1,\"137\":1,\"141\":1,\"147\":1,\"152\":1,\"184\":1,\"589\":1},\"1\":{\"131\":1,\"576\":1}}],[\"简而言之\",{\"1\":{\"474\":1,\"621\":1}}],[\"简写为\",{\"1\":{\"464\":1,\"468\":1,\"474\":1}}],[\"简称\",{\"1\":{\"846\":1}}],[\"简称lod\",{\"1\":{\"488\":1}}],[\"简称lan\",{\"1\":{\"155\":1}}],[\"简称dip\",{\"1\":{\"476\":1}}],[\"简称isp\",{\"1\":{\"472\":1}}],[\"简称srp\",{\"1\":{\"460\":1}}],[\"简洁\",{\"1\":{\"345\":1,\"361\":1}}],[\"简化代码\",{\"1\":{\"816\":1}}],[\"简化客户端代码\",{\"1\":{\"526\":1}}],[\"简化客户端与复杂子系统之间的交互\",{\"1\":{\"519\":1}}],[\"简化通信\",{\"1\":{\"410\":1}}],[\"简化了远程通信的操作\",{\"1\":{\"495\":1}}],[\"简化了聚合对象的接口\",{\"1\":{\"367\":1}}],[\"简化了代码结构\",{\"1\":{\"361\":1}}],[\"简化了代码的维护和扩展\",{\"1\":{\"355\":1}}],[\"简化为\",{\"1\":{\"316\":1}}],[\"简化存储管理\",{\"1\":{\"254\":1}}],[\"简化的网络处理功能\",{\"1\":{\"184\":1}}],[\"简单理解\",{\"1\":{\"857\":1}}],[\"简单说就是插入时\",{\"1\":{\"701\":1}}],[\"简单的代码更容易进行扩展和重构\",{\"1\":{\"482\":1}}],[\"简单的代码更易于理解\",{\"1\":{\"482\":1}}],[\"简单来说\",{\"1\":{\"466\":1,\"689\":1,\"696\":1,\"784\":1,\"797\":1,\"820\":1}}],[\"简单工厂模式通过将对象的创建逻辑封装在一个工厂类中\",{\"1\":{\"424\":1}}],[\"简单工厂设计模式提供了一种简单而统一的方式来创建对象\",{\"1\":{\"430\":1}}],[\"简单工厂设计模式通过一个工厂类来封装对象的创建过程\",{\"1\":{\"430\":1}}],[\"简单工厂设计模式适用于以下场景\",{\"1\":{\"428\":1}}],[\"简单工厂设计模式的基本流程如下\",{\"1\":{\"427\":1}}],[\"简单工厂设计模式的核心思想是通过一个工厂类来封装对象的创建过程\",{\"1\":{\"425\":1}}],[\"简单工厂设计模式由以下组成部分构成\",{\"1\":{\"426\":1}}],[\"简单工厂设计模式\",{\"1\":{\"424\":1,\"430\":1}}],[\"简单工厂\",{\"0\":{\"423\":1}}],[\"简单工作流程\",{\"1\":{\"181\":1,\"274\":1}}],[\"简单可靠\",{\"1\":{\"205\":1}}],[\"简单邮件传输协议\",{\"1\":{\"92\":1}}],[\"简记为pvid\",{\"1\":{\"159\":1}}],[\"简介\",{\"0\":{\"55\":1,\"118\":1,\"179\":1,\"227\":1,\"272\":1,\"446\":1,\"460\":1,\"464\":1,\"468\":1,\"472\":1,\"476\":1,\"480\":1,\"484\":1,\"488\":1,\"500\":1,\"504\":1,\"508\":1},\"1\":{\"495\":1,\"496\":1}}],[\"可设置容量队列\",{\"1\":{\"862\":1}}],[\"可缓存线程的线程池\",{\"1\":{\"859\":1}}],[\"可用于解决原子的更新数据和数据的版本号\",{\"1\":{\"847\":1}}],[\"可用于分析jvm性能\",{\"1\":{\"763\":1}}],[\"可实现选择性通知\",{\"1\":{\"843\":1}}],[\"可实现公平锁\",{\"1\":{\"843\":1}}],[\"可中断锁和不可中断锁有什么区别\",{\"0\":{\"841\":1},\"1\":{\"841\":1}}],[\"可中断锁\",{\"1\":{\"832\":1,\"841\":1}}],[\"可表示的字符\",{\"1\":{\"789\":1}}],[\"可表示范围内的字符\",{\"1\":{\"789\":1}}],[\"可在子类中被重新定义\",{\"1\":{\"783\":1}}],[\"可通过\",{\"1\":{\"768\":1}}],[\"可通过更好的路由\",{\"1\":{\"201\":1}}],[\"可对比正常情况看频率是否正常\",{\"1\":{\"768\":1}}],[\"可视化的堆内存分析工具\",{\"1\":{\"768\":1}}],[\"可全方位监控\",{\"1\":{\"768\":1}}],[\"可初步查看是哪个对象占用了内存\",{\"1\":{\"766\":1}}],[\"可达性分析算法\",{\"1\":{\"733\":1}}],[\"可重入性怎么实现\",{\"0\":{\"836\":1}}],[\"可重复的\",{\"1\":{\"671\":3}}],[\"可重用性和灵活性\",{\"1\":{\"512\":1}}],[\"可重用性\",{\"1\":{\"328\":1}}],[\"可复用的面向对象软件元素\",{\"1\":{\"490\":1}}],[\"可复用性和可扩展性\",{\"1\":{\"470\":1}}],[\"可测试性和可理解性提供了指导原则\",{\"1\":{\"474\":1}}],[\"可测试性和可理解性\",{\"1\":{\"474\":1}}],[\"可测试性和可扩展性\",{\"1\":{\"461\":1}}],[\"可测试性和可维护性\",{\"1\":{\"458\":1}}],[\"可阅读的\",{\"1\":{\"458\":1}}],[\"可维护和可扩展的软件系统\",{\"1\":{\"488\":1}}],[\"可维护和可扩展的代码\",{\"1\":{\"458\":1}}],[\"可维护和可扩展\",{\"1\":{\"461\":1,\"473\":1}}],[\"可维护和可测试\",{\"1\":{\"461\":1}}],[\"可维护和易于扩展\",{\"1\":{\"346\":1}}],[\"可维护性和可重用性\",{\"1\":{\"493\":2}}],[\"可维护性和可测试性\",{\"1\":{\"472\":1}}],[\"可维护性和可扩展性\",{\"1\":{\"458\":1,\"469\":1,\"482\":1}}],[\"可维护性和测试性\",{\"1\":{\"465\":1}}],[\"可维护性下降\",{\"1\":{\"465\":1}}],[\"可维护性\",{\"1\":{\"328\":1,\"396\":1,\"490\":1}}],[\"可维护的软件系统\",{\"1\":{\"326\":1}}],[\"可扩展的系统架构\",{\"1\":{\"496\":1}}],[\"可扩展的系统\",{\"1\":{\"474\":1}}],[\"可扩展的通信机制\",{\"1\":{\"326\":1}}],[\"可扩展性和可理解性\",{\"1\":{\"474\":1}}],[\"可扩展性和可维护性\",{\"1\":{\"470\":1}}],[\"可扩展性差\",{\"1\":{\"422\":1}}],[\"可扩展和可维护\",{\"1\":{\"500\":1}}],[\"可扩展和可维护的代码结构\",{\"1\":{\"352\":1}}],[\"可扩展和可维护的方式来管理对象之间的交互和行为\",{\"1\":{\"320\":2}}],[\"可扩展和易于理解\",{\"1\":{\"474\":1}}],[\"可扩展和易于维护\",{\"1\":{\"343\":1,\"344\":1}}],[\"可见性指的是一个线程修改了某一个共享变量的值时\",{\"1\":{\"825\":1}}],[\"可见性\",{\"0\":{\"825\":1},\"1\":{\"814\":1,\"825\":2,\"827\":1,\"834\":1,\"844\":1}}],[\"可见现在网络中不是堆积了报文段而是减少了3个报文段\",{\"1\":{\"299\":1}}],[\"可见光\",{\"1\":{\"230\":1}}],[\"可编程的硬件\",{\"1\":{\"257\":1}}],[\"可变部分40字节\",{\"1\":{\"194\":1}}],[\"可靠\",{\"1\":{\"287\":1}}],[\"可靠通信的责任落在了用户主机\",{\"1\":{\"184\":1}}],[\"可靠通信由用户主机保证\",{\"1\":{\"184\":1}}],[\"可靠通信由网络保证\",{\"1\":{\"184\":1}}],[\"可靠传输指的是数据链路层确保数据在传输过程中能够可靠地到达目的地的能力\",{\"1\":{\"577\":1}}],[\"可靠传输的特点\",{\"1\":{\"291\":1}}],[\"可靠传输是tcp的主要目的\",{\"1\":{\"287\":1}}],[\"可靠传输协议的使用\",{\"1\":{\"184\":1}}],[\"可靠传输服务并不仅局限于数据链路层\",{\"1\":{\"136\":1}}],[\"可靠传输\",{\"0\":{\"136\":1},\"1\":{\"121\":1,\"133\":1,\"136\":1,\"577\":1}}],[\"可能基于错误的支付状态进行\",{\"1\":{\"845\":1}}],[\"可能造成的影响\",{\"1\":{\"845\":1}}],[\"可能controller层不需要的参数\",{\"1\":{\"817\":1}}],[\"可能无法准确地从哈希表中删除对象\",{\"1\":{\"788\":1}}],[\"可能抛异常的位置\",{\"1\":{\"747\":1}}],[\"可能超过了老年代当前可用内存空间\",{\"1\":{\"739\":1}}],[\"可能影响性能\",{\"1\":{\"706\":1}}],[\"可能出现的aba问题\",{\"1\":{\"845\":1}}],[\"可能出现树枝不均匀情况\",{\"1\":{\"698\":1}}],[\"可能出现和帧定界的控制字符一样的字符\",{\"1\":{\"132\":1,\"577\":1}}],[\"可能是真不足\",{\"1\":{\"767\":1}}],[\"可能是在尽可能平衡哈希表的空间利用率和性能之间做出的折中\",{\"1\":{\"696\":1}}],[\"可能是最后的结果\",{\"1\":{\"71\":1}}],[\"可能随着产品种类的增加而变得臃肿\",{\"1\":{\"430\":1}}],[\"可能此处会执行很久\",{\"1\":{\"422\":3,\"429\":3}}],[\"可能从一个连接变成需要多个连接\",{\"1\":{\"421\":1}}],[\"可能导致用户多次被扣款\",{\"1\":{\"845\":1}}],[\"可能导致线程阻塞和上下文切换\",{\"1\":{\"834\":1}}],[\"可能导致竞态条件\",{\"1\":{\"834\":1}}],[\"可能导致代码的执行顺序混乱\",{\"1\":{\"814\":1}}],[\"可能导致方法区溢出\",{\"1\":{\"731\":1}}],[\"可能导致不确定的结果\",{\"1\":{\"706\":1}}],[\"可能导致单例类的职责过重\",{\"1\":{\"421\":1}}],[\"可能导致性能问题\",{\"1\":{\"328\":1}}],[\"可能引入全局状态和全局访问点\",{\"1\":{\"421\":1}}],[\"可能引发拥塞\",{\"1\":{\"296\":1}}],[\"可能需要打破双亲委派机制\",{\"1\":{\"758\":1}}],[\"可能需要修改门面类\",{\"1\":{\"519\":1}}],[\"可能需要执行很久\",{\"1\":{\"422\":1}}],[\"可能需要根据不同的上下文创建多个实例来记录不同的日志信息\",{\"1\":{\"421\":1}}],[\"可能需要创建大量的表达式类\",{\"1\":{\"396\":1}}],[\"可能需要将任务分配给不同的执行器\",{\"1\":{\"355\":1}}],[\"可能需要按照一定的规则对数据进行处理\",{\"1\":{\"355\":1}}],[\"可能需要对不同类型的事件进行不同的处理\",{\"1\":{\"355\":1}}],[\"可能需要对不同类型的邮件进行不同的处理\",{\"1\":{\"355\":1}}],[\"可能需要在抽象类中定义大量的抽象方法\",{\"1\":{\"339\":1}}],[\"可能在性能上略微慢于\",{\"1\":{\"715\":1}}],[\"可能在审批处理上有所不同\",{\"1\":{\"333\":1}}],[\"可能在这些共性步骤上有所不同\",{\"1\":{\"333\":1}}],[\"可能有一些节点或链路的流量远远超过了其处理能力\",{\"1\":{\"296\":1}}],[\"可能实际吞吐量只有\",{\"1\":{\"262\":1}}],[\"可能由于①配置错误\",{\"1\":{\"205\":1}}],[\"可能会遇到什么情况呢\",{\"1\":{\"868\":1}}],[\"可能会频繁的\",{\"1\":{\"866\":1}}],[\"可能会有对象的半初始化的问题\",{\"1\":{\"826\":1}}],[\"可能会有安全隐患\",{\"1\":{\"159\":1}}],[\"可能会使用多个线程并行进行垃圾回收操作\",{\"1\":{\"721\":1}}],[\"可能会卸载不再需要的类\",{\"1\":{\"720\":1}}],[\"可能会根据程序的执行情况进行优化\",{\"1\":{\"720\":1}}],[\"可能会经常发生hash碰撞\",{\"1\":{\"690\":1}}],[\"可能会出现什么问题\",{\"1\":{\"788\":3}}],[\"可能会出现不同对象具有相同哈希码的情况\",{\"1\":{\"787\":1}}],[\"可能会出现类冲突和版本不兼容的问题\",{\"1\":{\"759\":1}}],[\"可能会出现元素集中分布\",{\"1\":{\"685\":1,\"686\":1}}],[\"可能会出现失序\",{\"1\":{\"254\":1}}],[\"可能会发生数据碰撞\",{\"1\":{\"581\":1}}],[\"可能会引入过多的具体命令类\",{\"1\":{\"385\":1}}],[\"可能会占用较大的内存空间\",{\"1\":{\"379\":1}}],[\"可能会导致在阻塞队列中的线程长期处于饥饿状态\",{\"1\":{\"840\":1}}],[\"可能会导致在哈希表中无法正常释放对象\",{\"1\":{\"788\":1}}],[\"可能会导致无法正确地检索对象\",{\"1\":{\"788\":1}}],[\"可能会导致以下问题\",{\"1\":{\"788\":1}}],[\"可能会导致门面对象变得庞大\",{\"1\":{\"519\":1}}],[\"可能会导致代码复杂性增加\",{\"1\":{\"396\":1}}],[\"可能会导致状态发生改变\",{\"1\":{\"359\":1}}],[\"可能会导致请求在责任链上无法被处理\",{\"1\":{\"355\":1}}],[\"可能会导致数据包时延\",{\"1\":{\"296\":1}}],[\"可能会导致死锁\",{\"1\":{\"294\":1}}],[\"可能会导致通信中断\",{\"1\":{\"153\":1}}],[\"可能会在不同的上下文中具有不同的含义\",{\"1\":{\"205\":1}}],[\"可能会造成转发错误\",{\"1\":{\"159\":1}}],[\"可能会浪费带宽\",{\"1\":{\"138\":1}}],[\"可能差百万倍\",{\"1\":{\"152\":1}}],[\"可以利用配置中心如nacos\",{\"1\":{\"869\":1}}],[\"可以切换到stop状态\",{\"1\":{\"867\":1}}],[\"可以切换到shutdown状态\",{\"1\":{\"867\":1}}],[\"可以达到重复利用的效果\",{\"1\":{\"857\":1}}],[\"可以主动释放它占有的资源\",{\"1\":{\"848\":1}}],[\"可以解决使用\",{\"1\":{\"847\":1}}],[\"可以考虑根绝情况将它拆分成cpu密集型和io密集型任务\",{\"1\":{\"866\":1}}],[\"可以考虑合并多个变量\",{\"1\":{\"845\":1}}],[\"可以考虑改用锁来保证操作的原子性\",{\"1\":{\"845\":1}}],[\"可以考虑使用\",{\"1\":{\"706\":1}}],[\"可以同时被多个线程持有\",{\"1\":{\"842\":1}}],[\"可以同时进行双向通信而不会出现冲突\",{\"1\":{\"582\":1}}],[\"可以执行同步锁代码\",{\"1\":{\"837\":2}}],[\"可以执行同步锁的代码\",{\"1\":{\"837\":1}}],[\"可以叫做内部锁\",{\"1\":{\"835\":1}}],[\"可以保证可见性和禁止指令重排序\",{\"1\":{\"829\":1}}],[\"可以重新安排语句的执行顺序\",{\"1\":{\"826\":1}}],[\"可以重写\",{\"1\":{\"787\":1}}],[\"可以让不同方法直接使用\",{\"1\":{\"817\":1}}],[\"可以让程序在运行时获取并操作类的信息\",{\"1\":{\"800\":1}}],[\"可以被类的所有实例和方法直接访问和共享\",{\"1\":{\"816\":1}}],[\"可以被不同的数据类型使用\",{\"1\":{\"797\":1}}],[\"可以随时看着自己拼的图\",{\"1\":{\"798\":1}}],[\"可以随时替换成员变量的实现\",{\"1\":{\"782\":1}}],[\"可以装数字\",{\"1\":{\"797\":1}}],[\"可以装不同类型的东西\",{\"1\":{\"797\":1}}],[\"可以生成本地化信息\",{\"1\":{\"794\":1}}],[\"可以不处理\",{\"1\":{\"793\":1}}],[\"可以简单分为两种情况\",{\"1\":{\"791\":1}}],[\"可以选择性地暴露对象的接口\",{\"1\":{\"782\":1}}],[\"可以把一个类当作成员变量给另一个类进行组合使用\",{\"1\":{\"782\":1}}],[\"可以把它比作一个旅行团的场景\",{\"1\":{\"372\":1}}],[\"可以体会到我的好处\",{\"1\":{\"781\":1}}],[\"可以参加表达式运算\",{\"1\":{\"777\":1}}],[\"可以搭配final关键字\",{\"1\":{\"776\":1}}],[\"可以用来设定线程名\",{\"1\":{\"860\":1}}],[\"可以用来表示系统中某种资源的数量\",{\"1\":{\"853\":1}}],[\"可以用来执行一些清理或资源释放操作\",{\"1\":{\"721\":1}}],[\"可以用于更复杂的并发控制\",{\"1\":{\"834\":1}}],[\"可以用于存储类级别的信息\",{\"1\":{\"776\":1}}],[\"可以用\",{\"1\":{\"783\":1}}],[\"可以多抓几次做个对比\",{\"1\":{\"769\":1}}],[\"可以实时监控应用程序的性能指标\",{\"1\":{\"763\":1}}],[\"可以实现线程在不同状态之间转换\",{\"1\":{\"812\":1}}],[\"可以实现线程安全的\",{\"1\":{\"708\":1}}],[\"可以实现更加灵活\",{\"1\":{\"352\":1}}],[\"可以查询线程的数量\",{\"1\":{\"763\":1}}],[\"可以有效地利用已加载的类\",{\"1\":{\"758\":1}}],[\"可以有效地支持大量细粒度的对象\",{\"1\":{\"533\":1}}],[\"可以作为\",{\"1\":{\"734\":1}}],[\"可以看到相应的字节码指令\",{\"1\":{\"835\":1}}],[\"可以看成是方法的运行模型\",{\"1\":{\"724\":1}}],[\"可以看作是一种中介者模式的中介\",{\"1\":{\"405\":1}}],[\"可以划分为\",{\"1\":{\"722\":1}}],[\"可以按照插入顺序或者最近访问的顺序进行\",{\"1\":{\"715\":1}}],[\"可以记录插入顺序\",{\"1\":{\"715\":1}}],[\"可以创建多个不同的比较器\",{\"1\":{\"674\":1}}],[\"可以创建不同类型的对象\",{\"1\":{\"452\":1}}],[\"可以创建不同的表示形式\",{\"1\":{\"451\":1}}],[\"可以对应多个域名吗\",{\"0\":{\"594\":1},\"1\":{\"594\":1}}],[\"可以建立\",{\"1\":{\"584\":1}}],[\"可以基于交换机的端口进行划分\",{\"1\":{\"579\":1}}],[\"可以举例说明一个符合restful设计风格的api吗\",{\"0\":{\"554\":1}}],[\"可以列举一些常见的应用层协议\",{\"0\":{\"547\":1}}],[\"可以很方便地在android\",{\"1\":{\"540\":1}}],[\"可以修改为java\",{\"1\":{\"538\":1}}],[\"可以自定义安装目录\",{\"1\":{\"538\":1}}],[\"可以递归地处理整个层次结构\",{\"1\":{\"526\":1}}],[\"可以统一通过组件接口进行操作\",{\"1\":{\"526\":1}}],[\"可以以相同的方式对待它们\",{\"1\":{\"525\":1}}],[\"可以以各种方式组合和包装\",{\"1\":{\"500\":1}}],[\"可以灵活地组合各种装饰器\",{\"1\":{\"502\":1}}],[\"可以灵活地扩展和修改算法的某些步骤\",{\"1\":{\"339\":1}}],[\"可以是像python\",{\"1\":{\"804\":1}}],[\"可以是接口或抽象类\",{\"1\":{\"524\":1}}],[\"可以是抽象类或接口\",{\"1\":{\"501\":2}}],[\"可以是一个集合或其他数据结构\",{\"1\":{\"371\":1}}],[\"可以封装远程通信的逻辑\",{\"1\":{\"495\":1}}],[\"可以直接从缓存中获取结果\",{\"1\":{\"495\":1}}],[\"可以提高查询性能\",{\"1\":{\"495\":1}}],[\"可以提高代码的可读性\",{\"1\":{\"482\":1}}],[\"可以提高代码的内聚性\",{\"1\":{\"472\":1}}],[\"可以更精确地控制锁的获取和释放\",{\"1\":{\"832\":1}}],[\"可以更方便地实现全局共享的线程局部变量\",{\"1\":{\"816\":1}}],[\"可以更好地进行单元测试和模块测试\",{\"1\":{\"490\":1}}],[\"可以更容易地维护和理解对象之间的关系\",{\"1\":{\"328\":1}}],[\"可以理解为接口的调用者或者使用者\",{\"1\":{\"472\":1}}],[\"可以改善代码的可扩展性\",{\"1\":{\"465\":1}}],[\"可以避免对原始对象的修改\",{\"1\":{\"455\":1}}],[\"可以分步骤构建复杂对象\",{\"1\":{\"451\":1}}],[\"可以分配一个较大的子网掩码\",{\"1\":{\"222\":1}}],[\"可以分配一个较小的子网掩码\",{\"1\":{\"222\":1}}],[\"可以帮助我们实现对象的创建和使用的解耦\",{\"1\":{\"437\":1}}],[\"可以控制对象的创建过程\",{\"1\":{\"417\":1}}],[\"可以引入一个中介者对象来简化和集中通信逻辑\",{\"1\":{\"411\":1}}],[\"可以引入中介者来减少对象之间的直接依赖\",{\"1\":{\"405\":1}}],[\"可以发送和接收消息\",{\"1\":{\"407\":1}}],[\"可以发送和接收通信\",{\"1\":{\"402\":1}}],[\"可以发送消息并接收消息\",{\"1\":{\"404\":1,\"409\":1}}],[\"可以减少参数传递的复杂性\",{\"1\":{\"816\":1}}],[\"可以减少命令模式的复杂性\",{\"1\":{\"385\":1}}],[\"可以减小传输的数据量\",{\"1\":{\"113\":1}}],[\"可以再次执行这些被撤销的操作\",{\"1\":{\"375\":1}}],[\"可以回到之前的状态\",{\"1\":{\"375\":1}}],[\"可以将几个任意长度的二进制数据散列计算成一个定长的二进制数据\",{\"1\":{\"690\":1}}],[\"可以将它们划分为三个不同的虚拟网络\",{\"1\":{\"579\":1}}],[\"可以将这个大的局域网划分成多个虚拟的\",{\"1\":{\"579\":1}}],[\"可以将其抽取为一个方法\",{\"1\":{\"485\":1}}],[\"可以将深拷贝的对象作为引用\",{\"1\":{\"455\":1}}],[\"可以将新活动应用于其他商品\",{\"1\":{\"455\":1}}],[\"可以将一系列操作参数化\",{\"1\":{\"385\":1}}],[\"可以将城市的景点看作是对象结构\",{\"1\":{\"372\":1}}],[\"可以将具有相同共同前缀的路由进行聚合\",{\"1\":{\"221\":1}}],[\"可以遍历聚合对象\",{\"1\":{\"363\":1}}],[\"可以方便地扩展和修改\",{\"1\":{\"465\":1}}],[\"可以方便地替换具体工厂和产品\",{\"1\":{\"444\":1}}],[\"可以方便地添加新的状态类\",{\"1\":{\"361\":1}}],[\"可以方便地增加新的策略类\",{\"1\":{\"345\":1}}],[\"可以动态地切换状态对象\",{\"1\":{\"358\":1}}],[\"可以通过回溯日志的方式来撤销正在处理的已经执行成功的操作\",{\"1\":{\"871\":1}}],[\"可以通过调用线程池的shutdown或shutdownnow方法来关闭线程池\",{\"1\":{\"864\":1}}],[\"可以通过set\",{\"1\":{\"811\":1}}],[\"可以通过java内置的等待\",{\"1\":{\"811\":1}}],[\"可以通过共享内存等方式进行数据传递\",{\"1\":{\"804\":1}}],[\"可以通过反射来读取配置文件中的类名\",{\"1\":{\"800\":1}}],[\"可以通过类名直接访问\",{\"1\":{\"778\":1,\"779\":1}}],[\"可以通过类名访问\",{\"1\":{\"776\":1}}],[\"可以通过\",{\"1\":{\"756\":1,\"793\":1}}],[\"可以通过将对象标记为灰色来识别正在遍历的对象\",{\"1\":{\"748\":1}}],[\"可以通过这个参数设置这个年龄值\",{\"1\":{\"740\":1}}],[\"可以通过索引进行访问\",{\"1\":{\"677\":1}}],[\"可以通过添加新的叶子对象或组合对象来扩展层次结构\",{\"1\":{\"526\":1}}],[\"可以通过添加新的具体工厂类和产品类来创建新的产品对象\",{\"1\":{\"437\":1}}],[\"可以通过循环调用子节点的操作方法来实现对子节点的操作\",{\"1\":{\"524\":1}}],[\"可以通过动态代理在运行时动态地为目标对象添加横切逻辑\",{\"1\":{\"496\":1}}],[\"可以通过几种方式实现深拷贝\",{\"1\":{\"455\":1}}],[\"可以通过改变工厂方法的实现\",{\"1\":{\"430\":1}}],[\"可以通过插件在sql执行前后进行拦截和处理\",{\"1\":{\"352\":1}}],[\"可以通过配置多个interceptor\",{\"1\":{\"352\":1}}],[\"可以通过配置多个filter\",{\"1\":{\"352\":1}}],[\"可以通过使用线程池来实现异步通知\",{\"1\":{\"327\":1}}],[\"可以继续注册更多版本的策略\",{\"1\":{\"346\":1}}],[\"可以使用jdk自带的命令行工具排查\",{\"1\":{\"849\":1}}],[\"可以使用\",{\"1\":{\"769\":1,\"829\":1,\"844\":2}}],[\"可以使用class\",{\"1\":{\"755\":1}}],[\"可以使用linkedhashmap\",{\"1\":{\"703\":1}}],[\"可以使用组合设计模式来表示组织架构\",{\"1\":{\"525\":1}}],[\"可以使用门面设计模式来提供一个简化的接口\",{\"1\":{\"518\":1}}],[\"可以使用远程代理来进行网络请求和响应的处理\",{\"1\":{\"495\":1}}],[\"可以使用安全代理来确保只有经过验证的用户才能执行敏感操作\",{\"1\":{\"495\":1}}],[\"可以使用静态代理来实现远程代理的功能\",{\"1\":{\"495\":1}}],[\"可以使用静态代理来实现安全代理的功能\",{\"1\":{\"495\":1}}],[\"可以使用静态代理来实现查询缓存的功能\",{\"1\":{\"495\":1}}],[\"可以使用继承和接口来抽象共享的功能\",{\"1\":{\"485\":1}}],[\"可以使用builder模式创建不可变对象\",{\"1\":{\"449\":1}}],[\"可以使用builder模式\",{\"1\":{\"449\":1}}],[\"可以使用builder模式来创建不同的表示\",{\"1\":{\"449\":1}}],[\"可以使用builder模式将构建过程分解为多个简单步骤\",{\"1\":{\"449\":1}}],[\"可以使用工厂方法模式\",{\"1\":{\"435\":1}}],[\"可以使用工厂方法模式来统一创建这些对象\",{\"1\":{\"435\":1}}],[\"可以使用观察者模式来建立对象之间的依赖关系\",{\"1\":{\"411\":1}}],[\"可以使用中介者模式来简化对象之间的通信\",{\"1\":{\"405\":1}}],[\"可以使用解释器模式来解释和处理语法规则\",{\"1\":{\"391\":1}}],[\"可以使用访问者模式\",{\"1\":{\"372\":2}}],[\"可以使用责任链模式来创建一个邮件处理链\",{\"1\":{\"355\":1}}],[\"可以使用策略模式来实现算法的灵活替换\",{\"1\":{\"344\":1}}],[\"可以使用策略模式来避免使用多个if\",{\"1\":{\"344\":1}}],[\"可以使网络资源得到合理利用\",{\"1\":{\"296\":1}}],[\"可以传入所有实现了该策略的具体实现\",{\"1\":{\"342\":1}}],[\"可以传送多个vlan的数据帧\",{\"1\":{\"159\":1}}],[\"可以促使开发人员在子类中实现特定步骤\",{\"1\":{\"333\":1}}],[\"可以进行深拷贝\",{\"1\":{\"455\":1}}],[\"可以进行拓展的功能\",{\"1\":{\"333\":1}}],[\"可以进行复用的功能\",{\"1\":{\"333\":1}}],[\"可以进行跨路由器扩展\",{\"1\":{\"159\":1,\"579\":1}}],[\"可以确保对它的操作具有可见性\",{\"1\":{\"844\":1}}],[\"可以确保对象在构建后不可再修改\",{\"1\":{\"449\":1}}],[\"可以确保在使用迭代器的remove\",{\"1\":{\"367\":1}}],[\"可以确保在具有多个交换机的网络中\",{\"1\":{\"175\":1}}],[\"可以确保算法的结构稳定\",{\"1\":{\"331\":1}}],[\"可以在程序运行时动态加载一些类\",{\"1\":{\"800\":1}}],[\"可以在类中定义多个方法\",{\"1\":{\"780\":1}}],[\"可以在多线程下并发使用\",{\"1\":{\"709\":1}}],[\"可以在不同的系统和项目中重复使用\",{\"1\":{\"512\":1}}],[\"可以在不修改现有代码的情况下扩展对象的功能\",{\"1\":{\"500\":1}}],[\"可以在不修改现有类的情况下\",{\"1\":{\"373\":1}}],[\"可以在不修改原始代码的情况下\",{\"1\":{\"495\":1}}],[\"可以在保留原有代码和接口的情况下\",{\"1\":{\"510\":1}}],[\"可以在执行敏感操作前进行安全验证\",{\"1\":{\"495\":1}}],[\"可以在运行时加载类\",{\"1\":{\"755\":1}}],[\"可以在运行时根据对象的实际类型来调用相应的方法\",{\"1\":{\"470\":1}}],[\"可以在运行时动态地选择算法\",{\"1\":{\"345\":1}}],[\"可以在之后根据备忘录对象恢复原对象的状态\",{\"1\":{\"376\":1}}],[\"可以在事件驱动的系统中发挥重要作用\",{\"1\":{\"328\":1}}],[\"可以在浏览器中添加交互性和动态性\",{\"1\":{\"104\":1}}],[\"可以为两个\",{\"1\":{\"674\":1}}],[\"可以为任意数\",{\"1\":{\"316\":1}}],[\"可以为接入交换机的任意两个网络节点提供独享的电信号通路\",{\"1\":{\"173\":1}}],[\"可以得到算法的运行时间为\",{\"1\":{\"315\":1}}],[\"可以携带数据\",{\"1\":{\"285\":1}}],[\"可以处理不同大小的数据而不受消息边界的影响\",{\"1\":{\"282\":1}}],[\"可以根据自定义的逻辑来加载类\",{\"1\":{\"759\":1}}],[\"可以根据键来查询\",{\"1\":{\"704\":1}}],[\"可以根据业务情况进行挑选\",{\"1\":{\"673\":1}}],[\"可以根据业务需求定义更复杂的处理器链\",{\"1\":{\"353\":1}}],[\"可以根据日志级别灵活地记录日志信息\",{\"1\":{\"355\":1}}],[\"可以根据网络状况和接收方的处理能力来动态控制数据的发送速度\",{\"1\":{\"294\":1}}],[\"可以根据不同链路类型对物理层的比特流进行帧封装和传输\",{\"1\":{\"274\":1}}],[\"可以根据具体需求分配不同大小的子网\",{\"1\":{\"222\":1}}],[\"可以单独运行使用\",{\"1\":{\"257\":1}}],[\"可以调制出16种码元\",{\"1\":{\"239\":1}}],[\"可以采取以下几种方式\",{\"1\":{\"844\":1}}],[\"可以采取外同步或内同步的方式\",{\"1\":{\"236\":1}}],[\"可以采取多种措施减少出现该问题的概率或减小该问题带来的危害\",{\"1\":{\"209\":1}}],[\"可以从主机号部分借用一部分比特作为子网号\",{\"1\":{\"218\":1}}],[\"可以容忍一定程度的丢包情况\",{\"1\":{\"139\":1}}],[\"可以接收窗口内的分组\",{\"1\":{\"139\":1}}],[\"可以检查出误码\",{\"1\":{\"134\":1,\"576\":1}}],[\"可以显著降低网络延迟\",{\"1\":{\"113\":1}}],[\"可以跨邮件服务器\",{\"1\":{\"99\":1}}],[\"可选择\",{\"1\":{\"715\":1}}],[\"可选填\",{\"1\":{\"302\":1}}],[\"可选\",{\"1\":{\"91\":1}}],[\"+解锁+可重入锁\",{\"1\":{\"839\":1}}],[\"+=\",{\"1\":{\"795\":1}}],[\"+printgctimestamps\",{\"1\":{\"764\":1}}],[\"+printgcdetails\",{\"1\":{\"764\":1}}],[\"+printgc\",{\"1\":{\"764\":1}}],[\"+cmsincrementalmode\",{\"1\":{\"764\":1}}],[\"+useconcmarksweepgc\",{\"1\":{\"764\":1}}],[\"+useparalledloldgc\",{\"1\":{\"764\":1}}],[\"+useparallelgc\",{\"1\":{\"764\":1}}],[\"+useserialgc\",{\"1\":{\"764\":1}}],[\"+表示加法\",{\"1\":{\"343\":1,\"346\":1}}],[\"+2n\",{\"1\":{\"316\":1}}],[\"+5n\",{\"1\":{\"316\":1}}],[\"++size\",{\"1\":{\"707\":2}}],[\"++curr\",{\"1\":{\"366\":1}}],[\"++\",{\"1\":{\"316\":1}}],[\"+1是因为可能存在页缺失\",{\"1\":{\"866\":1}}],[\"+1\",{\"1\":{\"316\":7,\"835\":1,\"836\":1}}],[\"+\",{\"1\":{\"91\":1,\"194\":1,\"196\":1,\"263\":3,\"314\":1,\"315\":2,\"316\":4,\"325\":4,\"326\":5,\"327\":2,\"343\":3,\"344\":6,\"346\":4,\"350\":4,\"353\":2,\"354\":2,\"360\":2,\"366\":2,\"372\":3,\"377\":2,\"378\":5,\"384\":3,\"390\":3,\"394\":8,\"403\":7,\"408\":6,\"436\":1,\"443\":1,\"448\":4,\"450\":14,\"454\":11,\"461\":4,\"485\":2,\"495\":7,\"497\":10,\"498\":10,\"506\":6,\"510\":4,\"525\":4,\"689\":1,\"701\":3,\"711\":2,\"714\":1,\"715\":1,\"745\":1,\"790\":3,\"792\":3,\"795\":1,\"822\":1,\"835\":1,\"844\":1,\"847\":1,\"866\":1,\"870\":5}}],[\"首次访问类\",{\"1\":{\"755\":1}}],[\"首次打开\",{\"1\":{\"538\":1}}],[\"首先就会调用\",{\"1\":{\"840\":1}}],[\"首先就是要拿起电话拨号\",{\"1\":{\"125\":1}}],[\"首先会调用\",{\"1\":{\"839\":1}}],[\"首先会根据对象的\",{\"1\":{\"788\":1}}],[\"首先进行年轻代gc\",{\"1\":{\"741\":1}}],[\"首先进行哈希值的扰动\",{\"1\":{\"695\":1}}],[\"首先这两个都是属于java异常体系的error\",{\"1\":{\"731\":1}}],[\"首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用\",{\"1\":{\"726\":1}}],[\"首先计算hash\",{\"1\":{\"711\":1}}],[\"首先创建了一个concretecomponent对象作为原始对象\",{\"1\":{\"502\":1}}],[\"首先\",{\"1\":{\"344\":1,\"346\":2,\"360\":1,\"372\":1,\"448\":1,\"454\":1,\"486\":1,\"495\":7,\"506\":1,\"799\":1,\"813\":1}}],[\"首先必须建立tcp连接\",{\"1\":{\"212\":1}}],[\"首部字段+数据字段\",{\"1\":{\"302\":1}}],[\"首部字段\",{\"1\":{\"302\":1}}],[\"首部行\",{\"1\":{\"107\":2}}],[\"首部\",{\"1\":{\"91\":2}}],[\"首页\",{\"0\":{\"53\":1,\"545\":1},\"1\":{\"372\":2}}],[\"上面是线程等待的方法\",{\"1\":{\"807\":1}}],[\"上面选定的除\",{\"1\":{\"135\":2,\"576\":2}}],[\"上实现\",{\"1\":{\"579\":1}}],[\"上\",{\"1\":{\"579\":1}}],[\"上层的数据被封装成数据链路层的帧\",{\"1\":{\"573\":1,\"577\":1}}],[\"上层使用下层所提供的服务必须通过与下层交换一些命令\",{\"1\":{\"251\":1}}],[\"上述两个保存操作都是cas操作\",{\"1\":{\"837\":1}}],[\"上述树形结构只是一种可视化的表示方式\",{\"1\":{\"525\":1}}],[\"上述代码是\",{\"1\":{\"498\":1}}],[\"上述代码是基于cglib的方法拦截器\",{\"1\":{\"498\":1}}],[\"上述代码是一个基于事件的发布\",{\"1\":{\"326\":1}}],[\"上述代码定义了一个数据库操作的具体实现类\",{\"1\":{\"498\":1}}],[\"上述代码包含两个类\",{\"1\":{\"422\":1}}],[\"上述代码实现了一个简单的聊天应用程序\",{\"1\":{\"409\":1}}],[\"上述代码实现了一个简单的飞机交通管制系统\",{\"1\":{\"404\":1}}],[\"上述代码实现了一个简单的规则引擎\",{\"1\":{\"395\":1}}],[\"上下文切换开销少\",{\"1\":{\"804\":1}}],[\"上下文类可以轻松地切换不同的状态\",{\"1\":{\"361\":1}}],[\"上下文类\",{\"1\":{\"344\":1}}],[\"上下文类在需要执行算法时\",{\"1\":{\"343\":1}}],[\"上下文类持有一个策略接口对象\",{\"1\":{\"343\":1}}],[\"上下文类持有一个策略对象\",{\"1\":{\"343\":1}}],[\"上下文\",{\"1\":{\"343\":1,\"359\":2}}],[\"上车前后验票\",{\"1\":{\"119\":1}}],[\"上等待客户端建立数据连接\",{\"1\":{\"86\":1}}],[\"上传安装包到此目录\",{\"1\":{\"18\":1,\"44\":1}}],[\"等到第二步完成后\",{\"1\":{\"864\":1}}],[\"等到并发标记后\",{\"1\":{\"746\":1}}],[\"等锁来控制对共享资源的访问\",{\"1\":{\"832\":1}}],[\"等机制来实现原子性操作\",{\"1\":{\"829\":1}}],[\"等原子类来代替\",{\"1\":{\"829\":1}}],[\"等修饰符所修饰\",{\"1\":{\"775\":1}}],[\"等常用命令\",{\"1\":{\"768\":1}}],[\"等命令会触发\",{\"1\":{\"739\":1}}],[\"等命令触发\",{\"1\":{\"739\":1}}],[\"等容器中时候\",{\"1\":{\"731\":1}}],[\"等技术来检测数据传输过程中可能发生的错误\",{\"1\":{\"584\":1}}],[\"等技术来检测和纠正在传输过程中产生的错误\",{\"1\":{\"573\":1}}],[\"等库\",{\"1\":{\"485\":1}}],[\"等于等\",{\"1\":{\"392\":1}}],[\"等于16时相当于不可达\",{\"1\":{\"208\":1}}],[\"等功能\",{\"1\":{\"384\":1}}],[\"等具体元素类\",{\"1\":{\"372\":1}}],[\"等方法\",{\"1\":{\"367\":1,\"755\":1}}],[\"等问题\",{\"1\":{\"268\":1}}],[\"等\",{\"1\":{\"227\":1,\"312\":1,\"315\":1,\"596\":1,\"768\":1,\"793\":2,\"798\":1,\"831\":1,\"837\":1,\"844\":1}}],[\"等不同的数据传输方式\",{\"1\":{\"227\":1}}],[\"等价负载均衡\",{\"1\":{\"208\":1}}],[\"等信道不忙后再进行操作\",{\"1\":{\"152\":1}}],[\"等收件人确认就好了\",{\"1\":{\"126\":1}}],[\"等待区也没位置了\",{\"1\":{\"868\":1}}],[\"等待区也满了\",{\"1\":{\"868\":1}}],[\"等待区号靠前的赶紧去新窗口办\",{\"1\":{\"868\":1}}],[\"等待所有子线程运行结束\",{\"1\":{\"851\":1}}],[\"等待latch降为0\",{\"1\":{\"851\":2}}],[\"等待队列应该尽量用有界的\",{\"1\":{\"860\":1}}],[\"等待队列中的下一个线程将有机会获取到锁\",{\"1\":{\"839\":1}}],[\"等待队列\",{\"1\":{\"839\":1}}],[\"等待将来被唤醒\",{\"1\":{\"837\":1}}],[\"等待被唤醒\",{\"1\":{\"835\":1}}],[\"等待\",{\"1\":{\"811\":1,\"851\":1}}],[\"等待状态\",{\"1\":{\"808\":1}}],[\"等待其他线程执行完\",{\"1\":{\"807\":1}}],[\"等待或睡眠状态\",{\"1\":{\"793\":1}}],[\"等待下载完成\",{\"1\":{\"538\":1}}],[\"等待异步任务完成\",{\"1\":{\"327\":1}}],[\"等待延迟\",{\"1\":{\"153\":1}}],[\"等待延时\",{\"1\":{\"153\":1}}],[\"等待一段随机时间后再次尝试发送数据\",{\"1\":{\"578\":1}}],[\"等待一段随机时间\",{\"1\":{\"152\":1}}],[\"等待接收端的确认\",{\"1\":{\"142\":1,\"576\":1}}],[\"等待接收方的确认分组或否认分组\",{\"1\":{\"137\":1}}],[\"等待协议可以不用给ack分组编号\",{\"1\":{\"137\":1}}],[\"等待协议的停等特性\",{\"1\":{\"137\":1}}],[\"等待协议sw\",{\"1\":{\"137\":1}}],[\"等待协议\",{\"0\":{\"137\":1},\"1\":{\"152\":1,\"576\":1}}],[\"等待客户端连接\",{\"1\":{\"85\":1}}],[\"等待服务器连接\",{\"1\":{\"85\":1}}],[\"等等\",{\"1\":{\"3\":1,\"5\":1,\"29\":1,\"31\":1}}],[\"因而发送窗口大小取决于拥塞程度\",{\"1\":{\"296\":1}}],[\"因而适合于在异构网络中任意计算机之间传送文件\",{\"1\":{\"83\":1}}],[\"因为都是io密集型任务\",{\"1\":{\"853\":1}}],[\"因为countdownlatch的使用是一次性的\",{\"1\":{\"852\":1}}],[\"因为获取写锁的时候\",{\"1\":{\"842\":1}}],[\"因为as\",{\"1\":{\"836\":1}}],[\"因为访问静态\",{\"1\":{\"833\":1}}],[\"因为静态成员不属于任何⼀个实例对象\",{\"1\":{\"833\":1}}],[\"因为线程其实也是一个对象\",{\"1\":{\"857\":1}}],[\"因为线程内存储的不是此threadlocal\",{\"1\":{\"818\":1}}],[\"因为线程共享进程的资源\",{\"1\":{\"804\":1}}],[\"因为rpc调用过程中可能会返回的rpc响应出现一些了调用失败的信息\",{\"1\":{\"817\":1}}],[\"因为threadlocal提供了线程内存储变量的能力\",{\"1\":{\"816\":1}}],[\"因为sleep的作用是\",{\"1\":{\"813\":1}}],[\"因为切换的时间特别短\",{\"1\":{\"805\":1}}],[\"因为hashcode\",{\"1\":{\"787\":1}}],[\"因为父加载器加载的类对子加载器是可见的\",{\"1\":{\"758\":1}}],[\"因为核心类通常由启动类加载器加载\",{\"1\":{\"758\":1}}],[\"因为用锁为的就是互斥\",{\"1\":{\"848\":1}}],[\"因为用户线程可能会不断的更新引用域\",{\"1\":{\"746\":1,\"750\":1}}],[\"因为用于mac地址寻址的广播帧只能在同一个以太网段内部进行\",{\"1\":{\"191\":1}}],[\"因为新生代的存活对象比较少\",{\"1\":{\"744\":1}}],[\"因为堆是由一个个栈中组成\",{\"1\":{\"731\":1}}],[\"因为堆用于储存对象实例\",{\"1\":{\"731\":1}}],[\"因为可能会有很多线程都去执行那一段代码\",{\"1\":{\"722\":1}}],[\"因为可能有多个站点在信道忙时都想发送帧\",{\"1\":{\"152\":1}}],[\"因为只要和\",{\"1\":{\"719\":1}}],[\"因为只有在传输完成后\",{\"1\":{\"275\":1}}],[\"因为交换机能够提供更好的性能和碰撞的避免\",{\"1\":{\"581\":1}}],[\"因为交换机的性能和功能更优\",{\"1\":{\"580\":1}}],[\"因为所有设备共享带宽\",{\"1\":{\"580\":1}}],[\"因为所有通信依赖于主站的正常运行\",{\"1\":{\"153\":2}}],[\"因为传统的网络设置中\",{\"1\":{\"579\":1}}],[\"因为帧在传输过程中可能出现错误\",{\"1\":{\"576\":1}}],[\"因为物理层解决了在不同物理机之间传输比特流的问题\",{\"1\":{\"573\":1}}],[\"因为java的单继承限制\",{\"1\":{\"496\":1}}],[\"因为需要逐级向上查找父加载器是否已加载该类\",{\"1\":{\"758\":1}}],[\"因为需要重新计算所有元素的哈希值并重新分配到新的位置\",{\"1\":{\"685\":1}}],[\"因为需要编写多个测试用例来覆盖不同的分支\",{\"1\":{\"465\":1}}],[\"因为需要定义和实现多个类\",{\"1\":{\"451\":1}}],[\"因为任何错误的修改都可能导致现有功能的破坏\",{\"1\":{\"465\":1}}],[\"因为对象的状态无法在创建后被修改\",{\"1\":{\"450\":1}}],[\"因为每个类或模块只关注一个职责\",{\"1\":{\"461\":1}}],[\"因为每个文法规则都对应一个表达式类\",{\"1\":{\"396\":1}}],[\"因为每次添加新的版本需要修改已有的实现类\",{\"1\":{\"346\":1}}],[\"因为我们都知道嘛\",{\"1\":{\"813\":1}}],[\"因为我们会对每个状态进行独立封装\",{\"1\":{\"360\":1}}],[\"因为我们的网络比较大\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"因为不同的web应用程序可能使用不同版本的类库\",{\"1\":{\"759\":1}}],[\"因为不同类型的报告共用了相同的生成算法框架\",{\"1\":{\"336\":1}}],[\"因为不同网络上的链路可以传输的最大报文大小是不同的\",{\"1\":{\"193\":1}}],[\"因为算法需要在各种不同的平台上运行\",{\"1\":{\"315\":1}}],[\"因为这样会导致异常栈信息错乱\",{\"1\":{\"793\":1}}],[\"因为这样\",{\"1\":{\"694\":1}}],[\"因为这样的路由更具体\",{\"1\":{\"221\":1}}],[\"因为这类数据传输的连续性要比数据的完整性更重要\",{\"1\":{\"301\":1}}],[\"因为udp不拆分报文\",{\"1\":{\"301\":1}}],[\"因为此时通信的实体是各个应用进程\",{\"1\":{\"277\":1}}],[\"因为在某些传输介质中\",{\"1\":{\"619\":1}}],[\"因为在运行时需要使用反射机制来生成代理类和调用方法\",{\"1\":{\"496\":1}}],[\"因为在同一时刻\",{\"1\":{\"274\":1}}],[\"因为在帧的有效数据当中\",{\"1\":{\"132\":1,\"577\":1}}],[\"因为两台网络主机间的真正数据通信主体不是这两台主机\",{\"1\":{\"274\":1}}],[\"因为仅靠网络层把数据传送到目的主机上还是不够的\",{\"1\":{\"274\":1}}],[\"因为报文大小没有限制\",{\"1\":{\"255\":1}}],[\"因为分组是逐个传输\",{\"1\":{\"254\":1}}],[\"因为分组大小固定\",{\"1\":{\"254\":1}}],[\"因为网络设备间大多数使用的是串行传输方式\",{\"1\":{\"234\":1}}],[\"因为网络本身不提供可靠传输服务\",{\"1\":{\"184\":1}}],[\"因为ip数据报文必须封装成帧才能通过物理网络发送\",{\"1\":{\"196\":1}}],[\"因为ip协议是无连接的服务\",{\"1\":{\"192\":1}}],[\"因为\",{\"1\":{\"181\":1,\"316\":1,\"574\":1,\"587\":1,\"683\":1,\"694\":1,\"701\":1,\"813\":1}}],[\"因为它可以重复利用\",{\"1\":{\"852\":1}}],[\"因为它只是保证了可见性\",{\"1\":{\"834\":1}}],[\"因为它只需要对双向链表进行简单的指针调整\",{\"1\":{\"714\":1}}],[\"因为它们通常表示程序无法恢复的严重问题\",{\"1\":{\"793\":1}}],[\"因为它们都与\",{\"1\":{\"316\":1}}],[\"因为它需要对整个堆内存进行遍历和处理\",{\"1\":{\"741\":1}}],[\"因为它的吞吐量比较大\",{\"1\":{\"840\":1}}],[\"因为它的分配和释放内存都是有序的\",{\"1\":{\"724\":1}}],[\"因为它的两个端口不是共享一条背板总线\",{\"1\":{\"171\":1}}],[\"因为它允许设备在需要时将数据包发送到非本地网络\",{\"1\":{\"597\":1}}],[\"因为它允许网络管理员定义一个通用的路径\",{\"1\":{\"205\":1}}],[\"因为它能够在不同端口之间直接连接\",{\"1\":{\"580\":1}}],[\"因为它将多个功能聚合在了一个接口中\",{\"1\":{\"473\":1}}],[\"因为它是一个示例代码\",{\"1\":{\"408\":1}}],[\"因为它没有后继处理器\",{\"1\":{\"350\":1}}],[\"因为它担负了两方面的主要职责\",{\"1\":{\"144\":1}}],[\"因为其他站此时可能有优先级更高的帧需要发送\",{\"1\":{\"152\":1}}],[\"因为下面物理层中建立的物理链路有着很多传输介质的差异\",{\"1\":{\"123\":1}}],[\"因特网的传输层为应用层提供了两种不同的运输协议\",{\"1\":{\"273\":1}}],[\"因特网\",{\"0\":{\"248\":1},\"1\":{\"248\":1}}],[\"因特网采用了这种设计思想\",{\"1\":{\"184\":1}}],[\"因特网邮件访问协议\",{\"0\":{\"98\":1},\"1\":{\"98\":1}}],[\"因特网上所有的isp都有邮件服务器\",{\"1\":{\"90\":1}}],[\"因此我们需要考虑线程池异常情况\",{\"1\":{\"865\":1}}],[\"因此我们需要得到ip地址与mac地址的对应关系\",{\"1\":{\"168\":1,\"583\":1}}],[\"因此程序不可能正常终止\",{\"1\":{\"848\":1}}],[\"因此同步操作也被称为非阻塞同步\",{\"1\":{\"831\":1}}],[\"因此这种同步也被称为阻塞同步\",{\"1\":{\"831\":1}}],[\"因此这类开销积少成多也是一项极为可观的执行成本\",{\"1\":{\"730\":1}}],[\"因此将创建总共\",{\"1\":{\"791\":1}}],[\"因此将传输地址分成网络id\",{\"1\":{\"277\":1}}],[\"因此所有的加载请求最终都应该传送到最顶层的启动类加载器中\",{\"1\":{\"758\":1}}],[\"因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考\",{\"1\":{\"743\":1}}],[\"因此一些资料中它也被称作gc\",{\"1\":{\"722\":1}}],[\"因此按照插入的顺序可以遍历键值对\",{\"1\":{\"703\":1}}],[\"因此不能直接按照键来排序\",{\"1\":{\"703\":1}}],[\"因此更适合长距离传输\",{\"1\":{\"619\":1}}],[\"因此测试变得更加简单\",{\"1\":{\"461\":1}}],[\"因此循环次数是\",{\"1\":{\"316\":1}}],[\"因此也有可能会因为其他主机之间的通信使得网络拥堵\",{\"1\":{\"296\":1}}],[\"因此是可靠传输\",{\"1\":{\"275\":1}}],[\"因此出错概率也会比较小\",{\"1\":{\"254\":1}}],[\"因此传播距离受到限制\",{\"1\":{\"230\":1}}],[\"因此其不能通过电离层反射到很远的地方\",{\"1\":{\"230\":1}}],[\"因此必须将其做成结实的光缆\",{\"1\":{\"230\":1}}],[\"因此称同轴电缆\",{\"1\":{\"230\":1}}],[\"因此可用的主机ip数量是254个\",{\"1\":{\"222\":1}}],[\"因此可以确保复合操作的原子性\",{\"1\":{\"834\":1}}],[\"因此可以按照键的自然顺序或者自定义的比较器来排序\",{\"1\":{\"703\":1}}],[\"因此可以适当把拥塞窗口扩大些\",{\"1\":{\"299\":1}}],[\"因此可以利用运输层的端口号和ip地址一起进行转换\",{\"1\":{\"223\":1}}],[\"因此可以聚合成的聚合地址块172\",{\"1\":{\"221\":1}}],[\"因此可以借用这些违法编码序列来定界帧的起始与终止\",{\"1\":{\"131\":1}}],[\"因此ipv4地址采用点分十进制表示方法以方便用户使用\",{\"1\":{\"215\":1}}],[\"因此发送站还必须有接收站的mac地址\",{\"1\":{\"196\":1}}],[\"因此首先将b的mac地址和ip地址的对应关系记录到自己的高速缓存表中\",{\"1\":{\"168\":1,\"583\":1}}],[\"因此无法封装数据帧\",{\"1\":{\"168\":1,\"583\":1}}],[\"因此广域网首要考虑的问题是通信容量必须足够大\",{\"1\":{\"161\":1}}],[\"因此节点的位置不受物理位置的限制\",{\"1\":{\"159\":1}}],[\"因此现在许多网卡仅装有mac协议而没有llc协议\",{\"1\":{\"158\":1}}],[\"因此需要一个随机时间将他们进行错峰发送\",{\"1\":{\"152\":1}}],[\"因此它需要知道应该释放哪个锁\",{\"1\":{\"813\":1}}],[\"因此它是有序的\",{\"1\":{\"705\":1}}],[\"因此它的时间复杂度是线性阶\",{\"1\":{\"316\":1}}],[\"因此它们都会被搁置直至信道不忙\",{\"1\":{\"152\":1}}],[\"因此它主要与用户应用程序和用户需求相关联\",{\"1\":{\"56\":1}}],[\"因此有difs时间进行缓冲\",{\"1\":{\"152\":1}}],[\"因此在使用时需要慎重考虑性能方面的影响\",{\"1\":{\"800\":1}}],[\"因此在类加载\",{\"1\":{\"725\":1}}],[\"因此在一般情况下\",{\"1\":{\"715\":1}}],[\"因此在遍历时无法保证元素的顺序性\",{\"1\":{\"715\":1}}],[\"因此在多线程环境下提供了线程安全性\",{\"1\":{\"706\":1}}],[\"因此在应用时需根据实际情况权衡利弊\",{\"1\":{\"367\":1}}],[\"因此在时间复杂度分析中\",{\"1\":{\"316\":1}}],[\"因此在数据链路层实现停止\",{\"1\":{\"137\":1}}],[\"因此在转义字符前也加转义字符\",{\"1\":{\"132\":1}}],[\"因此当llc子层从mac子层收到一个数据包时必须能够判断要送给网络层的是哪一个通信协议\",{\"1\":{\"120\":1}}],[\"因此\",{\"1\":{\"81\":1,\"98\":1,\"152\":1,\"208\":1,\"212\":1,\"247\":1,\"262\":1,\"265\":1,\"301\":1,\"316\":1,\"355\":1,\"367\":1,\"469\":1,\"581\":1,\"619\":1,\"683\":1,\"709\":1,\"787\":3,\"788\":2,\"799\":1,\"813\":1,\"842\":1}}],[\"重\",{\"1\":{\"865\":1}}],[\"重排序可以分为编译器重排序和处理器重排序\",{\"1\":{\"827\":1}}],[\"重排序分3种类型\",{\"1\":{\"826\":1}}],[\"重写方法\",{\"1\":{\"869\":1}}],[\"重写call\",{\"1\":{\"806\":1}}],[\"重写run\",{\"1\":{\"806\":2}}],[\"重写了\",{\"1\":{\"788\":1}}],[\"重写只发生在子类覆盖父类的方法的情况下\",{\"1\":{\"780\":1}}],[\"重写\",{\"1\":{\"780\":1,\"788\":5}}],[\"重写就是子类对父类方法的重新改造\",{\"1\":{\"780\":1}}],[\"重写父类方法\",{\"1\":{\"335\":1}}],[\"重载可以发生在同一个类中\",{\"1\":{\"780\":1}}],[\"重载\",{\"1\":{\"780\":1}}],[\"重载一个类中可以有多个同名方法\",{\"1\":{\"780\":1}}],[\"重载和重写都是java中多态的实现方式之一\",{\"1\":{\"780\":1}}],[\"重载和重写都与方法相关\",{\"1\":{\"780\":1}}],[\"重载和重写有什么区别\",{\"0\":{\"780\":1},\"1\":{\"780\":2}}],[\"重用性\",{\"1\":{\"758\":1}}],[\"重用代码库和框架\",{\"1\":{\"485\":1}}],[\"重新去创建一条线程执行\",{\"1\":{\"857\":1}}],[\"重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"746\":1,\"750\":1}}],[\"重新标记\",{\"1\":{\"746\":1}}],[\"重新计算冲突元素的地址\",{\"1\":{\"692\":1}}],[\"重新将其内容设置到表单或页面中\",{\"1\":{\"455\":1}}],[\"重新加载profile\",{\"1\":{\"19\":1,\"45\":1}}],[\"重置按钮通常用于将表单或页面恢复到初始状态\",{\"1\":{\"455\":1}}],[\"重做和排队等功能\",{\"1\":{\"384\":1,\"385\":1}}],[\"重做是指在执行了撤销操作后\",{\"1\":{\"375\":1}}],[\"重做\",{\"1\":{\"375\":1,\"386\":2}}],[\"重点内容\",{\"1\":{\"330\":1}}],[\"重传机制等\",{\"1\":{\"577\":1}}],[\"重传机制\",{\"1\":{\"291\":1}}],[\"重传机制确保了即使出现丢失或损坏\",{\"1\":{\"282\":1}}],[\"重传2\",{\"1\":{\"291\":1}}],[\"重传时间过长\",{\"1\":{\"291\":1}}],[\"重传时间过短\",{\"1\":{\"291\":1}}],[\"重传时间rtts\",{\"1\":{\"291\":1}}],[\"重传\",{\"0\":{\"291\":1}}],[\"重定向\",{\"1\":{\"201\":1}}],[\"重复利用\",{\"1\":{\"857\":1}}],[\"重复的代码只有在处理相同逻辑和功能时才被认为是违反dry原则的\",{\"1\":{\"486\":1}}],[\"重复分组\",{\"1\":{\"254\":1}}],[\"重复或失序的情况\",{\"1\":{\"184\":1}}],[\"重复和失序\",{\"1\":{\"184\":1}}],[\"重复确认\",{\"1\":{\"137\":1}}],[\"重命名等操作\",{\"1\":{\"83\":1}}],[\"删除效率\",{\"1\":{\"679\":1}}],[\"删除可以头部删除\",{\"1\":{\"677\":1,\"678\":1}}],[\"删除和查找\",{\"1\":{\"705\":1}}],[\"删除和查找操作\",{\"1\":{\"705\":1}}],[\"删除和获取子组件的方法\",{\"1\":{\"526\":1}}],[\"删除和通知观察者\",{\"1\":{\"324\":1}}],[\"删除子节点\",{\"1\":{\"524\":1}}],[\"删除子节点等\",{\"1\":{\"524\":1}}],[\"删除结果\",{\"1\":{\"497\":1}}],[\"删除语句\",{\"1\":{\"497\":1}}],[\"删除文件等\",{\"1\":{\"86\":1}}],[\"删除等\",{\"1\":{\"86\":1}}],[\"删除\",{\"1\":{\"83\":1,\"685\":1,\"698\":1,\"704\":1,\"709\":1}}],[\"分析会占比较大的内存\",{\"1\":{\"769\":1}}],[\"分析是否有同类型对象频繁晋升到老年代\",{\"1\":{\"767\":1}}],[\"分析内存使用情况\",{\"1\":{\"767\":1}}],[\"分析\",{\"1\":{\"766\":1}}],[\"分多次做完\",{\"1\":{\"750\":1}}],[\"分代年龄\",{\"1\":{\"729\":1}}],[\"分代年龄等\",{\"1\":{\"726\":1}}],[\"分代年龄等信息\",{\"1\":{\"726\":1}}],[\"分段锁的设计\",{\"1\":{\"711\":1}}],[\"分段锁来保证安全\",{\"1\":{\"711\":1}}],[\"分\",{\"1\":{\"502\":9}}],[\"分为两个模块\",{\"1\":{\"749\":1}}],[\"分为强引用\",{\"1\":{\"735\":1}}],[\"分为\",{\"1\":{\"494\":1}}],[\"分为三大类\",{\"1\":{\"490\":1}}],[\"分为以下三种情况\",{\"1\":{\"174\":1}}],[\"分裂\",{\"1\":{\"316\":1}}],[\"分裂两轮后变为\",{\"1\":{\"316\":1}}],[\"分裂一轮后变为\",{\"1\":{\"316\":1}}],[\"分别为\",{\"1\":{\"810\":1}}],[\"分别为继承thread类\",{\"1\":{\"806\":1}}],[\"分别用于不同的目的\",{\"1\":{\"788\":1}}],[\"分别表示狗和猫\",{\"1\":{\"469\":1}}],[\"分别是大于10并且小于20的结果为\",{\"1\":{\"395\":1}}],[\"分别实现了state接口\",{\"1\":{\"359\":1}}],[\"分别实现了支付宝支付\",{\"1\":{\"344\":1}}],[\"分别处理get\",{\"1\":{\"338\":1}}],[\"分别接收到事件\",{\"1\":{\"326\":1}}],[\"分别使用两种方式统计时间复杂度\",{\"1\":{\"314\":1}}],[\"分别有一条独立的交换信道\",{\"1\":{\"171\":1}}],[\"分散空间存储\",{\"1\":{\"312\":1}}],[\"分散性\",{\"1\":{\"206\":1}}],[\"分布上成等差数列的漏洞\",{\"1\":{\"694\":1}}],[\"分布是源端口和目的端口\",{\"1\":{\"301\":1}}],[\"分布式协调功能dcf\",{\"1\":{\"152\":1}}],[\"分用时\",{\"1\":{\"301\":1}}],[\"分用保证了数据能够正确地交付给目标应用程序\",{\"1\":{\"280\":1}}],[\"分用依赖于端口号\",{\"1\":{\"280\":1}}],[\"分用是根据协议字段的值\",{\"1\":{\"280\":1}}],[\"分用\",{\"1\":{\"280\":1}}],[\"分层举例\",{\"1\":{\"268\":1}}],[\"分层的必要性和各层需要解决的问题\",{\"1\":{\"268\":1}}],[\"分配重试的方式来保证更新操作的原子性\",{\"1\":{\"728\":1}}],[\"分配新的缓存区时才需要同步锁定\",{\"1\":{\"728\":1}}],[\"分配内存空间\",{\"1\":{\"826\":1}}],[\"分配内存\",{\"1\":{\"720\":1,\"726\":1}}],[\"分配子网的地址范围\",{\"1\":{\"596\":1}}],[\"分配子网\",{\"1\":{\"596\":1}}],[\"分配的资源始终被占用\",{\"1\":{\"253\":1}}],[\"分配通信资源\",{\"1\":{\"253\":1}}],[\"分配不同大小的ip地址块\",{\"1\":{\"222\":1}}],[\"分配其他网络配置参数\",{\"1\":{\"62\":1}}],[\"分级路由算法\",{\"1\":{\"206\":1,\"211\":1}}],[\"分组和路由\",{\"1\":{\"593\":1}}],[\"分组是同类概念\",{\"1\":{\"278\":1}}],[\"分组是通过转发表进行转发的\",{\"1\":{\"162\":1}}],[\"分组在进过网络传输时\",{\"1\":{\"263\":1}}],[\"分组到达目的结点时\",{\"1\":{\"254\":1}}],[\"分组头部信息\",{\"1\":{\"254\":1}}],[\"分组头部必须携带目的主机的完整地址\",{\"1\":{\"184\":1}}],[\"分组比报文小\",{\"1\":{\"254\":1}}],[\"分组交换组成和流程\",{\"1\":{\"254\":1}}],[\"分组交换\",{\"0\":{\"254\":1},\"1\":{\"254\":1}}],[\"分组\",{\"1\":{\"210\":6}}],[\"分组可能出现误码\",{\"1\":{\"184\":1}}],[\"分组可以走不同的路径\",{\"1\":{\"184\":1}}],[\"分类编址的ipv4\",{\"0\":{\"217\":1},\"1\":{\"217\":1}}],[\"分类编址\",{\"1\":{\"215\":1}}],[\"分类\",{\"0\":{\"121\":1,\"258\":1}}],[\"分类管理等\",{\"1\":{\"98\":1}}],[\"分享\",{\"1\":{\"83\":1}}],[\"硬\",{\"1\":{\"83\":1}}],[\"企业相关管理者和运营者一定要做好域名及域名解析的安全防护工作\",{\"1\":{\"81\":1}}],[\"主次版本号是否在当前虚拟机范围内\",{\"1\":{\"754\":1}}],[\"主线程countdown\",{\"1\":{\"851\":1}}],[\"主线程await\",{\"1\":{\"851\":1}}],[\"主线程通过countdownlatch\",{\"1\":{\"851\":1}}],[\"主线程\",{\"1\":{\"721\":1,\"822\":1}}],[\"主题和观察者可以在不同的场景中被重用\",{\"1\":{\"328\":1}}],[\"主题和观察者之间的松散耦合使得它们可以独立变化\",{\"1\":{\"328\":1}}],[\"主题接口\",{\"1\":{\"325\":1}}],[\"主题\",{\"1\":{\"324\":1,\"539\":1}}],[\"主题维护一份观察者列表\",{\"1\":{\"323\":1}}],[\"主动探测接收方窗口变化\",{\"1\":{\"294\":1}}],[\"主动关闭tcp连接\",{\"1\":{\"286\":2}}],[\"主动发起连接建立的应用进程叫做客户\",{\"1\":{\"284\":1}}],[\"主动模式\",{\"1\":{\"85\":1}}],[\"主机数量以及对网络管理和安全性的需求\",{\"1\":{\"596\":1}}],[\"主机可能丢失分组\",{\"1\":{\"294\":1}}],[\"主机分配的端口三部分\",{\"1\":{\"277\":1}}],[\"主机id\",{\"1\":{\"277\":1}}],[\"主机id部分全是0表示\",{\"1\":{\"216\":1}}],[\"主机b与路由器2\",{\"1\":{\"275\":1}}],[\"主机\",{\"1\":{\"268\":1}}],[\"主机和web服务器之间基于网络的通信\",{\"1\":{\"268\":1}}],[\"主机编址问题\",{\"1\":{\"268\":1}}],[\"主机编号\",{\"1\":{\"167\":1}}],[\"主机或路由器在收到分组时要花费一定时间进行处理\",{\"1\":{\"263\":1}}],[\"主机或路由器发送数据帧所需要的时间\",{\"1\":{\"263\":1}}],[\"主机或路由器使用icmp来发送差错报告报文和询问报文\",{\"1\":{\"200\":1}}],[\"主机全0\",{\"1\":{\"220\":1}}],[\"主机号\",{\"1\":{\"279\":1}}],[\"主机号+端口号\",{\"1\":{\"279\":1}}],[\"主机号全为1\",{\"1\":{\"220\":1}}],[\"主机号全为0\",{\"1\":{\"220\":1}}],[\"主机号12位\",{\"1\":{\"220\":1}}],[\"主机所在子网的网络地址为\",{\"1\":{\"218\":1}}],[\"主机是否可达\",{\"1\":{\"200\":1}}],[\"主机a向主机b发送数据\",{\"1\":{\"198\":1}}],[\"主机更换了网卡\",{\"1\":{\"174\":1}}],[\"主机访问文档时\",{\"1\":{\"114\":1}}],[\"主节点故障则整个网络瘫痪\",{\"1\":{\"153\":1}}],[\"主结点轮流\",{\"1\":{\"153\":1}}],[\"主体\",{\"1\":{\"91\":1}}],[\"主域名\",{\"0\":{\"80\":1}}],[\"主要优势在于有效地管理和复用线程资源\",{\"1\":{\"858\":1}}],[\"主要的实现逻辑包括\",{\"1\":{\"839\":1}}],[\"主要依赖于\",{\"1\":{\"839\":1}}],[\"主要关注的是两个要素\",{\"1\":{\"819\":1}}],[\"主要在于理解其功能以及java对象的锁机制\",{\"1\":{\"813\":1}}],[\"主要在rip\",{\"1\":{\"207\":1}}],[\"主要使用在哈希表中\",{\"1\":{\"785\":1}}],[\"主要原因如下\",{\"1\":{\"778\":1}}],[\"主要有四种\",{\"1\":{\"859\":1}}],[\"主要有四种类加载器\",{\"1\":{\"756\":1}}],[\"主要有以下操作步骤\",{\"1\":{\"769\":1}}],[\"主要有以下4大类\",{\"1\":{\"158\":1}}],[\"主要是通过处理器的指令来保证操作的原⼦性的\",{\"1\":{\"845\":1}}],[\"主要是\",{\"1\":{\"754\":1}}],[\"主要是为了避免二义性\",{\"1\":{\"712\":1}}],[\"主要是为了将复杂的网络系统分解成若干个相对独立\",{\"1\":{\"268\":1}}],[\"主要针\",{\"1\":{\"754\":1}}],[\"主要存放存活时间较长的对象\",{\"1\":{\"737\":1}}],[\"主要处理\",{\"1\":{\"580\":2}}],[\"主要区别在于线程安全性\",{\"1\":{\"706\":1}}],[\"主要区别在于\",{\"1\":{\"574\":1}}],[\"主要区别如下\",{\"1\":{\"386\":1}}],[\"主要用于老年代\",{\"1\":{\"744\":1}}],[\"主要用于存储已被虚拟机加载的类型信息\",{\"1\":{\"722\":1}}],[\"主要用于以太网局域网中\",{\"1\":{\"581\":1}}],[\"主要用于局域网内部的数据交换和转发\",{\"1\":{\"580\":1}}],[\"主要用于解决不兼容接口之间的问题\",{\"1\":{\"508\":1}}],[\"主要用于网络层的错误处理和状态通知\",{\"1\":{\"200\":1}}],[\"主要倾向于增强对象的功能\",{\"1\":{\"500\":1}}],[\"主要倾向于控制对对象的访问\",{\"1\":{\"500\":1}}],[\"主要分为\",{\"1\":{\"453\":1}}],[\"主要分为分为两种\",{\"1\":{\"144\":1}}],[\"主要作用是防止originator以外的对象访问备忘录\",{\"1\":{\"377\":1}}],[\"主要解决了内存碎片过多的问题\",{\"1\":{\"751\":1}}],[\"主要解决应用程序与网络之间的交互问题\",{\"1\":{\"268\":1}}],[\"主要解决进程之间基于网络的通信问题\",{\"1\":{\"268\":1}}],[\"主要解决数据路由\",{\"1\":{\"268\":1}}],[\"主要解决帧的定界\",{\"1\":{\"268\":1}}],[\"主要解决物理传输介质\",{\"1\":{\"268\":1}}],[\"主要功能\",{\"0\":{\"190\":1,\"196\":1,\"200\":1},\"1\":{\"200\":1,\"573\":1}}],[\"主要功能包括\",{\"1\":{\"158\":1}}],[\"主要侧重点\",{\"1\":{\"162\":1}}],[\"主要特点\",{\"0\":{\"156\":1}}],[\"主要过程包括\",{\"0\":{\"124\":1}}],[\"主要和两家接口相关\",{\"1\":{\"670\":1}}],[\"主要和用户应用程序有关\",{\"1\":{\"56\":1}}],[\"主要和什么有关\",{\"1\":{\"56\":1}}],[\"主要任务\",{\"0\":{\"56\":1,\"180\":1,\"273\":1},\"1\":{\"56\":1}}],[\"询问报文类型\",{\"1\":{\"201\":1}}],[\"询问报文\",{\"1\":{\"201\":1}}],[\"询问是否有数据要发送\",{\"1\":{\"153\":1}}],[\"询问权威域名\",{\"0\":{\"80\":1}}],[\"询问顶级域名服务器\",{\"0\":{\"79\":1}}],[\"询问根域名服务器\",{\"0\":{\"78\":1}}],[\"为何要将\",{\"1\":{\"789\":1}}],[\"为我办事\",{\"1\":{\"782\":1}}],[\"为\",{\"1\":{\"764\":1,\"818\":1}}],[\"为每个\",{\"1\":{\"760\":1}}],[\"为每种具体元素对象提供具体的访问操作\",{\"1\":{\"371\":1}}],[\"为类的静态变量分配内存并将其初始化为默认值\",{\"1\":{\"754\":1}}],[\"为类变量\",{\"1\":{\"720\":1}}],[\"为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知\",{\"1\":{\"735\":1}}],[\"为一个单位所拥有\",{\"1\":{\"156\":1}}],[\"为例进行介绍\",{\"1\":{\"707\":1}}],[\"为例\",{\"1\":{\"694\":1}}],[\"为互联网上的各种网络和设备提供了连接和通信的能力\",{\"1\":{\"593\":1}}],[\"为客户端提供一个简单的接口来预订酒店房间\",{\"1\":{\"517\":1}}],[\"为特定方法或特定场景添加额外的功能\",{\"1\":{\"497\":1}}],[\"为原始对象的能力提高增强\",{\"1\":{\"494\":1}}],[\"为空\",{\"1\":{\"436\":1}}],[\"为传输流中的每一个字节进行编号\",{\"1\":{\"289\":1}}],[\"为没有熟知端口号的应用程序使用的\",{\"1\":{\"279\":1}}],[\"为确保所有的传输地址在整个网络中是唯一的\",{\"1\":{\"277\":1}}],[\"为运行在不同主机上的上层应用进程提供直接的通信服务\",{\"1\":{\"273\":1}}],[\"为保持同步\",{\"1\":{\"236\":1}}],[\"为实现远距离通信\",{\"1\":{\"230\":1}}],[\"为11111111\",{\"1\":{\"218\":1}}],[\"为什么volatile不能保证原子性\",{\"0\":{\"829\":1},\"1\":{\"829\":1}}],[\"为什么重写\",{\"0\":{\"788\":1},\"1\":{\"788\":2}}],[\"为什么还要引入\",{\"1\":{\"751\":1}}],[\"为什么还要传回\",{\"0\":{\"641\":1}}],[\"为什么使用\",{\"1\":{\"725\":1}}],[\"为什么使用元空间替代永久代作为方法区的实现\",{\"0\":{\"725\":1}}],[\"为什么扩容因子是0\",{\"0\":{\"696\":1},\"1\":{\"696\":1}}],[\"为什么哈希\",{\"0\":{\"694\":1},\"1\":{\"694\":1}}],[\"为什么hashmap链表转红黑树的阈值为8呢\",{\"0\":{\"697\":1},\"1\":{\"697\":1}}],[\"为什么hashmap\",{\"0\":{\"688\":1},\"1\":{\"688\":1}}],[\"为什么最arraylist不直接序列化元素数组呢\",{\"1\":{\"680\":1}}],[\"为什么\",{\"0\":{\"663\":1,\"712\":1,\"813\":1},\"1\":{\"712\":1,\"813\":3}}],[\"为什么不用二叉树\",{\"0\":{\"698\":1},\"1\":{\"698\":1}}],[\"为什么不用继承实现呢\",{\"1\":{\"500\":1}}],[\"为什么不能是两次握手\",{\"0\":{\"639\":1}}],[\"为什么有了\",{\"0\":{\"601\":1},\"1\":{\"751\":1}}],[\"为什么要引入g1\",{\"1\":{\"751\":1}}],[\"为什么要引入\",{\"0\":{\"748\":1},\"1\":{\"748\":2}}],[\"为什么要停顿\",{\"0\":{\"747\":1}}],[\"为什么要进行空间担保\",{\"1\":{\"743\":1}}],[\"为什么要维护\",{\"1\":{\"710\":1}}],[\"为什么要使用static修饰\",{\"1\":{\"816\":1}}],[\"为什么要使用\",{\"1\":{\"758\":2}}],[\"为什么要使用元空间替代永久代作为方法区的实现呢\",{\"1\":{\"725\":1}}],[\"为什么要使用集合\",{\"0\":{\"673\":1},\"1\":{\"673\":1}}],[\"为什么要使用它\",{\"0\":{\"549\":1}}],[\"为什么要用\",{\"0\":{\"665\":1}}],[\"为什么要有线程池\",{\"0\":{\"857\":1},\"1\":{\"857\":1}}],[\"为什么要有hashcode\",{\"1\":{\"787\":1}}],[\"为什么要有调制\",{\"1\":{\"619\":1}}],[\"为什么要有\",{\"1\":{\"619\":1}}],[\"为什么要有端口号\",{\"1\":{\"279\":1}}],[\"为什么要有子网掩码\",{\"1\":{\"216\":1}}],[\"为什么叫端到端服务呢\",{\"1\":{\"275\":1}}],[\"为什么需要等待\",{\"0\":{\"646\":1}}],[\"为什么需要传输层\",{\"1\":{\"274\":1}}],[\"为什么需要网络层\",{\"1\":{\"181\":1}}],[\"为什么需要\",{\"0\":{\"181\":1,\"274\":1}}],[\"为其报文头部添加一些网络层协议控制信息封装成数据包\",{\"1\":{\"186\":1,\"591\":1}}],[\"为网络间通信提供路由选择\",{\"0\":{\"185\":1,\"590\":1}}],[\"为网络层提供服务\",{\"1\":{\"120\":1}}],[\"为网络层服务\",{\"1\":{\"120\":1}}],[\"为不同主机提供通信服务\",{\"1\":{\"178\":1,\"180\":1,\"587\":1}}],[\"为使发送方尽早重传\",{\"1\":{\"137\":1}}],[\"为了应对一些特殊场景\",{\"1\":{\"832\":1}}],[\"为了实现volatile的内存语义\",{\"1\":{\"827\":1}}],[\"为了提高性能\",{\"1\":{\"826\":1}}],[\"为了解决这个问题\",{\"1\":{\"759\":1}}],[\"为了确保解析动作能正确执行\",{\"1\":{\"754\":1}}],[\"为了保证多线程下\",{\"1\":{\"844\":1}}],[\"为了保证应用程序的稳定有序\",{\"1\":{\"758\":1}}],[\"为了保证对象引用更新的正确性\",{\"1\":{\"747\":1}}],[\"为了保持保持平衡\",{\"1\":{\"698\":1}}],[\"为了保持平衡\",{\"1\":{\"698\":1}}],[\"为了降低内存的消耗\",{\"1\":{\"744\":1}}],[\"为了找出该区域中的存活对象\",{\"1\":{\"742\":1}}],[\"为了能更好地适应不同程序的内存状况\",{\"1\":{\"740\":1}}],[\"为了方便哈希取余\",{\"1\":{\"688\":1}}],[\"为了正确地恢复出信号\",{\"1\":{\"622\":1}}],[\"为了简化订单处理系统的复杂性\",{\"1\":{\"518\":1}}],[\"为了处理商品和销售渠道之间的关系\",{\"1\":{\"506\":1}}],[\"为了遵循接口隔离原则\",{\"1\":{\"473\":1}}],[\"为了将资源的创建过程与资源加载器解耦\",{\"1\":{\"429\":1}}],[\"为了运行测试\",{\"1\":{\"408\":1}}],[\"为了测试代码\",{\"1\":{\"403\":1}}],[\"为了避免错误\",{\"1\":{\"854\":1}}],[\"为了避免创建多个对象\",{\"1\":{\"817\":1}}],[\"为了避免频繁扩容带来的性能开销\",{\"1\":{\"685\":1}}],[\"为了避免在每次通信时都进行arp请求\",{\"1\":{\"583\":1}}],[\"为了避免并发修改问题\",{\"1\":{\"367\":1}}],[\"为了避免这种耦合\",{\"1\":{\"346\":1}}],[\"为了在\",{\"1\":{\"296\":1}}],[\"为了使该示例代码正常运行\",{\"1\":{\"498\":1}}],[\"为了使运行不同操作系统的计算机的应用进程之间能进行网络通信\",{\"1\":{\"279\":1}}],[\"为了使我们要传输的数据报能在不同网络中传输\",{\"1\":{\"193\":1}}],[\"为了减少路由表的大小\",{\"1\":{\"221\":1}}],[\"为了减小时延\",{\"1\":{\"111\":1}}],[\"为了更有效地转发ip数据报和提高交付成功的机会\",{\"1\":{\"200\":1}}],[\"为了防止环路\",{\"1\":{\"175\":1}}],[\"为了防止将这些字符当中帧定界的字符\",{\"1\":{\"132\":1,\"577\":1}}],[\"为了让用户感觉多个线程是在同时执行的\",{\"1\":{\"809\":1}}],[\"为了让发送方能够判断所收到的ack分组是否是重复的\",{\"1\":{\"137\":1}}],[\"为了让接收方能够判断所收到的数据分组是否是重复的\",{\"1\":{\"137\":1}}],[\"为了达到这种功能\",{\"1\":{\"120\":1}}],[\"为llc子层服务\",{\"1\":{\"120\":1}}],[\"为辅根域名服务器\",{\"1\":{\"78\":1}}],[\"为此\",{\"1\":{\"58\":1}}],[\"其总是认为\",{\"1\":{\"831\":1}}],[\"其含义是\",{\"1\":{\"807\":1,\"811\":1}}],[\"其内部定义了一个节点类node\",{\"1\":{\"846\":1}}],[\"其内部调用的是\",{\"1\":{\"807\":1}}],[\"其内部的帧交换表是通过自学习算法自动地逐渐建立起来的\",{\"1\":{\"173\":1}}],[\"其后可接零个或多个\",{\"1\":{\"795\":1}}],[\"其作用是将指定的字符串对象的引用保存在字符串常量池中\",{\"1\":{\"791\":1}}],[\"其作用是已知设备所分配到的ip地址\",{\"1\":{\"168\":1,\"583\":1}}],[\"其区别只是虚拟机栈为虚拟机执行\",{\"1\":{\"722\":1}}],[\"其发展历史分为经典以太网和交换式以太网两个阶段\",{\"1\":{\"578\":1}}],[\"其工作流程包括四个步骤\",{\"1\":{\"578\":1}}],[\"其结构在以太网帧的基础上增加了vlan标签\",{\"1\":{\"575\":1}}],[\"其大致流程如下\",{\"1\":{\"494\":1}}],[\"其核心就是\",{\"1\":{\"494\":1}}],[\"其好处主要体现在以下几个方面\",{\"1\":{\"461\":1}}],[\"其它的原子操作类基本都是大同小异\",{\"1\":{\"847\":1}}],[\"其它线程就会在获取失败后被阻塞\",{\"1\":{\"846\":1}}],[\"其它线程无法获取主内存中的共享变量\",{\"1\":{\"836\":1}}],[\"其它线程能够立即知道这个修改\",{\"1\":{\"825\":1}}],[\"其它\",{\"1\":{\"367\":1}}],[\"其相关依赖对象都能得到通知并自动更新\",{\"1\":{\"322\":1}}],[\"其组织方式不受固定顺序的限制\",{\"1\":{\"311\":1}}],[\"其实这是一种无锁操作\",{\"1\":{\"845\":1}}],[\"其实是两把锁\",{\"1\":{\"842\":1}}],[\"其实谷歌的开发工具包\",{\"1\":{\"831\":1}}],[\"其实它是没有实现map接口的\",{\"1\":{\"819\":1}}],[\"其实在\",{\"1\":{\"810\":1}}],[\"其实支持两个编码方案\",{\"1\":{\"789\":1}}],[\"其实就是说每个region他都是属于新生代或者老年代的\",{\"1\":{\"749\":1}}],[\"其实只要\",{\"1\":{\"297\":1}}],[\"其实并不是这样的\",{\"1\":{\"275\":1}}],[\"其主要目的是避免在网络中发生拥塞\",{\"1\":{\"296\":1}}],[\"其主要功能包括逻辑链路的建立和释放\",{\"1\":{\"120\":1}}],[\"其主要功能包括\",{\"1\":{\"120\":1}}],[\"其次会为代码块插入指令monitorenter\",{\"1\":{\"843\":1}}],[\"其次从解决问题的方式上来看\",{\"1\":{\"832\":1}}],[\"其次在\",{\"1\":{\"832\":1}}],[\"其次它的底层实现原理是\",{\"1\":{\"832\":1}}],[\"其次我的rpc也使用了\",{\"1\":{\"817\":1}}],[\"其次我们可以通过其提供get和set方法设置\",{\"1\":{\"816\":1}}],[\"其次java对象由对象头\",{\"1\":{\"813\":1}}],[\"其次可以查看代码优化对象的生命周期\",{\"1\":{\"767\":1}}],[\"其次关于操作过程中的一些问题\",{\"1\":{\"673\":1}}],[\"其次通过校验和\",{\"1\":{\"573\":1}}],[\"其次责任链模式在工作中的应用非常广泛\",{\"1\":{\"355\":1}}],[\"其次\",{\"1\":{\"294\":1,\"486\":1}}],[\"其所传输数据的\",{\"1\":{\"261\":1}}],[\"其与utp相比增加了金属丝编织的屏蔽层\",{\"1\":{\"230\":1}}],[\"其任务是长距离运送主机所发送的数据\",{\"1\":{\"161\":1}}],[\"其信号强度的动态范围非常大\",{\"1\":{\"152\":1}}],[\"其他线程无法同时访问被锁定的资源\",{\"1\":{\"834\":1}}],[\"其他线程可以立即看到最新值\",{\"1\":{\"834\":1}}],[\"其他线程能够立即看到这个修改后的值\",{\"1\":{\"814\":1}}],[\"其他线程调用了线程a的\",{\"1\":{\"807\":1}}],[\"其他时候不要来占用cpu资源\",{\"1\":{\"813\":1}}],[\"其他\",{\"1\":{\"812\":1}}],[\"其他几个运行时区域都有发生内存溢出\",{\"1\":{\"731\":1}}],[\"其他部位特别短\",{\"1\":{\"685\":1,\"686\":1}}],[\"其他人必须等待\",{\"1\":{\"582\":1}}],[\"其他点next即可\",{\"1\":{\"538\":1}}],[\"其他订单处理逻辑\",{\"1\":{\"518\":1}}],[\"其他方法\",{\"1\":{\"497\":1}}],[\"其他方法的实现省略\",{\"1\":{\"481\":1}}],[\"其他对象可以通过该访问点获取单例类的实例\",{\"1\":{\"418\":1}}],[\"其他代码\",{\"1\":{\"346\":1}}],[\"其他项的影响都可以忽略\",{\"1\":{\"316\":1}}],[\"其他的需要两条\",{\"1\":{\"237\":1}}],[\"其他分组的确认将被丢弃\",{\"1\":{\"138\":1}}],[\"其他各层均可选择实现可靠传输\",{\"1\":{\"136\":1}}],[\"其他什么也不做\",{\"1\":{\"136\":1}}],[\"其他用户才可能与同一个接收端进行数据传输\",{\"1\":{\"125\":1}}],[\"其中元空间被打满\",{\"1\":{\"768\":1}}],[\"其中元素之间存在一个对应关系\",{\"1\":{\"311\":1}}],[\"其中年轻代\",{\"1\":{\"741\":1}}],[\"其中又分为\",{\"1\":{\"738\":1}}],[\"其中一些常见的数据帧包括\",{\"1\":{\"575\":1}}],[\"其中一个典型的例子是网站数据统计\",{\"1\":{\"372\":1}}],[\"其中的设备可以相互通信\",{\"1\":{\"579\":1}}],[\"其中的\",{\"1\":{\"472\":1}}],[\"其中有两个类\",{\"1\":{\"461\":1}}],[\"其中有多个用户参与聊天\",{\"1\":{\"405\":1}}],[\"其中多个用户之间进行实时聊天\",{\"1\":{\"405\":1}}],[\"其中订单的创建\",{\"1\":{\"333\":1}}],[\"其中通用的处理步骤在抽象类中实现\",{\"1\":{\"333\":1}}],[\"其中\",{\"1\":{\"326\":1,\"372\":1,\"383\":1,\"395\":1,\"404\":1,\"409\":1,\"525\":1,\"848\":1}}],[\"其中定义了加入聊天群\",{\"1\":{\"325\":1}}],[\"其中需要选择传送的最佳路径\",{\"1\":{\"274\":1}}],[\"其中包括订单\",{\"1\":{\"489\":1}}],[\"其中包括\",{\"1\":{\"450\":1}}],[\"其中包括一个网络地址和一个广播地址\",{\"1\":{\"222\":1}}],[\"其中包含一些通用的销售渠道属性和方法\",{\"1\":{\"506\":1}}],[\"其中包含一些通用的商品属性和方法\",{\"1\":{\"506\":1}}],[\"其中包含一个列表\",{\"1\":{\"372\":1}}],[\"其中包含一个接受访问者的方法accept\",{\"1\":{\"372\":1}}],[\"其中包含一个\",{\"1\":{\"344\":1}}],[\"其中包含一个模板方法generatereport\",{\"1\":{\"336\":1}}],[\"其中包含订单信息和关联的商品和客户对象\",{\"1\":{\"455\":1}}],[\"其中包含各个构建步骤的方法\",{\"1\":{\"448\":1}}],[\"其中包含消息传递的方法\",{\"1\":{\"406\":1}}],[\"其中包含类似visitmuseum\",{\"1\":{\"372\":1}}],[\"其中包含不同类型的报告\",{\"1\":{\"336\":1}}],[\"其中包含了构建电脑对象所需的方法\",{\"1\":{\"448\":1}}],[\"其中包含了一个模板方法和若干抽象方法\",{\"1\":{\"332\":1}}],[\"其中包含了算法的模板\",{\"1\":{\"331\":1}}],[\"其中包含了算法的基本骨架\",{\"1\":{\"330\":1,\"332\":1}}],[\"其中包含了ip地址和相关配置信息\",{\"1\":{\"64\":1}}],[\"其中包含自己的mac地址\",{\"1\":{\"168\":1,\"583\":1}}],[\"其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒\",{\"1\":{\"201\":1}}],[\"其中选择的端口称为根端口\",{\"1\":{\"175\":1}}],[\"其中前两种方法主要用于总线形局域网\",{\"1\":{\"158\":1}}],[\"其中双绞线为主流传输介质\",{\"1\":{\"158\":1}}],[\"其中最重要的是介质访问控制方式\",{\"1\":{\"157\":1}}],[\"其中最显著的改进之一是引入了多路复用\",{\"1\":{\"113\":1}}],[\"其中帧有大小限制\",{\"1\":{\"130\":1}}],[\"其中记录了上次文档的修改时间\",{\"1\":{\"114\":1}}],[\"其功能是发送和接收邮件\",{\"1\":{\"90\":1}}],[\"其余动作完全由虚拟机主导和控制\",{\"1\":{\"754\":1}}],[\"其余部分保持以太网帧的结构\",{\"1\":{\"575\":1}}],[\"其余\",{\"1\":{\"78\":1}}],[\"个参数\",{\"1\":{\"845\":1}}],[\"个槽位中\",{\"1\":{\"820\":1}}],[\"个字符串对象\",{\"1\":{\"791\":2}}],[\"个字节\",{\"1\":{\"777\":1,\"789\":1}}],[\"个数\",{\"1\":{\"780\":1}}],[\"个或若干个字符\",{\"1\":{\"777\":1}}],[\"个对象的内存地址是否相等\",{\"1\":{\"785\":1}}],[\"个对象非常多\",{\"1\":{\"769\":1}}],[\"个对象类型\",{\"1\":{\"766\":1}}],[\"个人理解\",{\"1\":{\"342\":1}}],[\"个人简介\",{\"0\":{\"0\":1}}],[\"个互不重复的元素\",{\"1\":{\"316\":1}}],[\"个细胞\",{\"1\":{\"316\":2}}],[\"个打印操作\",{\"1\":{\"316\":1}}],[\"个ip地址\",{\"1\":{\"222\":1}}],[\"个\",{\"1\":{\"218\":1,\"316\":2}}],[\"个主根域名服务器\",{\"1\":{\"78\":1}}],[\"台根域名服务器\",{\"1\":{\"78\":1}}],[\"则以原子方式将引用值和印戳标志的值更新为给定的更新值\",{\"1\":{\"845\":1}}],[\"则以上函数的操作数量为\",{\"1\":{\"316\":1}}],[\"则根据锁的公平性策略将当前线程加入到等待队列中\",{\"1\":{\"839\":1}}],[\"则更适合在对象级别实现线程安全的数据共享\",{\"1\":{\"816\":1}}],[\"则必须跟一个\",{\"1\":{\"795\":1}}],[\"则必须在除最后一个路由器外的其他路由器上依次配置到达相同目的节点或目的网络的静态路由\",{\"1\":{\"205\":1}}],[\"则该方法返回的信息与\",{\"1\":{\"794\":1}}],[\"则改为进行一次full\",{\"1\":{\"743\":1}}],[\"则尝试进行一次minor\",{\"1\":{\"743\":1}}],[\"则虚拟机会查看handlepromotionfailure设置值是否允许担保失败\",{\"1\":{\"743\":1}}],[\"则此次minor\",{\"1\":{\"743\":1}}],[\"则此时会出现\",{\"1\":{\"294\":1}}],[\"则可以判定为无用类\",{\"1\":{\"733\":1}}],[\"则重新开始购买流程\",{\"1\":{\"728\":1}}],[\"则重复之前发送的那个数据分组\",{\"1\":{\"137\":1}}],[\"则异常不会抛出\",{\"1\":{\"709\":1}}],[\"则需要把链表转换为红黑树\",{\"1\":{\"695\":1}}],[\"则需要使用调制\",{\"1\":{\"239\":1}}],[\"则是\",{\"1\":{\"812\":1}}],[\"则是一个固定的\",{\"1\":{\"683\":1}}],[\"则是将模拟信号转换回数字信号的过程\",{\"1\":{\"619\":1}}],[\"则首先将当前容器复制一份\",{\"1\":{\"682\":1}}],[\"则立即停止发送并发送干扰信号通知其他设备\",{\"1\":{\"578\":1}}],[\"则拒绝访问\",{\"1\":{\"495\":1}}],[\"则调用实际的敏感操作类执行敏感操作\",{\"1\":{\"495\":1}}],[\"则执行实际的数据库查询\",{\"1\":{\"495\":1}}],[\"则侧重于接口的设计\",{\"1\":{\"474\":1}}],[\"则返回默认前缀\",{\"1\":{\"436\":1}}],[\"则抛出一个\",{\"1\":{\"422\":1}}],[\"则创建一个默认的\",{\"1\":{\"422\":1}}],[\"则创建一个新实例并返回\",{\"1\":{\"418\":1}}],[\"则直接将自己挂起\",{\"1\":{\"837\":1}}],[\"则直接插入即可否则需要覆盖\",{\"1\":{\"695\":1}}],[\"则直接返回现有实例\",{\"1\":{\"418\":1}}],[\"则直接转发\",{\"1\":{\"159\":1}}],[\"则进行处理并结束\",{\"1\":{\"350\":1}}],[\"则进行处理\",{\"1\":{\"348\":1,\"350\":1}}],[\"则进入根服务器进行查询\",{\"1\":{\"78\":1}}],[\"则进入路由器缓存中检查\",{\"1\":{\"76\":1}}],[\"则下次发送大小为4\",{\"1\":{\"298\":1}}],[\"则在所发送的第一个比特即将到达终点时\",{\"1\":{\"264\":1}}],[\"则在第一次扫描时在标志位前面加一个转义字符帮助区分哪个是真正的帧头\",{\"1\":{\"132\":1}}],[\"则网卡发送完该数据块需要多长时间\",{\"1\":{\"260\":1}}],[\"则每个码元可携带的比特数量为log2x\",{\"1\":{\"240\":1}}],[\"则传播距离可增大到100公里\",{\"1\":{\"230\":1}}],[\"则选择网络前缀最长的那条\",{\"1\":{\"221\":1}}],[\"则目的地址可以是\",{\"1\":{\"218\":1}}],[\"则认为该邻居路由器不可达\",{\"1\":{\"210\":1}}],[\"则这些路由器间就会自动生成这些路由器直接连接的网络间的路由表项\",{\"1\":{\"206\":1}}],[\"则被路由器转发\",{\"1\":{\"205\":1}}],[\"则将其减一\",{\"1\":{\"853\":1}}],[\"则将当前请求资源的线程设置为有效的工作线程\",{\"1\":{\"846\":1}}],[\"则将请求传递给下一个处理器\",{\"1\":{\"348\":1,\"350\":2}}],[\"则将校验和字段全部置0\",{\"1\":{\"305\":1}}],[\"则将该ip数据报转发出去\",{\"1\":{\"201\":1}}],[\"则将进入\",{\"1\":{\"77\":1}}],[\"则主机a要先使用arp协议询问本网络网关地址\",{\"1\":{\"198\":1}}],[\"则ip地址和mac地址都需要使用\",{\"1\":{\"167\":1}}],[\"则使用mac地址就足够了\",{\"1\":{\"167\":1}}],[\"则\",{\"1\":{\"159\":1,\"705\":1}}],[\"则说明信道是真正的空闲\",{\"1\":{\"152\":1}}],[\"则继续执行步骤5\",{\"1\":{\"837\":1}}],[\"则继续检测并等待总线转为空闲\",{\"1\":{\"152\":1}}],[\"则继续发送下一个分组\",{\"1\":{\"137\":1}}],[\"则超时重传报文\",{\"1\":{\"294\":1}}],[\"则超时重传相应的分组\",{\"1\":{\"139\":1}}],[\"则超时重传窗口内的所有分组或者重传末尾帧确认后开始\",{\"1\":{\"138\":1}}],[\"则丢弃并不会发送确认\",{\"1\":{\"139\":1}}],[\"则丢弃后续分组\",{\"1\":{\"138\":1}}],[\"则没有差错\",{\"1\":{\"135\":1,\"576\":1}}],[\"则奇偶性不发生变化\",{\"1\":{\"134\":1,\"576\":1}}],[\"则奇偶性发生变化\",{\"1\":{\"134\":1,\"576\":1}}],[\"则会通过cas\",{\"1\":{\"855\":1}}],[\"则会清除中断标志\",{\"1\":{\"807\":1}}],[\"则会自动以类型的默认值而赋值\",{\"1\":{\"775\":1}}],[\"则会自动检查用户计算机系统\",{\"1\":{\"75\":1}}],[\"则会抛出concurrent\",{\"1\":{\"709\":1}}],[\"则会hashmap会向上寻找离得最近的2的倍数\",{\"1\":{\"685\":1}}],[\"则会输出\",{\"1\":{\"350\":1}}],[\"则会将其所缺少的链路状态项目的详细信息封装在链路状态更新分组\",{\"1\":{\"210\":1}}],[\"则会发送链路状态请求分组\",{\"1\":{\"210\":1}}],[\"则会发生碰撞\",{\"1\":{\"152\":1}}],[\"则会进入电信的\",{\"1\":{\"77\":1}}],[\"则访问\",{\"1\":{\"21\":1,\"47\":1}}],[\"若干线程之间形成一种头尾相接的循环等待资源关系\",{\"1\":{\"848\":1}}],[\"若干次交换和更新后\",{\"1\":{\"208\":1}}],[\"若将其定义在thread类中\",{\"1\":{\"813\":1}}],[\"若达到阀值就会执行\",{\"1\":{\"769\":1}}],[\"若有冲突则停止发送\",{\"1\":{\"578\":1}}],[\"若空闲则发送数据\",{\"1\":{\"578\":1}}],[\"若不使用校验\",{\"1\":{\"305\":1}}],[\"若不存在\",{\"1\":{\"159\":1}}],[\"若接收方发送的允许发送的确认信息丢包\",{\"1\":{\"294\":1}}],[\"若窗口内的某个值很久没有收到回答报文\",{\"1\":{\"294\":1}}],[\"若用tcp封装则称tcp复用\",{\"1\":{\"280\":1}}],[\"若发送端连续发送数据\",{\"1\":{\"264\":1}}],[\"若发现自己缺少其中某些链路状态项目\",{\"1\":{\"210\":1}}],[\"若发现有其他站在发送帧\",{\"1\":{\"152\":1}}],[\"若发现碰撞\",{\"1\":{\"152\":1}}],[\"若分组交换采用虚电路服务\",{\"1\":{\"254\":1}}],[\"若路由器查表转发分组时发现有多条路由可选\",{\"1\":{\"221\":1}}],[\"若ttl的值不等于0\",{\"1\":{\"205\":1}}],[\"若结果为0\",{\"1\":{\"201\":1}}],[\"若结果不为0\",{\"1\":{\"201\":1}}],[\"若在不同网络上\",{\"1\":{\"198\":1}}],[\"若网络中某个网卡出了故障\",{\"1\":{\"170\":1}}],[\"若存在\",{\"1\":{\"159\":1}}],[\"若数据出错则再次发送\",{\"1\":{\"153\":1}}],[\"若这个时间内没有高优先级的帧要发送\",{\"1\":{\"152\":1}}],[\"若检测到总线忙\",{\"1\":{\"152\":1}}],[\"若收到否认分组\",{\"1\":{\"137\":1}}],[\"若收到确认分组\",{\"1\":{\"137\":1}}],[\"若余数为0\",{\"1\":{\"135\":1,\"576\":1}}],[\"若一个网页上有很多引用对象\",{\"1\":{\"111\":1}}],[\"若无记录则将其管辖范围内权威域名服务器的\",{\"1\":{\"79\":1}}],[\"若无则将其管辖范围内顶级域名\",{\"1\":{\"78\":1}}],[\"若曾经访问过该域名且没有清空缓存便存在\",{\"1\":{\"74\":1}}],[\"若相符\",{\"1\":{\"64\":1}}],[\"每创建一个threadlocal对象\",{\"1\":{\"819\":1}}],[\"每隔\",{\"1\":{\"769\":1}}],[\"每隔一秒打印一次\",{\"1\":{\"766\":1}}],[\"每隔一段时间\",{\"1\":{\"208\":1}}],[\"每调用一个方法jvm\",{\"1\":{\"722\":1}}],[\"每当有一个地方引用它时\",{\"1\":{\"733\":1}}],[\"每当迭代器使用hashnext\",{\"1\":{\"709\":1}}],[\"每当比期望序号大的失序报文段到达时\",{\"1\":{\"291\":1}}],[\"每台连接到互联网的设备都有唯一的ip地址\",{\"1\":{\"594\":1}}],[\"每台主机都会有一个arp高速缓存表\",{\"1\":{\"168\":1,\"583\":1}}],[\"每种锁都有其适用的场景和特性\",{\"1\":{\"832\":1}}],[\"每种折扣类型都实现该接口\",{\"1\":{\"465\":1}}],[\"每种支付方式的支付逻辑不同\",{\"1\":{\"344\":1}}],[\"每新增一个具体产品\",{\"1\":{\"437\":1}}],[\"每轮缩减到一半\",{\"1\":{\"316\":1}}],[\"每轮都执行\",{\"1\":{\"316\":1}}],[\"每轮都要执行\",{\"1\":{\"315\":1}}],[\"每经过一个路由器\",{\"1\":{\"208\":1}}],[\"每行4个字节\",{\"1\":{\"194\":1}}],[\"每5个连续的比特1后就插入1个比特0\",{\"1\":{\"132\":1}}],[\"每请求一个文档就要有两倍的rtt的开销\",{\"1\":{\"111\":1}}],[\"每一次移区年龄加一\",{\"1\":{\"740\":1}}],[\"每一次\",{\"1\":{\"728\":1}}],[\"每一次连接是一样的\",{\"1\":{\"109\":1}}],[\"每一条tcp连接只能是点对点的\",{\"1\":{\"282\":1}}],[\"每一条tcp连接只能有两个端点\",{\"1\":{\"282\":1}}],[\"每一层对应的网络协议有哪些\",{\"0\":{\"628\":1}}],[\"每一层对应的任务\",{\"1\":{\"268\":1}}],[\"每一层循环依然可以分别套用第\",{\"1\":{\"316\":1}}],[\"每一层负责不同的功能和任务\",{\"1\":{\"268\":1}}],[\"每一组由点分隔的十进制数对应了四组8位的二进制数\",{\"1\":{\"215\":1}}],[\"每一个线程读取的变量是对应的互相独立的\",{\"1\":{\"816\":1}}],[\"每一个\",{\"1\":{\"760\":1}}],[\"每一个层次的类加载器都是如此\",{\"1\":{\"758\":1}}],[\"每一个相邻路由器又再次将此信息发往其所有的相邻路由器\",{\"1\":{\"210\":1}}],[\"每一个主机能占用令牌的时间是有限的\",{\"1\":{\"153\":1}}],[\"每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧\",{\"1\":{\"152\":1}}],[\"每一个用户拥有唯一的码片\",{\"1\":{\"150\":1}}],[\"每一个用户在一个tdm帧中占用固定序号的时隙\",{\"1\":{\"148\":1}}],[\"每一个互联网服务提供者isp都可以拥有一个本地域名服务器\",{\"1\":{\"71\":1}}],[\"每一帧划分为若干时隙\",{\"1\":{\"148\":1}}],[\"每次修改变量\",{\"1\":{\"845\":1}}],[\"每次修改现有的条件逻辑时\",{\"1\":{\"465\":1}}],[\"每次垃圾回收时就删除\",{\"1\":{\"818\":1}}],[\"每次手动抛出异常\",{\"1\":{\"793\":1}}],[\"每次只能一个线程访问\",{\"1\":{\"789\":1}}],[\"每次只使用其中的一块\",{\"1\":{\"744\":1}}],[\"每次复制的只是少量的存活对象\",{\"1\":{\"744\":1}}],[\"每次需要添加新的折扣类型时\",{\"1\":{\"465\":1}}],[\"每次需要传输文件时都会建立一个新的数据连接\",{\"1\":{\"85\":1}}],[\"每次添加新的折扣类型时\",{\"1\":{\"465\":1}}],[\"每次调用函数执行的次数\",{\"1\":{\"316\":1}}],[\"每次发送的tcp数据段大小和数据段数都是可变的\",{\"1\":{\"282\":1}}],[\"每次发送一个\",{\"1\":{\"233\":1}}],[\"每次发送一个bit\",{\"1\":{\"232\":1}}],[\"每次传输的内容\",{\"1\":{\"235\":1}}],[\"每次浏览器要请求一个文件都要与服务器建立tcp连接\",{\"1\":{\"111\":1}}],[\"每次查询所得的下一级域名服务器ip返回给本地域名服务器\",{\"1\":{\"72\":1}}],[\"每个插入操作必须等到另一个线程调用移除操作\",{\"1\":{\"862\":1}}],[\"每个部分都由一个独立的计数器维护\",{\"1\":{\"855\":1}}],[\"每个部门可以包含其他部门或员工\",{\"1\":{\"525\":1}}],[\"每个entry就是key\",{\"1\":{\"816\":1}}],[\"每个都是一个副本变量\",{\"1\":{\"816\":1}}],[\"每个进程都被独立地管理\",{\"1\":{\"804\":1}}],[\"每个进程都有自己的内存空间\",{\"1\":{\"804\":1}}],[\"每个对象实例都有自己的\",{\"1\":{\"816\":1}}],[\"每个对象都有一个唯一的哈希码\",{\"1\":{\"787\":1}}],[\"每个对象中都维护了一个引用计数器\",{\"1\":{\"733\":1}}],[\"每个应用都有自己的类加载器\",{\"1\":{\"759\":1}}],[\"每个应用程序会被分配一个唯一的端口号\",{\"1\":{\"280\":1}}],[\"每个应用程序都使用特定的应用层协议来完成其特定功能\",{\"1\":{\"56\":1}}],[\"每个web应用程序都有自己的类加载器\",{\"1\":{\"759\":2}}],[\"每个region通过组合来形成代\",{\"1\":{\"749\":1}}],[\"每个小内存的大小相等\",{\"1\":{\"749\":1}}],[\"每个人都能安心地将自己的书本放在自己的抽屉里\",{\"1\":{\"816\":1}}],[\"每个人自己的专用抽屉\",{\"1\":{\"816\":1}}],[\"每个人先分点零食\",{\"1\":{\"728\":1}}],[\"每个人写出的代码可能都不一样\",{\"1\":{\"458\":1}}],[\"每个jvm实例都唯一对应一个堆\",{\"1\":{\"724\":1}}],[\"每个java应用都唯一对应一个jvm实例\",{\"1\":{\"724\":1}}],[\"每个线程都有一个私有的本地内存\",{\"1\":{\"824\":1}}],[\"每个线程都拥有自己的单例实例\",{\"1\":{\"421\":1}}],[\"每个线程需要一个独享的对象\",{\"1\":{\"817\":1}}],[\"每个线程内需要保存全局变量\",{\"1\":{\"817\":1}}],[\"每个线程在\",{\"1\":{\"728\":1}}],[\"每个线程负责执行不同类型的垃圾回收操作\",{\"1\":{\"721\":1}}],[\"每个键值对都是由键和值组成的\",{\"1\":{\"704\":1}}],[\"每个键最多映射到一个值\",{\"1\":{\"671\":1}}],[\"每个红色节点的两个子节点一定都是黑色\",{\"1\":{\"698\":1}}],[\"每个端口之间的数据传输不会相互影响\",{\"1\":{\"580\":1}}],[\"每个交换机端口都被指派到一个特定的\",{\"1\":{\"579\":1}}],[\"每个交换机选择到根桥的最短路径\",{\"1\":{\"175\":1}}],[\"每个数据链路层协议都有其特定的帧格式和封装规则\",{\"1\":{\"577\":1}}],[\"每个数据帧\",{\"1\":{\"235\":1}}],[\"每个组件负责一部分具体的功能\",{\"1\":{\"516\":1}}],[\"每个被代理类都需要手动创建一个代理类\",{\"1\":{\"495\":1}}],[\"每个接口关注特定的功能领域\",{\"1\":{\"474\":1}}],[\"每个接口只关注特定的功能\",{\"1\":{\"473\":1}}],[\"每个接口都可以直接与一台主机或另一个以太网交换机相连\",{\"1\":{\"173\":1}}],[\"每个折扣类型都是独立的策略类\",{\"1\":{\"465\":1}}],[\"每个类就一份\",{\"1\":{\"779\":1}}],[\"每个类的责任更加清晰\",{\"1\":{\"481\":1}}],[\"每个类或模块只关注一个单一的职责\",{\"1\":{\"461\":1}}],[\"每个类或模块专注于一个单一的职责\",{\"1\":{\"461\":1}}],[\"每个类别都有不同的地址范围和可用主机数量\",{\"1\":{\"217\":1}}],[\"每个方法都返回\",{\"1\":{\"450\":1}}],[\"每个\",{\"1\":{\"419\":1,\"714\":1}}],[\"每个飞机\",{\"1\":{\"401\":1}}],[\"每个相关对象都知道中介者对象\",{\"1\":{\"400\":1}}],[\"每个景点都可以接受访问者并提供一种或多种参观方式\",{\"1\":{\"372\":1}}],[\"每个具体产品都实现了\",{\"1\":{\"443\":1}}],[\"每个具体工厂对应一个具体产品家族\",{\"1\":{\"441\":1}}],[\"每个具体的工厂实现该接口\",{\"1\":{\"440\":1}}],[\"每个具体状态类负责对应状态下的行为实现\",{\"1\":{\"359\":1}}],[\"每个具体策略类都需要一个对应的类\",{\"1\":{\"345\":1}}],[\"每个具体策略类实现了一种具体的算法\",{\"1\":{\"343\":1}}],[\"每个状态类都实现了相同的接口\",{\"1\":{\"358\":1}}],[\"每个规则可以看作是一个处理器\",{\"1\":{\"355\":1}}],[\"每个过滤器或拦截器执行特定的任务\",{\"1\":{\"355\":1}}],[\"每个记录器处理特定级别的日志\",{\"1\":{\"355\":1}}],[\"每个处理器负责处理特定类型的事件\",{\"1\":{\"355\":1}}],[\"每个处理器负责处理特定类型的邮件\",{\"1\":{\"355\":1}}],[\"每个处理器处理请求的一个部分\",{\"1\":{\"355\":1}}],[\"每个处理器检查是否能够处理该请求\",{\"1\":{\"350\":1}}],[\"每个处理器只需要关心自己能否处理该请求\",{\"1\":{\"349\":1}}],[\"每个处理器将依次检查自己是否能够处理该请求\",{\"1\":{\"348\":1}}],[\"每个序列化器实现类中的判断确实会导致代码耦合\",{\"1\":{\"346\":1}}],[\"每个观察者的更新操作都将作为一个任务提交给线程池\",{\"1\":{\"327\":1}}],[\"每个观察者接收到通知后\",{\"1\":{\"324\":1}}],[\"每个用户可以发送消息给其他用户\",{\"1\":{\"405\":1}}],[\"每个用户收到消息后\",{\"1\":{\"325\":1}}],[\"每个用户都可以接收消息并发送消息给聊天室中的其他用户\",{\"1\":{\"325\":1}}],[\"每个元素都有且仅有一个前驱元素和一个后继元素\",{\"1\":{\"311\":1}}],[\"每个码元可携带的比特数量\",{\"1\":{\"240\":2}}],[\"每个码元传输结束后信号都要\",{\"1\":{\"238\":1}}],[\"每个bit依次发送\",{\"1\":{\"232\":1}}],[\"每个子类对象都可以调用wait\",{\"1\":{\"813\":1}}],[\"每个子网可以容纳一定数量的主机\",{\"1\":{\"595\":1}}],[\"每个子网可分配的地址数量\",{\"1\":{\"218\":1}}],[\"每个子网将包含2^8\",{\"1\":{\"222\":1}}],[\"每个子网使用相同长度的子网掩码\",{\"1\":{\"222\":1}}],[\"每个子网都有自己的网络地址和广播地址\",{\"1\":{\"222\":1}}],[\"每个子信道只占用该媒体频带资源的一部分\",{\"1\":{\"150\":1}}],[\"每个网络都有一个下一跳和共同前缀\",{\"1\":{\"221\":1}}],[\"每个网络中最大主机数\",{\"1\":{\"217\":1}}],[\"每个网络适配器都有一个全球唯一的mac地址\",{\"1\":{\"165\":1}}],[\"每个自治系统的管理员要选择至少一个路由器作为该自治系统的\",{\"1\":{\"212\":1}}],[\"每个距离矢量表项包括两部分\",{\"1\":{\"208\":1}}],[\"每个路由器仅和相邻路由器周期性地交换并更新路由信息\",{\"1\":{\"208\":1}}],[\"每个路由器维护一个距离矢量\",{\"1\":{\"208\":1}}],[\"每个路由器只有相邻路由器的路由信息\",{\"1\":{\"206\":1}}],[\"每个路由器只与直接相连的路由器交换路由信息\",{\"1\":{\"206\":1}}],[\"每个路由器都只有自己所在区域路由器的信息\",{\"1\":{\"211\":1}}],[\"每个路由器都知道到达本as内各网络的最短距离和下一跳地址\",{\"1\":{\"208\":1}}],[\"每个路由器都拥有网络中某个区域或者整个网络中所有其他路由器的全部信息以及网络的流量状态\",{\"1\":{\"206\":1}}],[\"每个路由器都会返回一个时间超过报文\",{\"1\":{\"200\":1}}],[\"每个分组带有目标地址信息\",{\"1\":{\"593\":1}}],[\"每个分组的头部包含了目的主机的完整地址\",{\"1\":{\"184\":1}}],[\"每个分组的首部只需携带一个虚拟电路的编号\",{\"1\":{\"184\":1}}],[\"每个分组可以根据网络的情况走不同的路径\",{\"1\":{\"184\":1}}],[\"每个分组被独立发送\",{\"1\":{\"184\":1}}],[\"每个物理网段的主机都连接到各自的集线器上\",{\"1\":{\"171\":1}}],[\"每个vlan是一个单独的广播域\",{\"1\":{\"159\":1}}],[\"每个节点要么是红色\",{\"1\":{\"698\":1}}],[\"每个节点在特定条件下可以自由接入\",{\"1\":{\"153\":1}}],[\"每个节点既可以是资源的提供者\",{\"1\":{\"59\":1}}],[\"每个站点使用csma\",{\"1\":{\"152\":1}}],[\"每个请求都需要在一个独立的tcp连接上进行传输\",{\"1\":{\"113\":1}}],[\"下设备之间的通信\",{\"1\":{\"579\":1}}],[\"下的设备即使连接到不同的端口\",{\"1\":{\"579\":1}}],[\"下的音乐文件夹和电影文件夹\",{\"1\":{\"525\":1}}],[\"下列是运行输出\",{\"1\":{\"497\":1}}],[\"下列是使用chatgpt学习中回答的使用场景和代码示例\",{\"1\":{\"495\":1}}],[\"下列是一个简单的建造者设计模式的例子\",{\"1\":{\"448\":1}}],[\"下列是一种关于udp校验和填充的过程\",{\"1\":{\"305\":1}}],[\"下列代码实现了抽象工厂设计模式\",{\"1\":{\"443\":1}}],[\"下列这段代码展示了使用抽象工厂设计模式的资源加载器实现\",{\"1\":{\"436\":1}}],[\"下列例子演示了一个简单的发布\",{\"1\":{\"326\":1}}],[\"下列一段代码\",{\"1\":{\"314\":1}}],[\"下面以一个文本编辑器为例来演示备忘录设计模式的应用\",{\"1\":{\"378\":1}}],[\"下面是桥接模式的基本流程\",{\"1\":{\"505\":1}}],[\"下面是代码的解析\",{\"1\":{\"498\":1}}],[\"下面是符合kiss原则的重构后的示例代码\",{\"1\":{\"481\":1}}],[\"下面是用java语言实现的示例代码\",{\"1\":{\"372\":1}}],[\"下面是一个使用接口实现静态代理的示例代码\",{\"1\":{\"495\":1}}],[\"下面是一个使用lombok的\",{\"1\":{\"450\":1}}],[\"下面是一个简单的示例代码\",{\"1\":{\"495\":3,\"502\":1}}],[\"下面是一个简单的命令设计模式的例子\",{\"1\":{\"383\":1}}],[\"下面是一个简化的示例代码\",{\"1\":{\"518\":1}}],[\"下面是一个简化的示例\",{\"1\":{\"335\":1}}],[\"下面是一个用java语言实现网站数据统计的访问者模式示例代码\",{\"1\":{\"372\":1}}],[\"下面是一个示例代码\",{\"1\":{\"346\":1,\"510\":1}}],[\"下面是一个经过格式化的示例代码\",{\"1\":{\"327\":1}}],[\"下面是详细解答\",{\"1\":{\"274\":1}}],[\"下面的协议对上面的实体是\",{\"1\":{\"251\":1}}],[\"下同\",{\"1\":{\"208\":1}}],[\"下一跳\",{\"1\":{\"221\":1}}],[\"下一跳位null0\",{\"1\":{\"205\":1}}],[\"下一步应当找哪一个权威域名服务器\",{\"1\":{\"71\":1}}],[\"下载完后使用xftp等工具将文件上传至linux\",{\"1\":{\"17\":1,\"43\":1}}],[\"下载地址\",{\"1\":{\"17\":1,\"43\":1,\"538\":1}}],[\"下载\",{\"0\":{\"17\":1,\"43\":1},\"1\":{\"83\":1,\"86\":1}}],[\"下载并解压\",{\"0\":{\"16\":1,\"42\":1}}],[\"当运行当线程数=\",{\"1\":{\"860\":1}}],[\"当blockingqueue也满了\",{\"1\":{\"860\":1}}],[\"当bgp发言人互相交换了网络可达性的信息后\",{\"1\":{\"212\":1}}],[\"当进行累加操作时\",{\"1\":{\"855\":1}}],[\"当两个线程都到达同步点时\",{\"1\":{\"854\":1}}],[\"当后续线程尝试获取锁时\",{\"1\":{\"837\":1}}],[\"当没有被当成锁时\",{\"1\":{\"837\":1}}],[\"当没有使用工厂设计模式的情况下\",{\"1\":{\"422\":1}}],[\"当执行完退出后\",{\"1\":{\"835\":1}}],[\"当执行浅拷贝时\",{\"1\":{\"454\":1}}],[\"当其它线程读取该共享变量\",{\"1\":{\"827\":1}}],[\"当每个人需要存储或者取出自己的书\",{\"1\":{\"816\":1}}],[\"当每个线程在往threadlocal里放值的时候\",{\"1\":{\"816\":1}}],[\"当时间片用完cpu就会执行外部中断指令\",{\"1\":{\"809\":1}}],[\"当线程数\",{\"1\":{\"860\":1}}],[\"当线程池中线程池数\",{\"1\":{\"860\":1}}],[\"当线程释放锁时\",{\"1\":{\"839\":1}}],[\"当线程b试图获得这个锁时\",{\"1\":{\"837\":1}}],[\"当线程a再次试图来获得锁时\",{\"1\":{\"837\":1}}],[\"当线程a运行时\",{\"1\":{\"807\":1}}],[\"当线程执行完毕后\",{\"1\":{\"836\":1}}],[\"当线程进入\",{\"1\":{\"832\":1}}],[\"当线程进入一个java方法函数的时候\",{\"1\":{\"724\":1}}],[\"当线程使用完时间片后\",{\"1\":{\"809\":1}}],[\"当jvm耗尽了可用的内存资源时抛出\",{\"1\":{\"793\":1}}],[\"当jack发送消息时\",{\"1\":{\"325\":1}}],[\"当无法解析字符串为指定格式的日期时抛出\",{\"1\":{\"793\":1}}],[\"当试图加载类\",{\"1\":{\"793\":1}}],[\"当试图加载类但找不到对应的类文件时抛出\",{\"1\":{\"793\":1}}],[\"当试图创建一个url实例\",{\"1\":{\"793\":1}}],[\"当试图实例化一个抽象类\",{\"1\":{\"793\":1}}],[\"当试图访问一个不存在的字段时抛出\",{\"1\":{\"793\":1}}],[\"当试图调用一个不存在的方法时抛出\",{\"1\":{\"793\":1}}],[\"当试图克隆一个不支持克隆的对象时抛出\",{\"1\":{\"793\":1}}],[\"当继承自抽象类的自己进行实例化时\",{\"1\":{\"783\":1}}],[\"当程序首次访问一个类时\",{\"1\":{\"755\":1}}],[\"当这些对象的存活年龄超过分代年龄时便会进入老年代\",{\"1\":{\"768\":1}}],[\"当这一块的内存用完了\",{\"1\":{\"744\":1}}],[\"当这个年龄达到\",{\"1\":{\"740\":1}}],[\"当eden空间满了之后\",{\"1\":{\"741\":1}}],[\"当谈到垃圾回收\",{\"1\":{\"741\":1}}],[\"当垃圾收集器开始工作\",{\"1\":{\"735\":1}}],[\"当引用失效时\",{\"1\":{\"733\":1}}],[\"当某一个对象不再有用的时候\",{\"1\":{\"731\":1}}],[\"当某个类不再被引用或使用\",{\"1\":{\"725\":1}}],[\"当某个对象只能有一个实例\",{\"1\":{\"419\":1}}],[\"当超过变量的作用域后\",{\"1\":{\"724\":1}}],[\"当在\",{\"1\":{\"795\":1}}],[\"当在一段代码块中定义一个变量时\",{\"1\":{\"724\":1}}],[\"当在用户客服端查找不到域名对应\",{\"1\":{\"77\":1}}],[\"当退出函数方法时\",{\"1\":{\"724\":1}}],[\"当类不再被引用或者程序结束时\",{\"1\":{\"720\":1}}],[\"当发生哈希冲突时\",{\"1\":{\"706\":1}}],[\"当发送端收到接收端对前两个帧的确认后\",{\"1\":{\"142\":1,\"576\":1}}],[\"当发送端收到对应的xoff控制字符时就停止数据的继续发送\",{\"1\":{\"141\":1,\"576\":1}}],[\"当⼆进制的各个位置都是1以后\",{\"1\":{\"689\":1}}],[\"当链表长度大于阈值\",{\"1\":{\"686\":1,\"706\":1}}],[\"当设备需要发送数据包到另一个网络或互联网时\",{\"1\":{\"597\":1}}],[\"当设备知道目标设备的ip地址但不知道其mac地址时\",{\"1\":{\"583\":1}}],[\"当设备发送数据时\",{\"1\":{\"582\":1}}],[\"当设备发送数据帧时\",{\"1\":{\"166\":1}}],[\"当数据流经某个端口时\",{\"1\":{\"579\":1}}],[\"当数据报过大时\",{\"1\":{\"180\":1,\"587\":1}}],[\"当系统需要大量相似对象\",{\"1\":{\"531\":1}}],[\"当存在一个复杂的子系统\",{\"1\":{\"517\":1}}],[\"当面对新老支付接口替换的场景时\",{\"1\":{\"510\":1}}],[\"当代理类较多或变动频繁时\",{\"1\":{\"495\":1}}],[\"当涉及到远程对象的访问时\",{\"1\":{\"495\":1}}],[\"当涉及到继承关系时\",{\"1\":{\"495\":1}}],[\"当涉及到软件设计和开发原则时\",{\"1\":{\"458\":1}}],[\"当多个线程同时尝试更新计数器时\",{\"1\":{\"855\":1}}],[\"当多个线程同时访问某个对象或资源时\",{\"1\":{\"814\":1}}],[\"当多个类具有相似的行为时\",{\"1\":{\"485\":1}}],[\"当多个对象之间存在复杂的关联关系\",{\"1\":{\"405\":1}}],[\"当低层模块的实现发生变化时\",{\"1\":{\"476\":1}}],[\"当遵循里氏替换原则时\",{\"1\":{\"470\":1}}],[\"当调用\",{\"1\":{\"469\":2,\"868\":1}}],[\"当折扣类型增多时\",{\"1\":{\"465\":1}}],[\"当使用迭代器遍历集合的过程中\",{\"1\":{\"710\":1}}],[\"当使用单一责任原则的代码需要进行维护时\",{\"1\":{\"461\":1}}],[\"当使用状态模式时\",{\"1\":{\"361\":1}}],[\"当应用单一责任原则时\",{\"1\":{\"461\":1}}],[\"当加载表单或页面时\",{\"1\":{\"455\":1}}],[\"当对象被当做同步锁并有一个线程a抢到了锁时\",{\"1\":{\"837\":1}}],[\"当对象的年龄达到一定阈值时\",{\"1\":{\"741\":1}}],[\"当对象的大部分状态可以外部化\",{\"1\":{\"531\":1}}],[\"当对象的创建逻辑比较复杂\",{\"1\":{\"435\":1}}],[\"当对象的状态发生改变时\",{\"1\":{\"358\":1}}],[\"当对象之间的通信逻辑过于复杂且耦合性高时\",{\"1\":{\"411\":1}}],[\"当有请求到达时\",{\"1\":{\"858\":1}}],[\"当有一个语言需要解释执行\",{\"1\":{\"391\":1}}],[\"当有新的消息或事件发生时\",{\"1\":{\"326\":1}}],[\"当我们设计软件时\",{\"1\":{\"488\":1}}],[\"当我们设计一个用户管理系统时\",{\"1\":{\"481\":1}}],[\"当我们设计代码时\",{\"1\":{\"476\":1}}],[\"当我们设计接口时\",{\"1\":{\"472\":1}}],[\"当我们使用继承关系创建派生类\",{\"1\":{\"468\":1}}],[\"当我们需要添加一个新的功能时\",{\"1\":{\"464\":1}}],[\"当我们执行了一系列编辑操作\",{\"1\":{\"375\":1}}],[\"当我们谈论访问者设计模式时\",{\"1\":{\"372\":1}}],[\"当元素类个数较少且变化不大时\",{\"1\":{\"373\":1}}],[\"当访问者访问各种页面时\",{\"1\":{\"372\":1}}],[\"当状态较多时\",{\"1\":{\"360\":1}}],[\"当前任务直接丢弃\",{\"1\":{\"861\":1}}],[\"当前\",{\"1\":{\"833\":1}}],[\"当前对象实例的锁\",{\"1\":{\"833\":1}}],[\"当前线程和它之前的\",{\"1\":{\"811\":1}}],[\"当前线程a等待thread线程终止之后才从thread\",{\"1\":{\"807\":1,\"811\":1}}],[\"当前线程\",{\"1\":{\"707\":1,\"837\":1}}],[\"当前节点是否为树节点\",{\"1\":{\"700\":1}}],[\"当前节点和key匹配\",{\"1\":{\"700\":1}}],[\"当前状态\",{\"1\":{\"360\":1}}],[\"当前是状态b\",{\"1\":{\"359\":1}}],[\"当前是状态a\",{\"1\":{\"359\":1}}],[\"当希望向客户端隐藏子系统的复杂性\",{\"1\":{\"517\":1}}],[\"当希望将遍历算法和遍历逻辑与聚合对象分离\",{\"1\":{\"366\":1}}],[\"当希望避免请求发送者与接收者之间的耦合关系\",{\"1\":{\"351\":1}}],[\"当希望在不改变算法整体结构的情况下\",{\"1\":{\"333\":1}}],[\"当请求到达末端后\",{\"1\":{\"350\":1}}],[\"当客户端发送请求时\",{\"1\":{\"350\":1}}],[\"当用户点击重置按钮时\",{\"1\":{\"455\":1}}],[\"当用户选择不同的支付方式时\",{\"1\":{\"344\":1}}],[\"当用户通过浏览器访问某域名时\",{\"1\":{\"74\":1}}],[\"当扩展到处理http的get\",{\"1\":{\"338\":1}}],[\"当结合真实业务场景时\",{\"1\":{\"384\":1,\"391\":1}}],[\"当结合具体业务场景时\",{\"1\":{\"333\":1}}],[\"当结点收到分组后\",{\"1\":{\"205\":1}}],[\"当算法中的结构相对稳定\",{\"1\":{\"333\":1}}],[\"当观察者模式需要在异步非阻塞的场景中使用时\",{\"1\":{\"327\":1}}],[\"当\",{\"1\":{\"326\":1,\"489\":2,\"721\":1,\"795\":1}}],[\"当主题的状态发生变化时\",{\"1\":{\"324\":1}}],[\"当主机或其他网络设备有数据要发送给另一个主机或设备时\",{\"1\":{\"196\":1}}],[\"当主机访问文档时\",{\"1\":{\"114\":1}}],[\"当n\",{\"1\":{\"316\":1}}],[\"当输入数最差情况为n\",{\"1\":{\"316\":1}}],[\"当需要处理大量数据或执行一系列异步任务时\",{\"1\":{\"858\":1}}],[\"当需要缓存和复用对象以提高系统性能时\",{\"1\":{\"531\":1}}],[\"当需要将子系统的接口与实现解耦\",{\"1\":{\"517\":1}}],[\"当需要将对象的创建和使用分离\",{\"1\":{\"428\":1}}],[\"当需要抽象和实现\",{\"1\":{\"504\":1}}],[\"当需要修改系统时\",{\"1\":{\"488\":1}}],[\"当需要添加新的折扣类型时\",{\"1\":{\"465\":2}}],[\"当需要添加新的资源类型时\",{\"1\":{\"422\":1}}],[\"当需要在构建过程中灵活地添加或修改构建步骤时\",{\"1\":{\"449\":1}}],[\"当需要在整个系统中共享一个共享资源或管理共享状态时\",{\"1\":{\"419\":1}}],[\"当需要构建的对象存在不同的表示形式时\",{\"1\":{\"449\":1}}],[\"当需要构建一个可以灵活配置的语法树\",{\"1\":{\"391\":1}}],[\"当需要创建具有复杂内部结构的对象时\",{\"1\":{\"449\":1}}],[\"当需要创建一组相关的对象时\",{\"1\":{\"435\":1}}],[\"当需要根据不同参数创建不同的对象时\",{\"1\":{\"428\":1}}],[\"当需要对代码进行修改时\",{\"1\":{\"461\":1}}],[\"当需要对资源进行集中管理\",{\"1\":{\"419\":1}}],[\"当需要对一个对象结构中的元素进行多种不相关的操作\",{\"1\":{\"372\":1}}],[\"当需要为一个对象结构中的元素添加新的操作\",{\"1\":{\"372\":1}}],[\"当需要提供多种遍历方式\",{\"1\":{\"366\":1}}],[\"当需要遍历一个复杂对象结构\",{\"1\":{\"366\":1}}],[\"当需要改变算法时\",{\"1\":{\"342\":1}}],[\"当需要目的主机回应时使用\",{\"1\":{\"302\":1}}],[\"当需要传输文件时\",{\"1\":{\"85\":2,\"86\":1}}],[\"当cwnd\",{\"1\":{\"299\":3}}],[\"当网络设备的缓冲区已满时\",{\"1\":{\"296\":1}}],[\"当网络发送拥塞时\",{\"1\":{\"296\":1}}],[\"当网络发生故障或拓扑变化时\",{\"1\":{\"175\":1}}],[\"当网络中的路由器\",{\"1\":{\"296\":1}}],[\"当接收方通过确认重传机制进行字节编号确认时\",{\"1\":{\"294\":1}}],[\"当接收端可以继续接收数据时\",{\"1\":{\"141\":1,\"576\":1}}],[\"当服务器达到一定的连接数时\",{\"1\":{\"285\":1}}],[\"当服务器进程收到客户进程的报文时\",{\"1\":{\"279\":1}}],[\"当然继承也不是非常好的\",{\"1\":{\"782\":1}}],[\"当然也能重写父类的方法\",{\"1\":{\"782\":1}}],[\"当然hashmap里进行了优化改造\",{\"1\":{\"691\":1}}],[\"当然我们也可以自定义实现一些简单的hash算法\",{\"1\":{\"690\":1}}],[\"当然在该例子中我们的状态比较少\",{\"1\":{\"360\":1}}],[\"当然\",{\"1\":{\"275\":1,\"316\":1,\"327\":1,\"372\":1,\"722\":1,\"744\":1,\"840\":1,\"866\":1}}],[\"当分组交换采用数据报服务时\",{\"1\":{\"254\":1}}],[\"当被叫用户听到电话交换机送来的拨号音并拿起电话后\",{\"1\":{\"253\":1}}],[\"当你向\",{\"1\":{\"683\":1}}],[\"当你在浏览器中输入一个域名时\",{\"1\":{\"594\":1}}],[\"当你发现自己在多处重复相同的代码时\",{\"1\":{\"485\":1}}],[\"当你说话时\",{\"1\":{\"239\":1}}],[\"当你为新增网络申请新的网络号时\",{\"1\":{\"218\":1}}],[\"当内部主机发送数据包到公共网络时\",{\"1\":{\"223\":1}}],[\"当路由表发生变化时就立即发送更新报文\",{\"1\":{\"209\":1}}],[\"当路由器或目的主机收到ip数据报后\",{\"1\":{\"201\":1}}],[\"当路由器或主机由于拥塞而丢弃数据报时\",{\"1\":{\"201\":1}}],[\"当路由器或主机不能交付数据报时\",{\"1\":{\"201\":1}}],[\"当路由器收到一个目的ip地址不是自己的ip数据报\",{\"1\":{\"201\":1}}],[\"当终点在预先规定的时间内不能收到一个数据报的全部数据报片时\",{\"1\":{\"201\":1}}],[\"当一台设备需要发送数据到另一台设备时\",{\"1\":{\"583\":1}}],[\"当一些尺寸较大的数据报要在某个mtu值比较小的网络链路上传输时就可能需要对原来的数据报进行拆分\",{\"1\":{\"193\":1}}],[\"当一个变量被\",{\"1\":{\"834\":1}}],[\"当一个核心对一个共享的\",{\"1\":{\"828\":1}}],[\"当一个执行中的线程a调用了thread\",{\"1\":{\"807\":1}}],[\"当一个线程无事可做\",{\"1\":{\"868\":1}}],[\"当一个线程完成任务时\",{\"1\":{\"868\":1}}],[\"当一个线程尝试获取锁时\",{\"1\":{\"839\":1}}],[\"当一个线程获取到\",{\"1\":{\"834\":1}}],[\"当一个线程调用\",{\"1\":{\"807\":1}}],[\"当一个线程a调用一个共享变量的\",{\"1\":{\"807\":1}}],[\"当一个线程递归调用的深度超过了jvm所能处理的范围时抛出\",{\"1\":{\"793\":1}}],[\"当一个线程处于阻塞\",{\"1\":{\"793\":1}}],[\"当一个人在说话时\",{\"1\":{\"582\":1}}],[\"当一个对象发生变化时\",{\"1\":{\"490\":1}}],[\"当一个对象只与少数几个朋友对象进行交互时\",{\"1\":{\"488\":1}}],[\"当一个对象有许多状态且状态之间的转换频繁发生时\",{\"1\":{\"360\":1}}],[\"当一个对象的实现发生变化时\",{\"1\":{\"488\":1}}],[\"当一个对象的变化需要影响到多个其他对象时\",{\"1\":{\"411\":1}}],[\"当一个对象的变化需要影响其他对象\",{\"1\":{\"325\":1}}],[\"当一个对象的状态发生变化时\",{\"1\":{\"411\":1}}],[\"当一个对象的状态变化会导致其他对象的行为变化\",{\"1\":{\"325\":1}}],[\"当一个对象的行为依赖于其他多个对象时\",{\"1\":{\"405\":1}}],[\"当一个对象的行为包含大量与状态相关的代码\",{\"1\":{\"360\":1}}],[\"当一个对象的行为取决于它的状态\",{\"1\":{\"360\":1}}],[\"当一个请求需要被多个对象处理\",{\"1\":{\"351\":1}}],[\"当一个请求进入责任链时\",{\"1\":{\"348\":1,\"349\":1,\"350\":1}}],[\"当一个类的静态初始化器\",{\"1\":{\"793\":1}}],[\"当一个类继承自另一个类\",{\"1\":{\"755\":1}}],[\"当一个类有多个相似的算法\",{\"1\":{\"344\":1}}],[\"当一个类需要根据条件选择不同的算法时\",{\"1\":{\"344\":1}}],[\"当一个路由器接口收到一个报文分组后\",{\"1\":{\"205\":1}}],[\"当一个主机发出dns查询请求时\",{\"1\":{\"71\":1}}],[\"当一个权限域名服务器还不能给出最后的查询回答时\",{\"1\":{\"71\":1}}],[\"当会话结束时\",{\"1\":{\"86\":1}}],[\"当以上均未完成\",{\"1\":{\"78\":1}}],[\"当浏览器及系统缓存中均无域名对应\",{\"1\":{\"76\":1}}],[\"当浏览器缓存中无域名对应\",{\"1\":{\"75\":1}}],[\"当收到响应后就立即关闭连接\",{\"1\":{\"111\":1}}],[\"当收到\",{\"1\":{\"71\":1}}],[\"对阻塞队列持久化\",{\"1\":{\"871\":1}}],[\"对信号量的操作主要通过一对特殊的原语来完成\",{\"1\":{\"853\":1}}],[\"对操作系统而言\",{\"1\":{\"853\":1}}],[\"对java而言\",{\"1\":{\"853\":1}}],[\"对资源分配进行计算评估\",{\"1\":{\"848\":1}}],[\"对一些代码上要求同步\",{\"1\":{\"837\":1}}],[\"对给定对象\",{\"1\":{\"833\":1}}],[\"对其进行加一操作\",{\"1\":{\"829\":1}}],[\"对其他vlan的设备不可见\",{\"1\":{\"579\":1}}],[\"对字节码描述的信息进行语义分析\",{\"1\":{\"754\":1}}],[\"对它进行回收\",{\"1\":{\"749\":1}}],[\"对整个堆内存进行检查和清理\",{\"1\":{\"741\":1}}],[\"对齐填充不是必须的\",{\"1\":{\"729\":1}}],[\"对齐填充\",{\"1\":{\"729\":1}}],[\"对\",{\"1\":{\"706\":1,\"766\":1,\"834\":1}}],[\"对应抽象类而言\",{\"1\":{\"783\":1}}],[\"对应查询\",{\"1\":{\"685\":1}}],[\"对应索引的位置\",{\"1\":{\"685\":1}}],[\"对应的jvm指令分为三步\",{\"1\":{\"826\":1}}],[\"对应的线程信息\",{\"1\":{\"765\":1}}],[\"对应的\",{\"1\":{\"71\":1}}],[\"对付顺序的好帮手\",{\"1\":{\"671\":1}}],[\"对抽象部分进行扩展\",{\"1\":{\"504\":1}}],[\"对原有类进行增强\",{\"1\":{\"800\":1}}],[\"对原生对象的某些方法做增强\",{\"1\":{\"500\":1}}],[\"对原始功能并不够强大的能力让他变得更加强大\",{\"1\":{\"500\":1}}],[\"对方法体的验证\",{\"1\":{\"754\":1}}],[\"对方法做增强\",{\"1\":{\"498\":1}}],[\"对方法进行统一的增强或拦截\",{\"1\":{\"496\":1}}],[\"对方收到链路状态请求分组后\",{\"1\":{\"210\":1}}],[\"对修改关闭\",{\"1\":{\"464\":1,\"466\":1,\"500\":1}}],[\"对新订单的修改不会影响原始订单\",{\"1\":{\"455\":1}}],[\"对输入数据进行评估和处理\",{\"1\":{\"392\":1}}],[\"对输入数据进行评估\",{\"1\":{\"391\":1}}],[\"对语法树进行解释\",{\"1\":{\"390\":1}}],[\"对现有类的对象结构进行操作或添加新的操作\",{\"1\":{\"369\":1}}],[\"对外隐藏了内部表示\",{\"1\":{\"367\":1}}],[\"对数据结构中的元素进行操作的场景\",{\"1\":{\"373\":1}}],[\"对数据进行特定的处理\",{\"1\":{\"355\":1}}],[\"对数阶反映了\",{\"1\":{\"316\":1}}],[\"对性能有一定影响\",{\"1\":{\"355\":1}}],[\"对请求进行实际处理\",{\"1\":{\"350\":1}}],[\"对象列表\",{\"1\":{\"835\":1}}],[\"对象锁或方法锁来保护临界区\",{\"1\":{\"831\":1}}],[\"对象封装的异常信息\",{\"1\":{\"794\":1}}],[\"对象引用和\",{\"1\":{\"792\":1}}],[\"对象使用完后未调用\",{\"1\":{\"768\":1}}],[\"对象存活率\",{\"1\":{\"749\":1}}],[\"对象每经历一次年轻代gc\",{\"1\":{\"741\":1}}],[\"对象什么时候会进入老年代\",{\"0\":{\"740\":1},\"1\":{\"740\":1}}],[\"对象是否死亡\",{\"0\":{\"733\":1},\"1\":{\"733\":1}}],[\"对象头里面有一块结构叫mark\",{\"1\":{\"835\":1}}],[\"对象头包含了锁的标志信息\",{\"1\":{\"813\":1}}],[\"对象头主要由两部分组成\",{\"1\":{\"729\":1}}],[\"对象头\",{\"1\":{\"729\":1}}],[\"对象在堆内存中的存储布局可以划分为三个部分\",{\"1\":{\"729\":1}}],[\"对象在后续的操作中可以回到之前的状态\",{\"1\":{\"375\":1}}],[\"对象分配内存的线程\",{\"1\":{\"728\":1}}],[\"对象分配内存\",{\"1\":{\"728\":1}}],[\"对象时\",{\"0\":{\"728\":1},\"1\":{\"728\":2}}],[\"对象时出现了不一致和不可预测的行为\",{\"1\":{\"469\":1}}],[\"对象中的歌名和歌手名分别采用一种排序方法的话\",{\"1\":{\"674\":1}}],[\"对象的属性修改类型\",{\"1\":{\"847\":2}}],[\"对象的线程进入\",{\"1\":{\"835\":1}}],[\"对象的引用关系可能会发生变化\",{\"1\":{\"748\":1}}],[\"对象的哈希码将由默认的\",{\"1\":{\"788\":1}}],[\"对象的哈希码\",{\"1\":{\"726\":1}}],[\"对象的\",{\"1\":{\"495\":2,\"726\":1}}],[\"对象作为成员变量\",{\"1\":{\"495\":1}}],[\"对象只需关注与其密切相关的对象\",{\"1\":{\"490\":1}}],[\"对象传递给\",{\"1\":{\"469\":1}}],[\"对象传递给了\",{\"1\":{\"450\":1}}],[\"对象本身\",{\"1\":{\"450\":1}}],[\"对象之间的直接依赖越少\",{\"1\":{\"488\":1}}],[\"对象之间的交互应该尽量简单\",{\"1\":{\"488\":1}}],[\"对象之间的通信是通过中介者对象进行的\",{\"1\":{\"411\":1}}],[\"对象之间存在一对多的依赖关系\",{\"1\":{\"411\":1}}],[\"对象之间不存在直接的关联\",{\"1\":{\"411\":1}}],[\"对象关系不同\",{\"1\":{\"411\":1}}],[\"对象结构\",{\"1\":{\"371\":1,\"372\":2}}],[\"对象内部维护一个状态对象\",{\"1\":{\"358\":1}}],[\"对象等\",{\"1\":{\"317\":1}}],[\"对象\",{\"1\":{\"317\":1,\"386\":1,\"422\":6,\"436\":3,\"450\":4,\"683\":1,\"708\":1,\"720\":1,\"754\":1,\"785\":1,\"789\":1,\"790\":1,\"792\":1,\"835\":1}}],[\"对等层次之间传送的数据包称为该层的协议数据单元\",{\"1\":{\"251\":1}}],[\"对等实体\",{\"1\":{\"250\":1}}],[\"对等方式\",{\"1\":{\"59\":2}}],[\"对讲机就是典型的半双工设备\",{\"1\":{\"582\":1}}],[\"对讲机\",{\"1\":{\"237\":1}}],[\"对具有特殊地址\",{\"1\":{\"200\":1}}],[\"对具有多播地址的数据报都不发送icmp差错报告报文\",{\"1\":{\"200\":1}}],[\"对第一个分片的数据报片的所有后续数据报片都不发送icmp差错报告报文\",{\"1\":{\"200\":1}}],[\"对icmp差错报告报文不再发送icmp差错报告报文\",{\"1\":{\"200\":1}}],[\"对从低层到达网络层的报文\",{\"1\":{\"186\":1,\"591\":1}}],[\"对来自传输层的报文\",{\"1\":{\"186\":1,\"591\":1}}],[\"对安全不利\",{\"1\":{\"159\":1,\"579\":1}}],[\"对硬件的要求特别高\",{\"1\":{\"152\":1}}],[\"对发送端数据传输速率的控制\",{\"1\":{\"140\":1,\"576\":1}}],[\"对于操作系统而言\",{\"1\":{\"811\":1}}],[\"对于编译期可以确定值的字符串\",{\"1\":{\"792\":1}}],[\"对于重写\",{\"1\":{\"780\":3}}],[\"对于重载\",{\"1\":{\"780\":3}}],[\"对于引用类型\",{\"1\":{\"724\":1}}],[\"对于\",{\"1\":{\"722\":1,\"828\":2}}],[\"对于不同设备间的数据链路层而言\",{\"1\":{\"573\":1}}],[\"对于上层的网络层而言\",{\"1\":{\"573\":1}}],[\"对于下层的物理层\",{\"1\":{\"573\":1}}],[\"对于一个只能行走和工作的机器人\",{\"1\":{\"473\":1}}],[\"对于那些只需要实现部分功能的客户端来说\",{\"1\":{\"473\":1}}],[\"对于复杂对象\",{\"1\":{\"455\":1}}],[\"对于复杂的文法规则\",{\"1\":{\"396\":1}}],[\"对于简单对象的构建\",{\"1\":{\"451\":1}}],[\"对于简单的聚合对象\",{\"1\":{\"367\":1}}],[\"对于中介者设计模式的简单案例\",{\"1\":{\"408\":1}}],[\"对于个别丢失的报文段\",{\"1\":{\"299\":1}}],[\"对于带宽1\",{\"1\":{\"262\":1}}],[\"对于解题\",{\"1\":{\"240\":1}}],[\"对于自治系统之间的路由选择\",{\"1\":{\"212\":1}}],[\"对于聚合后或由于网络故障而不存在的路由条目设置黑洞路由\",{\"1\":{\"205\":1}}],[\"对于每条链路\",{\"1\":{\"175\":1}}],[\"对于vid不等于pvid的帧\",{\"1\":{\"159\":1}}],[\"对于vid等于pvid的帧\",{\"1\":{\"159\":1}}],[\"对于无线广播或电视广播站就是这样\",{\"1\":{\"150\":1}}],[\"对于各个用户的码片\",{\"1\":{\"150\":1}}],[\"对于广播型网络\",{\"1\":{\"144\":1}}],[\"对于数据链路层来说控制的是相邻两节点之间数据链路上的流量\",{\"1\":{\"140\":1}}],[\"对于面向比特的链路\",{\"1\":{\"132\":1}}],[\"对于面向字节\",{\"1\":{\"132\":1}}],[\"对帧的数据部分进行扫描\",{\"1\":{\"132\":1}}],[\"对邮件进行分类等\",{\"1\":{\"97\":1}}],[\"权威域名服务器接收到请求后查询自己的缓存\",{\"1\":{\"80\":1}}],[\"权威域名服务器\",{\"1\":{\"71\":1}}],[\"就让休息的小姐姐赶紧回来上班\",{\"1\":{\"868\":1}}],[\"就在排队区排队等\",{\"1\":{\"868\":1}}],[\"就算队列里面有任务\",{\"1\":{\"868\":1}}],[\"就算散列值分布再松散\",{\"1\":{\"694\":1}}],[\"就停止自旋\",{\"1\":{\"845\":1}}],[\"就停止发送下一个数据分组\",{\"1\":{\"137\":1}}],[\"就马上获取失败\",{\"1\":{\"842\":1}}],[\"就属于是不可中断锁\",{\"1\":{\"841\":1}}],[\"就属于是可中断锁\",{\"1\":{\"841\":1}}],[\"就只能等到拿到锁以后才能进行其他的逻辑处理\",{\"1\":{\"841\":1}}],[\"就使用了自旋加锁的方式\",{\"1\":{\"837\":1}}],[\"就使用synchronized写入数据\",{\"1\":{\"711\":1}}],[\"就释放锁了\",{\"1\":{\"836\":1}}],[\"就把mark\",{\"1\":{\"837\":2}}],[\"就把它赋给当前线程\",{\"1\":{\"822\":1}}],[\"就把已收到的数据报片都丢弃\",{\"1\":{\"201\":1}}],[\"就开始执行rehash\",{\"1\":{\"821\":1}}],[\"就判断下一个位置\",{\"1\":{\"820\":1}}],[\"就判断该元素与要存入的元素的\",{\"1\":{\"686\":1}}],[\"就调用remove方法移除即可\",{\"1\":{\"817\":1}}],[\"就和我们的java中类与对象实例的关系\",{\"1\":{\"804\":1}}],[\"就和hashmap基本上是一样的\",{\"1\":{\"711\":1}}],[\"就好像一个人在玩一个积木拼图游戏时\",{\"1\":{\"798\":1}}],[\"就直接返回该引用\",{\"1\":{\"791\":1}}],[\"就很大概率存在内存泄漏了\",{\"1\":{\"769\":1}}],[\"就记录一下引用关系\",{\"1\":{\"746\":1}}],[\"就将还存活着的对象复制到另外一块上面\",{\"1\":{\"744\":1}}],[\"就将相应的报文段立即重传\",{\"1\":{\"299\":1}}],[\"就比如我们传入的参数是一个父类\",{\"1\":{\"782\":1}}],[\"就比如我们有了女朋友\",{\"1\":{\"781\":1}}],[\"就比如我们去用花呗付款\",{\"1\":{\"731\":1}}],[\"就比如每个月需要进一批货\",{\"1\":{\"455\":1}}],[\"就先执行相应的类加载过程\",{\"1\":{\"726\":1}}],[\"就不会出问题\",{\"1\":{\"725\":1}}],[\"就不再需要使用繁琐的\",{\"1\":{\"346\":1}}],[\"就通过cas+自旋的方式初始化\",{\"1\":{\"711\":1}}],[\"就需要老年代进行分配担保\",{\"1\":{\"740\":1}}],[\"就需要使用\",{\"1\":{\"705\":1}}],[\"就需要用之前需要对数组的长度取模运算\",{\"1\":{\"694\":1}}],[\"就需要重新创建一个相似且大部分功能相同的单例类\",{\"1\":{\"421\":1}}],[\"就必须修改源代码\",{\"1\":{\"421\":1}}],[\"就必须重新拨号建立新的连接\",{\"1\":{\"253\":1}}],[\"就可以用一个初值为1的信号量来表示打印机的可用性\",{\"1\":{\"853\":1}}],[\"就可以进入临界区执行操作\",{\"1\":{\"839\":1}}],[\"就可以了\",{\"1\":{\"818\":1}}],[\"就可以得到和\",{\"1\":{\"688\":1}}],[\"就可以得到一个完完全全相同的对象\",{\"1\":{\"455\":1}}],[\"就可以使用semaphore来做流量控制\",{\"1\":{\"853\":1}}],[\"就可以使用深拷贝\",{\"1\":{\"455\":1}}],[\"就可以使用重做功能重新执行之前的操作\",{\"1\":{\"375\":1}}],[\"就可以使用撤销功能\",{\"1\":{\"375\":1}}],[\"就可以从isp得到所需要的ip地址\",{\"1\":{\"249\":1}}],[\"就丢弃报文\",{\"1\":{\"301\":1}}],[\"就丢弃该数据报\",{\"1\":{\"201\":1}}],[\"就表明有3个数据报文段已经离开了网络\",{\"1\":{\"299\":1}}],[\"就知道现在只是丢失了个别报文段\",{\"1\":{\"299\":1}}],[\"就知道了客户进程所使用的的动态端口号\",{\"1\":{\"279\":1}}],[\"就减少\",{\"1\":{\"297\":1}}],[\"就有了拥塞控制\",{\"1\":{\"296\":1}}],[\"就会清空本地内存变量\",{\"1\":{\"827\":1}}],[\"就会造成了内存泄漏问题\",{\"1\":{\"818\":1}}],[\"就会处于就绪状态并让出\",{\"1\":{\"809\":1}}],[\"就会把对象内什么偏移量上是什么类型的数据计算出来\",{\"1\":{\"747\":1}}],[\"就会触发类加载\",{\"1\":{\"755\":1}}],[\"就会触发\",{\"1\":{\"739\":1}}],[\"就会触发扩容操作\",{\"1\":{\"696\":1}}],[\"就会在当前线程的栈里压入一个栈帧\",{\"1\":{\"724\":1}}],[\"就会抛出\",{\"1\":{\"710\":2}}],[\"就会改变modcount的值\",{\"1\":{\"709\":1}}],[\"就会认为网络出现了拥塞\",{\"1\":{\"297\":1}}],[\"就会增大\",{\"1\":{\"297\":1}}],[\"就会重传数据\",{\"1\":{\"296\":1}}],[\"就会导致网络拥塞\",{\"1\":{\"296\":1}}],[\"就会告知发出查询请求的dns客户\",{\"1\":{\"71\":1}}],[\"就启动持续计时器\",{\"1\":{\"294\":1}}],[\"就发出连接释放报文段\",{\"1\":{\"286\":1}}],[\"就加一跳\",{\"1\":{\"208\":1}}],[\"就向源点发送源点抑制报文\",{\"1\":{\"201\":1}}],[\"就向源点发送终点不可达报文\",{\"1\":{\"201\":1}}],[\"就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存\",{\"1\":{\"866\":1}}],[\"就是给一个元素赋值的时候\",{\"1\":{\"845\":1}}],[\"就是所有的控制权都交给了操作系统\",{\"1\":{\"837\":1}}],[\"就是只要不去做正确的同步措施\",{\"1\":{\"832\":1}}],[\"就是不管有没有风险\",{\"1\":{\"831\":1,\"832\":1}}],[\"就是通过分别限制这两种类型的重排序\",{\"1\":{\"827\":1}}],[\"就是这个坑被人占了\",{\"1\":{\"820\":1}}],[\"就是告知程序任何对该变量的访问均需要从共享内存中获取\",{\"1\":{\"811\":1}}],[\"就是刀下留人\",{\"1\":{\"736\":1}}],[\"就是申请的内存超过了可用内存\",{\"1\":{\"731\":1}}],[\"就是申请的内存空间没有被正确释放\",{\"1\":{\"731\":1}}],[\"就是和hashmap一样\",{\"1\":{\"711\":1}}],[\"就是为了混合原始哈希码的高位和低位\",{\"1\":{\"694\":1}}],[\"就是⼀个标准的2的倍数减1了\",{\"1\":{\"689\":1}}],[\"就是初始化时\",{\"1\":{\"689\":1}}],[\"就是在设计中要尽量避免修改已有的代码\",{\"1\":{\"466\":1}}],[\"就是需要在两端所经过的线路上建立一条构建于网络层已搭建好的路由路径之上的虚拟传输连接\",{\"1\":{\"275\":1}}],[\"就是按照某种方式动态地分配传输线路的资源\",{\"1\":{\"253\":1}}],[\"就是物理层的象征\",{\"1\":{\"227\":1}}],[\"就是把数据分组从源端传到目的端\",{\"1\":{\"178\":1,\"180\":1,\"587\":1}}],[\"就是基于反馈的流量控制\",{\"1\":{\"141\":1,\"576\":1}}],[\"就推迟发送以避免碰撞\",{\"1\":{\"152\":1}}],[\"就立即发送帧\",{\"1\":{\"152\":1}}],[\"就要停止\",{\"1\":{\"142\":1,\"576\":1}}],[\"就构成了一个完整帧\",{\"1\":{\"130\":1}}],[\"就构成了数据链路\",{\"1\":{\"119\":1}}],[\"就像是这栋大楼中的各个部门实际上在逻辑上组成了各自独立的小区域\",{\"1\":{\"579\":1}}],[\"就像它们是直接相连的一样\",{\"1\":{\"275\":1}}],[\"就像通信双方是直接互连一样\",{\"1\":{\"184\":1,\"589\":1}}],[\"就像高速公路可以有多条路径连接不同城市一样\",{\"1\":{\"182\":1}}],[\"就像公司内部的专线网络vpn\",{\"1\":{\"127\":1}}],[\"就像寄快递\",{\"1\":{\"126\":1}}],[\"就像我们打电话\",{\"1\":{\"125\":1}}],[\"就像我们乘坐高铁\",{\"1\":{\"119\":1}}],[\"就像在本地操控一样\",{\"1\":{\"98\":1}}],[\"就给出相应的回答\",{\"1\":{\"71\":1}}],[\"就首先求助于根域名服务器\",{\"1\":{\"71\":1}}],[\"查找红黑树\",{\"1\":{\"700\":1}}],[\"查找的最坏时间复杂度都为\",{\"1\":{\"698\":1}}],[\"查询未做分页\",{\"1\":{\"768\":1}}],[\"查询和删除方面可能会略微快于\",{\"1\":{\"715\":1}}],[\"查询和删除性能\",{\"1\":{\"715\":1}}],[\"查询效率\",{\"1\":{\"679\":1}}],[\"查询的时间复杂度是o\",{\"1\":{\"677\":1,\"678\":1}}],[\"查询结果\",{\"1\":{\"497\":1}}],[\"查询语句\",{\"1\":{\"497\":1}}],[\"查询缓存\",{\"1\":{\"495\":1}}],[\"查询请求时\",{\"1\":{\"71\":1}}],[\"查看堆的摘要信息\",{\"1\":{\"769\":1}}],[\"查看堆内存中的存活对象\",{\"1\":{\"768\":1}}],[\"查看堆内存各区域的使用率以及gc情况\",{\"1\":{\"768\":1}}],[\"查看堆内存占用空间最大的前\",{\"1\":{\"766\":1}}],[\"查看堆内存\",{\"1\":{\"763\":1}}],[\"查看进程下的所有线程占\",{\"1\":{\"769\":1}}],[\"查看进程使用\",{\"1\":{\"769\":1}}],[\"查看运行的\",{\"1\":{\"769\":1}}],[\"查看监控\",{\"1\":{\"768\":1}}],[\"查看内存泄漏或不合理的对象创建\",{\"1\":{\"767\":1}}],[\"查看\",{\"1\":{\"766\":1,\"769\":1}}],[\"查看是否有线程长时间的\",{\"1\":{\"765\":1}}],[\"查看是否需要做记录日志\",{\"1\":{\"497\":1,\"498\":1}}],[\"查看distributionurl的gradle版本\",{\"1\":{\"538\":1}}],[\"查看vfs以及它的实现类\",{\"1\":{\"419\":1}}],[\"查看帧的vid是否在端口的去标签列表中\",{\"1\":{\"159\":1}}],[\"查看isp\",{\"0\":{\"77\":1}}],[\"查看路由器缓存\",{\"0\":{\"76\":1}}],[\"查看系统缓存\",{\"0\":{\"75\":1}}],[\"查看浏览器缓存\",{\"0\":{\"74\":1}}],[\"查看安装的版本\",{\"1\":{\"24\":1,\"50\":1}}],[\"查看javac版本\",{\"1\":{\"20\":1,\"46\":1}}],[\"查看java版本\",{\"1\":{\"20\":1,\"46\":1}}],[\"查看root密码\",{\"1\":{\"11\":1,\"37\":1}}],[\"整型数组原子类\",{\"1\":{\"847\":1}}],[\"整型原子类\",{\"1\":{\"847\":1}}],[\"整理算法更加合适\",{\"1\":{\"744\":1}}],[\"整理算法\",{\"1\":{\"744\":1}}],[\"整堆收集\",{\"1\":{\"738\":1}}],[\"整体\",{\"1\":{\"522\":1}}],[\"整体域名不超过255个字符\",{\"1\":{\"69\":1}}],[\"整合银行不同接口发来的不同格式的报文\",{\"1\":{\"511\":1}}],[\"整个生命周期需要经过七个阶段\",{\"1\":{\"754\":1}}],[\"整个区域就可能被选为老年代\",{\"1\":{\"749\":1}}],[\"整个流程和hashmap非常类似\",{\"1\":{\"711\":1}}],[\"整个导入过程有一定的稳定结构\",{\"1\":{\"333\":1}}],[\"整个udp数据报的长度\",{\"1\":{\"302\":1}}],[\"整个过程中\",{\"1\":{\"239\":1}}],[\"整个工作流程\",{\"1\":{\"138\":1,\"139\":1}}],[\"整行复制执行\",{\"1\":{\"3\":1,\"29\":1}}],[\"自然是它有和countdownlatch不同的地方\",{\"1\":{\"852\":1}}],[\"自然也无法单独删除了\",{\"1\":{\"731\":1}}],[\"自然也就没有报文段之说\",{\"1\":{\"301\":1}}],[\"自旋cas\",{\"1\":{\"845\":1}}],[\"自旋默认10次\",{\"1\":{\"837\":1}}],[\"自旋次数由jvm决定\",{\"1\":{\"837\":1}}],[\"自旋锁重试之后如果抢锁依然失败\",{\"1\":{\"837\":1}}],[\"自旋锁默认启用\",{\"1\":{\"837\":1}}],[\"自旋锁不是一个锁状态\",{\"1\":{\"837\":1}}],[\"自旋锁\",{\"1\":{\"837\":1}}],[\"自旋超过次数就阻塞获取\",{\"1\":{\"711\":1}}],[\"自带的\",{\"1\":{\"769\":1}}],[\"自己的高半区和低半区做异或\",{\"1\":{\"694\":1}}],[\"自己的定义\",{\"1\":{\"257\":1}}],[\"自己在新增歌曲\",{\"1\":{\"454\":2}}],[\"自己注册的\",{\"1\":{\"69\":1}}],[\"自治\",{\"1\":{\"257\":1}}],[\"自治的计算机的集合\",{\"1\":{\"257\":1}}],[\"自治系统之间的路由选择必须考虑相关策略\",{\"1\":{\"212\":1}}],[\"自治系统as\",{\"1\":{\"211\":1}}],[\"自同步\",{\"1\":{\"238\":1}}],[\"自适应路由算法分为两类\",{\"1\":{\"206\":1}}],[\"自适应路由算法\",{\"1\":{\"206\":1}}],[\"自学习和转发帧的流程\",{\"1\":{\"174\":1}}],[\"自学习和转发帧流程\",{\"0\":{\"174\":1}}],[\"自动调整大小\",{\"1\":{\"723\":1}}],[\"自动回复\",{\"1\":{\"355\":1}}],[\"自动重发请求\",{\"1\":{\"141\":1,\"576\":1}}],[\"自动请求重传arq\",{\"1\":{\"137\":1}}],[\"自动请求重传\",{\"0\":{\"137\":1},\"1\":{\"576\":1}}],[\"自动分配ip地址\",{\"1\":{\"62\":1}}],[\"国家顶级域名\",{\"1\":{\"69\":1}}],[\"顶级域名服务器收到请求后查看区域文件记录\",{\"1\":{\"79\":1}}],[\"顶级域名服务器负责管理在该服务器注册的所有二级域名\",{\"1\":{\"71\":1}}],[\"顶级域名服务器\",{\"1\":{\"71\":1}}],[\"顶级域名\",{\"1\":{\"69\":1}}],[\"的散列运算获得\",{\"1\":{\"855\":1}}],[\"的屏障\",{\"1\":{\"852\":1}}],[\"的原理是什么\",{\"1\":{\"847\":1}}],[\"的原理\",{\"0\":{\"847\":1}}],[\"的原子性更新\",{\"1\":{\"839\":1}}],[\"的结果正确\",{\"1\":{\"844\":1}}],[\"的操作是线程安全的\",{\"1\":{\"844\":1}}],[\"的操作都会返回一个新的\",{\"1\":{\"789\":1}}],[\"的修改能够被其他线程立即看到\",{\"1\":{\"844\":1}}],[\"的增加操作是原子性的\",{\"1\":{\"844\":1}}],[\"的构造方法中传入\",{\"1\":{\"839\":2}}],[\"的机制来实现可重入锁的功能\",{\"1\":{\"839\":1}}],[\"的线程栈中开辟一块单独的空间\",{\"1\":{\"837\":1}}],[\"的线程安全性能会带来额外的开销\",{\"1\":{\"706\":1}}],[\"的开销较大\",{\"1\":{\"834\":1}}],[\"的开销相对较小\",{\"1\":{\"834\":1}}],[\"的可见性\",{\"1\":{\"834\":1}}],[\"的锁\",{\"1\":{\"833\":2}}],[\"的乐观读模式\",{\"1\":{\"832\":1}}],[\"的乐观读模式允许乐观地进行读操作\",{\"1\":{\"832\":1}}],[\"的扩展\",{\"1\":{\"832\":1}}],[\"的扩展库\",{\"1\":{\"756\":1}}],[\"的inheritablethreadlocals\",{\"1\":{\"822\":1}}],[\"的弱引用有关\",{\"1\":{\"818\":1}}],[\"的弱引用导致内存泄漏\",{\"1\":{\"731\":1}}],[\"的调度\",{\"1\":{\"807\":1}}],[\"的sleep方法后\",{\"1\":{\"807\":1}}],[\"的sap\",{\"1\":{\"120\":1}}],[\"的子类覆盖这个方法\",{\"1\":{\"794\":1}}],[\"的字符串拼接方式\",{\"1\":{\"792\":1}}],[\"的字段\",{\"1\":{\"114\":1}}],[\"的底层实现由\",{\"1\":{\"789\":1}}],[\"的底层是基于数组和链表\",{\"1\":{\"706\":1}}],[\"的次数\",{\"1\":{\"787\":1}}],[\"的相关知识\",{\"1\":{\"778\":1}}],[\"的相关依赖\",{\"1\":{\"498\":1}}],[\"的主要作用是使成员变量或方法与类关联\",{\"1\":{\"776\":1}}],[\"的主要有四种对象\",{\"1\":{\"734\":1}}],[\"的参数设置\",{\"1\":{\"768\":1}}],[\"的自增操作是线程安全的\",{\"1\":{\"844\":1}}],[\"的自增操作是原子性的\",{\"1\":{\"844\":1}}],[\"的自带工具\",{\"1\":{\"768\":1}}],[\"的自治系统连通图\",{\"1\":{\"212\":1}}],[\"的各项指标\",{\"1\":{\"768\":1}}],[\"的频率\",{\"1\":{\"767\":1,\"768\":1}}],[\"的常见参数配置知道哪些\",{\"1\":{\"764\":1}}],[\"的常见参数配置\",{\"0\":{\"764\":1}}],[\"的常数时间复杂度进行插入\",{\"1\":{\"705\":1}}],[\"的并发能力比较依赖于\",{\"1\":{\"751\":1}}],[\"的时候\",{\"1\":{\"739\":1}}],[\"的时间复杂度比\",{\"1\":{\"316\":1}}],[\"的时间复杂度相同\",{\"1\":{\"316\":1}}],[\"的时间复杂度和\",{\"1\":{\"316\":1}}],[\"的时间复杂度\",{\"1\":{\"316\":3,\"705\":1}}],[\"的对象有哪几种\",{\"0\":{\"734\":1},\"1\":{\"734\":1}}],[\"的几个内存区域中\",{\"1\":{\"731\":1}}],[\"的整个生命周期中存在\",{\"1\":{\"731\":1}}],[\"的整数幂\",{\"1\":{\"694\":1}}],[\"的距离\",{\"1\":{\"728\":1}}],[\"的上限\",{\"1\":{\"725\":1}}],[\"的特定处理程序\",{\"1\":{\"721\":1}}],[\"的文件格式关联\",{\"1\":{\"719\":1}}],[\"的查询性能的同时\",{\"1\":{\"714\":1}}],[\"的查找指定资源的方法的封装\",{\"1\":{\"419\":1}}],[\"的基础上\",{\"1\":{\"715\":1}}],[\"的基础上增加了按照插入顺序或者访问顺序\",{\"1\":{\"714\":1}}],[\"的基本工作原理是基于客户端\",{\"1\":{\"85\":1}}],[\"的个数\",{\"1\":{\"711\":1}}],[\"的个数是否仍与原来一样的奇数或偶数\",{\"1\":{\"134\":1,\"576\":1}}],[\"的个数是奇数或偶数来进行校验的\",{\"1\":{\"134\":1}}],[\"的计数器主要是为了在迭代器遍历集合时进行快速失败\",{\"1\":{\"710\":1}}],[\"的值\",{\"1\":{\"829\":2,\"844\":1}}],[\"的值只增加了\",{\"1\":{\"707\":1}}],[\"的值更新为\",{\"1\":{\"707\":2}}],[\"的值也为\",{\"1\":{\"707\":1}}],[\"的值为\",{\"1\":{\"707\":1}}],[\"的值不正确\",{\"1\":{\"707\":1}}],[\"的方法都是同步的\",{\"1\":{\"706\":1}}],[\"的方法设置属性的值\",{\"1\":{\"450\":1}}],[\"的幂作为哈希表的大小\",{\"1\":{\"706\":1}}],[\"的幂次方大小\",{\"1\":{\"706\":1}}],[\"的幂次方\",{\"0\":{\"688\":1},\"1\":{\"688\":1}}],[\"的hashmap主要有五点优化\",{\"1\":{\"701\":1}}],[\"的hashcode\",{\"1\":{\"693\":1}}],[\"的一致\",{\"1\":{\"758\":1}}],[\"的一个类\",{\"1\":{\"714\":1}}],[\"的一半\",{\"1\":{\"694\":1}}],[\"的一端传送到另一端所需的时间\",{\"1\":{\"263\":1}}],[\"的价值就体现出来了\",{\"1\":{\"694\":1}}],[\"的2进制也就是1111111\",{\"1\":{\"688\":1}}],[\"的效率高得多\",{\"1\":{\"688\":1}}],[\"的性能\",{\"1\":{\"685\":1,\"686\":1,\"688\":1}}],[\"的集合\",{\"1\":{\"683\":1}}],[\"的读写\",{\"1\":{\"681\":1}}],[\"的状态和意义\",{\"0\":{\"648\":1}}],[\"的解析过程\",{\"0\":{\"632\":1}}],[\"的配置\",{\"1\":{\"596\":1}}],[\"的关系\",{\"0\":{\"594\":1},\"1\":{\"594\":1}}],[\"的其他端口\",{\"1\":{\"579\":1}}],[\"的长度是\",{\"0\":{\"688\":1},\"1\":{\"688\":1}}],[\"的长度限制是多少\",{\"0\":{\"556\":1}}],[\"的长距离网络\",{\"1\":{\"161\":1}}],[\"的层次结构\",{\"1\":{\"522\":1}}],[\"的提示信息\",{\"1\":{\"497\":1}}],[\"的区别有哪些\",{\"0\":{\"562\":1}}],[\"的区别\",{\"0\":{\"566\":1,\"706\":1,\"786\":1,\"789\":1},\"1\":{\"474\":1,\"580\":2,\"674\":1,\"706\":1,\"786\":2,\"789\":2}}],[\"的行为约定\",{\"1\":{\"469\":1}}],[\"的类加载机制了解吗\",{\"1\":{\"760\":1}}],[\"的类加载机制\",{\"0\":{\"760\":1}}],[\"的类\",{\"1\":{\"455\":1,\"758\":1}}],[\"的属性值\",{\"1\":{\"450\":1}}],[\"的不可变对象类\",{\"1\":{\"450\":1}}],[\"的家族\",{\"1\":{\"443\":1}}],[\"的前缀来加载资源\",{\"1\":{\"422\":1}}],[\"的前缀\",{\"1\":{\"422\":1}}],[\"的缩写\",{\"1\":{\"375\":1,\"581\":1}}],[\"的引用\",{\"1\":{\"372\":1,\"791\":1}}],[\"的接口\",{\"1\":{\"372\":1,\"506\":2}}],[\"的支持\",{\"1\":{\"338\":1}}],[\"的实现本质上就是通过\",{\"1\":{\"683\":1}}],[\"的实现思路\",{\"1\":{\"327\":1}}],[\"的实例\",{\"1\":{\"326\":3,\"468\":1,\"495\":2}}],[\"的实际接收能力控制发送的数据量\",{\"1\":{\"293\":1}}],[\"的事件\",{\"1\":{\"326\":2}}],[\"的反函数\",{\"1\":{\"316\":1}}],[\"的函数\",{\"1\":{\"316\":1}}],[\"的算法\",{\"1\":{\"316\":1}}],[\"的算法一定优于\",{\"1\":{\"316\":1}}],[\"的运行时间呈线性增长\",{\"1\":{\"316\":1}}],[\"的大小\",{\"1\":{\"297\":1,\"868\":1}}],[\"的概念\",{\"1\":{\"296\":1}}],[\"的缓存\",{\"1\":{\"296\":1}}],[\"的情况下使用\",{\"1\":{\"788\":1}}],[\"的情况\",{\"1\":{\"294\":1,\"316\":1,\"769\":2}}],[\"的传输层协议\",{\"1\":{\"282\":1}}],[\"的交通工具\",{\"1\":{\"227\":1}}],[\"的每一个接口分配一个在全世界范围内是唯一的标识符\",{\"1\":{\"215\":1}}],[\"的问题\",{\"1\":{\"209\":1}}],[\"的问题而出现路由环路错误\",{\"1\":{\"205\":1}}],[\"的数组长度要取\",{\"1\":{\"694\":1}}],[\"的数组\",{\"1\":{\"312\":1}}],[\"的数据结构\",{\"1\":{\"687\":1}}],[\"的数据填满整个网络\",{\"1\":{\"296\":1}}],[\"的数据填满\",{\"1\":{\"296\":1}}],[\"的数据通信提供了虚拟的通信通道\",{\"1\":{\"274\":1}}],[\"的数据量\",{\"1\":{\"262\":1}}],[\"的数据报不发送icmp差错报告报文\",{\"1\":{\"200\":1}}],[\"的数量\",{\"1\":{\"240\":1}}],[\"的数字序列\",{\"1\":{\"68\":1}}],[\"的协议\",{\"1\":{\"196\":1}}],[\"的头上\",{\"1\":{\"184\":1}}],[\"的帧\",{\"1\":{\"159\":2}}],[\"的普通以太网mac帧\",{\"1\":{\"159\":1}}],[\"的\",{\"1\":{\"72\":1,\"251\":1,\"316\":1,\"326\":3,\"477\":1,\"686\":1,\"707\":1,\"712\":1,\"714\":1,\"829\":1,\"835\":1}}],[\"的作用\",{\"1\":{\"67\":1}}],[\"域名是别人喊你的名字\",{\"1\":{\"594\":1}}],[\"域名是人类可读的网址\",{\"1\":{\"594\":1}}],[\"域名和ip的关系\",{\"1\":{\"594\":1}}],[\"域名和ip地址之间存在映射关系\",{\"1\":{\"594\":1}}],[\"域名和\",{\"0\":{\"594\":1},\"1\":{\"594\":1}}],[\"域名下的具体解析记录\",{\"1\":{\"71\":1}}],[\"域名下的权威域名服务器列表\",{\"1\":{\"71\":1}}],[\"域名中的每一段称为一个标号\",{\"1\":{\"69\":1}}],[\"域名中的符号只能有\",{\"1\":{\"69\":1}}],[\"域名不区分大小写\",{\"1\":{\"69\":1}}],[\"域名的注意事项\",{\"1\":{\"69\":1}}],[\"域名解析方式\",{\"0\":{\"72\":1}}],[\"域名解析\",{\"1\":{\"68\":1,\"594\":1}}],[\"域名服务器分类\",{\"0\":{\"71\":1}}],[\"域名服务器\",{\"0\":{\"70\":1},\"1\":{\"68\":1,\"71\":1}}],[\"域名\",{\"0\":{\"69\":1},\"1\":{\"68\":1,\"69\":1}}],[\"域名系统\",{\"1\":{\"67\":1,\"594\":1}}],[\"域名系统dns\",{\"0\":{\"65\":1}}],[\"包下的原子类\",{\"1\":{\"844\":1}}],[\"包提供的\",{\"1\":{\"832\":1}}],[\"包提供的显式锁实现\",{\"1\":{\"832\":1}}],[\"包中的原子类\",{\"1\":{\"831\":1}}],[\"包中的\",{\"1\":{\"793\":1}}],[\"包装类的缓存机制\",{\"0\":{\"774\":1},\"1\":{\"774\":2}}],[\"包装类的自动拆装箱\",{\"1\":{\"773\":1}}],[\"包装\",{\"1\":{\"681\":1}}],[\"包装了一下\",{\"1\":{\"502\":9}}],[\"包它有一个compare\",{\"1\":{\"674\":1}}],[\"包名\",{\"1\":{\"538\":1}}],[\"包含应用程序的基本设置\",{\"1\":{\"539\":1}}],[\"包含对内部状态和外部状态的操作方法\",{\"1\":{\"530\":1}}],[\"包含内部状态和外部状态两部分\",{\"1\":{\"530\":1}}],[\"包含子组件\",{\"1\":{\"525\":1}}],[\"包含了代理对象的创建和方法调用的示例\",{\"1\":{\"498\":1}}],[\"包含了\",{\"1\":{\"498\":1}}],[\"包含了一些关于ip头部的信息\",{\"1\":{\"304\":1}}],[\"包含各个构建步骤的方法\",{\"1\":{\"448\":1}}],[\"包含一个抽象的工厂方法\",{\"1\":{\"434\":2}}],[\"包含一个静态方法用于创建产品对象\",{\"1\":{\"427\":1}}],[\"包含一个解释方法\",{\"1\":{\"390\":1}}],[\"包含execute方法\",{\"1\":{\"383\":1}}],[\"包含元素对象的结构\",{\"1\":{\"371\":1}}],[\"包含用于遍历聚合对象的方法\",{\"1\":{\"365\":1}}],[\"包含以下内容\",{\"1\":{\"210\":1}}],[\"包含在字段中的信息的含义\",{\"1\":{\"56\":1}}],[\"包括了\",{\"1\":{\"834\":1}}],[\"包括了客户端寻找dhcp服务器\",{\"1\":{\"64\":1}}],[\"包括读取\",{\"1\":{\"829\":1}}],[\"包括公共的\",{\"1\":{\"799\":2}}],[\"包括这个对象所包含的内部对象\",{\"1\":{\"784\":1}}],[\"包括总内存大小\",{\"1\":{\"768\":1}}],[\"包括自己的代码甚至框架中的代码\",{\"1\":{\"768\":1}}],[\"包括年轻代和年老代\",{\"1\":{\"741\":2}}],[\"包括两个区域\",{\"1\":{\"737\":1}}],[\"包括哈希码\",{\"1\":{\"729\":1}}],[\"包括对象的哈希码\",{\"1\":{\"726\":1}}],[\"包括垃圾回收\",{\"1\":{\"723\":1}}],[\"包括源ip地址和目标ip地址\",{\"1\":{\"593\":1}}],[\"包括目标mac地址\",{\"1\":{\"575\":1}}],[\"包括标签协议标识\",{\"1\":{\"575\":1}}],[\"包括sdk的本地路径\",{\"1\":{\"539\":1}}],[\"包括软件的安装\",{\"1\":{\"536\":1}}],[\"包括每个文件和文件夹的名称\",{\"1\":{\"525\":1}}],[\"包括库存管理\",{\"1\":{\"518\":2}}],[\"包括记录日志和调用被代理对象的方法\",{\"1\":{\"498\":1}}],[\"包括\",{\"1\":{\"490\":3,\"768\":2}}],[\"包括输入输出的约束\",{\"1\":{\"468\":1}}],[\"包括支付宝支付\",{\"1\":{\"344\":1}}],[\"包括硬件配置\",{\"1\":{\"315\":1}}],[\"包括udp头部和数据部分的长度\",{\"1\":{\"304\":1}}],[\"包括网络接口层\",{\"1\":{\"268\":1}}],[\"包括物理层\",{\"1\":{\"268\":1}}],[\"包括今后可能出现的各种应用\",{\"1\":{\"257\":1}}],[\"包括电缆\",{\"1\":{\"240\":1}}],[\"包括文字\",{\"1\":{\"238\":1}}],[\"包括比特率和带宽\",{\"1\":{\"229\":1}}],[\"包括铜线\",{\"1\":{\"229\":1}}],[\"包括串行传输\",{\"1\":{\"227\":1}}],[\"包括接收该分组的源接口\",{\"1\":{\"205\":1}}],[\"包括状态行\",{\"1\":{\"107\":1}}],[\"包括请求行\",{\"1\":{\"107\":1}}],[\"包括字体\",{\"1\":{\"104\":1}}],[\"包括中文\",{\"1\":{\"96\":1}}],[\"包括邮件头和邮件正文\",{\"1\":{\"94\":1}}],[\"包括创建文件夹\",{\"1\":{\"98\":1}}],[\"包括创建\",{\"1\":{\"83\":1}}],[\"以atomicinteger的添加方法为例\",{\"1\":{\"847\":1}}],[\"以复用\",{\"1\":{\"790\":1}}],[\"以纳秒为单位\",{\"1\":{\"785\":1}}],[\"以了解出现问题的时间点以及当前\",{\"1\":{\"768\":1}}],[\"以达到更好的垃圾回收效果\",{\"1\":{\"751\":1}}],[\"以这些对象触发\",{\"1\":{\"746\":1}}],[\"以帧为单位的压栈和出栈操作\",{\"1\":{\"724\":1}}],[\"以后的编码过程无需再关心对象内部的执行过程\",{\"1\":{\"782\":1}}],[\"以后的\",{\"1\":{\"706\":1}}],[\"以初始长度\",{\"1\":{\"694\":1}}],[\"以减少竞争\",{\"1\":{\"855\":1}}],[\"以减少停顿时间\",{\"1\":{\"748\":1}}],[\"以减少搜索时间\",{\"1\":{\"686\":1,\"706\":1}}],[\"以减少冲突再次发生的可能性\",{\"1\":{\"581\":1}}],[\"以最大化数据传输的可靠性和效率\",{\"1\":{\"622\":1}}],[\"以识别和路由到新划分的子网\",{\"1\":{\"596\":1}}],[\"以检测是否有其他设备正在发送数据\",{\"1\":{\"581\":1}}],[\"以检测是否发生碰撞\",{\"1\":{\"152\":1}}],[\"以更清晰地理解文件夹和文件之间的层次关系\",{\"1\":{\"525\":1}}],[\"以文件和文件夹为对象来说明组合设计模式的应用\",{\"1\":{\"525\":1}}],[\"以表示\",{\"1\":{\"522\":1}}],[\"以提高查找和插入的效率\",{\"1\":{\"788\":1}}],[\"以提高执行效率\",{\"1\":{\"720\":1}}],[\"以提高系统的效率和可扩展性\",{\"1\":{\"533\":1}}],[\"以提高系统的可维护性和灵活性时\",{\"1\":{\"517\":1}}],[\"以提供特定的实现\",{\"1\":{\"330\":1}}],[\"以提供可靠的通信服务\",{\"1\":{\"184\":1}}],[\"以增强被代理对象的功能\",{\"1\":{\"495\":1}}],[\"以控制对这个对象的访问\",{\"1\":{\"494\":1}}],[\"以免影响代码的可读性和理解性\",{\"1\":{\"485\":1}}],[\"以免引发concurrentmodificationexception异常\",{\"1\":{\"367\":1}}],[\"以简化客户端与子系统之间的交互\",{\"1\":{\"514\":1,\"515\":1}}],[\"以简单的方式解决问题\",{\"1\":{\"482\":1}}],[\"以简洁的方式解决问题\",{\"1\":{\"482\":1}}],[\"以符合客户端的实际需求\",{\"1\":{\"474\":2}}],[\"以满足组合和叶子对象的需要\",{\"1\":{\"526\":1}}],[\"以满足客户端的需求\",{\"1\":{\"512\":1}}],[\"以满足客户端的实际需求\",{\"1\":{\"472\":1}}],[\"以满足特定的需求\",{\"1\":{\"495\":1}}],[\"以满足系统的变化需求\",{\"1\":{\"461\":1}}],[\"以满足通信双方的需求和传输介质的限制\",{\"1\":{\"229\":1}}],[\"以上方法都可以保证在多线程环境下对\",{\"1\":{\"844\":1}}],[\"以上代码展示了一个适配器模式的示例\",{\"1\":{\"510\":1}}],[\"以上代码展示了一个简单的资源加载器\",{\"1\":{\"422\":1}}],[\"以上三步均为客服端的\",{\"1\":{\"76\":1}}],[\"以确保锁的释放与对象的关联性\",{\"1\":{\"813\":1}}],[\"以确保正确的行为\",{\"1\":{\"788\":2}}],[\"以确保它们在哈希表中的存储位置一致\",{\"1\":{\"788\":1}}],[\"以确保程序的健壮性和可靠性\",{\"1\":{\"710\":1}}],[\"以确保在网络中正确传输数据\",{\"1\":{\"577\":1}}],[\"以确保数据的完整性和正确性\",{\"1\":{\"576\":1}}],[\"以确保数据的有效传输\",{\"1\":{\"182\":1}}],[\"以确保系统的正确性和可靠性\",{\"1\":{\"533\":1}}],[\"以确保系统的可维护性和可扩展性\",{\"1\":{\"430\":1}}],[\"以确保系统的可维护性和灵活性\",{\"1\":{\"421\":1}}],[\"以确保设计的合理性和可扩展性\",{\"1\":{\"519\":1}}],[\"以防止其他对象直接实例化该类\",{\"1\":{\"418\":1}}],[\"以防止本地数据丢失\",{\"1\":{\"83\":1}}],[\"以避免混叠\",{\"1\":{\"622\":1}}],[\"以避免接收方无法处理过多的数据而发生数据丢失\",{\"1\":{\"584\":1}}],[\"以避免出现不必要的操作或错误\",{\"1\":{\"526\":1}}],[\"以避免碰撞和确保安全航行\",{\"1\":{\"401\":1}}],[\"以避免发送方发送速度过快导致接收方无法处理或缓存溢出的问题\",{\"1\":{\"293\":1}}],[\"以演示解释器设计模式的应用\",{\"1\":{\"390\":1}}],[\"以支持请求的参数化和解耦客户端与接收者\",{\"1\":{\"386\":1}}],[\"以一个遥控器控制电灯为例\",{\"1\":{\"383\":1}}],[\"以一个明星发布要开全球音乐巡演会的例子来说明\",{\"1\":{\"326\":1}}],[\"以一个特殊字符代表一个帧的起始\",{\"1\":{\"131\":1}}],[\"以实现对相似对象的共享和复用\",{\"1\":{\"529\":1}}],[\"以实现更复杂的功能组合\",{\"1\":{\"500\":1}}],[\"以实现更灵活\",{\"1\":{\"496\":1}}],[\"以实现更灵活和解耦的系统设计\",{\"1\":{\"403\":1,\"408\":1}}],[\"以实现不同的业务逻辑\",{\"1\":{\"386\":2}}],[\"以实现不同对象之间的交互和任务分配\",{\"1\":{\"320\":2}}],[\"以实现数据和信息的共享\",{\"1\":{\"257\":1}}],[\"以此来加大低位的随机性\",{\"1\":{\"694\":1}}],[\"以此来屏蔽所经网络类型或参数配置的不同\",{\"1\":{\"275\":1}}],[\"以此类推\",{\"1\":{\"316\":1}}],[\"以平方级别增长\",{\"1\":{\"316\":1}}],[\"以字节为单位传送\",{\"1\":{\"282\":1}}],[\"以两码元的临界点区分是否发生变化\",{\"1\":{\"238\":1}}],[\"以适应不同的需求和变化\",{\"1\":{\"506\":1}}],[\"以适应不同部门或网络区域的需求\",{\"1\":{\"222\":1}}],[\"以适应特定的传输介质\",{\"1\":{\"238\":1,\"239\":1}}],[\"以判别接收到的是比特0还是1\",{\"1\":{\"236\":1}}],[\"以节约公共ip地址的使用\",{\"1\":{\"223\":1}}],[\"以保证合理的使用公共资源\",{\"1\":{\"853\":1}}],[\"以保证对象在哈希表等数据结构中的正确性和性能\",{\"1\":{\"788\":1}}],[\"以保证遍历过程中的一致性和避免潜在的并发修改引起的数据不一致性\",{\"1\":{\"710\":1}}],[\"以保证遍历过程中的一致性和防止数据不一致性\",{\"1\":{\"710\":1}}],[\"以保证传输的完整性和正确性\",{\"1\":{\"577\":1}}],[\"以保证数据在传输过程中的准确性和完整性\",{\"1\":{\"305\":1}}],[\"以保证网络的稳定性和吞吐量的合理分配\",{\"1\":{\"296\":1}}],[\"以保证网络尽快恢复正常\",{\"1\":{\"175\":1}}],[\"以保证被传输数据的正确性\",{\"1\":{\"119\":1}}],[\"以下是组合模式的一些关键点和总结\",{\"1\":{\"526\":1}}],[\"以下是使用markdown格式绘制上述文件夹和文件的树形结构\",{\"1\":{\"525\":1}}],[\"以下是使用开闭原则改进后的代码示例\",{\"1\":{\"465\":1}}],[\"以下是桥接模式的几个关键角色\",{\"1\":{\"504\":1}}],[\"以下是对kiss原则的总结\",{\"1\":{\"482\":1}}],[\"以下是接口隔离原则的总结\",{\"1\":{\"474\":1}}],[\"以下是其中一些重要的原则和准则\",{\"1\":{\"458\":1}}],[\"以下是编译前和编译后的代码\",{\"1\":{\"450\":1}}],[\"以下是整合后的代码\",{\"1\":{\"443\":1}}],[\"以下是java实现的简单聊天应用程序\",{\"1\":{\"408\":1}}],[\"以下是java实现的简单飞机交通管制系统\",{\"1\":{\"403\":1}}],[\"以下是java实现的简单规则引擎\",{\"1\":{\"394\":1}}],[\"以下是一些常见的使用场景\",{\"1\":{\"355\":1}}],[\"以下是一些具体案例\",{\"1\":{\"352\":1}}],[\"以下是一个违反kiss原则的示例代码\",{\"1\":{\"481\":1}}],[\"以下是一个示例代码片段\",{\"1\":{\"524\":1}}],[\"以下是一个示例代码\",{\"1\":{\"495\":1}}],[\"以下是一个示例\",{\"1\":{\"461\":1}}],[\"以下是一个按照组成和基本流程的代码案例\",{\"1\":{\"365\":1}}],[\"以下是一个简单的客户端代码示例\",{\"1\":{\"403\":1,\"408\":1}}],[\"以下是一个简单的状态设计模式代码案例\",{\"1\":{\"359\":1}}],[\"以下是一个简化的示例代码\",{\"1\":{\"325\":1}}],[\"以下是一个使用责任链设计模式的简单的示例\",{\"1\":{\"350\":1}}],[\"以下是一个使用策略设计模式的简单的示例\",{\"1\":{\"343\":1}}],[\"以下是一个例子\",{\"1\":{\"221\":1}}],[\"以下是用于接受用户输入并根据输入选择策略的代码\",{\"1\":{\"343\":1}}],[\"以下是这些字段的功能和作用\",{\"1\":{\"283\":1,\"302\":1}}],[\"以下是ip地址的应用规划涉及的一些重要方面\",{\"1\":{\"222\":1}}],[\"以下是关于stp的一些基本信息\",{\"1\":{\"175\":1}}],[\"以下是dns的一些重要概念\",{\"1\":{\"68\":1}}],[\"以扩大网络的传输距离\",{\"1\":{\"170\":1}}],[\"以太网协议简单\",{\"1\":{\"578\":1}}],[\"以太网协议是一种计算机局域网技术\",{\"1\":{\"578\":1}}],[\"以太网协议是怎样运作的\",{\"0\":{\"578\":1},\"1\":{\"578\":1}}],[\"以太网数据帧\",{\"1\":{\"575\":1}}],[\"以太网交换机和路由器等\",{\"1\":{\"582\":1}}],[\"以太网交换机通过自学习算法逐渐建立起帧交换表\",{\"1\":{\"174\":1}}],[\"以太网交换机通常由多个接口\",{\"1\":{\"173\":1}}],[\"以太网交换机是即插即用设备\",{\"1\":{\"174\":1}}],[\"以太网交换机是一种即插即用的设备\",{\"1\":{\"173\":1}}],[\"以太网交换机收到帧后\",{\"1\":{\"174\":1}}],[\"以太网交换机工作在数据链路层\",{\"1\":{\"173\":1}}],[\"以太网交换机一般都具有多种速率的接口\",{\"1\":{\"173\":1}}],[\"以太网交换机具有并行性\",{\"1\":{\"173\":1}}],[\"以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞\",{\"1\":{\"152\":1}}],[\"以太网规定\",{\"1\":{\"152\":1}}],[\"以太网\",{\"1\":{\"152\":1,\"158\":1,\"578\":1}}],[\"以太网mac帧\",{\"1\":{\"129\":2}}],[\"以便接收设备能够理解和处理\",{\"1\":{\"619\":1}}],[\"以便计算机能够定位要访问的服务器\",{\"1\":{\"594\":1}}],[\"以便它们可以协同工作\",{\"1\":{\"520\":1}}],[\"以便它们可以无缝地协同工作\",{\"1\":{\"512\":1}}],[\"以便与新的系统集成\",{\"1\":{\"510\":1}}],[\"以便可以连续调用多个方法\",{\"1\":{\"450\":1}}],[\"以便可以在需要时进行查看或恢复\",{\"1\":{\"378\":1}}],[\"以便于协调和控制时\",{\"1\":{\"419\":1}}],[\"以便于ipv4地址的寻址操作\",{\"1\":{\"216\":1}}],[\"以便能够解释和处理特定的语法结构\",{\"1\":{\"389\":1}}],[\"以便进行转发\",{\"1\":{\"268\":1}}],[\"以便知道实际上到底有多少数据量能够通过网络\",{\"1\":{\"262\":1}}],[\"以便访问内部资源\",{\"1\":{\"223\":1}}],[\"以便建立和维护邻居关系\",{\"1\":{\"210\":1}}],[\"以便将未知目的地的数据包发送到一个已知的位置\",{\"1\":{\"205\":1}}],[\"以便释放网络资源\",{\"1\":{\"184\":1}}],[\"以便不同网络间能相互识别\",{\"1\":{\"184\":1,\"589\":1}}],[\"以便在特定传输介质中\",{\"1\":{\"619\":1}}],[\"以便在特定场景中获得更好的效果\",{\"1\":{\"385\":1}}],[\"以便在数据链路上传输\",{\"1\":{\"584\":1}}],[\"以便在不同的上下文中执行相似的请求\",{\"1\":{\"384\":1}}],[\"以便在物理介质上传输\",{\"1\":{\"238\":1,\"573\":1}}],[\"以便在传输层和网络层之间传输\",{\"1\":{\"280\":1}}],[\"以便在传输介质上传输\",{\"1\":{\"227\":1,\"229\":1,\"239\":1}}],[\"以便在传输过程中不受邮件系统的修改\",{\"1\":{\"96\":1}}],[\"以便在公共网络中唯一标识这个连接\",{\"1\":{\"223\":1}}],[\"以便在网络发生变化时适时调整\",{\"1\":{\"175\":1}}],[\"以便所有设备都能接收到\",{\"1\":{\"166\":1}}],[\"以便构造路由表\",{\"1\":{\"162\":1}}],[\"以便支持日益增长的通信量\",{\"1\":{\"161\":1}}],[\"以便向网络层提供高质量的服务\",{\"1\":{\"119\":1}}],[\"以及该锁属于哪个线程\",{\"1\":{\"813\":1}}],[\"以及进行其他与时间相关的操作\",{\"1\":{\"809\":1}}],[\"以及其他被虚拟机认为是基础类的类\",{\"1\":{\"755\":1}}],[\"以及\",{\"1\":{\"708\":1}}],[\"以及根据实际情况调整负载因子\",{\"1\":{\"685\":1}}],[\"以及在不同网络之间传输数据\",{\"1\":{\"593\":1}}],[\"以及在拥塞发生时能够有效地应对和解决问题\",{\"1\":{\"296\":1}}],[\"以及它们的子文件和子文件夹\",{\"1\":{\"525\":1}}],[\"以及一些抽象的操作方法\",{\"1\":{\"505\":1}}],[\"以及代理对象的增强效果\",{\"1\":{\"498\":1}}],[\"以及前置条件和后置条件\",{\"1\":{\"468\":1}}],[\"以及构建过程中涉及多个步骤或变化的对象\",{\"1\":{\"452\":1}}],[\"以及获取构建完成的电脑对象的方法getcomputer\",{\"1\":{\"448\":1}}],[\"以及对应的设置方法\",{\"1\":{\"448\":1}}],[\"以及对报文进行响应的规则\",{\"1\":{\"56\":1}}],[\"以及大于30或小于40的结果为\",{\"1\":{\"395\":1}}],[\"以及解释预定义的表达式\",{\"1\":{\"388\":1}}],[\"以及next\",{\"1\":{\"365\":1}}],[\"以及若干抽象方法\",{\"1\":{\"332\":1}}],[\"以及udp长度和校验和\",{\"1\":{\"301\":1}}],[\"以及网络的稳定性\",{\"1\":{\"287\":1}}],[\"以及传输层为它的上层提供服务的逻辑接口\",{\"1\":{\"277\":1}}],[\"以及调制技术的选择和应用\",{\"1\":{\"229\":1}}],[\"以及划分子网的概念\",{\"1\":{\"220\":1}}],[\"以及列出要撤销的多条路由\",{\"1\":{\"212\":1}}],[\"以及报告出错的情况等\",{\"1\":{\"212\":1}}],[\"以及所有回答ap探询的帧和在pcf方式中接入点ap发送出的任何帧\",{\"1\":{\"152\":1}}],[\"以及电子邮件所需的协议\",{\"1\":{\"90\":1}}],[\"以备下一次使用\",{\"1\":{\"81\":1}}],[\"以释放其当前使用的ip地址\",{\"1\":{\"64\":1}}],[\"以获取新的租约\",{\"1\":{\"64\":1}}],[\"并处理阻塞队列中的任务\",{\"1\":{\"867\":1}}],[\"并处理表达式的非终结符部分\",{\"1\":{\"390\":1}}],[\"并处理表达式的终结符部分\",{\"1\":{\"390\":1}}],[\"并唤醒因为等待该资源而被阻塞的进程\",{\"1\":{\"853\":1}}],[\"并禁止了指令重排序\",{\"1\":{\"834\":1}}],[\"并立即返回\",{\"1\":{\"807\":1}}],[\"并减少了在运行时出现类型错误的可能性\",{\"1\":{\"797\":1}}],[\"并没有实现缓存机制\",{\"1\":{\"774\":1}}],[\"并没有发生改变\",{\"1\":{\"502\":2}}],[\"并按空间排序\",{\"1\":{\"768\":1}}],[\"并按照要求构建了文件夹的层次结构\",{\"1\":{\"525\":1}}],[\"并按照一定的顺序将它们连接成责任链\",{\"1\":{\"352\":2}}],[\"并按照处理顺序连接成了一个责任链\",{\"1\":{\"350\":1}}],[\"并按照先后顺序存入自己的缓存\",{\"1\":{\"148\":1}}],[\"并行就是同一时刻\",{\"1\":{\"805\":1}}],[\"并行跟并发\",{\"0\":{\"805\":1}}],[\"并行收集线程数\",{\"1\":{\"764\":2}}],[\"并行收集器设置\",{\"1\":{\"764\":1}}],[\"并行传输\",{\"0\":{\"233\":1},\"1\":{\"233\":1}}],[\"并进行分析和诊断\",{\"1\":{\"763\":1}}],[\"并放在程序的\",{\"1\":{\"758\":1}}],[\"并记录下直接与\",{\"1\":{\"746\":1,\"750\":1}}],[\"并更新列表上的记录\",{\"1\":{\"727\":1}}],[\"并更容易进行维护和扩展\",{\"1\":{\"485\":1}}],[\"并由堆内存被应用所有的线程共享\",{\"1\":{\"724\":1}}],[\"并以链表或红黑树的形式存储\",{\"1\":{\"707\":1}}],[\"并以一个专门的字段来标识当前帧内字节数\",{\"1\":{\"131\":1}}],[\"并利用数据的随机访问特性快速的元素进行增删查改\",{\"1\":{\"690\":1}}],[\"并影响了可用的网络和主机数量\",{\"1\":{\"595\":1}}],[\"并确保信号在传输过程中的稳定性和可靠性\",{\"1\":{\"618\":1}}],[\"并确保发送和接收双方的数据同步和正确传输\",{\"1\":{\"584\":1}}],[\"并确保在整个系统中只有一个实例存在\",{\"1\":{\"421\":1}}],[\"并确保在整个系统中只存在一个实例\",{\"1\":{\"417\":1}}],[\"并提高了传输的可靠性和适应性\",{\"1\":{\"619\":1}}],[\"并提高系统的性能\",{\"1\":{\"529\":1}}],[\"并提供默认实现\",{\"1\":{\"526\":1}}],[\"并提供一个统一的接口给客户端\",{\"1\":{\"517\":1}}],[\"并提供一个方法来在特定销售渠道上销售商品\",{\"1\":{\"506\":1}}],[\"并提供一个全局访问点来获取该实例\",{\"1\":{\"417\":1}}],[\"并提供一个全局访问点以供其他对象使用\",{\"1\":{\"416\":1}}],[\"并提供灵活性和可扩展性\",{\"1\":{\"446\":1}}],[\"并提供对该实例的全局访问\",{\"1\":{\"418\":1}}],[\"并提供给originator进行恢复操作的接口\",{\"1\":{\"377\":1}}],[\"并提供具体的实现\",{\"1\":{\"371\":1}}],[\"并提供添加处理器和执行处理器链的方法\",{\"1\":{\"353\":1}}],[\"并提供了公平锁和非公平锁的不同实现方式\",{\"1\":{\"839\":1}}],[\"并提供了添加\",{\"1\":{\"526\":1}}],[\"并提供了添加元素\",{\"1\":{\"366\":1}}],[\"并提供了一种灵活的方式来处理树状结构\",{\"1\":{\"525\":1}}],[\"并提供了系统的可扩展性和灵活性\",{\"1\":{\"512\":1}}],[\"并提供了各自特定的属性和方法\",{\"1\":{\"506\":1}}],[\"并提供了灵活性和可扩展性\",{\"1\":{\"451\":1}}],[\"并提供了addhandler方法用于添加处理器到链中\",{\"1\":{\"354\":1}}],[\"并提供了\",{\"1\":{\"344\":1}}],[\"并提供方法用于添加\",{\"1\":{\"324\":1}}],[\"并非真正的文件系统结构\",{\"1\":{\"525\":1}}],[\"并对两个excel数据进行校对\",{\"1\":{\"854\":1}}],[\"并对叶子节点和组合节点提供一致的操作接口\",{\"1\":{\"523\":1}}],[\"并对其进行进一步操作\",{\"1\":{\"448\":1}}],[\"并传入适配器\",{\"1\":{\"510\":1}}],[\"并打印出\",{\"1\":{\"502\":1}}],[\"并打印相应的消息内容\",{\"1\":{\"403\":1}}],[\"并设置默认初始值\",{\"1\":{\"720\":1}}],[\"并设置父类和方法拦截器\",{\"1\":{\"498\":1}}],[\"并设置其接收者\",{\"1\":{\"383\":1}}],[\"并观察远程通信的效果\",{\"1\":{\"495\":1}}],[\"并观察安全验证的效果\",{\"1\":{\"495\":1}}],[\"并观察缓存的效果\",{\"1\":{\"495\":1}}],[\"并观察输出结果\",{\"1\":{\"495\":1}}],[\"并观察功能增强的效果\",{\"1\":{\"495\":1}}],[\"并拥有一个\",{\"1\":{\"495\":1}}],[\"并促进了可\",{\"1\":{\"490\":1}}],[\"并促进了代码的模块化和解耦\",{\"1\":{\"461\":1}}],[\"并有两个实现类\",{\"1\":{\"489\":1}}],[\"并降低项目的成本和风险\",{\"1\":{\"482\":1}}],[\"并保持多态性的特性\",{\"1\":{\"470\":1}}],[\"并抛出了一个不支持的操作异常\",{\"1\":{\"469\":1}}],[\"并符合开闭原则的设计理念\",{\"1\":{\"465\":1}}],[\"并增加系统的灵活性和可扩展性\",{\"1\":{\"486\":1}}],[\"并增加了代码的复杂性\",{\"1\":{\"461\":1}}],[\"并增加对应的分支\",{\"1\":{\"422\":1}}],[\"并包含一个指向实现部分的引用\",{\"1\":{\"504\":1}}],[\"并包含一些特定的方法\",{\"1\":{\"443\":1}}],[\"并包含订单的处理逻辑\",{\"1\":{\"461\":1}}],[\"并复制原始订单中的商品和客户信息\",{\"1\":{\"455\":1}}],[\"并复制歌单中的歌曲列表\",{\"1\":{\"454\":1}}],[\"并针对引用类型的属性进行深度复制\",{\"1\":{\"455\":1}}],[\"并允许在构建过程中进行配置和定制\",{\"1\":{\"452\":1}}],[\"并允许在构建过程中配置对象的各个部分\",{\"1\":{\"452\":1}}],[\"并允许文件具有存取权限\",{\"1\":{\"83\":1}}],[\"并最后调用\",{\"1\":{\"450\":1}}],[\"并最终显示了每种类型页面的访问次数\",{\"1\":{\"372\":1}}],[\"并最终导出为指定格式的文件\",{\"1\":{\"336\":1}}],[\"并返回构建完成的对象\",{\"1\":{\"448\":2}}],[\"并返回分割后的第一个元素作为前缀\",{\"1\":{\"422\":1}}],[\"并从\",{\"1\":{\"436\":1}}],[\"并定义了叶子节点的操作方法\",{\"1\":{\"524\":1}}],[\"并定义了一个抽象方法\",{\"1\":{\"436\":1}}],[\"并定义解释方法\",{\"1\":{\"389\":1}}],[\"并权衡其优缺点\",{\"1\":{\"410\":1}}],[\"并创建了两个具体的折扣策略类\",{\"1\":{\"465\":1}}],[\"并创建了两个用户作为参与者\",{\"1\":{\"409\":1}}],[\"并创建了两个飞机作为参与者\",{\"1\":{\"404\":1}}],[\"并创建了一个\",{\"1\":{\"326\":1}}],[\"并模拟它们之间的通信\",{\"1\":{\"403\":1,\"408\":1}}],[\"并负责控制数据传输的物理特性\",{\"1\":{\"617\":1}}],[\"并负责实现具体产品的创建和加载\",{\"1\":{\"443\":1}}],[\"并负责实际处理用户之间的消息传递逻辑\",{\"1\":{\"407\":1}}],[\"并负责创建特定的产品家族\",{\"1\":{\"440\":1}}],[\"并负责创建备忘录对象和从备忘录对象中恢复状态\",{\"1\":{\"377\":1}}],[\"并负责处理飞机之间的通信和交互\",{\"1\":{\"402\":1}}],[\"并结合实际情况选择是否使用解释器模式来解决问题\",{\"1\":{\"396\":1}}],[\"并解释预定义的表达式\",{\"1\":{\"395\":1}}],[\"并使代码更易于理解和修改\",{\"1\":{\"486\":1}}],[\"并使得它们可以互相替换\",{\"1\":{\"386\":1}}],[\"并使这些策略类可以相互替换\",{\"1\":{\"386\":1}}],[\"并使用交叉规则得出2个交配结果\",{\"1\":{\"854\":1}}],[\"并使用它来处理订单\",{\"1\":{\"518\":1}}],[\"并使用策略模式在\",{\"1\":{\"465\":1}}],[\"并使用额外一根传输线来传输时钟信号\",{\"1\":{\"238\":1}}],[\"并使用143端口号进行通信\",{\"1\":{\"98\":1}}],[\"并使用110端口号进行通信\",{\"1\":{\"97\":1}}],[\"并再次按下按钮\",{\"1\":{\"383\":1}}],[\"并能控制不同网络之间的数据流向\",{\"1\":{\"580\":1}}],[\"并能够跟踪进度\",{\"1\":{\"375\":1}}],[\"并能支持广泛的和日益增长的应用\",{\"1\":{\"257\":1}}],[\"并接受访问者的访问\",{\"1\":{\"372\":1}}],[\"并接受对方的访问请求\",{\"1\":{\"184\":1,\"589\":1}}],[\"并让他们按照一定顺序访问这些景点\",{\"1\":{\"372\":1}}],[\"并可以通过super关键字直接调用\",{\"1\":{\"782\":1}}],[\"并可以提供一定程度的灵活性和扩展性\",{\"1\":{\"430\":1}}],[\"并可以接受访问者\",{\"1\":{\"372\":1}}],[\"并可以根据版本号注册不同的反序列化策略\",{\"1\":{\"346\":1}}],[\"并为每种具体元素对象提供具体的访问操作\",{\"1\":{\"371\":1}}],[\"并为每个报文段分配一个唯一的序列号\",{\"1\":{\"289\":1}}],[\"并发任务处理\",{\"1\":{\"858\":1}}],[\"并发工具类\",{\"0\":{\"850\":1}}],[\"并发包中的锁就是基于aqs实现的\",{\"1\":{\"846\":1}}],[\"并发其实是一个cpu来应付多个线程\",{\"1\":{\"809\":1}}],[\"并发的实现依赖于cpu切换线程\",{\"1\":{\"805\":1}}],[\"并发就是同一时刻\",{\"1\":{\"805\":1}}],[\"并发回收时垃圾收集线程可能会抢占用户线程的资源\",{\"1\":{\"751\":1}}],[\"并发收集\",{\"1\":{\"751\":1}}],[\"并发清除阶段\",{\"1\":{\"751\":1}}],[\"并发清除\",{\"1\":{\"746\":1}}],[\"并发标记是指在垃圾回收的过程中\",{\"1\":{\"748\":1}}],[\"并发标记\",{\"1\":{\"746\":1,\"750\":1}}],[\"并发度更大\",{\"1\":{\"711\":1}}],[\"并发度\",{\"1\":{\"711\":1}}],[\"并发修改异常\",{\"1\":{\"710\":1}}],[\"并发修改异常是什么\",{\"0\":{\"710\":1},\"1\":{\"710\":1}}],[\"并发修改\",{\"1\":{\"367\":1,\"709\":1,\"710\":1}}],[\"并发送数据\",{\"1\":{\"198\":1}}],[\"并支持系统的扩展\",{\"1\":{\"361\":1}}],[\"并初始状态为状态a\",{\"1\":{\"359\":1}}],[\"并初始化为某个具体状态的对象\",{\"1\":{\"359\":1}}],[\"并委派给当前具体状态对象处理\",{\"1\":{\"359\":1}}],[\"并持有一个子组件列表\",{\"1\":{\"524\":1}}],[\"并持有一个抽象组件对象的引用\",{\"1\":{\"501\":1}}],[\"并持有一个具体状态的引用\",{\"1\":{\"359\":1}}],[\"并持有下一个处理器的引用\",{\"1\":{\"350\":1,\"353\":1}}],[\"并依次调用它们的handle方法\",{\"1\":{\"354\":1}}],[\"并实现它们的具体功能\",{\"1\":{\"516\":1}}],[\"并实现了\",{\"1\":{\"506\":1}}],[\"并实现了相关的操作方法\",{\"1\":{\"505\":1}}],[\"并实现了构建电脑各个部件的方法\",{\"1\":{\"448\":1}}],[\"并实现各个构建步骤的具体逻辑\",{\"1\":{\"448\":1}}],[\"并实现更多的具体处理器来满足不同的需求\",{\"1\":{\"353\":1}}],[\"并实现其中的抽象方法\",{\"1\":{\"332\":1,\"336\":1}}],[\"并不会立即停止\",{\"1\":{\"864\":1}}],[\"并不意味着java平台的具体实现必须要按照\",{\"1\":{\"826\":1}}],[\"并不真实存在\",{\"1\":{\"824\":1}}],[\"并不是固定地处于某个状态\",{\"1\":{\"808\":1}}],[\"并不是所有的类在程序启动时都会被加载\",{\"1\":{\"755\":1}}],[\"并不需要保持顺序的情况\",{\"1\":{\"705\":1}}],[\"并不需要持有下一个处理器的引用\",{\"1\":{\"350\":1}}],[\"并不仅仅是基于泊松分布考虑的\",{\"1\":{\"696\":1}}],[\"并不限于一般的计算机\",{\"1\":{\"257\":1}}],[\"并注册不同版本的反序列化策略\",{\"1\":{\"346\":1}}],[\"并通过哈希表实现\",{\"1\":{\"704\":1}}],[\"并通过组件接口操作对象\",{\"1\":{\"524\":1}}],[\"并通过包装或转换来适应被适配者\",{\"1\":{\"508\":1}}],[\"并通过构造器调用父类的构造器进行初始化\",{\"1\":{\"502\":2}}],[\"并通过构造器接收一个component对象进行初始化\",{\"1\":{\"502\":1}}],[\"并通过构造函数依赖注入的方式获取userrepository和emailservice实例\",{\"1\":{\"481\":1}}],[\"并通过中介者来与其他飞机通信\",{\"1\":{\"401\":1}}],[\"并通过中介者来与其他相关对象通信\",{\"1\":{\"400\":1}}],[\"并通过工厂设计模式根据用户的输入动态创建相应的策略对象\",{\"1\":{\"346\":1}}],[\"并通过调用\",{\"1\":{\"326\":1,\"436\":1,\"495\":1}}],[\"并执行相应的增强逻辑\",{\"1\":{\"496\":1}}],[\"并执行支付操作\",{\"1\":{\"344\":1}}],[\"并执行了一次消息发送操作\",{\"1\":{\"325\":1}}],[\"并平衡代码的复杂性和灵活性\",{\"1\":{\"339\":1}}],[\"并调用每个文件和文件夹的\",{\"1\":{\"525\":1}}],[\"并调用每个观察者的通知方法\",{\"1\":{\"324\":1}}],[\"并调用被装饰对象的方法\",{\"1\":{\"501\":1}}],[\"并调用其方法\",{\"1\":{\"494\":1}}],[\"并调用其\",{\"1\":{\"469\":1,\"495\":2}}],[\"并调用\",{\"1\":{\"408\":1}}],[\"并调用相应的抽象方法处理具体的请求逻辑\",{\"1\":{\"338\":1}}],[\"并感谢你的理解\",{\"1\":{\"335\":1}}],[\"并输出结果\",{\"1\":{\"395\":1}}],[\"并输出相应的消息\",{\"1\":{\"326\":1}}],[\"并输入规则条件和待评估的数据\",{\"1\":{\"393\":1}}],[\"并输入有效的口令\",{\"1\":{\"83\":1}}],[\"并逐个调用订阅者的\",{\"1\":{\"326\":1}}],[\"并维护了一个用户列表\",{\"1\":{\"325\":1}}],[\"并与其他用户进行实时聊天\",{\"1\":{\"325\":1}}],[\"并给发送方发送icmp\",{\"1\":{\"301\":1}}],[\"并重置计时器时间\",{\"1\":{\"294\":1}}],[\"并重复该步骤直至找到正确记录\",{\"1\":{\"80\":1}}],[\"并转为close\",{\"1\":{\"286\":1}}],[\"并向网站中添加了不同类型的页面\",{\"1\":{\"372\":1}}],[\"并向其中添加了不同的景点\",{\"1\":{\"372\":1}}],[\"并向其添加了\",{\"1\":{\"353\":1}}],[\"并向服务器端返回确认的确认\",{\"1\":{\"285\":1}}],[\"并向客户端返回确认报文段\",{\"1\":{\"285\":1}}],[\"并向源点发送参数问题报文\",{\"1\":{\"201\":1}}],[\"并在内存中创建一个表示该类的class对象\",{\"1\":{\"799\":1}}],[\"并在内部使用新的支付接口\",{\"1\":{\"510\":1}}],[\"并在这些网络间转发数据\",{\"1\":{\"580\":1}}],[\"并在operation方法中递归调用子组件的操作方法\",{\"1\":{\"524\":1}}],[\"并在processorder方法中调用它们的相应方法来处理订单\",{\"1\":{\"518\":1}}],[\"并在保持对象接口不变的情况下\",{\"1\":{\"501\":1}}],[\"并在代理类中增加了日志记录的功能\",{\"1\":{\"497\":1}}],[\"并在方法区创建一个对应的class对象\",{\"1\":{\"726\":1}}],[\"并在方法调用前后执行额外的逻辑操作\",{\"1\":{\"497\":1}}],[\"并在方法中通过调用\",{\"1\":{\"495\":1}}],[\"并在调用其方法前后添加额外的逻辑\",{\"1\":{\"495\":1}}],[\"并在其方法中添加额外的逻辑\",{\"1\":{\"495\":1}}],[\"并在其中定义一个被代理类的对象作为成员变量\",{\"1\":{\"495\":1}}],[\"并在其中定义实现方法\",{\"1\":{\"495\":1}}],[\"并在需要时选择使用\",{\"1\":{\"674\":1}}],[\"并在需要时进行纠正\",{\"1\":{\"584\":1}}],[\"并在需要的地方调用该方法\",{\"1\":{\"485\":1}}],[\"并在需要执行命令时调用命令的execute方法\",{\"1\":{\"382\":1}}],[\"并在需要执行算法时调用策略对象的方法\",{\"1\":{\"343\":1}}],[\"并在构建过程中根据你的喜好进行定制\",{\"1\":{\"452\":1}}],[\"并在构造方法内进行了赋值操作\",{\"1\":{\"450\":1}}],[\"并在每个分支中执行复杂的操作\",{\"1\":{\"422\":1}}],[\"并在execute方法中调用接收者的相应操作\",{\"1\":{\"382\":1}}],[\"并在之后恢复该状态\",{\"1\":{\"375\":1}}],[\"并在accept方法中调用访问者的对应方法\",{\"1\":{\"372\":1}}],[\"并在聚合对象中实现一个方法用于返回迭代器对象\",{\"1\":{\"365\":1}}],[\"并在运行时动态决定请求的处理顺序\",{\"1\":{\"349\":1}}],[\"并在`deserialize`方法中根据版本号选择对应的策略进行反序列化操作\",{\"1\":{\"346\":1}}],[\"并在上下文类中持有一个策略对象\",{\"1\":{\"341\":1}}],[\"并在具体的子类中提供个性化的实现\",{\"1\":{\"338\":1}}],[\"并在具体的子类中实现特定请求类型的处理\",{\"1\":{\"338\":1}}],[\"并在不同的线程中异步执行\",{\"1\":{\"327\":1}}],[\"并在状态变化时通知观察者\",{\"1\":{\"323\":1}}],[\"并在一定频率以上剔除所有的信号成分\",{\"1\":{\"240\":1}}],[\"并在发送完数据后将令牌传递给下一个站点\",{\"1\":{\"153\":1}}],[\"并将元素插入到该桶位中\",{\"1\":{\"707\":1}}],[\"并将对象的共享部分提取出来以实现复用\",{\"1\":{\"533\":1}}],[\"并将不同对象之间的变化部分外部化\",{\"1\":{\"529\":1}}],[\"并将叶子节点添加到组合节点中\",{\"1\":{\"524\":1}}],[\"并将适配后的接口对象传递给订单对象进行支付处理\",{\"1\":{\"510\":1}}],[\"并将结果返回给适配器\",{\"1\":{\"509\":1}}],[\"并将结果存入缓存\",{\"1\":{\"495\":1}}],[\"并将decoratora对象作为参数传递给它的构造器\",{\"1\":{\"502\":1}}],[\"并将原始对象component作为参数传递给它的构造器\",{\"1\":{\"502\":1}}],[\"并将查询结果存入缓存中\",{\"1\":{\"495\":1}}],[\"并将客户端与具体对象的实例化过程解耦\",{\"1\":{\"452\":1}}],[\"并将需要的属性通过构造函数进行初始化\",{\"1\":{\"449\":1}}],[\"并将中介者对象传递给相关对象\",{\"1\":{\"400\":1}}],[\"并将命令对象传递给调用者\",{\"1\":{\"383\":1}}],[\"并将状态转换逻辑集中管理\",{\"1\":{\"357\":1}}],[\"并将请求委派给当前状态对象进行处理\",{\"1\":{\"357\":1}}],[\"并将事件传递给下一个处理器\",{\"1\":{\"355\":1}}],[\"并将审批请求传递给下一个审批者\",{\"1\":{\"355\":1}}],[\"并将它们组织起来形成组织架构\",{\"1\":{\"525\":1}}],[\"并将它们组织起来形成文件系统的层次结构\",{\"1\":{\"525\":1}}],[\"并将它们连接成责任链\",{\"1\":{\"352\":1}}],[\"并将它们按照处理顺序连接成责任链\",{\"1\":{\"350\":1}}],[\"并将策略模式的逻辑添加到其中\",{\"1\":{\"346\":1}}],[\"并将其加入到该集合中\",{\"1\":{\"733\":1}}],[\"并将其转发给\",{\"1\":{\"721\":1}}],[\"并将其转发给被适配者\",{\"1\":{\"509\":1}}],[\"并将其放入缓存中\",{\"1\":{\"443\":1}}],[\"并将其实例化放入缓存中\",{\"1\":{\"436\":1}}],[\"并将其返回给客户端\",{\"1\":{\"509\":1}}],[\"并将其返回\",{\"1\":{\"436\":1}}],[\"并将其赋值给\",{\"1\":{\"422\":1}}],[\"并将其他任务传递给下一个执行器\",{\"1\":{\"355\":1}}],[\"并将其传递给上下文类\",{\"1\":{\"343\":1}}],[\"并将其存储到数据库中\",{\"1\":{\"333\":1}}],[\"并将\",{\"1\":{\"326\":1,\"707\":2}}],[\"并将所有操作的执行时间求和\",{\"1\":{\"315\":1}}],[\"并将这些地址分配给主机\",{\"1\":{\"222\":1}}],[\"并将数据链路层拆分为两个子层\",{\"1\":{\"158\":1}}],[\"并根据目的地\",{\"1\":{\"580\":1}}],[\"并根据需要进行组合\",{\"1\":{\"506\":1}}],[\"并根据具体情况做出权衡决策\",{\"1\":{\"421\":1}}],[\"并根据组合条件进行解释和评估\",{\"1\":{\"393\":1}}],[\"并根据输入条件进行解释和评估\",{\"1\":{\"393\":1}}],[\"并根据当前状态委派请求给相应的状态对象处理\",{\"1\":{\"359\":1,\"361\":1}}],[\"并根据收到的事件进行相应的处理\",{\"1\":{\"326\":1}}],[\"并根据这些学习到的信息\",{\"1\":{\"174\":1}}],[\"并根据字节数\",{\"1\":{\"131\":1}}],[\"并且当断电或者系统崩溃\",{\"1\":{\"871\":1}}],[\"并且当前印戳\",{\"1\":{\"845\":1}}],[\"并且线程池中执行的任务也为空\",{\"1\":{\"867\":1}}],[\"并且将共享资源设置为锁定状态\",{\"1\":{\"846\":1}}],[\"并且将其更新到\",{\"1\":{\"713\":1}}],[\"并且提供了更多的灵活性\",{\"1\":{\"832\":1}}],[\"并且提高开发效率\",{\"1\":{\"480\":1}}],[\"并且操作自己的能力\",{\"1\":{\"798\":1}}],[\"并且\",{\"1\":{\"792\":1}}],[\"并且的抽象方法需要使用abstract修饰\",{\"1\":{\"783\":1}}],[\"并且没有时间要求要求\",{\"1\":{\"752\":1}}],[\"并且没有提供任何修改它们的方法\",{\"1\":{\"450\":1}}],[\"并且其引用的其他对象也都被访问过\",{\"1\":{\"748\":1}}],[\"并且其他用户成功接收到了这些消息\",{\"1\":{\"408\":1}}],[\"并且同时去掉了灰色对象到该白色对象的直接引用或者间接引用\",{\"1\":{\"746\":1}}],[\"并且在没有正确实现\",{\"1\":{\"788\":1}}],[\"并且在遍历过程中使用一个\",{\"1\":{\"709\":1}}],[\"并且在其中定义实现方法\",{\"1\":{\"494\":1}}],[\"并且发生了哈希冲突\",{\"1\":{\"707\":1}}],[\"并且允许一个\",{\"1\":{\"704\":1}}],[\"并且具有快速查找\",{\"1\":{\"704\":1}}],[\"并且位运算比\",{\"1\":{\"688\":1}}],[\"并且只转发到同一\",{\"1\":{\"579\":1}}],[\"并且确保数据按顺序到达目的地\",{\"1\":{\"577\":1}}],[\"并且确保数据能够从源地址传输到目标地址\",{\"1\":{\"182\":1}}],[\"并且创建和管理这些对象会消耗大量资源时\",{\"1\":{\"531\":1}}],[\"并且通常存储子节点\",{\"1\":{\"524\":2}}],[\"并且可以通过future的get\",{\"1\":{\"863\":1}}],[\"并且可以在运行时调用这些方法\",{\"1\":{\"798\":1}}],[\"并且可以在不同对象之间共享时\",{\"1\":{\"531\":1}}],[\"并且可以在不同的销售渠道上进行销售\",{\"1\":{\"506\":1}}],[\"并且可以递归地处理整个层次结构\",{\"1\":{\"526\":1}}],[\"并且可以方便地扩展和修改系统\",{\"1\":{\"506\":1}}],[\"并且可以支持撤销和重做操作\",{\"1\":{\"383\":1}}],[\"并且它们实现相同的接口或继承相同的父类\",{\"1\":{\"495\":1}}],[\"并且它没有vlan标签\",{\"1\":{\"159\":1}}],[\"并且增加了对userrepository和emailservice的直接依赖\",{\"1\":{\"481\":1}}],[\"并且程序的行为保持一致\",{\"1\":{\"470\":1}}],[\"并且随着业务需求的变化\",{\"1\":{\"422\":1}}],[\"并且中介者\",{\"1\":{\"403\":1}}],[\"并且能够支持特定领域的解释和处理\",{\"1\":{\"391\":1}}],[\"并且保持了结构的清晰性\",{\"1\":{\"384\":1}}],[\"并且实现了迭代器设计模式\",{\"1\":{\"366\":1}}],[\"并且不能重写\",{\"1\":{\"785\":3}}],[\"并且不再依赖传统的垃圾回收机制\",{\"1\":{\"725\":1}}],[\"并且不会对系统造成损害\",{\"1\":{\"720\":1}}],[\"并且不会引入干扰或失真\",{\"1\":{\"240\":1}}],[\"并且不需要顺序\",{\"1\":{\"705\":1}}],[\"并且不应该破坏基类的约定\",{\"1\":{\"468\":1}}],[\"并且不希望暴露其内部表示时\",{\"1\":{\"366\":1}}],[\"并且该对象需要根据状态改变行为时\",{\"1\":{\"360\":1}}],[\"并且客户端需要动态地选择其中一个时\",{\"1\":{\"344\":1}}],[\"并且降低了修改代码时引入错误的风险\",{\"1\":{\"339\":1}}],[\"并且采用数据报交换方式\",{\"1\":{\"192\":1}}],[\"并且无线信道误码率较高\",{\"1\":{\"152\":1}}],[\"并用二进制除法除以该比特串\",{\"1\":{\"135\":1,\"576\":1}}],[\"并开始使用\",{\"1\":{\"64\":1}}],[\"并等待客户的服务请求\",{\"1\":{\"58\":1}}],[\"通俗的说\",{\"1\":{\"831\":1}}],[\"通话\",{\"1\":{\"253\":1}}],[\"通知机制\",{\"1\":{\"811\":3,\"843\":1}}],[\"通知或中断\",{\"1\":{\"808\":1}}],[\"通知其他人\",{\"1\":{\"325\":1}}],[\"通知\",{\"1\":{\"212\":1}}],[\"通告了各自所直接连接的网络后\",{\"1\":{\"206\":1}}],[\"通信\",{\"1\":{\"812\":1}}],[\"通信和协作方式\",{\"1\":{\"320\":2}}],[\"通信结束后\",{\"1\":{\"279\":1}}],[\"通信线路为通信双方专用的\",{\"1\":{\"253\":1}}],[\"通信时延小\",{\"1\":{\"253\":1}}],[\"通信子网中的其他每个路由器在表中占据一个表项\",{\"1\":{\"208\":1}}],[\"通信双方在不同的时间分段占用物理线路\",{\"1\":{\"255\":1}}],[\"通信双方在交换http报文之前不需要先建立http连接\",{\"1\":{\"109\":1}}],[\"通信双方只有一条专用通信线路\",{\"1\":{\"253\":1}}],[\"通信双方只有一个数据传输方向\",{\"1\":{\"237\":1}}],[\"通信双方可以同时发送和接收消息\",{\"1\":{\"237\":1}}],[\"通信双方可以相互传输数据\",{\"1\":{\"237\":1}}],[\"通信双方\",{\"1\":{\"236\":1}}],[\"通信双方没有相同的时钟参考\",{\"1\":{\"235\":1}}],[\"通信双方沿着已建立的虚拟电路发送分组\",{\"1\":{\"184\":1}}],[\"通信双方需要在网络层建立一个连接\",{\"1\":{\"184\":1}}],[\"通信交互的接口\",{\"1\":{\"120\":1}}],[\"通过日志恢复该次操作\",{\"1\":{\"871\":1}}],[\"通过复用连接\",{\"1\":{\"858\":1}}],[\"通过复制算法进行回收\",{\"1\":{\"750\":1}}],[\"通过线程池可以轻松地调度和执行这些任务\",{\"1\":{\"858\":1}}],[\"通过线程池创建\",{\"1\":{\"806\":1}}],[\"通过unsafe类的实例来进行添加操作\",{\"1\":{\"847\":1}}],[\"通过atomicreference来保证原子性\",{\"1\":{\"845\":1}}],[\"通过arp协议确认此地址未被使用\",{\"1\":{\"64\":1}}],[\"通过lock\",{\"1\":{\"843\":1}}],[\"通过自旋cas操作来实现对\",{\"1\":{\"839\":1}}],[\"通过get和set方法就可以得到当前线程对应的值\",{\"1\":{\"831\":1}}],[\"通过设置线程的中断标志并不能直接终止该线程的执行\",{\"1\":{\"807\":1}}],[\"通过class对象可以获取到类的所有成员\",{\"1\":{\"799\":1}}],[\"通过component\",{\"1\":{\"502\":1}}],[\"通过context类来与状态对象进行交互\",{\"1\":{\"359\":1}}],[\"通过cookie识别用户\",{\"1\":{\"109\":1}}],[\"通过继承\",{\"1\":{\"782\":1}}],[\"通过可疑对象定位到具体代码再次分析\",{\"1\":{\"768\":1}}],[\"通过双亲委派机制\",{\"1\":{\"758\":1}}],[\"通过双向链表的结构保持了键值对的顺序\",{\"1\":{\"714\":1}}],[\"通过验\",{\"1\":{\"754\":1}}],[\"通过一个个方法的执行解决问题\",{\"1\":{\"781\":1}}],[\"通过一个类的全限定名获取该类的二进制流\",{\"1\":{\"754\":1}}],[\"通过一台台直接相连的设备\",{\"1\":{\"275\":1}}],[\"通过跟踪每个region块的回收价值\",{\"1\":{\"749\":1}}],[\"通过即时编译器将热点代码\",{\"1\":{\"720\":1}}],[\"通过垃圾回收器回收不再使用的对象\",{\"1\":{\"720\":1}}],[\"通过key计算位置\",{\"1\":{\"711\":1}}],[\"通过集合的方法\",{\"1\":{\"710\":1}}],[\"通过传入\",{\"1\":{\"708\":1}}],[\"通过键的哈希码来确定存储位置\",{\"1\":{\"706\":1}}],[\"通过键来获取值\",{\"1\":{\"704\":1}}],[\"通过键获取对应的值\",{\"1\":{\"702\":1}}],[\"通过⽅法\",{\"1\":{\"689\":1}}],[\"通过广播方式将数据传输到网络中的所有设备\",{\"1\":{\"618\":1}}],[\"通过路由器等设备将数据包从一个网络传输到另一个网络\",{\"1\":{\"593\":1}}],[\"通过ip地址\",{\"1\":{\"593\":1}}],[\"通过\",{\"1\":{\"580\":1,\"686\":1,\"702\":3,\"820\":1}}],[\"通过vlan技术\",{\"1\":{\"579\":1}}],[\"通过共享对象的方式减少相似对象的创建\",{\"1\":{\"533\":1}}],[\"通过运行该代码\",{\"1\":{\"525\":1}}],[\"通过适配器模式\",{\"1\":{\"510\":1}}],[\"通过桥接设计模式\",{\"1\":{\"506\":1}}],[\"通过桥接模式\",{\"1\":{\"504\":2,\"505\":1,\"506\":1}}],[\"通过层层装饰\",{\"1\":{\"502\":1}}],[\"通过组合\",{\"1\":{\"782\":1}}],[\"通过组合关系而不是继承关系来连接抽象和实现\",{\"1\":{\"504\":1}}],[\"通过组合关系和包装\",{\"1\":{\"500\":1}}],[\"通过组合和继承的方式实现了装饰功能\",{\"1\":{\"502\":1}}],[\"通过decoratorb\",{\"1\":{\"502\":1}}],[\"通过decoratora\",{\"1\":{\"502\":1}}],[\"通过代理对象调用方法\",{\"1\":{\"496\":1,\"498\":1}}],[\"通过代理对象对被代理对象进行功能增强\",{\"1\":{\"495\":1}}],[\"通过静态代理\",{\"1\":{\"495\":4}}],[\"通过静态缓存\",{\"1\":{\"443\":1}}],[\"通过创建代理对象并调用其方法\",{\"1\":{\"495\":1}}],[\"通过创建代理对象\",{\"1\":{\"494\":1}}],[\"通过减少对象之间的直接依赖关系来提高代码的质量\",{\"1\":{\"490\":1}}],[\"通过减少接口之间的依赖\",{\"1\":{\"474\":1}}],[\"通过遵循迪米特法则\",{\"1\":{\"489\":1}}],[\"通过遵循kiss原则\",{\"1\":{\"482\":1}}],[\"通过遵循接口隔离原则\",{\"1\":{\"473\":1}}],[\"通过避免不必要的复杂性\",{\"1\":{\"482\":1}}],[\"通过避免环路的产生\",{\"1\":{\"175\":1}}],[\"通过拆分职责\",{\"1\":{\"481\":1}}],[\"通过依赖注入等方式实现依赖倒置原则可以使代码更易于扩展和修改\",{\"1\":{\"478\":1}}],[\"通过接口的细化和分离\",{\"1\":{\"474\":1}}],[\"通过接口的方式与上下层进行交互和通信\",{\"1\":{\"268\":1}}],[\"通过对线程\",{\"1\":{\"855\":1}}],[\"通过对比这两个示例\",{\"1\":{\"461\":1}}],[\"通过对应设备的ip地址与mac地址绑定命令进行\",{\"1\":{\"198\":1}}],[\"通过深拷贝并使用引用转换\",{\"1\":{\"455\":1}}],[\"通过递归遍历对象的每个属性\",{\"1\":{\"455\":1}}],[\"通过实现cloneable接口实现浅拷贝\",{\"1\":{\"454\":1}}],[\"通过实例化具体类对象\",{\"1\":{\"332\":1}}],[\"通过向工厂提供披萨的类型\",{\"1\":{\"452\":1}}],[\"通过私有的构造方法\",{\"1\":{\"450\":1}}],[\"通过工厂对象创建具体产品\",{\"1\":{\"441\":1}}],[\"通过读取配置文件\",{\"1\":{\"436\":1,\"443\":1}}],[\"通过抽象工厂类创建产品对象\",{\"1\":{\"434\":1}}],[\"通过切换具体工厂类来创建不同的产品对象\",{\"1\":{\"433\":1}}],[\"通过中介者对象进行消息传递\",{\"1\":{\"400\":1}}],[\"通过命令设计模式\",{\"1\":{\"383\":1}}],[\"通过访问者来访问对象结构中的元素\",{\"1\":{\"371\":1}}],[\"通过这种结构提高代码的可拓展性\",{\"1\":{\"493\":2}}],[\"通过这种方式\",{\"1\":{\"331\":1,\"336\":1,\"465\":1,\"497\":1,\"523\":1}}],[\"通过这段代码\",{\"1\":{\"436\":1}}],[\"通过这个\",{\"1\":{\"863\":1}}],[\"通过这个简单的例子\",{\"1\":{\"404\":1,\"409\":1}}],[\"通过这个简单的案例\",{\"1\":{\"395\":1}}],[\"通过这个接口\",{\"1\":{\"371\":2}}],[\"通过引入抽象和多态的设计方式\",{\"1\":{\"465\":1}}],[\"通过引入一个中介者对象\",{\"1\":{\"411\":1}}],[\"通过引入访问者对象\",{\"1\":{\"370\":1}}],[\"通过引入消息总线或事件系统作为中介\",{\"1\":{\"326\":1}}],[\"通过其他方式修改了集合的结构\",{\"1\":{\"367\":1}}],[\"通过聚合对象的迭代器方法获取迭代器对象\",{\"1\":{\"365\":1}}],[\"通过封装状态的处理逻辑\",{\"1\":{\"361\":1}}],[\"通过调用processorder方法\",{\"1\":{\"518\":1}}],[\"通过调用它们的方法来获取用户信息和库存信息\",{\"1\":{\"489\":1}}],[\"通过调用computerbuilder的方法\",{\"1\":{\"448\":1}}],[\"通过调用builder的方法\",{\"1\":{\"448\":1}}],[\"通过调用其\",{\"1\":{\"436\":1}}],[\"通过调用工厂类的静态方法create\",{\"1\":{\"429\":1}}],[\"通过调用accept方法\",{\"1\":{\"372\":1}}],[\"通过调用iterator\",{\"1\":{\"366\":1}}],[\"通过调用\",{\"1\":{\"353\":1,\"450\":1}}],[\"通过调用策略对象的方法来执行具体的算法\",{\"1\":{\"342\":1}}],[\"通过使用信号量\",{\"1\":{\"853\":1}}],[\"通过使用组合模式\",{\"1\":{\"524\":1,\"525\":1,\"526\":1}}],[\"通过使用门面设计模式\",{\"1\":{\"517\":1,\"518\":1}}],[\"通过使用门面模式\",{\"1\":{\"514\":1}}],[\"通过使用桥接模式\",{\"1\":{\"506\":1}}],[\"通过使用接口实现静态代理\",{\"1\":{\"495\":1}}],[\"通过使用不同的工厂方法或参数\",{\"1\":{\"452\":1}}],[\"通过使用单例模式\",{\"1\":{\"417\":1}}],[\"通过使用命令模式\",{\"1\":{\"381\":1}}],[\"通过使用迭代器\",{\"1\":{\"363\":1}}],[\"通过使用状态模式\",{\"1\":{\"360\":1}}],[\"通过使用策略模式和工厂模式的组合\",{\"1\":{\"346\":1}}],[\"通过使用观察者模式\",{\"1\":{\"325\":1,\"328\":1}}],[\"通过`registerdeserializationstrategy`方法注册不同版本的反序列化策略\",{\"1\":{\"346\":1}}],[\"通过策略模式\",{\"1\":{\"343\":1}}],[\"通过将每条请求共享资源的线程封装成一个节点来实现锁的分配\",{\"1\":{\"846\":1}}],[\"通过将对象作为成员变量引入\",{\"1\":{\"782\":1}}],[\"通过将重复的代码抽象为单一的实现\",{\"1\":{\"486\":1}}],[\"通过将重复的代码抽取到单独的方法\",{\"1\":{\"486\":1}}],[\"通过将通用的逻辑抽象为可复用的组件\",{\"1\":{\"486\":1}}],[\"通过将接口作为抽象的约定\",{\"1\":{\"477\":1}}],[\"通过将子类对象视为父类对象\",{\"1\":{\"470\":1}}],[\"通过将代码依赖于抽象的父类而不是具体的子类\",{\"1\":{\"470\":1}}],[\"通过将建造者的构建方法设置为私有\",{\"1\":{\"449\":1}}],[\"通过将状态与上下文类分离\",{\"1\":{\"361\":1}}],[\"通过将处理逻辑拆分成多个处理器\",{\"1\":{\"352\":1}}],[\"通过将算法的公共部分抽象到父类中\",{\"1\":{\"339\":1}}],[\"通过将窗口大小设为零来暂停数据的接收\",{\"1\":{\"294\":1}}],[\"通过模板方法\",{\"1\":{\"338\":1}}],[\"通过子类实现具体步骤\",{\"1\":{\"330\":1}}],[\"通过合理的设计和使用\",{\"1\":{\"328\":1}}],[\"通过发布\",{\"1\":{\"326\":1}}],[\"通过发送方发送和接收方接收严格同步\",{\"1\":{\"238\":1}}],[\"通过指针来连接各个元素\",{\"1\":{\"312\":1}}],[\"通过元素的物理地址和相对位置来访问数据\",{\"1\":{\"312\":1}}],[\"通过动态调整数据发送速率和监测网络状态\",{\"1\":{\"296\":1}}],[\"通过动态调整传输速率\",{\"1\":{\"296\":1}}],[\"通过监测网络状态\",{\"1\":{\"296\":1}}],[\"通过确认号和序号的机制进行发送\",{\"1\":{\"289\":1}}],[\"通过伪首部进行检验和校验\",{\"1\":{\"288\":1}}],[\"通过防火墙\",{\"1\":{\"285\":1}}],[\"通过光的反射进行传播\",{\"1\":{\"230\":1}}],[\"通过连接传输媒体在不同计算机上传输数据比特流\",{\"1\":{\"229\":1}}],[\"通过在原对象和备忘录对象之间建立关联\",{\"1\":{\"376\":1}}],[\"通过在抽象类中添加dopost\",{\"1\":{\"338\":1}}],[\"通过在抽象类中定义模板方法\",{\"1\":{\"333\":1}}],[\"通过在内部网络中使用私有ip地址来连接到公共网络\",{\"1\":{\"223\":1}}],[\"通过在帧头和帧尾各插入一个特定的比特串\",{\"1\":{\"131\":1}}],[\"通过各路由器洪泛法发送封装有自己lsa的lsu分组\",{\"1\":{\"210\":1}}],[\"通过手工配置\",{\"1\":{\"198\":1}}],[\"通过令牌传递\",{\"1\":{\"153\":1}}],[\"通过生成多项式\",{\"1\":{\"135\":1,\"576\":1}}],[\"通过mac地址进行的\",{\"1\":{\"120\":1}}],[\"通过数据链路层解析物理层发出去的信号怎么样选择\",{\"1\":{\"119\":1}}],[\"通过浏览器登录\",{\"1\":{\"99\":1}}],[\"通过http协议与邮件服务器连接\",{\"1\":{\"99\":1}}],[\"通过smtp与邮件服务器\",{\"1\":{\"94\":1}}],[\"通过tcp提供的可靠数据传输服务来保证文件的正确传输\",{\"1\":{\"87\":1}}],[\"通过ftp\",{\"1\":{\"83\":1}}],[\"通用顶级域名\",{\"1\":{\"69\":1}}],[\"通常被用于暂停执行\",{\"1\":{\"812\":1}}],[\"通常被用于向整个网络发送信息\",{\"1\":{\"166\":1}}],[\"通常被侧重用于线程间交互\",{\"1\":{\"812\":1}}],[\"通常与日期解析相关\",{\"1\":{\"793\":1}}],[\"通常与反射相关\",{\"1\":{\"793\":1}}],[\"通常需要同时重写\",{\"1\":{\"788\":2}}],[\"通常使用图形化工具分析\",{\"1\":{\"769\":1}}],[\"通常使用路由器来连接\",{\"1\":{\"161\":1}}],[\"通常会出现\",{\"1\":{\"769\":1}}],[\"通常会涉及到两种主要类型的垃圾回收过程\",{\"1\":{\"741\":1}}],[\"通常称为s0和s1\",{\"1\":{\"741\":1}}],[\"通常涉及到类加载器和类引用链的分析\",{\"1\":{\"733\":1}}],[\"通常设置为\",{\"1\":{\"696\":1}}],[\"通常要结合数组和hash算法来实现\",{\"1\":{\"690\":1}}],[\"通常在使用迭代器遍历集合时\",{\"1\":{\"710\":1}}],[\"通常在创建\",{\"1\":{\"685\":1}}],[\"通常在更高层次的网络设备\",{\"1\":{\"579\":1}}],[\"通常为0xff\",{\"1\":{\"575\":1}}],[\"通常表示为一系列的十六进制数字和字母\",{\"1\":{\"574\":1}}],[\"通常表示为十六进制\",{\"1\":{\"574\":1}}],[\"通常以点分十进制的形式表示\",{\"1\":{\"574\":1}}],[\"通常以十六进制表示\",{\"1\":{\"166\":1}}],[\"通常由\",{\"1\":{\"793\":1}}],[\"通常由48位二进制数\",{\"1\":{\"574\":1}}],[\"通常由两个子层组成\",{\"1\":{\"120\":1}}],[\"通常具有复杂的内部结构\",{\"1\":{\"448\":1}}],[\"通常包含一个execute方法\",{\"1\":{\"382\":1}}],[\"通常包括hasnext\",{\"1\":{\"365\":1}}],[\"通常\",{\"1\":{\"239\":1,\"505\":1}}],[\"通常用于简单变量的状态标记\",{\"1\":{\"834\":1}}],[\"通常用于需要存储键值对且需要根据键快速检索值的情况\",{\"1\":{\"704\":1}}],[\"通常用于指示数据包应该发送到默认的网关或者默认的下一跳路由器\",{\"1\":{\"205\":1}}],[\"通常用于连接交换机之间或交换机与路由器之间的链路\",{\"1\":{\"159\":1}}],[\"通常就是网关\",{\"1\":{\"205\":1}}],[\"通常位于一个区域\",{\"1\":{\"162\":1}}],[\"通常是数组\",{\"1\":{\"855\":2}}],[\"通常是工具类\",{\"1\":{\"817\":1}}],[\"通常是由于类版本不匹配\",{\"1\":{\"793\":1}}],[\"通常是因为调用栈溢出\",{\"1\":{\"793\":1}}],[\"通常是对象被创建后的初始分配区域\",{\"1\":{\"741\":1}}],[\"通常是基于类加载器和类的引用关系来进行管理和释放\",{\"1\":{\"725\":1}}],[\"通常是不能仅配置ipv4地址\",{\"1\":{\"216\":1}}],[\"通常是延时或跳数\",{\"1\":{\"208\":1}}],[\"通常是指覆盖范围很广\",{\"1\":{\"161\":1}}],[\"通常是计算机\",{\"1\":{\"59\":1}}],[\"通常跨接很大的物理范围\",{\"1\":{\"161\":1}}],[\"通常情况下\",{\"1\":{\"58\":1,\"447\":1,\"690\":1,\"706\":1,\"793\":1}}],[\"和shutdownnow简单来说区别如下\",{\"1\":{\"864\":1}}],[\"和shutdown\",{\"1\":{\"864\":1}}],[\"和stringbuilder\",{\"1\":{\"789\":1}}],[\"和共享变量的新值\",{\"1\":{\"845\":1}}],[\"和unlock\",{\"1\":{\"843\":1}}],[\"和公平锁一样都会进入到\",{\"1\":{\"840\":1}}],[\"和期望值\",{\"1\":{\"839\":1}}],[\"和非公平锁\",{\"1\":{\"838\":1}}],[\"和join\",{\"1\":{\"811\":1}}],[\"和java堆类似\",{\"1\":{\"722\":1}}],[\"和状态\",{\"1\":{\"804\":1}}],[\"和初始化等阶段\",{\"1\":{\"755\":1}}],[\"和用户线程\",{\"1\":{\"746\":1,\"750\":1}}],[\"和老年代两个区域\",{\"1\":{\"737\":1}}],[\"和notify\",{\"1\":{\"722\":1,\"811\":1,\"843\":1}}],[\"和安全失败\",{\"0\":{\"709\":1},\"1\":{\"709\":1}}],[\"和hashmap基本相同\",{\"1\":{\"711\":1}}],[\"和hashmap\",{\"1\":{\"705\":1}}],[\"和handleputrequest\",{\"1\":{\"338\":2}}],[\"和统计学有关\",{\"1\":{\"697\":1}}],[\"和某个散列值做\",{\"1\":{\"694\":1}}],[\"和原来的数做|运算\",{\"1\":{\"689\":1}}],[\"和频谱\",{\"1\":{\"620\":1}}],[\"和路由器\",{\"1\":{\"580\":1}}],[\"和集线器\",{\"1\":{\"580\":1}}],[\"和库存\",{\"1\":{\"489\":1}}],[\"和继承来避免在\",{\"1\":{\"485\":1}}],[\"和工厂设计模式的区别\",{\"0\":{\"452\":1}}],[\"和具体工厂类\",{\"1\":{\"443\":1}}],[\"和具体实现类\",{\"1\":{\"443\":1}}],[\"和其前缀\",{\"1\":{\"422\":1}}],[\"和观察者对比\",{\"0\":{\"411\":1}}],[\"和观察者之间可以独立变化\",{\"1\":{\"323\":1}}],[\"和接收者\",{\"1\":{\"386\":1}}],[\"和接收窗口\",{\"1\":{\"297\":1}}],[\"和策略设计模式比较\",{\"0\":{\"386\":1}}],[\"和导游\",{\"1\":{\"372\":1}}],[\"和两个具体处理器\",{\"1\":{\"353\":1}}],[\"和doput\",{\"1\":{\"338\":3}}],[\"和发送窗口有什么关系呢\",{\"1\":{\"297\":1}}],[\"和发送方\",{\"1\":{\"268\":1}}],[\"和它上面的一个进程\",{\"1\":{\"279\":1}}],[\"和tpdu\",{\"1\":{\"276\":1}}],[\"和连接这些结点的链路\",{\"1\":{\"246\":1}}],[\"和带宽\",{\"1\":{\"227\":1}}],[\"和并行传输\",{\"1\":{\"227\":1}}],[\"和维护\",{\"1\":{\"198\":1}}],[\"和无线局域网适配器\",{\"1\":{\"165\":1}}],[\"和生成多项式\",{\"1\":{\"135\":1,\"576\":1}}],[\"和\",{\"0\":{\"561\":1,\"648\":1,\"674\":1,\"704\":1,\"705\":1,\"706\":1,\"712\":1,\"786\":1},\"1\":{\"132\":1,\"135\":1,\"240\":2,\"316\":2,\"326\":4,\"344\":1,\"353\":1,\"360\":1,\"372\":2,\"375\":2,\"384\":1,\"395\":3,\"422\":1,\"450\":1,\"461\":1,\"465\":1,\"469\":3,\"473\":1,\"474\":1,\"485\":1,\"489\":3,\"498\":1,\"506\":2,\"576\":1,\"577\":1,\"674\":1,\"687\":1,\"688\":1,\"702\":4,\"703\":2,\"705\":4,\"706\":2,\"707\":1,\"712\":2,\"713\":1,\"715\":1,\"725\":1,\"739\":2,\"769\":3,\"786\":2,\"788\":4,\"789\":2,\"793\":1,\"809\":1,\"810\":1,\"834\":1,\"838\":1,\"842\":1}}],[\"和该服务器可以继续在这条连接上传送后续的http请求报文和响应报文\",{\"1\":{\"112\":1}}],[\"和端口号67\",{\"1\":{\"63\":1}}],[\"和端口号68\",{\"1\":{\"63\":1}}],[\"和多个客户端\",{\"1\":{\"58\":1}}],[\"默认使用此策略\",{\"1\":{\"861\":1}}],[\"默认使用非公平锁\",{\"1\":{\"838\":1}}],[\"默认使用index\",{\"1\":{\"8\":1,\"34\":1}}],[\"默认就是抽象\",{\"1\":{\"783\":1}}],[\"默认值\",{\"1\":{\"775\":1}}],[\"默认2048个region\",{\"1\":{\"750\":1}}],[\"默认是一直等\",{\"1\":{\"812\":1}}],[\"默认是\",{\"1\":{\"711\":1}}],[\"默认的segment长度是16\",{\"1\":{\"711\":1}}],[\"默认的初始化大小为\",{\"1\":{\"706\":1}}],[\"默认的初始大小为\",{\"1\":{\"706\":1}}],[\"默认的子网掩码是\",{\"1\":{\"218\":1}}],[\"默认为\",{\"1\":{\"685\":1,\"686\":1,\"706\":1}}],[\"默认为22\",{\"1\":{\"87\":1}}],[\"默认为21\",{\"1\":{\"87\":1}}],[\"默认大小是16\",{\"1\":{\"685\":1}}],[\"默认\",{\"1\":{\"540\":1,\"740\":1,\"839\":1}}],[\"默认配置块\",{\"1\":{\"539\":1}}],[\"默认kotlin\",{\"1\":{\"538\":2}}],[\"默认安装c盘\",{\"1\":{\"538\":1}}],[\"默认选择版本1的反序列化逻辑\",{\"1\":{\"346\":2}}],[\"默认版本1的反序列化方式\",{\"1\":{\"346\":2}}],[\"默认路由在网络配置中非常重要\",{\"1\":{\"205\":1}}],[\"默认路由\",{\"1\":{\"205\":1}}],[\"默认情况下\",{\"1\":{\"159\":3}}],[\"默认smtp端口\",{\"1\":{\"94\":1}}],[\"默认端口20\",{\"1\":{\"86\":1}}],[\"默认端口为21\",{\"1\":{\"86\":1}}],[\"默认网关的设置通常是在设备的网络设置中配置的\",{\"1\":{\"597\":1}}],[\"默认网关通常是本地网络中一个指定的ip地址\",{\"1\":{\"597\":1}}],[\"默认网关是计算机或网络设备用于发送非本地数据包的ip地址\",{\"1\":{\"597\":1}}],[\"默认网关\",{\"1\":{\"62\":1}}],[\"功能特点\",{\"1\":{\"843\":1}}],[\"功能特性\",{\"1\":{\"227\":1}}],[\"功能和作用\",{\"1\":{\"724\":1}}],[\"功能或信息\",{\"1\":{\"486\":1}}],[\"功能或问题\",{\"1\":{\"375\":1}}],[\"功能单一的类\",{\"1\":{\"462\":1}}],[\"功能是将分组存储并转发\",{\"1\":{\"161\":2}}],[\"功能有限的邮件读取协议\",{\"1\":{\"97\":1}}],[\"功能\",{\"1\":{\"62\":1,\"196\":1}}],[\"用submit\",{\"1\":{\"864\":1}}],[\"用调用者所在的线程来执行任务\",{\"1\":{\"861\":1}}],[\"用通俗的比喻\",{\"1\":{\"747\":1}}],[\"用\",{\"1\":{\"671\":1}}],[\"用输入流读出来\",{\"1\":{\"455\":1}}],[\"用以标记一个字符的结束\",{\"1\":{\"235\":1}}],[\"用以标记一个字符的开始\",{\"1\":{\"235\":1}}],[\"用一个闭包结构去记录可达对象\",{\"1\":{\"746\":1,\"750\":1}}],[\"用一个全球ip地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信\",{\"1\":{\"223\":1}}],[\"用一些特定的控制字符来定界一个帧的起始与结束\",{\"1\":{\"131\":1}}],[\"用来标记线程是\",{\"1\":{\"846\":1}}],[\"用来标记该线程是获取共享资源时被阻挂起后放入aqs\",{\"1\":{\"846\":1}}],[\"用来保存objectwaiter\",{\"1\":{\"835\":1}}],[\"用来做用户信息上下文的存储\",{\"1\":{\"817\":1}}],[\"用来做数组下标访问\",{\"1\":{\"694\":1}}],[\"用来提高并发度\",{\"1\":{\"804\":1}}],[\"用来指示计算机执行特定任务的\",{\"1\":{\"804\":1}}],[\"用来加载\",{\"1\":{\"756\":1}}],[\"用来管理内存的一部分\",{\"1\":{\"741\":1}}],[\"用来配合我们的线程执行我们的代码的\",{\"1\":{\"722\":1}}],[\"用来与应用进程进行一一对应的\",{\"1\":{\"277\":1}}],[\"用来与相邻的另一个bgp发言人建立关系\",{\"1\":{\"212\":1}}],[\"用来表示网络的通信线路所能传送数据的能力\",{\"1\":{\"261\":1}}],[\"用来发送检测到的差错\",{\"1\":{\"212\":1}}],[\"用来发现和维护邻居路由器的可达性\",{\"1\":{\"210\":1}}],[\"用来周期性地证实邻站的连通性\",{\"1\":{\"212\":1}}],[\"用来通告某一路由的信息\",{\"1\":{\"212\":1}}],[\"用来测试ip数据报从源主机到达目的主机要经过哪些路由器\",{\"1\":{\"200\":1}}],[\"用来测试主机或路由器间的连通性\",{\"1\":{\"200\":1}}],[\"用来连接不同网段的计算机网络设备\",{\"1\":{\"171\":1}}],[\"用来分割一次对话的各帧\",{\"1\":{\"152\":1}}],[\"用来分隔开属于一次对话的各帧\",{\"1\":{\"152\":1}}],[\"用来作为除数的二进制比特串\",{\"1\":{\"135\":1,\"576\":1}}],[\"用不同的码来区分不同的用户信号\",{\"1\":{\"150\":1}}],[\"用二进制除法除以比特串\",{\"1\":{\"135\":1,\"576\":1}}],[\"用它控制这组代码中1的个数为奇数或偶数\",{\"1\":{\"134\":1,\"576\":1}}],[\"用户创建初始的latch数量\",{\"1\":{\"851\":1}}],[\"用户的支付历史\",{\"1\":{\"845\":1}}],[\"用户体验受损\",{\"1\":{\"845\":1}}],[\"用户在账单中看到重复的支付记录\",{\"1\":{\"845\":1}}],[\"用户在发送数据前需要等待授权\",{\"1\":{\"153\":1}}],[\"用户实际只发起了一次支付\",{\"1\":{\"845\":1}}],[\"用户a发起支付请求\",{\"1\":{\"845\":1}}],[\"用户发起支付请求\",{\"1\":{\"845\":1}}],[\"用户发送和接收消息\",{\"1\":{\"408\":1}}],[\"用户权限信息\",{\"1\":{\"817\":1}}],[\"用户线程\",{\"1\":{\"810\":1}}],[\"用户线程依然在运行\",{\"1\":{\"751\":1}}],[\"用户自定义类加载器\",{\"1\":{\"756\":1}}],[\"用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集\",{\"1\":{\"747\":1}}],[\"用户直接根据商家的地址去拿货\",{\"1\":{\"730\":1}}],[\"用户取货码\",{\"1\":{\"730\":1}}],[\"用户需要输入密码进行安全验证\",{\"1\":{\"495\":1}}],[\"用户需要输入密码进行验证\",{\"1\":{\"495\":1}}],[\"用户选择信用卡支付\",{\"1\":{\"344\":1}}],[\"用户选择微信支付\",{\"1\":{\"344\":1}}],[\"用户选择支付宝支付\",{\"1\":{\"344\":1}}],[\"用户主机和其内部的运输层\",{\"1\":{\"184\":1}}],[\"用户主机必须使用适当的协议来保证数据的可靠传输\",{\"1\":{\"184\":1}}],[\"用户主机会包含两个网络适配器\",{\"1\":{\"165\":1}}],[\"用户\",{\"1\":{\"110\":1,\"408\":1,\"489\":1}}],[\"用户与电子邮件系统的接口\",{\"1\":{\"90\":1}}],[\"用户代理\",{\"1\":{\"90\":2,\"99\":1}}],[\"用户认证等\",{\"1\":{\"87\":1}}],[\"用户通过继承\",{\"1\":{\"756\":1}}],[\"用户通过调用\",{\"1\":{\"408\":1}}],[\"用户通过用户名密码的方式登录到服务器\",{\"1\":{\"85\":1}}],[\"用户通过一个客户机程序连接至在远程计算机上运行的服务器程序进行文件传输\",{\"1\":{\"83\":1}}],[\"用户可以用来交互完成任务\",{\"1\":{\"539\":1}}],[\"用户可以修改个人信息\",{\"1\":{\"481\":1}}],[\"用户可以查看自己的个人信息\",{\"1\":{\"481\":1}}],[\"用户可以登录账号\",{\"1\":{\"481\":1}}],[\"用户可以注册账号\",{\"1\":{\"481\":1}}],[\"用户可以加入聊天群\",{\"1\":{\"325\":1}}],[\"用户可以设置hybrid端口的pvid值\",{\"1\":{\"159\":1}}],[\"用户可以设置trunk端口的pvid值\",{\"1\":{\"159\":1}}],[\"用户可以在邮件服务器网站上管理和处理自己的邮件\",{\"1\":{\"99\":1}}],[\"用户可以在本地计算机上操作邮件服务器中的邮箱\",{\"1\":{\"98\":1}}],[\"用户可以通过发送消息来进行聊天\",{\"1\":{\"409\":1}}],[\"用户可以通过下载并删除或下载并保留的方式将邮件从邮件服务器下载到本地计算机\",{\"1\":{\"97\":1}}],[\"用户可以通过ftp在本地计算机和远程服务器之间进行文件和文件夹的管理\",{\"1\":{\"83\":1}}],[\"用户可以轻松地将重要文件备份到远程服务器上\",{\"1\":{\"83\":1}}],[\"用户名\",{\"1\":{\"3\":1,\"29\":1}}],[\"用于提交不需要返回值的任务\",{\"1\":{\"863\":1}}],[\"用于提供不同种类主机系统\",{\"1\":{\"83\":1}}],[\"用于高并发情况下对长整型\",{\"1\":{\"855\":1}}],[\"用于释放资源或增加信号量的值\",{\"1\":{\"853\":1}}],[\"用于释放对象占用的资源\",{\"1\":{\"721\":1}}],[\"用于申请资源或降低信号量的值\",{\"1\":{\"853\":1}}],[\"用于对信号量进行操作\",{\"1\":{\"853\":1}}],[\"用于对每个请求或线程需要格式化时间的情况\",{\"1\":{\"817\":1}}],[\"用于管理等待获取锁的线程\",{\"1\":{\"839\":1}}],[\"用于管理公司的组织结构\",{\"1\":{\"525\":1}}],[\"用于构建不同类型的同步器\",{\"1\":{\"839\":1}}],[\"用于捕获异常\",{\"1\":{\"795\":1}}],[\"用于表示与虚拟机操作有关的错误情况\",{\"1\":{\"793\":1}}],[\"用于确切地比较两个对象的内容是否相等\",{\"1\":{\"788\":1}}],[\"用于确保udp数据在传输过程中的完整性\",{\"1\":{\"304\":1}}],[\"用于比较\",{\"1\":{\"785\":1}}],[\"用于返回对象的哈希码值\",{\"1\":{\"787\":1}}],[\"用于返回对象的哈希码\",{\"1\":{\"785\":1}}],[\"用于返回当前运行时对象的\",{\"1\":{\"785\":1}}],[\"用于覆盖父类中的方法\",{\"1\":{\"780\":1}}],[\"用于生产环境的性能调优和故障排查\",{\"1\":{\"763\":1}}],[\"用于加载tomcat本身的类库\",{\"1\":{\"759\":1}}],[\"用于加强信号的传输距离\",{\"1\":{\"240\":1}}],[\"用于运行java\",{\"1\":{\"759\":1}}],[\"用于优化和改进\",{\"1\":{\"720\":1}}],[\"用于记录集合被修改的次数\",{\"1\":{\"710\":1}}],[\"用于记录未完成的任务\",{\"1\":{\"375\":1}}],[\"用于实例对象之间比较大小\",{\"1\":{\"674\":1}}],[\"用于实现并发垃圾回收器中的增量标记\",{\"1\":{\"748\":1}}],[\"用于实现消息传递逻辑\",{\"1\":{\"406\":1}}],[\"用于实现对象间的松耦合通信\",{\"1\":{\"326\":1}}],[\"用于实现可靠传输\",{\"1\":{\"287\":1}}],[\"用于实现可靠的数据传输\",{\"1\":{\"138\":1,\"139\":1}}],[\"用于放大信号并延长信号传输的距离\",{\"1\":{\"618\":1}}],[\"用于分配给子网中的设备\",{\"1\":{\"596\":1}}],[\"用于分组网间探测ping\",{\"1\":{\"200\":1}}],[\"用于划分网络中的主机和子网\",{\"1\":{\"595\":1}}],[\"用于同步时钟和准备接收帧\",{\"1\":{\"575\":1}}],[\"用于识别网络设备\",{\"1\":{\"574\":1}}],[\"用于唯一标识网络设备\",{\"1\":{\"574\":1}}],[\"用于编写可读性强的\",{\"1\":{\"539\":1}}],[\"用于编写和运行单元测试\",{\"1\":{\"539\":1}}],[\"用于灵活而复杂的布局\",{\"1\":{\"539\":1}}],[\"用于代码混淆和优化\",{\"1\":{\"539\":1}}],[\"用于区分不同的应用程序版本\",{\"1\":{\"539\":1}}],[\"用于区分不同的服务类型\",{\"1\":{\"251\":1}}],[\"用于配置\",{\"1\":{\"539\":1}}],[\"用于描述类的结构信息\",{\"1\":{\"726\":1}}],[\"用于描述开发者电脑的环境配置\",{\"1\":{\"539\":1}}],[\"用于描述app工程的编译规则\",{\"1\":{\"539\":1}}],[\"用于适配多个不同的接口或类\",{\"1\":{\"512\":1}}],[\"用于将数字数据转换成模拟信号以在电话线等模拟介质上传输\",{\"1\":{\"618\":1}}],[\"用于将网络中的设备连接在一起\",{\"1\":{\"618\":1}}],[\"用于将一个类的接口转换为另一个类的接口\",{\"1\":{\"520\":1}}],[\"用于将新的支付接口适配到旧的支付接口上\",{\"1\":{\"510\":1}}],[\"用于将多个计算机连接到局域网上\",{\"1\":{\"240\":1}}],[\"用于拦截方法\",{\"1\":{\"498\":1}}],[\"用于封装远程通信的逻辑\",{\"1\":{\"495\":1}}],[\"用于添加安全验证的逻辑\",{\"1\":{\"495\":1}}],[\"用于添加查询缓存的逻辑\",{\"1\":{\"495\":1}}],[\"用于执行实际的远程任务\",{\"1\":{\"495\":1}}],[\"用于执行实际的敏感操作\",{\"1\":{\"495\":1}}],[\"用于执行实际的数据库查询\",{\"1\":{\"495\":1}}],[\"用于执行具体的命令\",{\"1\":{\"382\":1}}],[\"用于发出声音\",{\"1\":{\"469\":1}}],[\"用于创建并返回当前对象的一份拷贝\",{\"1\":{\"785\":1}}],[\"用于创建和管理享元对象\",{\"1\":{\"530\":1}}],[\"用于创建userbuilder对象\",{\"1\":{\"450\":1}}],[\"用于创建一系列相关或依赖的产品\",{\"1\":{\"443\":1}}],[\"用于创建抽象产品\",{\"1\":{\"436\":1}}],[\"用于创建网页的结构和内容\",{\"1\":{\"104\":1}}],[\"用于获取类的实例\",{\"1\":{\"418\":1}}],[\"用于展示中介者设计模式的运行测试\",{\"1\":{\"408\":1}}],[\"用于接收消息并进行传递\",{\"1\":{\"404\":1,\"409\":1}}],[\"用于协调多个相关对象之间的交互\",{\"1\":{\"399\":1}}],[\"用于组合多个终结符条件\",{\"1\":{\"395\":1}}],[\"用于根据用户输入的规则条件\",{\"1\":{\"392\":1}}],[\"用于根据用户输入的条件\",{\"1\":{\"391\":1}}],[\"用于根据一组规则对输入数据进行评估和决策\",{\"1\":{\"391\":1}}],[\"用于解决哈希冲突\",{\"1\":{\"685\":2,\"686\":2}}],[\"用于解决进程之间基于网络的通信问题\",{\"1\":{\"273\":1}}],[\"用于解释特定问题领域的表达式和语句\",{\"1\":{\"389\":1}}],[\"用于处理\",{\"1\":{\"795\":1}}],[\"用于处理飞机之间的通信\",{\"1\":{\"401\":1}}],[\"用于处理不同类型的http请求\",{\"1\":{\"338\":1}}],[\"用于处理特定类型的http请求的逻辑\",{\"1\":{\"338\":1}}],[\"用于读取输入流中的数据\",{\"1\":{\"335\":1}}],[\"用于从不同来源\",{\"1\":{\"333\":1}}],[\"用于维护事件和订阅者之间的关系\",{\"1\":{\"326\":1}}],[\"用于保存当前线程的状态\",{\"1\":{\"724\":1}}],[\"用于保存类的唯一实例\",{\"1\":{\"418\":1}}],[\"用于保存编译后的程序指令\",{\"1\":{\"317\":1}}],[\"用于保存调用函数的上下文数据\",{\"1\":{\"317\":1}}],[\"用于保存算法运行过程中的各种常量\",{\"1\":{\"317\":1}}],[\"用于存储在编译期间由双引号引起来的字符串常量\",{\"1\":{\"722\":1}}],[\"用于存储类加载后的符号引用解析信息\",{\"1\":{\"722\":1}}],[\"用于存储不同前缀对应的具体工厂对象\",{\"1\":{\"436\":1}}],[\"用于存储originator对象的内部状态\",{\"1\":{\"377\":1}}],[\"用于存储所有景点\",{\"1\":{\"372\":1}}],[\"用于存储具体元素对象\",{\"1\":{\"371\":1}}],[\"用于存储算法的输出数据\",{\"1\":{\"317\":1}}],[\"用于存储算法的输入数据\",{\"1\":{\"317\":1}}],[\"用于存储算法在运行过程中的变量\",{\"1\":{\"317\":1}}],[\"用于存储lsa\",{\"1\":{\"210\":1}}],[\"用于衡量算法占用内存空间随着数据量变大时的增长趋势\",{\"1\":{\"317\":1}}],[\"用于控制拥塞窗口\",{\"1\":{\"297\":1}}],[\"用于控制网页的外观和布局\",{\"1\":{\"104\":1}}],[\"用于检测数据传输过程中的错误\",{\"1\":{\"576\":1}}],[\"用于检测数据传输过程中是否发生错误\",{\"1\":{\"575\":1}}],[\"用于检测和纠正数据传输中可能产生的错误\",{\"1\":{\"576\":1}}],[\"用于检测报文在传输过程中是否发生了错误\",{\"1\":{\"288\":1}}],[\"用于检测帧在传输过程中是否发生了错误\",{\"1\":{\"131\":1}}],[\"用于光纤的信号收发\",{\"1\":{\"240\":1}}],[\"用于连接不同网络\",{\"1\":{\"580\":1}}],[\"用于连接不同组织之间的网络\",{\"1\":{\"223\":1}}],[\"用于连接企业内部的分支机构\",{\"1\":{\"223\":1}}],[\"用于连接终端设备\",{\"1\":{\"159\":1}}],[\"用于给因特网上的每一台主机\",{\"1\":{\"215\":1}}],[\"用于跟踪路由tracerouce\",{\"1\":{\"200\":1}}],[\"用于在测试代码中检查条件是否为真\",{\"1\":{\"793\":1}}],[\"用于在哈希表等数据结构中确定对象的存储位置\",{\"1\":{\"788\":1}}],[\"用于在网络中定位和标识这台设备\",{\"1\":{\"594\":1}}],[\"用于在计算机网络中标识和定位设备\",{\"1\":{\"593\":1}}],[\"用于在计算机网络中自动分配ip地址和其他网络配置参数给设备\",{\"1\":{\"62\":1}}],[\"用于在不修改已有类的情况下\",{\"1\":{\"369\":1}}],[\"用于在私有网络和公共网络之间进行通信\",{\"1\":{\"223\":1}}],[\"用于在ip主机\",{\"1\":{\"200\":1}}],[\"用于数据帧的转发\",{\"1\":{\"198\":1}}],[\"用于指示数据应传递给特定组中的设备\",{\"1\":{\"166\":1}}],[\"用于指示单播还是多播地址\",{\"1\":{\"166\":1}}],[\"用于指示地址的全球管理或本地管理\",{\"1\":{\"166\":1}}],[\"用于多个主机连接在同一个广播信道上\",{\"1\":{\"165\":1}}],[\"用于媒体接入控制\",{\"1\":{\"165\":1}}],[\"用于跨区域网络\",{\"1\":{\"162\":1}}],[\"用于标识网络上的设备或主机\",{\"1\":{\"574\":1}}],[\"用于标识该帧的结束\",{\"1\":{\"131\":1}}],[\"用于标识该帧的开始\",{\"1\":{\"131\":1}}],[\"用于标识dhcp客户端和服务器之间的通信\",{\"1\":{\"63\":1}}],[\"用于建立控制连接\",{\"1\":{\"87\":1}}],[\"用于传送数据的tcp连接只会在有数据传送时开启\",{\"1\":{\"85\":1}}],[\"用于传送控制命令的tcp连接在整个会话过程都保持开启状态\",{\"1\":{\"85\":1}}],[\"用于传输文件数据\",{\"1\":{\"85\":1,\"87\":1}}],[\"用于传输控制信息\",{\"1\":{\"85\":1}}],[\"用于自动分配ip地址和其他网络配置给主机\",{\"1\":{\"63\":1}}],[\"解锁操作连接在一起\",{\"1\":{\"837\":1}}],[\"解释一下带宽和频谱\",{\"0\":{\"620\":1},\"1\":{\"620\":1}}],[\"解释一下icmp协议的作用\",{\"0\":{\"611\":1}}],[\"解释一下半双工与全双工通信的区别是什么\",{\"1\":{\"582\":1}}],[\"解释一下半双工与全双工通信的区别\",{\"0\":{\"582\":1}}],[\"解释器模式\",{\"1\":{\"490\":1}}],[\"解释器模式将每个表达式规则封装在独立的类中\",{\"1\":{\"396\":1}}],[\"解释器设计模式提供了一种灵活的方式来处理特定领域的语法规则和表达式\",{\"1\":{\"396\":1}}],[\"解释器设计模式可以动态地修改\",{\"1\":{\"396\":1}}],[\"解释器设计模式可以用于处理自定义的查询语言或规则引擎\",{\"1\":{\"391\":1}}],[\"解释器设计模式适用于以下场景\",{\"1\":{\"391\":1}}],[\"解释器设计模式的基本流程如下\",{\"1\":{\"390\":1}}],[\"解释器设计模式的组成主要包括以下几个元素\",{\"1\":{\"390\":1}}],[\"解释器设计模式的核心思想是创建一个解释器\",{\"1\":{\"389\":1}}],[\"解释器设计模式\",{\"0\":{\"387\":1},\"1\":{\"388\":1}}],[\"解耦请求的发送者和接收者\",{\"1\":{\"385\":1}}],[\"解耦请求发送者和接收者\",{\"1\":{\"355\":1}}],[\"解耦性\",{\"1\":{\"328\":1}}],[\"解析出用户的基本信息\",{\"1\":{\"817\":1}}],[\"解析动作并不一\",{\"1\":{\"754\":1}}],[\"解析和初始化过\",{\"1\":{\"726\":1}}],[\"解析和注释\",{\"0\":{\"395\":1,\"404\":1,\"409\":1}}],[\"解析xml格式\",{\"1\":{\"511\":1}}],[\"解析xml的\",{\"1\":{\"511\":1}}],[\"解析json格式\",{\"1\":{\"511\":1}}],[\"解析json的\",{\"1\":{\"511\":1}}],[\"解析数据\",{\"1\":{\"333\":1}}],[\"解析\",{\"1\":{\"268\":1,\"511\":1,\"720\":1,\"754\":2,\"755\":1}}],[\"解码\",{\"1\":{\"239\":1}}],[\"解调和解码则将其还原成可听的声音\",{\"1\":{\"239\":1}}],[\"解调后的信号被转换回原始的声音信号\",{\"1\":{\"239\":1}}],[\"解调\",{\"1\":{\"239\":1,\"619\":1}}],[\"解决方案\",{\"1\":{\"845\":1}}],[\"解决方法包括\",{\"1\":{\"710\":1}}],[\"解决方法\",{\"1\":{\"285\":1,\"294\":1}}],[\"解决了标记\",{\"1\":{\"744\":1}}],[\"解决哈希冲突有哪些方法呢\",{\"0\":{\"692\":1},\"1\":{\"692\":1}}],[\"解决接口不匹配问题\",{\"1\":{\"512\":1}}],[\"解决ipv4地址枯竭问题\",{\"1\":{\"223\":1}}],[\"解决办法\",{\"1\":{\"218\":1}}],[\"解决如何在多路通信中介质争用的现象\",{\"1\":{\"144\":1}}],[\"解决如何在局域网内寻址\",{\"1\":{\"144\":1}}],[\"解决问题\",{\"1\":{\"119\":1}}],[\"解决什么问题\",{\"1\":{\"62\":1}}],[\"解压\",{\"0\":{\"18\":1,\"44\":1},\"1\":{\"18\":1,\"44\":1}}],[\"有界队列\",{\"1\":{\"862\":1}}],[\"有公平锁\",{\"1\":{\"838\":1}}],[\"有几个优势和好处\",{\"1\":{\"816\":1}}],[\"有序性指的是对于一个线程的执行代码\",{\"1\":{\"825\":1}}],[\"有序性的理解\",{\"0\":{\"825\":1},\"1\":{\"825\":1}}],[\"有序性\",{\"0\":{\"836\":1},\"1\":{\"814\":1,\"825\":1,\"827\":1}}],[\"有序传输\",{\"1\":{\"253\":1}}],[\"有两个常见的应用场景\",{\"1\":{\"851\":1}}],[\"有两个规则as\",{\"1\":{\"826\":1}}],[\"有两个属性id和name\",{\"1\":{\"787\":1}}],[\"有两种常见的垃圾回收策略分别用于判断常量和类的是否无用\",{\"1\":{\"733\":1}}],[\"有父类引用执行子类对象\",{\"1\":{\"782\":1}}],[\"有重写\",{\"1\":{\"782\":1}}],[\"有继承\",{\"1\":{\"782\":1}}],[\"有不被支持的类型\",{\"1\":{\"754\":1}}],[\"有个数据结构\",{\"1\":{\"747\":1}}],[\"有了对集合内元素的搜索的能力\",{\"1\":{\"705\":1}}],[\"有没有可以的实现\",{\"0\":{\"703\":1},\"1\":{\"703\":1}}],[\"有这样⼀段⽅法\",{\"1\":{\"689\":1}}],[\"有助于减少哈希冲突\",{\"1\":{\"688\":1}}],[\"有助于构建松耦合\",{\"1\":{\"326\":1}}],[\"有哪几种常见的线程池\",{\"0\":{\"859\":1}}],[\"有哪几种实现arraylist线程安全的方法\",{\"1\":{\"681\":1}}],[\"有哪些常见的线程池\",{\"1\":{\"859\":1}}],[\"有哪些常用的命令行性能监控和故障处理工具\",{\"1\":{\"762\":1}}],[\"有哪些区域需要停顿\",{\"0\":{\"747\":1}}],[\"有哪些请求方式\",{\"0\":{\"553\":1}}],[\"有存储转发功能\",{\"1\":{\"580\":1}}],[\"有以下关键部分\",{\"1\":{\"510\":1}}],[\"有以下几个具体的好处\",{\"1\":{\"361\":1}}],[\"有一线程\",{\"1\":{\"848\":1}}],[\"有一块结构\",{\"1\":{\"837\":1}}],[\"有一些错误需要修正\",{\"1\":{\"870\":1}}],[\"有一些占用大量连续内存空间的对象在被加载就会直接进入老年代\",{\"1\":{\"740\":1}}],[\"有一些常见的原则和准则可以帮助我们编写高质量\",{\"1\":{\"458\":1}}],[\"有一个经典的例子是java\",{\"1\":{\"335\":1}}],[\"有一个待发送的数据块\",{\"1\":{\"260\":1}}],[\"有一个或多个服务器端\",{\"1\":{\"58\":1}}],[\"有时会把排队时延看成处理时延一部分\",{\"1\":{\"263\":1}}],[\"有头部等信息\",{\"1\":{\"255\":1}}],[\"有摸得到的实物进行传导信号的方式\",{\"1\":{\"230\":1}}],[\"有对应表项则写入mac帧\",{\"1\":{\"198\":1}}],[\"有线网卡\",{\"1\":{\"165\":1}}],[\"有线局域网适配器\",{\"1\":{\"165\":1}}],[\"有确认的无连接服务\",{\"0\":{\"126\":1}}],[\"有确认的面向连接服务\",{\"0\":{\"125\":1}}],[\"有差错的物理传输线路的基础上\",{\"1\":{\"119\":1}}],[\"有什么保证线程安全的方案\",{\"1\":{\"831\":1}}],[\"有什么具体案例\",{\"1\":{\"759\":1}}],[\"有什么方法\",{\"0\":{\"733\":1},\"1\":{\"733\":1}}],[\"有什么区别\",{\"0\":{\"715\":1},\"1\":{\"715\":1}}],[\"有什么办法能解决hashmap线程不安全的问题呢\",{\"0\":{\"708\":1},\"1\":{\"708\":1}}],[\"有什么联系和区别\",{\"0\":{\"561\":1}}],[\"有什么作用\",{\"0\":{\"183\":1,\"736\":1},\"1\":{\"67\":1,\"722\":3,\"736\":1,\"797\":2}}],[\"有什么用\",{\"1\":{\"62\":1}}],[\"电等\",{\"1\":{\"618\":1}}],[\"电缆\",{\"1\":{\"619\":1}}],[\"电缆或光纤\",{\"1\":{\"581\":1}}],[\"电缆各层都是同轴心的\",{\"1\":{\"230\":1}}],[\"电影文件夹中包含了两部电影文件\",{\"1\":{\"525\":1}}],[\"电影文件夹中包含两部电影\",{\"1\":{\"525\":1}}],[\"电影\",{\"1\":{\"525\":3}}],[\"电商平台订单类\",{\"1\":{\"510\":1}}],[\"电子信号和介质访问层协议\",{\"1\":{\"578\":1}}],[\"电子产品商品\",{\"1\":{\"506\":1}}],[\"电子产品\",{\"1\":{\"506\":1}}],[\"电子邮件处理\",{\"1\":{\"355\":1}}],[\"电子邮件总结\",{\"1\":{\"100\":1}}],[\"电子邮件格式\",{\"0\":{\"91\":1},\"1\":{\"91\":2}}],[\"电子邮件系统的基础设施\",{\"1\":{\"90\":1}}],[\"电子邮件系统的三个主要组成构件\",{\"1\":{\"90\":1}}],[\"电子邮件系统\",{\"0\":{\"90\":1}}],[\"电子邮件系统和电子邮件\",{\"0\":{\"89\":1}}],[\"电子邮件\",{\"0\":{\"88\":1},\"1\":{\"54\":1}}],[\"电灯类\",{\"1\":{\"383\":1}}],[\"电磁波在信道中传播一定的距离需要花费的时间\",{\"1\":{\"263\":1}}],[\"电路交换三个步骤\",{\"1\":{\"253\":1}}],[\"电路交换怎么出现的\",{\"1\":{\"253\":1}}],[\"电路交换\",{\"0\":{\"253\":1},\"1\":{\"253\":1}}],[\"电平不会出现零电平\",{\"1\":{\"238\":1}}],[\"电话交换机接通电话线的方式称为电路交换\",{\"1\":{\"253\":1}}],[\"电话系统会使用调频调制\",{\"1\":{\"239\":1}}],[\"电话系统会将模拟信号转化为适合在电缆\",{\"1\":{\"239\":1}}],[\"电话\",{\"1\":{\"237\":1}}],[\"电话号码簿\",{\"1\":{\"67\":1}}],[\"电气特性\",{\"1\":{\"227\":1}}],[\"电驴\",{\"1\":{\"59\":1}}],[\"而内部的任务该怎么跑还是怎么跑\",{\"1\":{\"864\":1}}],[\"而longadder使用了分段的思想\",{\"1\":{\"855\":1}}],[\"而llc子层则是接受mac子层服务\",{\"1\":{\"120\":1}}],[\"而cyclicbarrier中的各个线程可以等待其他线程\",{\"1\":{\"852\":1}}],[\"而新资源己被其它线程占有\",{\"1\":{\"848\":1}}],[\"而reentrantlock需要手动调用lock\",{\"1\":{\"843\":1}}],[\"而reentrantlock是一个实现lock接口的类\",{\"1\":{\"843\":1}}],[\"而写锁最多只能同时被一个线程持有\",{\"1\":{\"842\":1}}],[\"而一旦被创建就永远不能改变\",{\"1\":{\"831\":1}}],[\"而槽位\",{\"1\":{\"820\":1}}],[\"而threadlocalmap它类似与我们的hashmap\",{\"1\":{\"816\":1}}],[\"而tcp是字节流\",{\"1\":{\"301\":1}}],[\"而如果定义在object类中\",{\"1\":{\"813\":1}}],[\"而synchronized不用手动释放锁\",{\"1\":{\"843\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"843\":1}}],[\"而sleep\",{\"1\":{\"812\":2}}],[\"而survivor空间是比较小的\",{\"1\":{\"743\":1}}],[\"而后两种面向字符\",{\"1\":{\"811\":1}}],[\"而传输的媒介为内存\",{\"1\":{\"811\":1}}],[\"而另一个线程感知到了变化\",{\"1\":{\"811\":2}}],[\"而另一个方向只传送确认\",{\"1\":{\"296\":1}}],[\"而唤醒线程主要是下面两个方法\",{\"1\":{\"807\":1}}],[\"而线程是具体干活的\",{\"1\":{\"804\":1}}],[\"而进程就类似于对应类的对象实例\",{\"1\":{\"804\":1}}],[\"而引入线程主要就是用于执行调度任务的\",{\"1\":{\"804\":1}}],[\"而引用被完全遍历后则标记为黑色\",{\"1\":{\"748\":1}}],[\"而抽象类的成员变量默认\",{\"1\":{\"783\":1}}],[\"而接口没有\",{\"1\":{\"783\":1}}],[\"而接口只能继承\",{\"1\":{\"783\":1}}],[\"而接口是使用interface修饰\",{\"1\":{\"783\":1}}],[\"而接收者也无需知道请求的发送者是谁\",{\"1\":{\"351\":1}}],[\"而接收邮件则通常使用pop3\",{\"1\":{\"94\":1}}],[\"而只面向这个对象本身\",{\"1\":{\"782\":1}}],[\"而面向对象的话\",{\"1\":{\"781\":1}}],[\"而实例方法与对应实例相关\",{\"1\":{\"779\":1}}],[\"而实际上多个站点同时发送数据会碰撞\",{\"1\":{\"152\":1}}],[\"而局部变量随着方法的调用而自动生成\",{\"1\":{\"775\":1}}],[\"而局部变量则不会自动赋值\",{\"1\":{\"775\":1}}],[\"而局部变量不能被访问控制修饰符及\",{\"1\":{\"775\":1}}],[\"而用户自定义的类由应用类加载器加载\",{\"1\":{\"758\":1}}],[\"而g1不会\",{\"1\":{\"751\":1}}],[\"而g1则是使用region块\",{\"1\":{\"751\":1}}],[\"而g1可以跟踪region的价值\",{\"1\":{\"749\":1}}],[\"而g1呢\",{\"1\":{\"749\":1}}],[\"而卡表就是记忆集的一种具体实现\",{\"1\":{\"742\":1}}],[\"而每次回收后存活的少量对象\",{\"1\":{\"737\":1}}],[\"而栈中的引用本身不需要被修改\",{\"1\":{\"730\":1}}],[\"而句柄中包含了对象实例数据与类型数据各自具体的地址信息\",{\"1\":{\"730\":1}}],[\"而本地方法栈则是为虚拟机使用到的本地\",{\"1\":{\"722\":1}}],[\"而并行垃圾回收器\",{\"1\":{\"721\":1}}],[\"而并不是\",{\"1\":{\"500\":1}}],[\"而访问顺序表示元素最近被访问的顺序\",{\"1\":{\"715\":1}}],[\"而在字符串内容基本不变的情况下\",{\"1\":{\"789\":1}}],[\"而在栈中分配的内存只是一个指向这个堆对象的引用而已\",{\"1\":{\"724\":1}}],[\"而在直接内存中划出一块区域作为元空间\",{\"1\":{\"723\":1}}],[\"而在多线程环境下\",{\"1\":{\"706\":1}}],[\"而在这个更大的网络中\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"而该数\",{\"1\":{\"688\":1}}],[\"而对它的改变必须同步刷新回共享内存\",{\"1\":{\"811\":1}}],[\"而对应的\",{\"1\":{\"683\":1}}],[\"而对于弱引用\",{\"1\":{\"818\":1}}],[\"而对于另一个只需要较少主机的子网\",{\"1\":{\"222\":1}}],[\"而对于传输层来说控制的是从源到最终目的端之间的流量\",{\"1\":{\"140\":1}}],[\"而集合可以分为4种\",{\"1\":{\"670\":1}}],[\"而香农公式则给出了信息传输的理论上限\",{\"1\":{\"622\":1}}],[\"而带宽则是描述信号在频域中所占用的范围\",{\"1\":{\"621\":1}}],[\"而频谱则关注信号中各个频率成分的分布情况\",{\"1\":{\"621\":1}}],[\"而光纤传输光信号\",{\"1\":{\"619\":1}}],[\"而全双工通信允许设备同时进行双向数据传输\",{\"1\":{\"582\":1}}],[\"而路由器则连接不同的网络\",{\"1\":{\"580\":1}}],[\"而差错控制是一种机制\",{\"1\":{\"576\":1}}],[\"而外部状态则由客户端提供\",{\"1\":{\"530\":1}}],[\"而其他无关的对象不会受到影响\",{\"1\":{\"490\":1}}],[\"而应该依赖于抽象接口或抽象类\",{\"1\":{\"478\":1}}],[\"而子类可以根据需要进行扩展和定制\",{\"1\":{\"470\":1}}],[\"而程序的行为不会出现意外\",{\"1\":{\"468\":1}}],[\"而原始活动保持不变\",{\"1\":{\"455\":1}}],[\"而建造者模式允许按照特定的步骤或顺序构建对象\",{\"1\":{\"452\":1}}],[\"而建造者设计模式适用于逐步构建复杂对象\",{\"1\":{\"452\":1}}],[\"而具体的建造者类负责实际构建对象\",{\"1\":{\"448\":1}}],[\"而具体的子类如myservletimpl则负责实现特定类型请求的处理逻辑\",{\"1\":{\"338\":1}}],[\"而观察者设计模式中\",{\"1\":{\"411\":1}}],[\"而观察者设计模式的目的是建立对象之间的依赖关系\",{\"1\":{\"411\":1}}],[\"而ipv6地址则采用128位地址\",{\"1\":{\"574\":1}}],[\"而ip地址是计算机在网络中的标识\",{\"1\":{\"594\":1}}],[\"而ip地址则用于在全球范围内定位和连接设备\",{\"1\":{\"574\":1}}],[\"而ip地址\",{\"1\":{\"574\":1}}],[\"而ip地址可以通过网络号做到\",{\"1\":{\"167\":1}}],[\"而isp关注接口的设计\",{\"1\":{\"474\":1}}],[\"而invoker类remotecontrol持有command对象\",{\"1\":{\"383\":1}}],[\"而\",{\"1\":{\"375\":1,\"706\":1,\"725\":1,\"769\":1,\"785\":1,\"812\":1,\"829\":1,\"834\":1}}],[\"而我们希望能够统计每种类型页面的访问量\",{\"1\":{\"372\":1}}],[\"而迭代器已经遍历到了最后一个元素\",{\"1\":{\"367\":1}}],[\"而迭代逻辑由迭代器来实现\",{\"1\":{\"364\":1}}],[\"而又不希望在聚合对象中增加复杂的遍历逻辑时\",{\"1\":{\"366\":1}}],[\"而数据库的连接数只有10个\",{\"1\":{\"853\":1}}],[\"而数据解析和校验的具体实现则由子类\",{\"1\":{\"333\":1}}],[\"而数据连接负责实际的文件传输\",{\"1\":{\"87\":1}}],[\"而基于消息队列的实现方式\",{\"1\":{\"327\":1}}],[\"而大数据征信系统是一个独立的系统\",{\"1\":{\"327\":1}}],[\"而订阅者也不需要知道发布者的细节\",{\"1\":{\"326\":1}}],[\"而订阅者\",{\"1\":{\"326\":1}}],[\"而时间复杂度是很难计算准确的\",{\"1\":{\"316\":1}}],[\"而执行快恢复算法\",{\"1\":{\"299\":1}}],[\"而校验和\",{\"1\":{\"287\":1}}],[\"而被动等待连接建立的应用进程叫服务器\",{\"1\":{\"284\":1}}],[\"而非静态的\",{\"1\":{\"816\":1}}],[\"而非静态成员属于实例对象\",{\"1\":{\"778\":1}}],[\"而非修改已有代码\",{\"1\":{\"464\":1}}],[\"而非报文流\",{\"1\":{\"282\":1}}],[\"而非实际的物理连接\",{\"1\":{\"184\":1}}],[\"而分用则确保接收主机能够将传输层数据流分解为多个上层应用程序的数据流\",{\"1\":{\"280\":1}}],[\"而必须借助传输层地址进行标识\",{\"1\":{\"277\":1}}],[\"而必须同时配置所谓的子网掩码\",{\"1\":{\"216\":1}}],[\"而理想低通信道只允许低频信号通过\",{\"1\":{\"240\":1}}],[\"而剔除高频成分\",{\"1\":{\"240\":1}}],[\"而剔除其他频率\",{\"1\":{\"240\":1}}],[\"而浪费掉了\",{\"1\":{\"238\":1}}],[\"而地球表面是个曲面\",{\"1\":{\"230\":1}}],[\"而将公共ip地址留给nat设备用于与公共网络通信\",{\"1\":{\"223\":1}}],[\"而将相对简单的分组交付功能放在网络核心\",{\"1\":{\"184\":1}}],[\"而没有使用\",{\"1\":{\"816\":1}}],[\"而没有实现\",{\"1\":{\"788\":1}}],[\"而没有其他区域路由器的信息\",{\"1\":{\"211\":1}}],[\"而没有网络中的其他路由器的路由信息\",{\"1\":{\"206\":1}}],[\"而这里等待了两次\",{\"1\":{\"852\":1}}],[\"而这里的应用进程识别就要依靠传输层了\",{\"1\":{\"274\":1}}],[\"而这里的拥塞控制是针对在网络传输路径中的端到端传输效率的控制\",{\"1\":{\"187\":1,\"592\":1}}],[\"而这样会出现频繁地对线程运行状态的切换\",{\"1\":{\"837\":1}}],[\"而这在双亲委派机制下可能变得复杂\",{\"1\":{\"758\":1}}],[\"而这也是jvm为我们承担的任务\",{\"1\":{\"719\":1}}],[\"而这些硬件并非专门用来实现某一特定目的\",{\"1\":{\"257\":1}}],[\"而这些资源在双方通信中不会被其他用户占用\",{\"1\":{\"253\":1}}],[\"而这些地址在公共因特网上是不可见的\",{\"1\":{\"223\":1}}],[\"而这个链路状态包括\",{\"1\":{\"210\":1}}],[\"而是从线程池中获取可用线程来处理请求\",{\"1\":{\"858\":1}}],[\"而是会把值刷新回主内存\",{\"1\":{\"827\":1}}],[\"而是弱引用容器装载的threadlocal\",{\"1\":{\"818\":1}}],[\"而是可以直接在方法内部获取线程独立的数据\",{\"1\":{\"816\":1}}],[\"而是随着代码的执行在不同的状态之间进行切换\",{\"1\":{\"808\":1}}],[\"而是被中断的线程根据中断状态自行处理\",{\"1\":{\"807\":1}}],[\"而是把这个请求委派给父类加载器去完成\",{\"1\":{\"758\":1}}],[\"而是根据类的访问情况和程序的运行情况来动态地加载\",{\"1\":{\"755\":1}}],[\"而是根据数据的哈希值决定的\",{\"1\":{\"672\":1}}],[\"而是将堆内存划分为多个大小相等的region区域\",{\"1\":{\"749\":1}}],[\"而是各个region块组成的新生代\",{\"1\":{\"749\":1}}],[\"而是必须是执行到安全点才能够暂停\",{\"1\":{\"747\":1}}],[\"而是让所有存活的对象都向内存空间一端移动\",{\"1\":{\"744\":1}}],[\"而是先复制原有集合内容\",{\"1\":{\"709\":1}}],[\"而是统一使用组件接口进行操作\",{\"1\":{\"526\":1}}],[\"而是统计算法运行时间和使用空间随着数据量变大时的增长趋势\",{\"1\":{\"313\":1}}],[\"而是以简洁的方式解决问题\",{\"1\":{\"480\":1}}],[\"而是应该依赖于抽象\",{\"1\":{\"476\":1}}],[\"而是按照基类的行为约定进行操作\",{\"1\":{\"469\":1}}],[\"而是通过门面来完成订单处理\",{\"1\":{\"518\":1}}],[\"而是通过java的反射机制在运行时动态生成代理类\",{\"1\":{\"496\":1}}],[\"而是通过调用公共方法来间接进行通信\",{\"1\":{\"488\":1}}],[\"而是通过扩展来实现新功能或适应变化的需求\",{\"1\":{\"466\":1}}],[\"而是通过中介者进行通信\",{\"1\":{\"411\":1}}],[\"而是通过中介者对象进行消息传递\",{\"1\":{\"399\":1}}],[\"而是通过加密和计算检验和等方式临时存储信息\",{\"1\":{\"285\":1}}],[\"而是要立即发送确认\",{\"1\":{\"299\":1}}],[\"而是两台主机中的各种网络应用进程\",{\"1\":{\"274\":1}}],[\"而是能够支持很多种的应用\",{\"1\":{\"257\":1}}],[\"而是包括了智能手机等智能硬件\",{\"1\":{\"257\":1}}],[\"而是涉及数据传输的实际介质和信号传输的方式\",{\"1\":{\"226\":1,\"227\":1}}],[\"而是维护一张网络拓扑图\",{\"1\":{\"210\":1}}],[\"而是r2\",{\"1\":{\"201\":1}}],[\"而是直接生成自己的报文\",{\"1\":{\"197\":1}}],[\"而是更大的广域网\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"而是只要这些文档都在同一个服务器上就可以实现\",{\"1\":{\"112\":1}}],[\"而交换机和路由器往往拥有更多的网络接口\",{\"1\":{\"165\":1}}],[\"而802委员会制定的llc子层作用已经不大\",{\"1\":{\"158\":1}}],[\"而所有的移动通信系统基本上都属于这种情况\",{\"1\":{\"150\":1}}],[\"而介质访问控制就是采取一定的措施\",{\"1\":{\"144\":1}}],[\"而介质访问控制子层则管理实际的物理传输\",{\"1\":{\"120\":1}}],[\"而高\",{\"1\":{\"131\":1}}],[\"而且正在运行的线程数量大于或等于\",{\"1\":{\"868\":1}}],[\"而且正在运行的线程数量小于\",{\"1\":{\"868\":1}}],[\"而且会中断正在运行的任务\",{\"1\":{\"867\":1}}],[\"而且第一个操作的执行顺序排在第二个操作之前\",{\"1\":{\"826\":1}}],[\"而且entry数据的key和当前不相等\",{\"1\":{\"820\":1}}],[\"而且sleep方法是不会去释放锁的\",{\"1\":{\"813\":1}}],[\"而且他俩都是本地方法\",{\"1\":{\"812\":1}}],[\"而且一个程序同时启动多个\",{\"1\":{\"804\":1}}],[\"而且先检验hashcode\",{\"1\":{\"787\":1}}],[\"而且每次回收的内存空间也正常\",{\"1\":{\"766\":1}}],[\"而且每个region是动态变化的\",{\"1\":{\"749\":1}}],[\"而且每一种通信协议又可能同时与多个对象沟通\",{\"1\":{\"120\":1}}],[\"而且这种操作需要\",{\"1\":{\"744\":1}}],[\"而且其中大部分是需要被回收的\",{\"1\":{\"744\":1}}],[\"而且有极少数方法\",{\"1\":{\"725\":1}}],[\"而且大小固定\",{\"1\":{\"724\":1}}],[\"而且它是线程私有\",{\"1\":{\"724\":1}}],[\"而且混合后的低位掺杂了高位的部分特征\",{\"1\":{\"694\":1}}],[\"而且物理层是真正的实体的物理线路\",{\"1\":{\"573\":1}}],[\"而且需要对该实例进行严格的控制和管理时\",{\"1\":{\"419\":1}}],[\"而且还会违反开闭原则\",{\"1\":{\"346\":1}}],[\"而且你希望能够动态地将对象加入或移除\",{\"1\":{\"325\":1}}],[\"而且必须知道每一位的持续时间\",{\"1\":{\"234\":1}}],[\"而且是永久存在的\",{\"1\":{\"126\":1}}],[\"而http\",{\"1\":{\"113\":1}}],[\"而不被其他的线程所影响\",{\"1\":{\"831\":1}}],[\"而不使用\",{\"1\":{\"816\":1}}],[\"而不管当前是否存在守护线程\",{\"1\":{\"810\":1}}],[\"而不像之前切成两份\",{\"1\":{\"749\":1}}],[\"而不同线程执行的时间又不同\",{\"1\":{\"722\":1}}],[\"而不涉及跨越路由器等设备的通信\",{\"1\":{\"583\":1}}],[\"而不影响基础类的原有实现\",{\"1\":{\"495\":1}}],[\"而不直接依赖于具体的\",{\"1\":{\"489\":1}}],[\"而不直接依赖具体产品的实现\",{\"1\":{\"440\":1}}],[\"而不会造成线程间的争用\",{\"1\":{\"855\":1}}],[\"而不会影响其他人的抽屉\",{\"1\":{\"816\":1}}],[\"而不会影响其他部分的代码\",{\"1\":{\"782\":1}}],[\"而不会影响其他接口的实现\",{\"1\":{\"473\":1}}],[\"而不会相互影响\",{\"1\":{\"504\":1}}],[\"而不会再次执行数据库查询\",{\"1\":{\"495\":1}}],[\"而不会对订单类产生影响\",{\"1\":{\"465\":1}}],[\"而不需要通过对象实例\",{\"1\":{\"816\":1}}],[\"而不需要在编译时就确定好所有的类和方法\",{\"1\":{\"798\":1}}],[\"而不需要完全暂停程序的运行\",{\"1\":{\"748\":1}}],[\"而不需要对哈希表进行重新的散列或重排\",{\"1\":{\"714\":1}}],[\"而不需要对每个子类编写特定的代码\",{\"1\":{\"470\":1}}],[\"而不需要了解其他对象的内部细节\",{\"1\":{\"488\":1}}],[\"而不需要强制实现不需要的方法\",{\"1\":{\"473\":1}}],[\"而不需要依赖于不相关的接口\",{\"1\":{\"472\":1}}],[\"而不需要针对每个具体的子类编写特定的代码\",{\"1\":{\"469\":1}}],[\"而不需要知道具体如何制作披萨\",{\"1\":{\"452\":1}}],[\"而不需要直接实例化对象\",{\"1\":{\"452\":1}}],[\"而不需要直接实例化具体的资源类\",{\"1\":{\"429\":1}}],[\"而不需要直接在\",{\"1\":{\"360\":1}}],[\"而不需要过多地关心状态切换和状态处理的细节\",{\"1\":{\"361\":1}}],[\"而不需要修改基础类的代码\",{\"1\":{\"495\":1}}],[\"而不需要修改\",{\"1\":{\"489\":1}}],[\"而不需要修改现有的类\",{\"1\":{\"506\":1}}],[\"而不需要修改现有的类继承结构\",{\"1\":{\"500\":1}}],[\"而不需要修改现有的方法\",{\"1\":{\"469\":1}}],[\"而不需要修改现有的实现类\",{\"1\":{\"346\":1}}],[\"而不需要修改订单类的代码\",{\"1\":{\"465\":1}}],[\"而不需要修改客户端代码\",{\"1\":{\"386\":1}}],[\"而不需要修改已有的代码\",{\"1\":{\"372\":1}}],[\"而不需要修改已有的实现类\",{\"1\":{\"346\":1}}],[\"而不需要一个一个地确认每个数据包\",{\"1\":{\"290\":1}}],[\"而不需要将邮件下载到本地进行管理\",{\"1\":{\"99\":1}}],[\"而不改变原网络id部分\",{\"1\":{\"216\":1}}],[\"而不让同一路由信息再通过此接口向反方向传送\",{\"1\":{\"209\":1}}],[\"而不仅是周期性发送\",{\"1\":{\"209\":1}}],[\"而不再实现碰撞检测功能\",{\"1\":{\"152\":1}}],[\"而不必每次都手动创建和管理线程\",{\"1\":{\"858\":1}}],[\"而不必处理与其他职责相关的复杂逻辑\",{\"1\":{\"461\":1}}],[\"而不必担心影响到与电子邮件发送相关的代码\",{\"1\":{\"461\":1}}],[\"而不必了解其内部结构\",{\"1\":{\"363\":1}}],[\"而不必修改\",{\"1\":{\"343\":1,\"344\":1,\"461\":1}}],[\"而不必为每个可能的目的地配置具体的路由\",{\"1\":{\"205\":1}}],[\"而不必等待确认\",{\"1\":{\"138\":1}}],[\"而不必记住复杂的ip地址\",{\"1\":{\"67\":1}}],[\"而不是忙等\",{\"1\":{\"837\":1}}],[\"而不是防止指令重排的有序性\",{\"1\":{\"836\":1}}],[\"而不是从线程的本地缓存中获取\",{\"1\":{\"834\":1}}],[\"而不是使用当前线程的本地内存中的值\",{\"1\":{\"827\":1}}],[\"而不是一个线程\",{\"1\":{\"785\":1}}],[\"而不是一味地向上委托给父加载器\",{\"1\":{\"759\":1}}],[\"而不是与类的实例关联\",{\"1\":{\"776\":1}}],[\"而不是对整个内存进行回收\",{\"1\":{\"749\":1}}],[\"而不是对网络上各设备的唯一标识\",{\"1\":{\"165\":1}}],[\"而不是8\",{\"1\":{\"697\":1}}],[\"而不是转换为红黑树\",{\"1\":{\"686\":1,\"706\":1}}],[\"而不是集线器\",{\"1\":{\"581\":1}}],[\"而不是广播到整个网络\",{\"1\":{\"573\":1}}],[\"而不是继承关系\",{\"1\":{\"505\":1}}],[\"而不是直接回收元空间内存\",{\"1\":{\"723\":1}}],[\"而不是直接依赖具体的对象\",{\"1\":{\"490\":1}}],[\"而不是直接依赖于具体的实现细节\",{\"1\":{\"476\":1}}],[\"而不是直接利用下面物理层中建立的物理链路\",{\"1\":{\"123\":1}}],[\"而不是依赖于不相关的方法\",{\"1\":{\"474\":1}}],[\"而不是将所有功能都聚合在一个接口中\",{\"1\":{\"474\":1}}],[\"而不是设计一个庞大而臃肿的接口\",{\"1\":{\"472\":1}}],[\"而不是共享引用\",{\"1\":{\"455\":1}}],[\"而不是通过使用构造函数进行创建\",{\"1\":{\"453\":1}}],[\"而不是通信双方主机\",{\"1\":{\"277\":1}}],[\"而不是实际运行和交互\",{\"1\":{\"408\":1}}],[\"而不是等该报文段的超时重传计时器超时再重传\",{\"1\":{\"299\":1}}],[\"而不是等待超时重传计时器超时再重传\",{\"1\":{\"299\":1}}],[\"而不是向慢开始那样根据发送方的返回窗口进行增加\",{\"1\":{\"298\":1}}],[\"而不是网络本身\",{\"1\":{\"184\":1}}],[\"而不是针对单个设备\",{\"1\":{\"166\":1}}],[\"而不是最新的版本\",{\"1\":{\"114\":1}}],[\"而mime引入了一种机制\",{\"1\":{\"96\":1}}],[\"而无需复杂的进程间通信机制\",{\"1\":{\"804\":1}}],[\"而无需直接与子系统的组件进行通信\",{\"1\":{\"514\":1}}],[\"而无需直接实例化具体的产品类\",{\"1\":{\"424\":1,\"434\":1}}],[\"而无需显式地依赖于特定类的构造函数\",{\"1\":{\"453\":1}}],[\"而无需关心具体产品的创建和加载过程\",{\"1\":{\"443\":1}}],[\"而无需关心其他处理器的存在\",{\"1\":{\"349\":1}}],[\"而无需指定具体实现类\",{\"1\":{\"439\":1,\"443\":1}}],[\"而无需改变景点的代码\",{\"1\":{\"372\":1}}],[\"而无需暴露底层集合的表示方式\",{\"1\":{\"363\":1}}],[\"而无需修改其源代码\",{\"1\":{\"512\":1}}],[\"而无需修改目标对象的代码\",{\"1\":{\"497\":1}}],[\"而无需修改现有代码\",{\"1\":{\"361\":1,\"526\":1}}],[\"而无需修改上下文类的代码\",{\"1\":{\"342\":1}}],[\"而无需用户主动提供用户标识信息\",{\"1\":{\"110\":1}}],[\"而无需手动配置\",{\"1\":{\"62\":1}}],[\"而无需依赖中央服务器\",{\"1\":{\"59\":1}}],[\"而运行服务器的主机也具有固定的ip地址\",{\"1\":{\"58\":1}}],[\"也基于它的机制\",{\"1\":{\"858\":1}}],[\"也引入了读写锁\",{\"1\":{\"832\":1}}],[\"也叫所记录\",{\"1\":{\"837\":1}}],[\"也叫\",{\"1\":{\"819\":1}}],[\"也有可能在初始化之后\",{\"1\":{\"754\":1}}],[\"也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些\",{\"1\":{\"299\":1}}],[\"也能正确地标记和遍历对象\",{\"1\":{\"748\":1}}],[\"也能够保证个个线程之间不出现数据征用的问题\",{\"1\":{\"831\":1}}],[\"也能够基于\",{\"1\":{\"579\":1}}],[\"也能够彼此通信\",{\"1\":{\"579\":1}}],[\"也简称为\",{\"1\":{\"747\":1}}],[\"也无法通过虚引用来取得一个对象实例\",{\"1\":{\"735\":1}}],[\"也执行\",{\"1\":{\"707\":1}}],[\"也不会处理阻塞队列中的任务\",{\"1\":{\"867\":1}}],[\"也不会出现书本混乱或丢失的问题\",{\"1\":{\"816\":1}}],[\"也不会导致\",{\"1\":{\"713\":1}}],[\"也不需要获得对象锁\",{\"1\":{\"813\":1}}],[\"也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用\",{\"1\":{\"742\":1}}],[\"也不保证元素的顺序\",{\"1\":{\"706\":1}}],[\"也不合并\",{\"1\":{\"301\":1}}],[\"也提供对应符合要求的集合\",{\"1\":{\"673\":1}}],[\"也要实现这个接口\",{\"1\":{\"494\":1}}],[\"也要立即发出对已收到的报文段的重复确认\",{\"1\":{\"299\":1}}],[\"也被称为最少知识原则\",{\"1\":{\"488\":1}}],[\"也被称为硬件地址\",{\"1\":{\"165\":1}}],[\"也成功接收到了这些消息\",{\"1\":{\"403\":1}}],[\"也就说如果此时有很多用于访问\",{\"1\":{\"818\":1}}],[\"也就导致实际上只有一个元素被添加到了\",{\"1\":{\"707\":1}}],[\"也就不会误认为出现了拥塞\",{\"1\":{\"299\":1}}],[\"也就是队列里靠前的任务\",{\"1\":{\"861\":1}}],[\"也就是你可以继续尝试\",{\"1\":{\"845\":1}}],[\"也就是偏向状态\",{\"1\":{\"837\":1}}],[\"也就是给当前类加锁\",{\"1\":{\"833\":1}}],[\"也就是咱们说的自旋\",{\"1\":{\"831\":1}}],[\"也就是size\",{\"1\":{\"821\":1}}],[\"也就是线程本地变量\",{\"1\":{\"816\":1}}],[\"也就是可以同时运行多个进程\",{\"1\":{\"804\":1}}],[\"也就是常量字符串\",{\"1\":{\"792\":1}}],[\"也就是它们的工作区域分为不同的垃圾回收器\",{\"1\":{\"745\":1}}],[\"也就是我们在程序代码里所定义的各种类型的字段内容\",{\"1\":{\"729\":1}}],[\"也就是本地线程分配缓冲\",{\"1\":{\"728\":1}}],[\"也就是使用了native标识的方法\",{\"1\":{\"722\":1}}],[\"也就是字节码\",{\"1\":{\"722\":1}}],[\"也就是支持16个线程的并发写\",{\"1\":{\"711\":1}}],[\"也就是减少了链表或红黑树的长度\",{\"1\":{\"696\":1}}],[\"也就是最⼤的map集合\",{\"1\":{\"689\":1}}],[\"也就是发生了超时重传\",{\"1\":{\"297\":1}}],[\"也就是发送端和接收端不同时开始工作\",{\"1\":{\"235\":1}}],[\"也就是拥塞窗口和接收窗口中的最小值\",{\"1\":{\"297\":1}}],[\"也就是将多个上层应用程序的数据流合并为一个传输层数据流\",{\"1\":{\"280\":1}}],[\"也就是将自己链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器\",{\"1\":{\"210\":1}}],[\"也就是被路由器转发\",{\"1\":{\"268\":1}}],[\"也就是从发送数据帧的第一个比特算起\",{\"1\":{\"263\":1}}],[\"也就是一条专用的物理通路\",{\"1\":{\"253\":1}}],[\"也就是构造出树形结构\",{\"1\":{\"212\":1}}],[\"也就是对应路由条目中除源站点所在网络直接连接的路由器外\",{\"1\":{\"208\":1}}],[\"也就是整条路由路径经历了三个或以上路由器结点\",{\"1\":{\"205\":1}}],[\"也就是帧头和帧尾\",{\"1\":{\"186\":1,\"591\":1}}],[\"也就是帧边界\",{\"1\":{\"130\":1}}],[\"也就是不管不同网络间的差异\",{\"1\":{\"184\":1,\"589\":1}}],[\"也就是280万亿\",{\"1\":{\"166\":1}}],[\"也就是找到目的节点\",{\"1\":{\"144\":1}}],[\"也就是接收端的缓存空间满了或者接近满时\",{\"1\":{\"141\":1,\"576\":1}}],[\"也就是接收端可以区分每个数据帧的起始和结束了\",{\"1\":{\"133\":1}}],[\"也就是通常所说的协议\",{\"1\":{\"123\":1}}],[\"也就是前面说到的sap\",{\"1\":{\"120\":1}}],[\"也就是说每个线程实例对象有一个自己的threadlocalmap\",{\"1\":{\"816\":1}}],[\"也就是说无需同步\",{\"1\":{\"816\":1}}],[\"也就是说一个线程可以根据一个threadlocal对象查询到绑定在这个线程上的一个值\",{\"1\":{\"811\":1}}],[\"也就是说守护线程是否结束并不影响\",{\"1\":{\"810\":1}}],[\"也就是说拷贝对象和原对象共用同一个内部对象\",{\"1\":{\"784\":1}}],[\"也就是说赋值的前后都在写屏障的覆盖范畴内\",{\"1\":{\"742\":1}}],[\"也就是说在建立一个对象时\",{\"1\":{\"724\":1}}],[\"也就是说它和我们的方法调用执行有关\",{\"1\":{\"722\":1}}],[\"也就是说平衡二叉树保持平衡的效率更低\",{\"1\":{\"698\":1}}],[\"也就是说\",{\"1\":{\"110\":1,\"184\":1,\"205\":1,\"251\":1,\"462\":1,\"706\":1,\"836\":1,\"871\":1}}],[\"也会根据threadlocal对象的hash值\",{\"1\":{\"820\":1}}],[\"也会停止回收\",{\"1\":{\"764\":1}}],[\"也会在特定的位置生成\",{\"1\":{\"747\":1}}],[\"也会在接收方重新排序后交付给应用层\",{\"1\":{\"291\":1}}],[\"也会触发\",{\"1\":{\"739\":1}}],[\"也会进行性能监控\",{\"1\":{\"720\":1}}],[\"也会向源点发送时间超过报文\",{\"1\":{\"201\":1}}],[\"也越高\",{\"1\":{\"261\":1}}],[\"也难以差错控制\",{\"1\":{\"253\":1}}],[\"也适用于传输数字信号\",{\"1\":{\"253\":1}}],[\"也包括物理层\",{\"1\":{\"173\":1}}],[\"也可被重新赋值\",{\"1\":{\"783\":1}}],[\"也可能创建一个新的线程来代替异常的线程\",{\"1\":{\"865\":1}}],[\"也可能是老年代\",{\"1\":{\"749\":1}}],[\"也可能是下一步需要查询的域名服务器的\",{\"1\":{\"71\":1}}],[\"也可能导致方法区溢出\",{\"1\":{\"731\":1}}],[\"也可用于交换机与用户计算机之间的互连\",{\"1\":{\"159\":1}}],[\"也可给发送方发送nak分组\",{\"1\":{\"137\":1}}],[\"也可以自己去扩展threadpoolexecutor\",{\"1\":{\"869\":1}}],[\"也可以自己开发配置中心\",{\"1\":{\"869\":1}}],[\"也可以叫同步点\",{\"1\":{\"852\":1}}],[\"也可以通过构造器来显式的指定使用公平锁\",{\"1\":{\"838\":1}}],[\"也可以通过匿名登陆访问公开共享的文件\",{\"1\":{\"85\":1}}],[\"也可以说是一种同步机制\",{\"1\":{\"835\":1}}],[\"也可以\",{\"1\":{\"817\":1}}],[\"也可以随时改变拼图的形状一样\",{\"1\":{\"798\":1}}],[\"也可以实现接口\",{\"1\":{\"783\":1}}],[\"也可以传参\",{\"1\":{\"685\":1}}],[\"也可以传送多个vlan的数据帧\",{\"1\":{\"159\":1}}],[\"也可以根据设备的\",{\"1\":{\"579\":1}}],[\"也可以在代理对象中进行一些额外的操作\",{\"1\":{\"495\":1}}],[\"也可以使用拥塞避免算法\",{\"1\":{\"299\":1}}],[\"也可以是更复杂的数据结构\",{\"1\":{\"853\":1}}],[\"也可以是机器语言\",{\"1\":{\"804\":1}}],[\"也可以是离散的\",{\"1\":{\"620\":1}}],[\"也可以是提供路由功能的三层交换机\",{\"1\":{\"208\":1}}],[\"也可以是长达几万千米的点对点卫星链路\",{\"1\":{\"161\":1}}],[\"也可以是资源的请求者\",{\"1\":{\"59\":1}}],[\"也是\",{\"1\":{\"832\":1}}],[\"也是一个键值对的存储\",{\"1\":{\"816\":1}}],[\"也是个图形化工具\",{\"1\":{\"769\":1}}],[\"也是基于分代回收\",{\"1\":{\"751\":1}}],[\"也是基于数组和链表实现的\",{\"1\":{\"706\":1}}],[\"也是目前最常用的方式\",{\"1\":{\"742\":1}}],[\"也是可以的\",{\"1\":{\"455\":1}}],[\"也是不启动慢开始算法\",{\"1\":{\"299\":1}}],[\"也是信息论中信息量的单位\",{\"1\":{\"260\":1}}],[\"也是保留字段\",{\"1\":{\"131\":1}}],[\"也是最重要的域名服务器\",{\"1\":{\"71\":1}}],[\"也是用户与网络之间交互的接口\",{\"1\":{\"56\":1}}],[\"也称为网络适配器\",{\"1\":{\"618\":1}}],[\"也称为订阅者\",{\"1\":{\"324\":1}}],[\"也称为被观察者或发布者\",{\"1\":{\"324\":1}}],[\"也称为比特率或数据率\",{\"1\":{\"260\":1}}],[\"也称为默认路由或默认路由表项\",{\"1\":{\"205\":1}}],[\"也称为泛洪\",{\"1\":{\"174\":1}}],[\"也称为dns服务器\",{\"1\":{\"68\":1}}],[\"也称为点对点方式\",{\"1\":{\"59\":1}}],[\"或其他基于哈希表的数据结构时\",{\"1\":{\"788\":1}}],[\"或以使用\",{\"1\":{\"769\":1}}],[\"或使用在线分析平台\",{\"1\":{\"769\":1}}],[\"或使用第三方式具分析的\",{\"1\":{\"769\":1}}],[\"或使用\",{\"1\":{\"769\":2}}],[\"或\",{\"1\":{\"485\":1,\"489\":2,\"765\":1,\"787\":1,\"791\":1,\"853\":2}}],[\"或next\",{\"1\":{\"367\":1}}],[\"或接收者\",{\"1\":{\"348\":1}}],[\"或q\",{\"1\":{\"343\":1}}],[\"或链路\",{\"1\":{\"263\":1}}],[\"或信道\",{\"1\":{\"262\":1}}],[\"或称cidr记法\",{\"1\":{\"220\":1}}],[\"或称物理地址\",{\"1\":{\"196\":1}}],[\"或路由器\",{\"1\":{\"215\":1}}],[\"或路由器各接口\",{\"1\":{\"167\":1}}],[\"或对等站\",{\"1\":{\"212\":1}}],[\"或撤销过时的路由\",{\"1\":{\"212\":1}}],[\"或哪些\",{\"1\":{\"174\":1}}],[\"或横跨几个洲并能提供远距离通信\",{\"1\":{\"161\":1}}],[\"或多项式\",{\"1\":{\"135\":1,\"576\":1}}],[\"或imap\",{\"1\":{\"94\":1}}],[\"或者monitor锁\",{\"1\":{\"835\":1}}],[\"或者乐观锁的实现方式\",{\"1\":{\"832\":1}}],[\"或者原子类的原子操作\",{\"1\":{\"825\":1}}],[\"或者根据配置文件动态加载不同的实现\",{\"1\":{\"800\":1}}],[\"或者内存泄露导致对象无法回收\",{\"1\":{\"766\":1}}],[\"或者堆空间比较大\",{\"1\":{\"752\":1}}],[\"或者垃圾收集暂停必须保持在大约\",{\"1\":{\"752\":1}}],[\"或者可以接受\",{\"1\":{\"752\":1}}],[\"或者新生代对象\",{\"1\":{\"739\":1}}],[\"或者使用同步机制来避免并发修改异常的发生\",{\"1\":{\"710\":1}}],[\"或者使用不同的邮件服务提供商\",{\"1\":{\"461\":1}}],[\"或者迭代器的\",{\"1\":{\"710\":1}}],[\"或者\",{\"1\":{\"703\":1,\"706\":1,\"735\":1,\"807\":1}}],[\"或者hash算法不太优秀或者存入的元素太多\",{\"1\":{\"690\":1}}],[\"或者将项目修改为spring\",{\"1\":{\"498\":1}}],[\"或者将请求放入队列中进行排队处理\",{\"1\":{\"381\":1}}],[\"或者把模块看作比类更加粗粒度的代码块\",{\"1\":{\"460\":1}}],[\"或者需要根据不同的条件创建不同的对象时\",{\"1\":{\"435\":1}}],[\"或者在同一个next\",{\"1\":{\"367\":1}}],[\"或者在一个独立的用户进程中\",{\"1\":{\"274\":1}}],[\"或者希望动态地指定处理请求的对象时\",{\"1\":{\"351\":1}}],[\"或者采取其他限制措施\",{\"1\":{\"285\":1}}],[\"或者以一个链接库的形式被绑定在具体的网络应用中\",{\"1\":{\"274\":1}}],[\"或者其他调制技术将模拟信号转化为适合传输的信号\",{\"1\":{\"239\":1}}],[\"或者收到了错误的确认\",{\"1\":{\"138\":1,\"139\":1}}],[\"或者从远程服务器下载到本地计算机\",{\"1\":{\"83\":1}}],[\"或者idea图形化界面打包\",{\"1\":{\"23\":1,\"49\":1}}],[\"或服务器场\",{\"1\":{\"58\":1}}],[\"常量和变量\",{\"1\":{\"792\":1}}],[\"常量和常量\",{\"1\":{\"792\":1}}],[\"常量折叠\",{\"1\":{\"792\":1}}],[\"常量等\",{\"1\":{\"776\":1}}],[\"常量等引用对象\",{\"1\":{\"746\":1}}],[\"常量池中的常量是否\",{\"1\":{\"754\":1}}],[\"常量池中的常量可能会成为废弃常量\",{\"1\":{\"733\":1}}],[\"常量池位于永久代\",{\"1\":{\"723\":1}}],[\"常量\",{\"1\":{\"722\":1}}],[\"常量定义文件\",{\"1\":{\"539\":1}}],[\"常数阶<对数阶<线性阶<线性对数阶<平方阶<指数阶<阶层阶\",{\"1\":{\"316\":1}}],[\"常数阶\",{\"1\":{\"316\":5}}],[\"常见工作在物理层的设备包括连接设备和传输媒体介质\",{\"1\":{\"618\":1}}],[\"常见大o类型和图例\",{\"1\":{\"316\":2}}],[\"常见线性数据结构和非线性数据结构\",{\"1\":{\"311\":1}}],[\"常见端口号\",{\"1\":{\"279\":1}}],[\"常见物理层设备\",{\"1\":{\"240\":1}}],[\"常见设备\",{\"0\":{\"169\":1}}],[\"常见的异常处理方式\",{\"1\":{\"865\":1}}],[\"常见的补偿策略就是不断的重试\",{\"1\":{\"831\":1,\"832\":1}}],[\"常见的遍历方式\",{\"0\":{\"702\":1},\"1\":{\"702\":1}}],[\"常见的hash算法有md5\",{\"1\":{\"690\":1}}],[\"常见的调制技术包括\",{\"1\":{\"619\":1}}],[\"常见的路由协议有哪些\",{\"0\":{\"603\":1}}],[\"常见的子网掩码有\",{\"1\":{\"596\":1}}],[\"常见的两种广域网数据链路层协议是\",{\"1\":{\"162\":1,\"584\":1}}],[\"常见的局域网拓扑结构\",{\"0\":{\"158\":1}}],[\"常见的例子包括web应用\",{\"1\":{\"58\":1}}],[\"常用异常有哪些\",{\"1\":{\"793\":1}}],[\"常用的可视化的性能监控和故障处理工具\",{\"0\":{\"763\":1}}],[\"常用的命令行性能监控和故障处理工具\",{\"0\":{\"762\":1}}],[\"常用的http\",{\"0\":{\"559\":1}}],[\"常用的mysql\",{\"1\":{\"3\":1,\"5\":1,\"29\":1,\"31\":1}}],[\"常用于回溯\",{\"1\":{\"316\":1}}],[\"常用于广域网\",{\"1\":{\"121\":1}}],[\"常用数据率单位\",{\"1\":{\"260\":1}}],[\"常用数据量单位\",{\"1\":{\"260\":1}}],[\"常用计算机群集\",{\"1\":{\"58\":1}}],[\"常会出现服务器计算机跟不上众多客户机请求的情况\",{\"1\":{\"58\":1}}],[\"基带同轴电缆\",{\"1\":{\"230\":1}}],[\"基本就可以看到死锁的信息\",{\"1\":{\"849\":1}}],[\"基本就能定位到问题在那了\",{\"1\":{\"769\":1}}],[\"基本类型\",{\"1\":{\"773\":1,\"847\":2}}],[\"基本类型和包装类型的区别\",{\"0\":{\"773\":1},\"1\":{\"773\":2}}],[\"基本上就可以定位到代码层的逻辑了\",{\"1\":{\"769\":1}}],[\"基本上\",{\"1\":{\"746\":1}}],[\"基本流程\",{\"0\":{\"427\":1,\"501\":1,\"505\":1,\"509\":1},\"1\":{\"350\":1,\"359\":1,\"365\":1,\"377\":1,\"383\":1,\"495\":1,\"496\":1}}],[\"基本流程如下\",{\"1\":{\"332\":1,\"371\":1}}],[\"基本调制\",{\"1\":{\"239\":1,\"619\":1}}],[\"基本任务\",{\"0\":{\"228\":1}}],[\"基本都采用多点接入技术\",{\"1\":{\"162\":1}}],[\"基于springboot的网页版短视频\",{\"0\":{\"883\":1}}],[\"基于springboot的网页云盘\",{\"0\":{\"879\":1}}],[\"基于netty的rpc远程调用框架\",{\"0\":{\"881\":1}}],[\"基于jvm字节码指令实现\",{\"1\":{\"843\":1}}],[\"基于jdk实现的动态代理\",{\"1\":{\"496\":1}}],[\"基于垃圾收集器的特点\",{\"1\":{\"752\":1}}],[\"基于这种结构\",{\"1\":{\"714\":1}}],[\"基于拷贝内容的优点是避免了concurrent\",{\"1\":{\"709\":1}}],[\"基于他们一次次的尝试\",{\"1\":{\"696\":1}}],[\"基于linux内核\",{\"1\":{\"537\":1}}],[\"基于\",{\"0\":{\"497\":1,\"498\":1},\"1\":{\"579\":2,\"831\":1}}],[\"基于继承实现\",{\"1\":{\"496\":1}}],[\"基于接口实现\",{\"1\":{\"496\":1}}],[\"基于链表可实现\",{\"1\":{\"312\":1}}],[\"基于数组可实现\",{\"1\":{\"312\":1}}],[\"基于流量的路由算法\",{\"1\":{\"205\":1}}],[\"基于ip地址\",{\"1\":{\"159\":1}}],[\"基于mac地址\",{\"1\":{\"159\":1}}],[\"基于端口\",{\"1\":{\"159\":1,\"579\":1}}],[\"基于窗口滑动机制的速率控制方\",{\"1\":{\"142\":1,\"576\":1}}],[\"基于速率的流量控制方案\",{\"0\":{\"142\":1},\"1\":{\"576\":1}}],[\"基于反馈的流量控制方案\",{\"0\":{\"141\":1},\"1\":{\"576\":1}}],[\"基于待发送的数据\",{\"1\":{\"135\":1,\"576\":1}}],[\"基于万维网的电子邮件\",{\"0\":{\"99\":1},\"1\":{\"99\":2}}],[\"基于cas来操作int类型变量\",{\"1\":{\"847\":1}}],[\"基于cglib使用的动态代理\",{\"1\":{\"496\":1}}],[\"基于c\",{\"1\":{\"58\":1}}],[\"基础组件升级等情况\",{\"1\":{\"768\":1}}],[\"基础数据结构\",{\"1\":{\"690\":1}}],[\"基础\",{\"0\":{\"669\":1,\"803\":1}}],[\"基础题\",{\"0\":{\"626\":1}}],[\"基础类\",{\"1\":{\"495\":1}}],[\"基础结构域名\",{\"1\":{\"69\":1}}],[\"基础学习路线图\",{\"1\":{\"53\":1}}],[\"相对于从线程池拿线程\",{\"1\":{\"857\":1}}],[\"相对来说\",{\"1\":{\"840\":1}}],[\"相对重量级锁\",{\"1\":{\"837\":1}}],[\"相似的互斥同步能力\",{\"1\":{\"832\":1}}],[\"相当于取余\",{\"1\":{\"819\":1}}],[\"相当于建立连接的过程\",{\"1\":{\"125\":1}}],[\"相比synchronized的加锁方式来解决共享变量的内存可见性问题\",{\"1\":{\"827\":1}}],[\"相比直接调用代码\",{\"1\":{\"799\":1}}],[\"相比之下\",{\"1\":{\"422\":1,\"715\":1,\"855\":1}}],[\"相较\",{\"1\":{\"789\":1}}],[\"相较于直接统计算法的运行时间\",{\"1\":{\"316\":1}}],[\"相等\",{\"1\":{\"788\":2}}],[\"相应就大大提高了执行速度\",{\"1\":{\"787\":1}}],[\"相连的对象\",{\"1\":{\"746\":1,\"750\":1}}],[\"相连接的引用链\",{\"1\":{\"736\":1}}],[\"相关对象在需要与其他对象通信时\",{\"1\":{\"400\":1}}],[\"相关对象\",{\"1\":{\"400\":1}}],[\"相关联\",{\"1\":{\"8\":1,\"34\":1}}],[\"相位或幅度\",{\"1\":{\"239\":1}}],[\"相邻路由器之间周期性发送问候分组\",{\"1\":{\"210\":1}}],[\"相同\",{\"1\":{\"316\":1}}],[\"相同下一跳\",{\"1\":{\"208\":1}}],[\"相同点\",{\"1\":{\"162\":1,\"704\":1,\"773\":1,\"843\":1}}],[\"相反\",{\"1\":{\"150\":1,\"469\":1}}],[\"相匹配\",{\"1\":{\"140\":1,\"576\":1}}],[\"相互交互\",{\"1\":{\"58\":1}}],[\"提取数据包\",{\"1\":{\"573\":1}}],[\"提取目的网络地址后查找自身路由表\",{\"1\":{\"268\":1}}],[\"提升了synchronized的性能\",{\"1\":{\"837\":1}}],[\"提升了代码的可读性和可测试性\",{\"1\":{\"489\":1}}],[\"提升效率\",{\"1\":{\"701\":1}}],[\"提升可维护性\",{\"1\":{\"488\":1}}],[\"提升团队的开发效率和协作效果\",{\"1\":{\"474\":1}}],[\"提升代码的灵活性\",{\"1\":{\"473\":1}}],[\"提高数据库访问的效率和性能\",{\"1\":{\"858\":1}}],[\"提高数据的访问性和代码的简洁性\",{\"1\":{\"816\":1}}],[\"提高服务器的吞吐量和响应速度\",{\"1\":{\"858\":1}}],[\"提高响应速度\",{\"1\":{\"857\":1}}],[\"提高可访问性\",{\"1\":{\"816\":1}}],[\"提高可扩展性\",{\"1\":{\"345\":1}}],[\"提高资源利用率\",{\"1\":{\"759\":1}}],[\"提高扩容的效率\",{\"1\":{\"701\":1}}],[\"提高\",{\"1\":{\"688\":1}}],[\"提高性能\",{\"1\":{\"533\":1}}],[\"提高代码复用性\",{\"1\":{\"512\":1}}],[\"提高代码复用\",{\"1\":{\"512\":1}}],[\"提高代码的灵活性\",{\"1\":{\"490\":1}}],[\"提高代码的灵活性和可维护性\",{\"1\":{\"478\":1,\"490\":1}}],[\"提高代码的内聚性\",{\"1\":{\"473\":1}}],[\"提高代码的可读性和可维护性\",{\"1\":{\"460\":1}}],[\"提高代码的可扩展性和维护性\",{\"1\":{\"437\":1}}],[\"提高代码的一致性和可读性\",{\"1\":{\"333\":1}}],[\"提高系统响应速度\",{\"1\":{\"495\":1}}],[\"提高系统的性能和响应能力\",{\"1\":{\"858\":1}}],[\"提高系统的性能和可扩展性\",{\"1\":{\"533\":1}}],[\"提高系统的性能\",{\"1\":{\"858\":1}}],[\"提高系统的灵活性和可扩展性\",{\"1\":{\"385\":1,\"405\":1}}],[\"提高系统的可维护性和可扩展性\",{\"1\":{\"504\":1}}],[\"提高系统的可维护性和灵活性\",{\"1\":{\"328\":1}}],[\"提高系统的可扩展性和可\",{\"1\":{\"345\":1}}],[\"提高灵活性\",{\"1\":{\"488\":1}}],[\"提高开发效率\",{\"1\":{\"482\":1,\"486\":1}}],[\"提高网络的吞吐量\",{\"1\":{\"296\":1}}],[\"提高网络性能\",{\"1\":{\"296\":1}}],[\"提高线路利用率\",{\"1\":{\"255\":1}}],[\"提高线路可靠性\",{\"1\":{\"255\":1}}],[\"提高路由器的性能\",{\"1\":{\"221\":1}}],[\"提高了传输效率和带宽利用率\",{\"1\":{\"619\":1}}],[\"提高了效率\",{\"1\":{\"580\":1}}],[\"提高了系统的性能\",{\"1\":{\"533\":1}}],[\"提高了系统的可维护性和可读性\",{\"1\":{\"519\":1}}],[\"提高了系统的灵活性和可维护性\",{\"1\":{\"474\":1}}],[\"提高了代码质量和可维护性\",{\"1\":{\"474\":1}}],[\"提高了代码的灵活性和可测试性\",{\"1\":{\"481\":1}}],[\"提高了代码的灵活性和可维护性\",{\"1\":{\"436\":1,\"476\":1,\"489\":1}}],[\"提高了代码的灵活性\",{\"1\":{\"472\":1}}],[\"提高了代码的可测试性和可扩展性\",{\"1\":{\"476\":1}}],[\"提高了代码的可维护性和灵活性\",{\"1\":{\"470\":1}}],[\"提高了代码的可扩展性和可维护性\",{\"1\":{\"422\":1}}],[\"提高了代码的复用性和可扩展性\",{\"1\":{\"470\":1}}],[\"提高了抗电磁干扰能力\",{\"1\":{\"230\":1}}],[\"提高了网络的性能和效率\",{\"1\":{\"174\":1}}],[\"提高了网络利用率\",{\"1\":{\"139\":1}}],[\"提高了下载文档的效率\",{\"1\":{\"112\":1}}],[\"提供隔离的机制\",{\"1\":{\"760\":1}}],[\"提供额外的测试功能\",{\"1\":{\"539\":1}}],[\"提供现代的\",{\"1\":{\"539\":1}}],[\"提供向后兼容性支持\",{\"1\":{\"539\":1}}],[\"提供一个屏幕\",{\"1\":{\"539\":1}}],[\"提供一个统一的接口\",{\"1\":{\"520\":1}}],[\"提供一个统一的接口给客户端进行商品购买操作\",{\"1\":{\"517\":1}}],[\"提供一个简化的接口来处理订单\",{\"1\":{\"518\":1}}],[\"提供一个简单而统一的接口时\",{\"1\":{\"517\":1}}],[\"提供一个公共的静态方法作为全局访问点\",{\"1\":{\"418\":1}}],[\"提供更多的功能或特性\",{\"1\":{\"504\":1}}],[\"提供对实例的全局访问\",{\"1\":{\"421\":1}}],[\"提供对单例类实例的全局访问\",{\"1\":{\"418\":1}}],[\"提供对该实例的全局访问\",{\"1\":{\"417\":1}}],[\"提供对物理层的统一访问接口\",{\"1\":{\"158\":1}}],[\"提供接受访问者访问的具体实现\",{\"1\":{\"371\":1}}],[\"提供多目标服务\",{\"1\":{\"255\":1}}],[\"提供透明传输\",{\"0\":{\"184\":1,\"589\":1}}],[\"提供了三种访问模式\",{\"1\":{\"832\":1}}],[\"提供了诸如\",{\"1\":{\"829\":1}}],[\"提供了诸多插件和功能\",{\"1\":{\"763\":1}}],[\"提供了默认的行为和管理子组件的方法\",{\"1\":{\"526\":1}}],[\"提供了一些原子性的复合操作\",{\"1\":{\"713\":1}}],[\"提供了一个清晰的界面和高层次的接口\",{\"1\":{\"519\":1}}],[\"提供了一个统一的接口\",{\"1\":{\"516\":1}}],[\"提供了一个简单且统一的接口供客户端使用\",{\"1\":{\"515\":1}}],[\"提供了一种框架\",{\"1\":{\"839\":1}}],[\"提供了一种快速确定对象存储位置的方法\",{\"1\":{\"787\":1}}],[\"提供了一种方便的方式来管理和操作树状结构的对象\",{\"1\":{\"526\":1}}],[\"提供了一种无缝的接口转换机制\",{\"1\":{\"512\":1}}],[\"提供了一种解决接口不匹配问题的灵活方案\",{\"1\":{\"510\":1}}],[\"提供了一种创建对象的灵活方式\",{\"1\":{\"444\":1}}],[\"提供了一种灵活的方式来创建一系列相关或依赖的产品家族\",{\"1\":{\"444\":1}}],[\"提供了一种灵活的方式来创建对象\",{\"1\":{\"439\":1,\"443\":1}}],[\"提供了一种可撤销和恢复操作的机制\",{\"1\":{\"375\":1}}],[\"提供了一种机制使得万维网服务器能够\",{\"1\":{\"110\":1}}],[\"提供了灵活性和可扩展性\",{\"1\":{\"512\":1}}],[\"提供了更强大的特性\",{\"1\":{\"834\":1}}],[\"提供了更多灵活性和功能\",{\"1\":{\"831\":1}}],[\"提供了更多对象构建的可能性\",{\"1\":{\"451\":1}}],[\"提供了更高效的通信能力\",{\"1\":{\"582\":1}}],[\"提供了更好的扩展性\",{\"1\":{\"533\":1}}],[\"提供了更快的收敛时间和更强的稳定性\",{\"1\":{\"175\":1}}],[\"提供了可扩展性\",{\"1\":{\"437\":1}}],[\"提供了可撤销和恢复状态的机制\",{\"1\":{\"379\":1}}],[\"提供了对共享资源和共享状态的集中管理\",{\"1\":{\"421\":1}}],[\"提供了对唯一实例的全局访问点\",{\"1\":{\"421\":1}}],[\"提供了全局访问点来获取该实例\",{\"1\":{\"421\":1}}],[\"提供的服务类型也不同\",{\"1\":{\"124\":1}}],[\"提供与网络层的接口\",{\"1\":{\"120\":1}}],[\"提供用户名和口令\",{\"1\":{\"99\":1}}],[\"提供服务时\",{\"1\":{\"125\":2}}],[\"提供服务\",{\"1\":{\"58\":1}}],[\"提示\",{\"1\":{\"0\":2}}],[\"客户到服务器这个方向的连接就释放了\",{\"1\":{\"286\":1}}],[\"客户端怎么去校验证书的合法性\",{\"0\":{\"551\":1}}],[\"客户端设置享元对象的外部状态\",{\"1\":{\"530\":1}}],[\"客户端无需区分处理单个对象和组合对象\",{\"1\":{\"526\":1}}],[\"客户端无需关心当前处理的是文件还是文件夹\",{\"1\":{\"525\":1}}],[\"客户端无需关心当前处理的是叶子节点还是组合节点\",{\"1\":{\"524\":1}}],[\"客户端无需直接与子系统交互\",{\"1\":{\"518\":1}}],[\"客户端与门面交互\",{\"1\":{\"516\":1}}],[\"客户端与具体产品的实现解耦\",{\"1\":{\"444\":1}}],[\"客户端与具体产品类之间解耦\",{\"1\":{\"430\":1}}],[\"客户端应该只依赖于它们真正需要的接口\",{\"1\":{\"474\":1}}],[\"客户端测试\",{\"1\":{\"443\":1}}],[\"客户端不关心或不知道如何创建产品的具体实现\",{\"1\":{\"442\":1}}],[\"客户端不需要知道命令是如何被执行的\",{\"1\":{\"386\":1}}],[\"客户端只依赖于所需的接口\",{\"1\":{\"473\":1}}],[\"客户端只与抽象工厂和抽象产品进行交互\",{\"1\":{\"440\":1}}],[\"客户端只需调用门面提供的接口\",{\"1\":{\"516\":1}}],[\"客户端只需与门面对象进行通信\",{\"1\":{\"519\":1}}],[\"客户端只需与门面对象进行交互\",{\"1\":{\"516\":1}}],[\"客户端只需与抽象工厂接口\",{\"1\":{\"436\":1}}],[\"客户端只需要与门面进行交互\",{\"1\":{\"518\":1}}],[\"客户端只需要与抽象工厂接口交互\",{\"1\":{\"437\":1}}],[\"客户端只需要依赖于它们真正需要的接口\",{\"1\":{\"473\":1}}],[\"客户端只需要通过工厂类来请求所需的对象\",{\"1\":{\"452\":1}}],[\"客户端只需要提供一个参数或条件给工厂类\",{\"1\":{\"430\":1}}],[\"客户端调用解释器的解释方法\",{\"1\":{\"390\":1}}],[\"客户端构建语法树\",{\"1\":{\"390\":1}}],[\"客户端和接收者是解耦的\",{\"1\":{\"386\":1}}],[\"客户端类\",{\"1\":{\"384\":1}}],[\"客户端切换状态为状态b\",{\"1\":{\"359\":1}}],[\"客户端创建相关对象\",{\"1\":{\"400\":1}}],[\"客户端创建中介者对象\",{\"1\":{\"400\":1}}],[\"客户端创建调用者对象\",{\"1\":{\"383\":1}}],[\"客户端创建具体的命令对象\",{\"1\":{\"383\":1}}],[\"客户端创建context对象\",{\"1\":{\"359\":1}}],[\"客户端创建多个具体处理器\",{\"1\":{\"350\":1}}],[\"客户端\",{\"1\":{\"350\":3,\"359\":3,\"371\":1,\"382\":1,\"394\":1,\"472\":1}}],[\"客户端需要选择合适的策略\",{\"1\":{\"345\":1}}],[\"客户端代码中\",{\"1\":{\"518\":1,\"525\":2}}],[\"客户端代码只需要与抽象工厂进行交互\",{\"1\":{\"443\":1}}],[\"客户端代码创建了规则引擎对象\",{\"1\":{\"395\":1}}],[\"客户端代码创建规则引擎对象\",{\"1\":{\"393\":1}}],[\"客户端代码\",{\"1\":{\"344\":1,\"365\":1,\"518\":1,\"524\":1,\"525\":2}}],[\"客户端根据需求选择具体的策略\",{\"1\":{\"343\":1}}],[\"客户端根据dhcp服务器提供的租约时长来使用ip地址\",{\"1\":{\"64\":1}}],[\"客户端回送一个确认报文段\",{\"1\":{\"286\":1}}],[\"客户端为该tcp连接分配缓存和变量\",{\"1\":{\"285\":1}}],[\"客户端在发送完邮件内容后\",{\"1\":{\"94\":1}}],[\"客户端使用享元对象进行操作\",{\"1\":{\"530\":1}}],[\"客户端使用的端口号\",{\"1\":{\"279\":1}}],[\"客户端使用rcpt\",{\"1\":{\"94\":1}}],[\"客户端使用mail\",{\"1\":{\"94\":1}}],[\"客户端使用tcp连接到服务器的25端口\",{\"1\":{\"94\":1}}],[\"客户端发送请求\",{\"1\":{\"350\":1}}],[\"客户端发送连接释放报文段\",{\"1\":{\"286\":1}}],[\"客户端发送连接请求报文段\",{\"1\":{\"285\":1}}],[\"客户端发送邮件内容\",{\"1\":{\"94\":1}}],[\"客户端发送相应的ftp命令\",{\"1\":{\"86\":1}}],[\"客户端发送ftp命令\",{\"1\":{\"86\":1}}],[\"客户端可以将单个对象和组合对象一视同仁\",{\"1\":{\"523\":1}}],[\"客户端可以通过与门面对象进行交互\",{\"1\":{\"514\":1}}],[\"客户端可以继续发送ftp命令执行其他操作\",{\"1\":{\"86\":1}}],[\"客户端可以发送各种ftp命令来执行相应的操作\",{\"1\":{\"86\":1}}],[\"客户端可以随时向dhcp服务器发送释放请求\",{\"1\":{\"64\":1}}],[\"客户端进行身份验证\",{\"1\":{\"86\":1}}],[\"客户端通过享元工厂获取或创建享元对象\",{\"1\":{\"530\":1}}],[\"客户端通过与门面对象进行交互来使用子系统\",{\"1\":{\"516\":1}}],[\"客户端通过调用目标接口中的方法来使用适配器\",{\"1\":{\"509\":1}}],[\"客户端通过调用工厂方法获取所需的产品对象\",{\"1\":{\"430\":1}}],[\"客户端通过调用工厂方法并传递参数\",{\"1\":{\"427\":1}}],[\"客户端通过传递不同的参数给工厂类\",{\"1\":{\"425\":1}}],[\"客户端通过用户名和密码进行身份验证\",{\"1\":{\"86\":1}}],[\"客户端通过tcp连接\",{\"1\":{\"86\":1}}],[\"客户端通过这个\",{\"1\":{\"81\":1}}],[\"客户端连接到ftp服务器\",{\"1\":{\"86\":1}}],[\"客户端会主动连接服务器的端口\",{\"1\":{\"85\":1}}],[\"客户端会在该端口上等待服务器的连接\",{\"1\":{\"85\":1}}],[\"客户端会在随机的端口上监听\",{\"1\":{\"85\":1}}],[\"客户端会在租约到达一定时长前\",{\"1\":{\"64\":1}}],[\"客户端收到这个确认段后转为fin\",{\"1\":{\"286\":1}}],[\"客户端收到dhcp确认消息后\",{\"1\":{\"64\":1}}],[\"客户端收到多个dhcp提供消息后\",{\"1\":{\"64\":1}}],[\"客户端向服务器发送quit命令\",{\"1\":{\"94\":1}}],[\"客户端向服务器发送data命令\",{\"1\":{\"94\":1}}],[\"客户端向服务器发送helo命令\",{\"1\":{\"94\":1}}],[\"客户端向服务器请求服务或资源\",{\"1\":{\"58\":1}}],[\"客户端向选定的dhcp服务器发送dhcp请求消息\",{\"1\":{\"64\":1}}],[\"客户端广播发送一个dhcp发现消息\",{\"1\":{\"64\":1}}],[\"客户是服务请求方\",{\"1\":{\"58\":1}}],[\"客户和服务器是指通信中所涉及的两个应用进程\",{\"1\":{\"58\":1}}],[\"客户\",{\"1\":{\"58\":2}}],[\"它最终会收缩到\",{\"1\":{\"868\":1}}],[\"它帮我们管理线程\",{\"1\":{\"857\":1}}],[\"它帮助我们简化了客户端代码\",{\"1\":{\"526\":1}}],[\"它帮助我们保护现有代码\",{\"1\":{\"512\":1}}],[\"它增加信号量的值\",{\"1\":{\"853\":1}}],[\"它和countdownlatch类似\",{\"1\":{\"852\":1}}],[\"它要做的事情是\",{\"1\":{\"852\":1}}],[\"它要求软件实体\",{\"1\":{\"466\":1}}],[\"它要求应该对扩展开放\",{\"1\":{\"464\":1}}],[\"它要求一个类或模块应该只负责一个特定的功能\",{\"1\":{\"460\":1}}],[\"它利用一个整型的\",{\"1\":{\"839\":1}}],[\"它支持公平性设置\",{\"1\":{\"832\":1}}],[\"它保证在当前\",{\"1\":{\"827\":1}}],[\"它保证了线程对变量访问的可见性和排他性\",{\"1\":{\"811\":1}}],[\"它没有上下文切换的额外开销成本\",{\"1\":{\"827\":1}}],[\"它没有子组件\",{\"1\":{\"526\":1}}],[\"它没有子节点\",{\"1\":{\"524\":1}}],[\"它其实涵盖了缓存\",{\"1\":{\"824\":1}}],[\"它用的是另外一种方式\",{\"1\":{\"820\":1}}],[\"它用来加载\",{\"1\":{\"756\":1}}],[\"它这时候如果不被回收\",{\"1\":{\"818\":1}}],[\"它本质就是一个特殊的数据结构\",{\"1\":{\"816\":1}}],[\"它主要是和不同锁的状态变化相关\",{\"1\":{\"837\":1}}],[\"它主要确保多个线程在同一个时刻\",{\"1\":{\"811\":1}}],[\"它主要用于线程之间的数据传输\",{\"1\":{\"811\":1}}],[\"它主要用于实现撤销\",{\"1\":{\"386\":1}}],[\"它只是作为一个key来让线程往threadlocalmap里存取值\",{\"1\":{\"816\":1}}],[\"它只有一个\",{\"1\":{\"804\":1}}],[\"它只允许低频信号通过\",{\"1\":{\"240\":1}}],[\"它只允许特定的频率范围内的信号通过\",{\"1\":{\"240\":1}}],[\"它只允许特定的频率范围通过\",{\"1\":{\"240\":1}}],[\"它并不一定能够唯一地标识一个对象\",{\"1\":{\"787\":1}}],[\"它并非指具体的硬件设备\",{\"1\":{\"226\":1}}],[\"它代表了对象在内存中的地址或者说是对象的标识符\",{\"1\":{\"787\":1}}],[\"它随着对象的创建而存在\",{\"1\":{\"775\":1}}],[\"它存放在\",{\"1\":{\"758\":1}}],[\"它存放在收集区域\",{\"1\":{\"742\":1}}],[\"它首先不会自己去尝试加载这个类\",{\"1\":{\"758\":1}}],[\"它首先检查目标ip地址是否属于本地网络\",{\"1\":{\"597\":1}}],[\"它首先检查\",{\"1\":{\"422\":1}}],[\"它根据\",{\"1\":{\"756\":1}}],[\"它既可以是新生代\",{\"1\":{\"749\":1}}],[\"它相对传统的垃圾回收器不同\",{\"1\":{\"749\":1}}],[\"它相对于http有哪些优势\",{\"0\":{\"565\":1}}],[\"它第一次实现了让垃圾收集线程与用户线程\",{\"1\":{\"746\":1}}],[\"它又分为eden空间和两个survivor空间\",{\"1\":{\"741\":1}}],[\"它又在二叉查找树的基础上增加了一些规则\",{\"1\":{\"698\":1}}],[\"它节省了一次指针定位的时间开销\",{\"1\":{\"730\":1}}],[\"它实现线程安全的关键点在于put流程\",{\"1\":{\"711\":1}}],[\"它实现了将数字数据转换成适合在物理媒介上传输的信号\",{\"1\":{\"617\":1}}],[\"它实现了组件接口\",{\"1\":{\"526\":1}}],[\"它实现了目标接口\",{\"1\":{\"508\":1}}],[\"它实现了实现部分接口定义的功能\",{\"1\":{\"505\":1}}],[\"它实现了operation方法\",{\"1\":{\"502\":1}}],[\"它实现了抽象表达式接口\",{\"1\":{\"393\":2}}],[\"它实现了抽象表达式的解释方法\",{\"1\":{\"390\":2}}],[\"它实现了访问者接口\",{\"1\":{\"372\":1}}],[\"它实现了iterator接口\",{\"1\":{\"366\":1}}],[\"它指出在理想情况下\",{\"1\":{\"622\":1}}],[\"它展示了信号中各个频率成分的强度或能量分布\",{\"1\":{\"620\":1}}],[\"它描述了信号中各个频率成分的强度或能量分布\",{\"1\":{\"620\":1}}],[\"它对于设备来说是发送数据包到其他网络的出口\",{\"1\":{\"597\":1}}],[\"它确定了ip地址中哪些位用于网络标识\",{\"1\":{\"595\":1}}],[\"它确保了复制对象与原始对象之间的数据隔离\",{\"1\":{\"455\":1}}],[\"它确保了网络拓扑的稳定性和可靠性\",{\"1\":{\"175\":1}}],[\"它确保一个类只有一个实例\",{\"1\":{\"416\":1}}],[\"它与ip地址一起确定了地址的类别\",{\"1\":{\"595\":1}}],[\"它与ip地址结合使用\",{\"1\":{\"595\":1}}],[\"它与ip地址有何区别\",{\"0\":{\"574\":1},\"1\":{\"574\":1}}],[\"它类似于计算机的\",{\"1\":{\"594\":1}}],[\"它需要知道目标设备的mac地址才能将数据帧发送到正确的位置\",{\"1\":{\"583\":1}}],[\"它不能立即接收来自同一通信链路的响应数据\",{\"1\":{\"582\":1}}],[\"它不仅是要根据所经过的路由器多少\",{\"1\":{\"210\":1}}],[\"它采用csma\",{\"1\":{\"578\":1}}],[\"它规定了物理层的连线\",{\"1\":{\"578\":1}}],[\"它应该是透明的\",{\"1\":{\"577\":1}}],[\"它就会新增0x61c88647\",{\"1\":{\"819\":1}}],[\"它就像一个容器\",{\"1\":{\"797\":1}}],[\"它就可能会产生垃圾\",{\"1\":{\"749\":1}}],[\"它就是一个管理线程的池子\",{\"1\":{\"857\":1}}],[\"它就是仅仅把gc\",{\"1\":{\"746\":1}}],[\"它就是通过\",{\"1\":{\"274\":1}}],[\"它就要识别上层数据\",{\"1\":{\"577\":1}}],[\"它拥有子节点\",{\"1\":{\"524\":1}}],[\"它拥有一个事件总线实例\",{\"1\":{\"326\":1}}],[\"它内部持有库存管理\",{\"1\":{\"518\":1}}],[\"它隐藏了子系统的复杂性\",{\"1\":{\"515\":1}}],[\"它也是各个线程共享的内存区域\",{\"1\":{\"722\":1}}],[\"它也被称为应用程序的入口点\",{\"1\":{\"721\":1}}],[\"它也将元素放入桶位中\",{\"1\":{\"707\":1}}],[\"它也提供了更高的代码可读性和可维护性\",{\"1\":{\"506\":1}}],[\"它也接收一个component对象\",{\"1\":{\"502\":1}}],[\"它扩展了抽象部分接口\",{\"1\":{\"505\":1}}],[\"它调用父类decorator的operation方法\",{\"1\":{\"502\":1}}],[\"它同样调用父类decorator的operation方法\",{\"1\":{\"502\":1}}],[\"它同样重写了operation方法\",{\"1\":{\"502\":1}}],[\"它同时实现了\",{\"1\":{\"495\":1}}],[\"它重写了operation方法\",{\"1\":{\"502\":1}}],[\"它接收一个component对象\",{\"1\":{\"502\":1}}],[\"它还实现了operation方法\",{\"1\":{\"502\":1}}],[\"它演示了如何使用动态代理在运行时为目标对象添加额外的逻辑处理\",{\"1\":{\"497\":1}}],[\"它演示了中介者设计模式的应用\",{\"1\":{\"403\":1,\"408\":1}}],[\"它为数据包添加了源地址和目标地址信息\",{\"1\":{\"593\":1}}],[\"它为子系统提供了一个统一的接口\",{\"1\":{\"514\":1}}],[\"它为其他对象提供一个代理\",{\"1\":{\"494\":1}}],[\"它为用户提供了各种实用的网络服务\",{\"1\":{\"56\":1}}],[\"它带来的优势包括降低耦合性\",{\"1\":{\"490\":1}}],[\"它鼓励开发人员在编写代码时避免重复的逻辑\",{\"1\":{\"486\":1}}],[\"它提供一个同步点\",{\"1\":{\"854\":1}}],[\"它提供了按键排序的有序映射\",{\"1\":{\"705\":1}}],[\"它提供了连接管理功能\",{\"1\":{\"584\":1}}],[\"它提供了添加子组件和移除子组件的方法\",{\"1\":{\"524\":1}}],[\"它提供了许多优点和一些潜在的缺点\",{\"1\":{\"519\":1}}],[\"它提供了一个直观的展示方式\",{\"1\":{\"525\":1}}],[\"它提供了一个简单的接口来封装子系统的复杂性\",{\"1\":{\"516\":1}}],[\"它提供了一种有效地共享和复用对象的机制\",{\"1\":{\"533\":1}}],[\"它提供了一种简单而统一的方式来创建对象\",{\"1\":{\"430\":1}}],[\"它提供了一种简单而有效的方式来管理共享资源和共享状态\",{\"1\":{\"421\":1}}],[\"它提供了一种统一的方式来创建对象\",{\"1\":{\"424\":1}}],[\"它提供了一种顺序访问聚合对象\",{\"1\":{\"363\":1}}],[\"它提供了一种灵活\",{\"1\":{\"326\":1}}],[\"它提供了设置酱料\",{\"1\":{\"452\":1}}],[\"它提供了链式调用的方法来设置\",{\"1\":{\"450\":1}}],[\"它提高了代码的可维护性和可读性\",{\"1\":{\"486\":1}}],[\"它提倡将大型\",{\"1\":{\"474\":1}}],[\"它促进了单一职责原则的实现\",{\"1\":{\"474\":1}}],[\"它强调对象之间的松耦合和信息隐藏\",{\"1\":{\"488\":1}}],[\"它强调避免重复代码的产生\",{\"1\":{\"484\":1}}],[\"它强调避免过度复杂化\",{\"1\":{\"482\":1}}],[\"它强调保持代码简单易懂的重要性\",{\"1\":{\"480\":1}}],[\"它强调高层模块不应该依赖于低层模块的具体实现方式\",{\"1\":{\"476\":1}}],[\"它强调类的内聚性\",{\"1\":{\"474\":1}}],[\"它强调客户端不应该强迫依赖于它们不需要的接口\",{\"1\":{\"472\":1}}],[\"它强调子类对象必须能够替换其父类对象并且保持系统行为的一致性\",{\"1\":{\"470\":1}}],[\"它强调子类型必须能够替换其基类型而不影响程序的正确性\",{\"1\":{\"468\":1}}],[\"它复制对象内的所有基本数据类型和引用数据类型的地址\",{\"1\":{\"454\":1}}],[\"它具有\",{\"1\":{\"705\":1}}],[\"它具有以下作用和功能\",{\"1\":{\"584\":1}}],[\"它具有一些属性\",{\"1\":{\"448\":1}}],[\"它具体执行开启和关闭操作\",{\"1\":{\"383\":1}}],[\"它专注于逐步构建复杂对象\",{\"1\":{\"446\":1}}],[\"它属于最基本的工厂模式\",{\"1\":{\"430\":1}}],[\"它执行不同的操作来创建\",{\"1\":{\"422\":1}}],[\"它执行不同的操作来创建并返回一个\",{\"1\":{\"422\":1}}],[\"它有智能的转发能力\",{\"1\":{\"580\":1}}],[\"它有一个\",{\"1\":{\"674\":1}}],[\"它有一个方法\",{\"1\":{\"469\":1}}],[\"它有一个私有的\",{\"1\":{\"422\":1}}],[\"它有多个可选组件\",{\"1\":{\"452\":1}}],[\"它有助于减少路由表的大小\",{\"1\":{\"221\":1}}],[\"它适用于哪些场景\",{\"0\":{\"661\":1}}],[\"它适用于需要大量相似对象的情况\",{\"1\":{\"533\":1}}],[\"它适用于需要根据不同参数创建不同对象的场景\",{\"1\":{\"430\":1}}],[\"它适用于需要简化对象之间通信关系的场景\",{\"1\":{\"410\":1}}],[\"它适用于特定领域的解释执行\",{\"1\":{\"396\":1}}],[\"它将一个long值分解为多个部分\",{\"1\":{\"855\":1}}],[\"它将抽象和实现分离\",{\"1\":{\"504\":1}}],[\"它将抛出异常而不是输出\",{\"1\":{\"469\":1}}],[\"它将对象的构建过程与其表示分离\",{\"1\":{\"446\":1}}],[\"它将对象的创建与使用相分离\",{\"1\":{\"439\":1}}],[\"它将产品的创建与使用相分离\",{\"1\":{\"443\":1}}],[\"它将每个文法规则表示为一个类\",{\"1\":{\"389\":1}}],[\"它将遍历算法与聚合对象解耦\",{\"1\":{\"367\":1}}],[\"它将不会转发该帧\",{\"1\":{\"159\":1}}],[\"它封装了一个整型数组\",{\"1\":{\"366\":1}}],[\"它持有一个支付策略对象\",{\"1\":{\"344\":1}}],[\"它允许你在代码中定义类\",{\"1\":{\"797\":1}}],[\"它允许你在不改变已有对象的情况下\",{\"1\":{\"500\":1}}],[\"它允许键和值都可以为\",{\"1\":{\"704\":1}}],[\"它允许将对象组织成树形结构\",{\"1\":{\"522\":1}}],[\"它允许将一个类的接口转换成客户端所期望的另一个接口\",{\"1\":{\"508\":1}}],[\"它允许将请求或操作封装为一个对象\",{\"1\":{\"381\":1}}],[\"它允许我们通过克隆\",{\"1\":{\"453\":1}}],[\"它允许按照特定的步骤或顺序构建对象\",{\"1\":{\"452\":1}}],[\"它允许在不修改现有代码的情况下\",{\"1\":{\"496\":1}}],[\"它允许在不破坏封装性的前提下\",{\"1\":{\"375\":1}}],[\"它允许在不改变对象结构的前提下\",{\"1\":{\"369\":1}}],[\"它允许在运行时选择算法的实现方式\",{\"1\":{\"341\":1}}],[\"它允许一个对象在其内部状态发生改变时改变其行为\",{\"1\":{\"357\":1}}],[\"它允许灵活地添加\",{\"1\":{\"353\":1}}],[\"它允许用户编写自定义的插件来扩展其功能\",{\"1\":{\"352\":1}}],[\"它允许发送方连续发送多个分组\",{\"1\":{\"138\":1,\"139\":1}}],[\"它继承自基础类\",{\"1\":{\"495\":1}}],[\"它继承自\",{\"1\":{\"436\":1}}],[\"它继承自抽象类myservlet\",{\"1\":{\"338\":1}}],[\"它继承自httpservlet\",{\"1\":{\"338\":1}}],[\"它定义了数据包的结构和传输规则\",{\"1\":{\"593\":1}}],[\"它定义了数据包的格式和结构\",{\"1\":{\"593\":1}}],[\"它定义了适配器需要适配的方法\",{\"1\":{\"508\":1}}],[\"它定义了客户端代码可以使用的方法\",{\"1\":{\"508\":1}}],[\"它定义了抽象部分的接口和功能\",{\"1\":{\"505\":1}}],[\"它定义了一些基本的操作\",{\"1\":{\"495\":1}}],[\"它定义了一个方法\",{\"1\":{\"436\":1}}],[\"它定义了一个用于创建对象的接口\",{\"1\":{\"432\":1}}],[\"它定义了一个模板方法readdata\",{\"1\":{\"335\":1}}],[\"它定义了一个操作中的算法框架\",{\"1\":{\"330\":1}}],[\"它定义了生成报告的基本骨架\",{\"1\":{\"336\":1}}],[\"它定义了浏览器和web服务器之间的通信规则\",{\"1\":{\"104\":1}}],[\"它能保证所有线程对变量访问的可见性\",{\"1\":{\"811\":1}}],[\"它能够在多任务处理中提供一定程度的优化和控制\",{\"1\":{\"858\":1}}],[\"它能够增强信号质量\",{\"1\":{\"618\":1}}],[\"它能够检测并纠正可能出现的传输错误\",{\"1\":{\"577\":1}}],[\"它能够提供一种灵活且统一的方式来处理对象的层次关系\",{\"1\":{\"526\":1}}],[\"它能够将不同的操作封装在具体的访问者中\",{\"1\":{\"373\":1}}],[\"它能够实现对象之间的松耦合\",{\"1\":{\"328\":1}}],[\"它能连接多个地区\",{\"1\":{\"161\":1}}],[\"它包含一个component类型的私有成员变量component\",{\"1\":{\"502\":1}}],[\"它包含一个方法\",{\"1\":{\"495\":1}}],[\"它包含一个builder对象作为成员变量\",{\"1\":{\"448\":1}}],[\"它包含一个静态方法\",{\"1\":{\"426\":1}}],[\"它包含以下几个关键组件\",{\"1\":{\"382\":1}}],[\"它包含了多个歌曲对象\",{\"1\":{\"454\":1}}],[\"它包含了一个读锁和一个写锁\",{\"1\":{\"832\":1}}],[\"它包含了一个\",{\"1\":{\"436\":1}}],[\"它包含了旅行团成员可能会访问的不同景点的访问方法\",{\"1\":{\"372\":1}}],[\"它包含了注册订阅者\",{\"1\":{\"326\":1}}],[\"它包括以下几个方面\",{\"1\":{\"227\":1}}],[\"它建立了对象之间的一对多依赖关系\",{\"1\":{\"322\":1}}],[\"它会从队列中取下一个任务来执行\",{\"1\":{\"868\":1}}],[\"它会将任务分散到其他的计数器上\",{\"1\":{\"855\":1}}],[\"它会一直等待第二个线程也执行exchange方法\",{\"1\":{\"854\":1}}],[\"它会扫描整个老年代\",{\"1\":{\"749\":1}}],[\"它会进行整个进行物理划分\",{\"1\":{\"749\":1}}],[\"它会对键进行排序存储\",{\"1\":{\"703\":1}}],[\"它会怎么处理\",{\"0\":{\"689\":1},\"1\":{\"689\":1}}],[\"它会递归调用叶子节点的操作方法\",{\"1\":{\"524\":1}}],[\"它会遍历观察者列表\",{\"1\":{\"324\":1}}],[\"它会根据网络的拥塞程度动态变化的\",{\"1\":{\"297\":1}}],[\"它会定时重传数据\",{\"1\":{\"291\":1}}],[\"它被设计成一个无私的协议\",{\"1\":{\"296\":1}}],[\"它在高并发情况下可能导致多个线程同时竞争更新同一个变量\",{\"1\":{\"855\":1}}],[\"它在类加载到内存时被\",{\"1\":{\"722\":1}}],[\"它在大多数情况下提供了更好的性能\",{\"1\":{\"705\":1}}],[\"它在传输层中的作用是什么\",{\"0\":{\"654\":1}}],[\"它在物理层连接数字设备与模拟介质\",{\"1\":{\"618\":1}}],[\"它在网络中的作用是什么\",{\"0\":{\"598\":1}}],[\"它在工程编译时自动生成\",{\"1\":{\"539\":1}}],[\"它在许多应用场景中都有着广泛的应用\",{\"1\":{\"519\":1}}],[\"它在需要共享资源或管理共享状态的情况下非常有用\",{\"1\":{\"421\":1}}],[\"它在握手阶段不会在连接表中保存信息\",{\"1\":{\"285\":1}}],[\"它在性能和效率上做了很多改进\",{\"1\":{\"113\":1}}],[\"它使应用进程看见的就好像是在两个传输层实体之间有一条端到端的逻辑通信信道\",{\"1\":{\"273\":1}}],[\"它使用哈希表存储数据\",{\"1\":{\"706\":2}}],[\"它使用transient修饰存储元素的elementdata的数组\",{\"1\":{\"680\":1}}],[\"它使用了tcp协议来实现可靠的文件传输\",{\"1\":{\"87\":1}}],[\"它使用两个独立的连接来完成文件传输\",{\"1\":{\"85\":1}}],[\"它通常比atomiclong性能更好\",{\"1\":{\"855\":1}}],[\"它通常是本地网络中的路由器或网关设备\",{\"1\":{\"597\":1}}],[\"它通常是将数字比特序列转换为模拟信号或另一种数字信号\",{\"1\":{\"238\":1}}],[\"它通常以6个十六进制数对的形式表示\",{\"1\":{\"574\":1}}],[\"它通过协调各个线程\",{\"1\":{\"853\":1}}],[\"它通过比较当前锁的状态\",{\"1\":{\"839\":1}}],[\"它通过哈希码计算来确定元素的存储位置\",{\"1\":{\"715\":1}}],[\"它通过一个双向链表来维护键值对的插入顺序或者访问顺序\",{\"1\":{\"714\":1}}],[\"它通过键的哈希码来快速定位存储位置\",{\"1\":{\"705\":1}}],[\"它通过帧的同步字段来确保帧的边界以及数据的准确接收\",{\"1\":{\"584\":1}}],[\"它通过共享对象来有效地支持大量细粒度的对象\",{\"1\":{\"528\":1}}],[\"它通过复杂的逻辑创建一个\",{\"1\":{\"436\":1}}],[\"它通过条件语句进行判断和创建\",{\"1\":{\"422\":1}}],[\"它通过将对象的共享部分提取出来\",{\"1\":{\"529\":1}}],[\"它通过将\",{\"1\":{\"422\":1}}],[\"它通过调用私有的\",{\"1\":{\"422\":1}}],[\"它通过构造函数接收一个\",{\"1\":{\"422\":1}}],[\"它通过引入中介者来降低对象间的直接通信复杂性\",{\"1\":{\"404\":1,\"409\":1}}],[\"它通过引入中介者来降低多个对象之间的直接通信复杂性\",{\"1\":{\"398\":1}}],[\"它通过定义语言的文法表示\",{\"1\":{\"388\":1,\"395\":1}}],[\"它通过为请求创建一个接收者链\",{\"1\":{\"348\":1}}],[\"它通过在交换机上配置端口的成员关系来实现vlan的划分和隔离\",{\"1\":{\"159\":1}}],[\"它通过标签定义文本的格式\",{\"1\":{\"104\":1}}],[\"它简单直观\",{\"1\":{\"222\":1}}],[\"它可能表示所有的ip地址或所有网络\",{\"1\":{\"205\":1}}],[\"它可以用于做流量控制\",{\"1\":{\"853\":1}}],[\"它可以用于处理用户输入\",{\"1\":{\"104\":1}}],[\"它可以用来修饰方法或代码块\",{\"1\":{\"832\":1}}],[\"它可以用来检查某个元素是否存在\",{\"1\":{\"704\":1}}],[\"它可以包含子组件\",{\"1\":{\"526\":1}}],[\"它可以包含部门和员工\",{\"1\":{\"525\":1}}],[\"它可以包含文件和其他文件夹\",{\"1\":{\"525\":1}}],[\"它可以避免类爆炸问题\",{\"1\":{\"504\":1}}],[\"它可以是接口或抽象类\",{\"1\":{\"400\":1,\"526\":1}}],[\"它可以是长达几千千米的光缆线路\",{\"1\":{\"161\":1}}],[\"它可以帮助我们实现请求的封装和参数化\",{\"1\":{\"385\":1}}],[\"它可以提高代码的可读性和可维护性\",{\"1\":{\"361\":1}}],[\"它可以提供更快的加载速度和更高的性能表现\",{\"1\":{\"113\":1}}],[\"它可以消除大量的条件语句\",{\"1\":{\"361\":1}}],[\"它可以在很多场景中帮助我们实现灵活的请求处理和任务分配\",{\"1\":{\"355\":1}}],[\"它可以将算法的定义和使用分开\",{\"1\":{\"345\":1}}],[\"它可以唯一地标识一个网页\",{\"1\":{\"104\":1}}],[\"它表示匹配所有可能的ip地址\",{\"1\":{\"205\":1}}],[\"它必须知道对方的ip地址\",{\"1\":{\"196\":1}}],[\"它负责解封装数据帧\",{\"1\":{\"573\":1}}],[\"它负责指导建造过程\",{\"1\":{\"448\":1}}],[\"它负责在不同的网络之间传输数据包\",{\"1\":{\"182\":1}}],[\"它负责处理特定的应用需求\",{\"1\":{\"56\":1}}],[\"它是java并发包的根基\",{\"1\":{\"846\":1}}],[\"它是java保证线程安全的一种无同步方案\",{\"1\":{\"816\":1}}],[\"它是隐式锁\",{\"1\":{\"832\":1}}],[\"它是斐波那契数\",{\"1\":{\"819\":1}}],[\"它是为了让线程在限定的时间后去执行\",{\"1\":{\"813\":1}}],[\"它是可以在指定的时间自行返回的\",{\"1\":{\"808\":1}}],[\"它是最弱的一种引用关系\",{\"1\":{\"735\":1}}],[\"它是个动态的结构\",{\"1\":{\"729\":1}}],[\"它是方法区的一部分\",{\"1\":{\"722\":1}}],[\"它是\",{\"1\":{\"719\":1}}],[\"它是无序的\",{\"1\":{\"705\":1,\"706\":1}}],[\"它是有序的键值对集合\",{\"1\":{\"705\":1}}],[\"它是基于\",{\"1\":{\"704\":1,\"839\":1}}],[\"它是基于c\",{\"1\":{\"103\":1}}],[\"它是如何工作的\",{\"0\":{\"657\":1}}],[\"它是指定频率范围的宽度\",{\"1\":{\"620\":1}}],[\"它是由厂商预先分配给网络设备的\",{\"1\":{\"574\":1}}],[\"它是用来做什么的\",{\"0\":{\"569\":1}}],[\"它是computerbuilder接口的具体实现\",{\"1\":{\"448\":1}}],[\"它是所有输入流的抽象基类\",{\"1\":{\"335\":1}}],[\"它是一个全年代的垃圾回收器\",{\"1\":{\"749\":1}}],[\"它是一个逻辑上的实现\",{\"1\":{\"722\":1}}],[\"它是一个单独的可管理的网络单元\",{\"1\":{\"211\":1}}],[\"它是一种链路层协议\",{\"1\":{\"175\":1}}],[\"它是ipv4协议簇中的一个子协议\",{\"1\":{\"200\":1}}],[\"它是逻辑上的连接\",{\"1\":{\"184\":1}}],[\"它收到帧后\",{\"1\":{\"173\":1}}],[\"它的compareandset方法首先检查当前的对象引用值是否等于预期引用\",{\"1\":{\"845\":1}}],[\"它的key就是弱引用类型threadlocal对象\",{\"1\":{\"816\":1}}],[\"它的不同之处在于\",{\"1\":{\"807\":1}}],[\"它的触发条件包括\",{\"1\":{\"741\":1}}],[\"它的大小不受jvm控制了\",{\"1\":{\"725\":1}}],[\"它的数据结构和hashmap是一样的\",{\"1\":{\"711\":1}}],[\"它的名字叫copyonwrite\",{\"1\":{\"682\":1}}],[\"它的工作原理是什么\",{\"0\":{\"608\":1}}],[\"它的工作流程是怎么样的\",{\"0\":{\"550\":1}}],[\"它的主要作用是在局域网中根据已知的ip地址查找对应的mac地址\",{\"1\":{\"583\":1}}],[\"它的主要功能也是由它的位置衍生而来\",{\"1\":{\"573\":1}}],[\"它的主要目的是将抽象部分与实现部分分离\",{\"1\":{\"505\":1}}],[\"它的主要目的是将内部私有网络中的多个主机共享一个公共ip地址\",{\"1\":{\"223\":1}}],[\"它的特点是什么\",{\"0\":{\"554\":1}}],[\"它的核心思想是高层模块不应该依赖于低层模块\",{\"1\":{\"478\":1}}],[\"它的职责是处理订单和发送确认电子邮件\",{\"1\":{\"461\":1}}],[\"它的属性就是不可变的\",{\"1\":{\"450\":1}}],[\"它的好处也非常明显\",{\"1\":{\"327\":1}}],[\"它的作用范围是整个类\",{\"1\":{\"816\":1}}],[\"它的作用包括\",{\"1\":{\"294\":1}}],[\"它的作用是什么\",{\"0\":{\"567\":1,\"579\":1,\"583\":1,\"595\":1,\"605\":1,\"609\":1,\"610\":1,\"612\":1,\"659\":1},\"1\":{\"216\":1,\"579\":1,\"583\":1,\"595\":1}}],[\"它的每个接口仅简单地转发比特\",{\"1\":{\"170\":1}}],[\"它的出现解决了手动配置网络参数的繁琐和容易出错的问题\",{\"1\":{\"62\":1}}],[\"它们中的一个或者全部都在等待某个资源被释放\",{\"1\":{\"848\":1}}],[\"它们提供了基本类型的原子性操作\",{\"1\":{\"844\":1}}],[\"它们可以直接读写这块内存来进行通信\",{\"1\":{\"811\":1}}],[\"它们可以独立加载和管理各自的类库\",{\"1\":{\"759\":1}}],[\"它们只是存在于磁盘或内存中\",{\"1\":{\"804\":1}}],[\"它们以某种特定的编程语言编写\",{\"1\":{\"804\":1}}],[\"它们被认为相等\",{\"1\":{\"788\":1}}],[\"它们被认为不相等\",{\"1\":{\"788\":1}}],[\"它们也不一定是相等的\",{\"1\":{\"787\":1}}],[\"它们有一些区别\",{\"1\":{\"706\":1}}],[\"它们关联但表示不同的概念\",{\"1\":{\"620\":1}}],[\"它们之间是相互隔离的\",{\"1\":{\"759\":1}}],[\"它们之间有以下区别\",{\"1\":{\"705\":1}}],[\"它们之间有何区别\",{\"0\":{\"620\":1},\"1\":{\"620\":1}}],[\"它们之间有什么区别\",{\"0\":{\"606\":1}}],[\"它们之间存在明显的区别和层次\",{\"1\":{\"58\":1}}],[\"它们通过csma\",{\"1\":{\"581\":1}}],[\"它们通过网络传输协议来实现数据交换和通信\",{\"1\":{\"257\":1}}],[\"它们应该是组合结构的最小单位\",{\"1\":{\"526\":1}}],[\"它们共同为代码的可维护性\",{\"1\":{\"474\":1}}],[\"它们都共享同一份静态变量\",{\"1\":{\"776\":1}}],[\"它们都是基于哈希表的实现\",{\"1\":{\"704\":1}}],[\"它们都连接到同一个物理的网络交换机上\",{\"1\":{\"579\":2}}],[\"它们都继承自\",{\"1\":{\"469\":1}}],[\"它们都用于创建对象\",{\"1\":{\"452\":1}}],[\"它们强调了良好的设计实践和规范\",{\"1\":{\"458\":1}}],[\"它们帮助简化了建造者模式的使用\",{\"1\":{\"450\":1}}],[\"它们的原理是遍历线程池中的工作线程\",{\"1\":{\"864\":1}}],[\"它们的内容也可能是不同的\",{\"1\":{\"787\":1}}],[\"它们的方法名相同但参数列表不同\",{\"1\":{\"780\":2}}],[\"它们的区别在于设备进行通信时能否同时发送和接收数据\",{\"1\":{\"582\":1}}],[\"它们的信号会在传输介质上发生碰撞\",{\"1\":{\"581\":1}}],[\"它们的变化不会相互影响\",{\"1\":{\"505\":1}}],[\"它们的关注点和应用场景有所不同\",{\"1\":{\"411\":1}}],[\"它们的工作原理也类似\",{\"1\":{\"161\":1}}],[\"它们与备忘录设计模式有相关性\",{\"1\":{\"375\":1}}],[\"它们分别用于什么\",{\"0\":{\"568\":1}}],[\"它们分别在原始对象的行为前后添加了特定的功能\",{\"1\":{\"502\":1}}],[\"它们分别表示普通旅游者和导游\",{\"1\":{\"372\":1}}],[\"它们分别能处理不同范围的请求\",{\"1\":{\"350\":1}}],[\"它们分别处理http的get\",{\"1\":{\"338\":1}}],[\"它们继承自抽象类\",{\"1\":{\"336\":1}}],[\"它们实现了\",{\"1\":{\"326\":1}}],[\"它们承载了udp通信过程中的关键信息\",{\"1\":{\"302\":1}}],[\"它们承载了tcp通信过程中的关键信息\",{\"1\":{\"283\":1}}],[\"它们贯穿整个传输层数据传输服务的始末\",{\"1\":{\"276\":1}}],[\"它向网络层提供无确认无连接\",{\"1\":{\"158\":1}}],[\"它向上层屏蔽对物理层访问的各种差异\",{\"1\":{\"158\":1}}],[\"它决定着局域网的技术特性\",{\"1\":{\"157\":1}}],[\"它比短帧间间隔sifs要长得多\",{\"1\":{\"152\":1}}],[\"它位于物理层之上\",{\"1\":{\"117\":1,\"119\":1,\"573\":1}}],[\"它解决了smtp在传送非ascii码文本和多媒体邮件方面的局限性\",{\"1\":{\"96\":1}}],[\"这对原语包括wait\",{\"1\":{\"853\":1}}],[\"这对原语是操作系统提供的函数\",{\"1\":{\"853\":1}}],[\"这对于大型应用和需要高吞吐量的场景非常重要\",{\"1\":{\"748\":1}}],[\"这块结构会随着锁的状态变化而变化\",{\"1\":{\"837\":1}}],[\"这将会导致用户态到内核态的转化\",{\"1\":{\"831\":1}}],[\"这将导致在查找时无法正确地找到相等的对象\",{\"1\":{\"788\":2}}],[\"这不符合锁机制的意图\",{\"1\":{\"813\":1}}],[\"这不是一般用户的应用方式\",{\"1\":{\"167\":1}}],[\"这让程序变得非常灵活\",{\"1\":{\"798\":1}}],[\"这让开发人员可以更加专注于业务逻辑的实现\",{\"1\":{\"361\":1}}],[\"这句话创建了几个字符串对象\",{\"0\":{\"791\":1},\"1\":{\"791\":2}}],[\"这和双亲委派刚好相反\",{\"1\":{\"760\":1}}],[\"这可以绕过编译时的访问权限检查\",{\"1\":{\"799\":1}}],[\"这可以通过继承classloader类并重写loadclass方法来实现\",{\"1\":{\"759\":1}}],[\"这可能导致相同内容的对象具有不同的哈希码\",{\"1\":{\"788\":1}}],[\"这可能导致不必要的变更风险\",{\"1\":{\"461\":1}}],[\"这可能由以下几个原因导致\",{\"1\":{\"294\":1}}],[\"这可能会导致类库的冲突\",{\"1\":{\"759\":1}}],[\"这可能会导致主机拿到的是过时的文档\",{\"1\":{\"114\":1}}],[\"这可能会导致连接的浪费和效率低下\",{\"1\":{\"113\":1}}],[\"这包括通过new关键字创建对象\",{\"1\":{\"755\":1}}],[\"这包括将数字信号转换成适合在传输媒介上传输的模拟信号或数字信号的过程\",{\"1\":{\"227\":1}}],[\"这一切都是g1进行的自动控制的\",{\"1\":{\"749\":1}}],[\"这并不意味着它可以保证所有的复合操作都是原子性的\",{\"1\":{\"713\":1}}],[\"这并不局限于传送同一个页面上引用的对象\",{\"1\":{\"112\":1}}],[\"这主要是为了把⼆进制的各个位置都填上1\",{\"1\":{\"689\":1}}],[\"这取决于网络的规模\",{\"1\":{\"596\":1}}],[\"这栋大楼有财务部门\",{\"1\":{\"579\":1}}],[\"这本书对软件开发领域产生了深远影响\",{\"1\":{\"490\":1}}],[\"这提高了代码的灵活性\",{\"1\":{\"465\":1}}],[\"这增加了代码的可靠性\",{\"1\":{\"469\":1}}],[\"这增加了代码的灵活性和可扩展性\",{\"1\":{\"469\":1}}],[\"这增加了代码的脆弱性\",{\"1\":{\"465\":1}}],[\"这增加了开发的复杂性和风险\",{\"1\":{\"465\":1}}],[\"这使得在高并发场景下\",{\"1\":{\"855\":1}}],[\"这使得加载和存储操作看上去可能是在乱序执行\",{\"1\":{\"826\":1}}],[\"这使得代码更加健壮和可靠\",{\"1\":{\"797\":1}}],[\"这使得系统更容易理解\",{\"1\":{\"470\":1}}],[\"这使得开发者能够更加轻松地修改\",{\"1\":{\"461\":1}}],[\"这使得维护过程更加可控和安全\",{\"1\":{\"461\":1}}],[\"这使得网络能够更加灵活地处理分组传输\",{\"1\":{\"184\":1}}],[\"这使得网络管理变得更加高效\",{\"1\":{\"62\":1}}],[\"这违反了单一责任原则\",{\"1\":{\"461\":1}}],[\"这违反了开闭原则\",{\"1\":{\"421\":1,\"422\":1}}],[\"这遵循了单一责任原则\",{\"1\":{\"461\":1}}],[\"这有助于降低类之间的耦合度\",{\"1\":{\"460\":1}}],[\"这造成了代码的重复\",{\"1\":{\"422\":1}}],[\"这导致类的职责过重\",{\"1\":{\"481\":1}}],[\"这导致代码在处理\",{\"1\":{\"469\":1}}],[\"这导致了以下问题\",{\"1\":{\"422\":1}}],[\"这导致无法将单例类作为其他类的父类\",{\"1\":{\"421\":1}}],[\"这展示了访问者模式在真实业务场景中的应用\",{\"1\":{\"372\":1}}],[\"这段代码演示了如何使用建造者设计模式创建一个电脑对象\",{\"1\":{\"448\":1}}],[\"这段代码展示了一个简化的java\",{\"1\":{\"338\":1}}],[\"这段时间称为帧间间隔\",{\"1\":{\"152\":1}}],[\"这正是时间增长趋势的含义\",{\"1\":{\"316\":1}}],[\"这给预估过程带来了极大的难度\",{\"1\":{\"315\":1}}],[\"这三个报文段不再消耗网络资源而是停留在接收方的接收缓存中\",{\"1\":{\"299\":1}}],[\"这时我们必须控制只有10个线程同时获取数据库连接保存数据\",{\"1\":{\"853\":1}}],[\"这时必须进行大量标记和清除的动作\",{\"1\":{\"744\":1}}],[\"这时就需要老年代进行分配担保\",{\"1\":{\"743\":1}}],[\"这时候会交换两人的数据\",{\"1\":{\"854\":1}}],[\"这时候要结合\",{\"1\":{\"768\":1}}],[\"这时候\",{\"1\":{\"694\":1}}],[\"这时\",{\"1\":{\"296\":1,\"452\":1}}],[\"这两个线程就可以交换数据\",{\"1\":{\"854\":1}}],[\"这两个线程通过\",{\"1\":{\"854\":1}}],[\"这两个特权指令实现原子性\",{\"1\":{\"809\":1}}],[\"这两个版本中都有一个类是\",{\"1\":{\"760\":1}}],[\"这两个机制共同保证了网络通信的有效进行\",{\"1\":{\"280\":1}}],[\"这两种情况都会破坏了哈希表的正确性和性能\",{\"1\":{\"788\":1}}],[\"这两种过程都是java虚拟机\",{\"1\":{\"741\":1}}],[\"这两种理想信道在实际应用中很难实现\",{\"1\":{\"240\":1}}],[\"这实际交付的是ip数据报\",{\"1\":{\"268\":1}}],[\"这条连接保证了双方通话时所需的通信资源\",{\"1\":{\"253\":1}}],[\"这里会先去清理过期的entry\",{\"1\":{\"821\":1}}],[\"这里才真正开始执行类中定义的\",{\"1\":{\"754\":1}}],[\"这里就是我们自己的主场了\",{\"1\":{\"754\":1}}],[\"这里异常的抛出条件是检测到\",{\"1\":{\"709\":1}}],[\"这里以\",{\"1\":{\"707\":1}}],[\"这里仅是针对面向连接的传输层协议而讲的\",{\"1\":{\"275\":1}}],[\"这里的threadlocalhashcode计算有点东西\",{\"1\":{\"819\":1}}],[\"这里的网络n2假设是以太网\",{\"1\":{\"268\":1}}],[\"这里的网络n1假设是以太网\",{\"1\":{\"268\":1}}],[\"这里的\",{\"1\":{\"240\":2,\"686\":1}}],[\"这里是localhost\",{\"1\":{\"8\":1,\"34\":1}}],[\"这称为哈希冲突\",{\"1\":{\"787\":1}}],[\"这称为\",{\"1\":{\"238\":1}}],[\"这确保了每个设备都有一个唯一的ip地址\",{\"1\":{\"222\":1}}],[\"这在大多数情况下意味着将数据包发送到连接网络的设备\",{\"1\":{\"205\":1}}],[\"这在用户仅仅暂时性地占用信道的应用中是必须的\",{\"1\":{\"150\":1}}],[\"这也就是基于面向对象编程的基础\",{\"1\":{\"782\":1}}],[\"这也就是二义性的由来\",{\"1\":{\"712\":1}}],[\"这也是为什么\",{\"1\":{\"731\":1}}],[\"这也是为什么我们可以在电子邮件中收到包括图片\",{\"1\":{\"96\":1}}],[\"这也会造成内存泄漏\",{\"1\":{\"731\":1}}],[\"这也正好解释了为什么\",{\"1\":{\"694\":1}}],[\"这也解释了为什么\",{\"1\":{\"683\":1}}],[\"这也很像一级域名\",{\"1\":{\"594\":1}}],[\"这也降低了网络设备的成本\",{\"1\":{\"184\":1}}],[\"这意味着它们在哈希表中可能会被放置到相同的位置\",{\"1\":{\"787\":1}}],[\"这意味着它们可以在没有创建类的实例的情况下被访问和调用\",{\"1\":{\"776\":1}}],[\"这意味着它会将连接到该端口的所有帧都归属于同一个vlan\",{\"1\":{\"159\":1}}],[\"这意味着每个web应用程序可以独立加载和管理它所需的类库\",{\"1\":{\"759\":1}}],[\"这意味着遍历\",{\"1\":{\"715\":1}}],[\"这意味着派生类在行为上应该保持与基类的一致性\",{\"1\":{\"468\":1}}],[\"这意味着两个对象的引用类型成员变量指向相同的对象\",{\"1\":{\"454\":1}}],[\"这意味着在浅拷贝中\",{\"1\":{\"454\":1}}],[\"这意味着在面对未来的需求变化时\",{\"1\":{\"421\":1}}],[\"这意味着我们可以撤销前一步或多步操作\",{\"1\":{\"375\":1}}],[\"这意味着所有子网中可以容纳的主机数量是相同的\",{\"1\":{\"222\":1}}],[\"这意味着网络会尽最大努力确保分组在传输过程中能够正确\",{\"1\":{\"184\":1}}],[\"这意味着只有目标设备会接收到这个数据帧\",{\"1\":{\"166\":1}}],[\"这是\",{\"1\":{\"721\":1}}],[\"这是程序的实际运行阶段\",{\"1\":{\"720\":1}}],[\"这是对空间成本和时间成本平衡的考虑\",{\"1\":{\"696\":1}}],[\"这是对链路状态更新分组的确认分组\",{\"1\":{\"210\":1}}],[\"这是具体的对象\",{\"1\":{\"502\":8}}],[\"这是为了避免迭代器状态的混乱\",{\"1\":{\"367\":1}}],[\"这是因为迭代器需要知道当前指针指向的元素\",{\"1\":{\"367\":1}}],[\"这是因为可能发生以下情况\",{\"1\":{\"174\":1}}],[\"这是java\",{\"1\":{\"338\":1}}],[\"这是udp协议头部的一些重要字段\",{\"1\":{\"302\":1}}],[\"这是udp复用\",{\"1\":{\"280\":1}}],[\"这是tcp协议头部的一些重要字段\",{\"1\":{\"283\":1}}],[\"这是ip复用\",{\"1\":{\"280\":1}}],[\"这是任何数据通信的基础\",{\"1\":{\"274\":1}}],[\"这是电话系统中的解调器\",{\"1\":{\"239\":1}}],[\"这是一种接力传输方式\",{\"1\":{\"275\":1}}],[\"这是一种古老且常用的传输媒体\",{\"1\":{\"230\":1}}],[\"这是一个相对耗时的过程\",{\"1\":{\"741\":1}}],[\"这是一个接口component\",{\"1\":{\"502\":1}}],[\"这是一个基于cglib实现的动态代理示例\",{\"1\":{\"498\":1}}],[\"这是一个简单的责任链设计模式示例代码\",{\"1\":{\"353\":1}}],[\"这是一个模拟信号\",{\"1\":{\"239\":1}}],[\"这是一个非常大的数字\",{\"1\":{\"166\":1}}],[\"这是b类网络\",{\"1\":{\"218\":1}}],[\"这是距离向量算法的一个固有问题\",{\"1\":{\"209\":1}}],[\"这是到达根桥的次短路径\",{\"1\":{\"175\":1}}],[\"这是最短的帧间间隔\",{\"1\":{\"152\":1}}],[\"这是802\",{\"1\":{\"152\":1}}],[\"这类协议需要解决如何尽量避免冲突以及在发生冲突后如何尽快恢复通信\",{\"1\":{\"152\":1}}],[\"这就要求有两个cpu去分别执行两个线程\",{\"1\":{\"805\":1}}],[\"这就解决了跨代引用的问题\",{\"1\":{\"742\":1}}],[\"这就发生了抢占\",{\"1\":{\"728\":1}}],[\"这就导致线程\",{\"1\":{\"707\":1}}],[\"这就得益于hashmap的大小是2的倍数\",{\"1\":{\"688\":1}}],[\"这就和我们的接口和子类的关系\",{\"1\":{\"573\":1}}],[\"这就引发了一个共享信道争用的问题\",{\"1\":{\"144\":1}}],[\"这就是一个普通的对象\",{\"1\":{\"837\":1}}],[\"这就是一个确认过程\",{\"1\":{\"125\":1}}],[\"这就是上下文切换\",{\"1\":{\"809\":1}}],[\"这就是调制的过程\",{\"1\":{\"239\":1}}],[\"这就是我们前面所说的私网ip地址\",{\"1\":{\"217\":1}}],[\"这就是我们通常所说的mtu\",{\"1\":{\"193\":1}}],[\"这就是包的解封装过程\",{\"1\":{\"186\":1,\"591\":1}}],[\"这就是前面已经讲过的负责一个区的域名服务器\",{\"1\":{\"71\":1}}],[\"这样负载很高\",{\"1\":{\"818\":1}}],[\"这样使得程序可以在运行时动态地进行操作\",{\"1\":{\"798\":1}}],[\"这样程序就能更加灵活和安全地处理数据\",{\"1\":{\"797\":1}}],[\"这样虽然hashcode相等\",{\"1\":{\"787\":1}}],[\"这样我们就大大减少了\",{\"1\":{\"787\":1}}],[\"这样我们只需要为新的功能创建装饰器类\",{\"1\":{\"500\":1}}],[\"这样恶意类无法通过类加载器的层次结构来替代核心类\",{\"1\":{\"758\":1}}],[\"这样呢\",{\"1\":{\"749\":1}}],[\"这样在少量竞争的情况下能很大程度提升性能\",{\"1\":{\"845\":1}}],[\"这样在收集新生代的时候\",{\"1\":{\"742\":1}}],[\"这样在传输层就可以区分不同应用程序的数据流\",{\"1\":{\"280\":1}}],[\"这样高位的信息也被变相保留下来\",{\"1\":{\"694\":1}}],[\"这样是要快捷一些\",{\"1\":{\"694\":1}}],[\"这样与添加元素的hash值进行位运算时\",{\"1\":{\"688\":1}}],[\"这样做立即生效\",{\"1\":{\"864\":1}}],[\"这样做可以降低耦合性\",{\"1\":{\"490\":1}}],[\"这样做的目的是让每个web应用程序可以自己控制类的加载过程\",{\"1\":{\"759\":1}}],[\"这样做的目的是确保迭代器在遍历时\",{\"1\":{\"710\":1}}],[\"这样做的目的是为了在寻址过程中使子网掩码与对应的ipv4地址做逻辑与运算时用0遮住ipv4地址中原主机id部分\",{\"1\":{\"216\":1}}],[\"这样做的好处是\",{\"1\":{\"469\":1,\"472\":1,\"476\":1,\"480\":1,\"488\":1}}],[\"这样做的好处是在不影响聚合对象结构的情况下\",{\"1\":{\"364\":1}}],[\"这样设计的好处是\",{\"1\":{\"461\":1}}],[\"这样的原子性操作\",{\"1\":{\"829\":1}}],[\"这样的大对象一般是一些数组\",{\"1\":{\"740\":1}}],[\"这样的处理确保了数据的可靠传输\",{\"1\":{\"617\":1}}],[\"这样的设计使得我们可以在不修改原有接口和实现类的情况下\",{\"1\":{\"497\":1}}],[\"这样的设计使得代码更加灵活\",{\"1\":{\"343\":1,\"344\":1}}],[\"这样的设计遵循了开闭原则\",{\"1\":{\"465\":1}}],[\"这样的测试可分离性使得测试更加可靠和可维护\",{\"1\":{\"461\":1}}],[\"这样的职责分离使得替换邮件发送方式变得更加容易和安全\",{\"1\":{\"461\":1}}],[\"这样的职责分离使得修改订单处理逻辑变得更加简单和直观\",{\"1\":{\"461\":1}}],[\"这样的对象可以提供更好的线程安全性和代码健壮性\",{\"1\":{\"449\":1}}],[\"这样的列表帮助团队成员了解尚未完成的工作\",{\"1\":{\"375\":1}}],[\"这样的一个接一个的请求报文到达服务器后\",{\"1\":{\"112\":1}}],[\"这样一来估算难度就大大降低了\",{\"1\":{\"316\":1}}],[\"这样可以防止当前\",{\"1\":{\"827\":3}}],[\"这样可以简化代码\",{\"1\":{\"816\":1}}],[\"这样可以方便地实现数据在多个对象实例\",{\"1\":{\"816\":1}}],[\"这样可以在编译时期提供更强的类型检查\",{\"1\":{\"797\":1}}],[\"这样可以在不修改客户端代码的情况下\",{\"1\":{\"433\":1}}],[\"这样可以节省内存\",{\"1\":{\"776\":1}}],[\"这样可以提高序列化和反序列化的效率\",{\"1\":{\"680\":1}}],[\"这样可以提高通信效率\",{\"1\":{\"583\":1}}],[\"这样可以提高代码的可维护性和可扩展性\",{\"1\":{\"518\":1}}],[\"这样可以提高代码的可读性和可理解性\",{\"1\":{\"490\":1}}],[\"这样可以提高代码的可测试性\",{\"1\":{\"486\":1}}],[\"这样可以减少线程创建和销毁的开销\",{\"1\":{\"858\":1}}],[\"这样可以减少重复加载\",{\"1\":{\"759\":1}}],[\"这样可以减少对象的创建和内存占用\",{\"1\":{\"529\":1}}],[\"这样可以减少代码量\",{\"1\":{\"486\":1}}],[\"这样可以使系统更加灵活\",{\"1\":{\"505\":1}}],[\"这样可以降低模块之间的耦合性\",{\"1\":{\"478\":1}}],[\"这样可以增加代码的可靠性和稳定性\",{\"1\":{\"470\":1}}],[\"这样可以实现客户端与具体产品类的解耦\",{\"1\":{\"436\":1}}],[\"这样可以将对象的创建和使用分离\",{\"1\":{\"425\":1}}],[\"这样可以让客户端在运行时动态选择算法\",{\"1\":{\"386\":1}}],[\"这样可以避免在对象中使用大量的条件语句来判断状态\",{\"1\":{\"357\":1}}],[\"这样可以避免在握手阶段占用过多的资源\",{\"1\":{\"285\":1}}],[\"这样可以确保这些属性在对象创建后不可变\",{\"1\":{\"450\":1}}],[\"这样可以确保系统的可扩展性和灵活性\",{\"1\":{\"355\":1}}],[\"这样可以确保性能敏感的场景不会因为观察者的通知而阻塞\",{\"1\":{\"327\":1}}],[\"这样可以根据各个子网的实际需求\",{\"1\":{\"222\":1}}],[\"这样前一个交换机的转发操作与后一个交换机的存储操作可同时进行\",{\"1\":{\"254\":1}}],[\"这样\",{\"1\":{\"223\":1,\"239\":1,\"335\":1,\"338\":1,\"342\":1,\"346\":1,\"349\":1,\"350\":1,\"355\":1,\"372\":2,\"375\":1,\"383\":1,\"430\":1,\"443\":1,\"450\":2,\"455\":1,\"470\":1,\"473\":1,\"476\":1,\"494\":1,\"495\":6,\"497\":1,\"506\":2,\"579\":1,\"816\":1,\"845\":1,\"855\":1}}],[\"这样以此类推\",{\"1\":{\"208\":1}}],[\"这样网络可以根据这个地址来确定分组的传输路径\",{\"1\":{\"184\":1}}],[\"这样传输层就可以在不同网络间进行透明\",{\"1\":{\"184\":1,\"589\":1}}],[\"这样就无需同步\",{\"1\":{\"831\":1}}],[\"这样就threadlocalmap释放了空间\",{\"1\":{\"818\":1}}],[\"这样就不会出现类型混乱的问题\",{\"1\":{\"797\":1}}],[\"这样就可以使用threadlocal保存参数\",{\"1\":{\"817\":1}}],[\"这样就可以尽可能的把垃圾回收造成影响控制在一个可控范围内\",{\"1\":{\"749\":1}}],[\"这样就可以确保在邮件中正确地传输和显示这些字符\",{\"1\":{\"96\":1}}],[\"这样就构成了一个双向链表的结构\",{\"1\":{\"714\":1}}],[\"这样就构成了一个覆盖范围更大的网络\",{\"1\":{\"247\":1}}],[\"这样就实现了旧接口和新接口的兼容性和平滑过渡\",{\"1\":{\"510\":1}}],[\"这样就一来就得到了目的ipv4地址的网络id\",{\"1\":{\"216\":1}}],[\"这样就节省了很多往返时间\",{\"1\":{\"112\":1}}],[\"这会增加线程之间的竞争和cas操作的失败重试次数\",{\"1\":{\"855\":1}}],[\"这会导致thread类和其他类没有相关性\",{\"1\":{\"813\":1}}],[\"这会导致两个对象在哈希表中被放置到不同的位置\",{\"1\":{\"788\":1}}],[\"这会导致两个对象在哈希表中被放置到相同的位置\",{\"1\":{\"788\":1}}],[\"这会影响到对象在哈希表中的存储位置\",{\"1\":{\"788\":1}}],[\"这会触发类的加载\",{\"1\":{\"755\":1}}],[\"这会再次调用原始对象的operation方法\",{\"1\":{\"502\":2}}],[\"这会使其负担很重\",{\"1\":{\"111\":1}}],[\"这会大量占用万维网服务器的资源\",{\"1\":{\"111\":1}}],[\"这种机制使得进程可以通过对信号量的操作来实现对共享资源的控制和同步\",{\"1\":{\"853\":1}}],[\"这种做法可以给数据带上了一种实效性的检验\",{\"1\":{\"845\":1}}],[\"这种锁被称之为重量级锁\",{\"1\":{\"837\":1}}],[\"这种措施的代码也常常被称之为\",{\"1\":{\"831\":1}}],[\"这种乐观并发策略的实现\",{\"1\":{\"831\":1}}],[\"这种的话\",{\"1\":{\"817\":1}}],[\"这种共享使得线程之间的通信更加直接和高效\",{\"1\":{\"804\":1}}],[\"这种隔离性是非常重要的\",{\"1\":{\"759\":1}}],[\"这种分配方式称为\",{\"1\":{\"727\":2}}],[\"这种操作在执行过程中可能会被其他线程打断\",{\"1\":{\"713\":1}}],[\"这种快速失败机制提供了一种机制来尽早检测并发修改\",{\"1\":{\"710\":1}}],[\"这种划分提高了网络的安全性和管理性\",{\"1\":{\"595\":1}}],[\"这种情况称为可重入锁\",{\"1\":{\"836\":1}}],[\"这种情况称为哈希码冲突\",{\"1\":{\"787\":1}}],[\"这种情况通常发生在运行时大量动态生成字符串常量或者类加载器大量加载类的场景\",{\"1\":{\"731\":1}}],[\"这种情况通常出现在共享服务器或负载均衡的情形下\",{\"1\":{\"594\":1}}],[\"这种情况下\",{\"1\":{\"452\":1,\"710\":1}}],[\"这种通信方式就像是双向的双车道\",{\"1\":{\"582\":1}}],[\"这种通信方式就像单行道交通\",{\"1\":{\"582\":1}}],[\"这种通信方式不需要在网络层建立连接\",{\"1\":{\"184\":1}}],[\"这种透明性确保了在传输过程中不会损坏或改变数据的含义\",{\"1\":{\"577\":1}}],[\"这种间接的依赖关系降低了耦合性\",{\"1\":{\"489\":1}}],[\"这种直接依赖关系导致了较高的耦合性\",{\"1\":{\"489\":1}}],[\"这种设计模式简化了代码\",{\"1\":{\"525\":1}}],[\"这种设计方式具有以下优势\",{\"1\":{\"470\":1}}],[\"这种设计违反了开闭原则\",{\"1\":{\"465\":1}}],[\"这种设计的问题在于\",{\"1\":{\"461\":1}}],[\"这种序列化的方式有很多\",{\"1\":{\"455\":1}}],[\"这种方法就是所谓的\",{\"1\":{\"692\":1}}],[\"这种方法可以让同一\",{\"1\":{\"579\":1}}],[\"这种方法可以避免冲突\",{\"1\":{\"153\":1}}],[\"这种方式一般和futuretask搭配使用用于获取任务执行的返回值\",{\"1\":{\"806\":1}}],[\"这种方式与\",{\"1\":{\"725\":1}}],[\"这种方式需要确保对象及其所有子对象都实现了\",{\"1\":{\"455\":1}}],[\"这种方式提供了不可变对象的安全性和线程安全性\",{\"1\":{\"450\":1}}],[\"这种实现方式存在代码冗余和可扩展性差的问题\",{\"1\":{\"422\":1}}],[\"这种实现方式也有弊端\",{\"1\":{\"327\":1}}],[\"这种场景下\",{\"1\":{\"355\":1}}],[\"这种结构允许我们在一个抽象的框架中定义通用的请求处理流程\",{\"1\":{\"338\":1}}],[\"这种模式的优势就会凸显出来\",{\"1\":{\"360\":1}}],[\"这种模式通过将不同的算法封装成独立的策略类\",{\"1\":{\"341\":1}}],[\"这种模式被广泛应用于事件驱动系统和发布\",{\"1\":{\"322\":1}}],[\"这种模型适用于需要大量资源共享和分布式处理的场景\",{\"1\":{\"59\":1}}],[\"这种连接导向的方式允许在数据传输前后进行数据完整性检查和确认\",{\"1\":{\"282\":1}}],[\"这种信道在频域上可以看作一个频率响应在一定范围内是非零的理想信道\",{\"1\":{\"240\":1}}],[\"这种编码方式如何区分连续几个相同电平呢\",{\"1\":{\"238\":1}}],[\"这种将端口号和ip地址一起进行转换的技术叫作网络地址与端口号转换napt\",{\"1\":{\"223\":1}}],[\"这种配置在需要直接连接到特定主机的情况下非常有用\",{\"1\":{\"205\":1}}],[\"这种询问报文用来进行时钟同步和测量时间\",{\"1\":{\"201\":1}}],[\"这种询问报文用来测试目的站是否可达及了解其有关状态\",{\"1\":{\"201\":1}}],[\"这种服务类型看似不可靠\",{\"1\":{\"127\":1}}],[\"这种服务类型存在三个阶段\",{\"1\":{\"125\":1}}],[\"这种层级结构使得数据链路层能够适应不同类型的物理介质和网络拓扑\",{\"1\":{\"120\":1}}],[\"这种工作模式与imap很类似\",{\"1\":{\"99\":1}}],[\"这保证了邮件内容的完整性\",{\"1\":{\"96\":1}}],[\"这个时候\",{\"1\":{\"853\":1}}],[\"这个机制\",{\"1\":{\"846\":1}}],[\"这个机制是实现并发操作的重要手段之一\",{\"1\":{\"809\":1}}],[\"这个方向基本上是不可逆的\",{\"1\":{\"837\":1}}],[\"这个方法相比\",{\"1\":{\"807\":1}}],[\"这个标识指明了该方法是一个同步方法\",{\"1\":{\"835\":1}}],[\"这个信号会打断当前正在执行的程序\",{\"1\":{\"809\":1}}],[\"这个class对象包含了该类的所有信息\",{\"1\":{\"799\":1}}],[\"这个对象包含了类的所有信息\",{\"1\":{\"799\":1}}],[\"这个对象将会被移入老年代\",{\"1\":{\"740\":1}}],[\"这个得益于编译器的优化\",{\"1\":{\"792\":1}}],[\"这个参数表示额外时间\",{\"1\":{\"785\":1}}],[\"这个吃饭的过程\",{\"1\":{\"781\":2}}],[\"这个需要结合\",{\"1\":{\"778\":1}}],[\"这个成员变量是属于实例的\",{\"1\":{\"775\":1}}],[\"这个动作在后面的解析过程中发生\",{\"1\":{\"754\":1}}],[\"这个动作的\",{\"1\":{\"742\":1}}],[\"这个阶段的停顿时间一般会比初始标记阶段的时间稍长\",{\"1\":{\"746\":1,\"750\":1}}],[\"这个阶段是类加载过程的最后一步\",{\"1\":{\"720\":1}}],[\"这个闭包结构并不能保证包含当前所有的可达对象\",{\"1\":{\"746\":1,\"750\":1}}],[\"这个结构被附带在线程上\",{\"1\":{\"811\":1}}],[\"这个结构把老年代划分成若干小块\",{\"1\":{\"742\":1}}],[\"这个结构功能不够强大\",{\"1\":{\"500\":1}}],[\"这个内存区域的唯一目的就是存放对象实例\",{\"1\":{\"722\":1}}],[\"这个线程用于执行在\",{\"1\":{\"721\":1}}],[\"这个线程负责执行对象的\",{\"1\":{\"721\":1}}],[\"这个线程负责接收操作系统发送的信号\",{\"1\":{\"721\":1}}],[\"这个链表使得\",{\"1\":{\"714\":1,\"715\":1}}],[\"这个计数器实际上是在\",{\"1\":{\"710\":1}}],[\"这个异常只建议用于检测并发修改的bug\",{\"1\":{\"709\":1}}],[\"这个条件\",{\"1\":{\"709\":1}}],[\"这个值很特殊\",{\"1\":{\"819\":1}}],[\"这个值可能会因不同的情况和需求而有所调整\",{\"1\":{\"696\":1}}],[\"这个值的选择是为了在空间利用和哈希表性能之间取得一个较好的平衡\",{\"1\":{\"696\":1}}],[\"这个值的选择考虑了几个方面\",{\"1\":{\"696\":1}}],[\"这个值选择可能考虑到了键的插入和查询操作符合泊松分布的假设\",{\"1\":{\"696\":1}}],[\"这个是临界范围\",{\"1\":{\"689\":1}}],[\"这个⽅法也要要寻找⽐初始值⼤的\",{\"1\":{\"689\":1}}],[\"这个极限被称为香农容量\",{\"1\":{\"622\":1}}],[\"这个我不清楚\",{\"1\":{\"596\":1}}],[\"这个vlan只允许财务部门内部的设备相互通信\",{\"1\":{\"579\":1}}],[\"这个树形结构表示了根文件夹\",{\"1\":{\"525\":1}}],[\"这个接口会导致不必要的依赖\",{\"1\":{\"473\":1}}],[\"这个接口并不符合接口隔离原则\",{\"1\":{\"473\":1}}],[\"这个问题的根本原因是\",{\"1\":{\"469\":1}}],[\"这个派生类应该能够无缝替换其基类\",{\"1\":{\"468\":1}}],[\"这个代码块完整地展示了如何使用命令设计模式来实现购物车系统的功能\",{\"1\":{\"384\":1}}],[\"这个城市里有很多不同的景点\",{\"1\":{\"372\":1}}],[\"这个示例非常清晰地展示了策略设计模式的优势\",{\"1\":{\"343\":1}}],[\"这个示例中的myservlet抽象类可以作为一个基类\",{\"1\":{\"338\":1}}],[\"这个类定义了一个模板方法read\",{\"1\":{\"335\":1}}],[\"这个例子是基于\",{\"1\":{\"497\":1}}],[\"这个例子是一个简单的模拟\",{\"1\":{\"403\":1,\"408\":1}}],[\"这个例子主要用于说明中介者设计模式的结构和实现\",{\"1\":{\"408\":1}}],[\"这个例子中\",{\"1\":{\"372\":1}}],[\"这个例子展示了状态模式的基本结构和用法\",{\"1\":{\"360\":1}}],[\"这个例子展示了模板方法设计模式在处理不同类型的http请求时的应用\",{\"1\":{\"338\":1}}],[\"这个例子模拟了一个音乐演唱会的情景\",{\"1\":{\"326\":1}}],[\"这个例子演示了观察者设计模式在网络聊天室中的应用\",{\"1\":{\"325\":1}}],[\"这个概念了\",{\"1\":{\"749\":1}}],[\"这个概念与时间复杂度非常类似\",{\"1\":{\"317\":1}}],[\"这个概念比较抽象\",{\"1\":{\"316\":1}}],[\"这个数字\",{\"1\":{\"819\":1}}],[\"这个数学符号称为\",{\"1\":{\"316\":1}}],[\"这个数值也是该以太网的吞吐量的绝对上限值\",{\"1\":{\"262\":1}}],[\"这个情况就会进入恶性循环被不断地放大\",{\"1\":{\"296\":1}}],[\"这个端口号可供其他客户进程以后使用\",{\"1\":{\"279\":1}}],[\"这个名称显然太容易混淆\",{\"1\":{\"273\":1}}],[\"这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体\",{\"1\":{\"211\":1}}],[\"这个连接是虚拟的\",{\"1\":{\"184\":1}}],[\"这个过程我们也称之为标记\",{\"1\":{\"733\":1}}],[\"这个过程大概如下\",{\"1\":{\"726\":1}}],[\"这个过程可能会比较耗时\",{\"1\":{\"685\":1}}],[\"这个过程包括了一些步骤\",{\"1\":{\"305\":1}}],[\"这个过程中\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"这个过程使得以太网交换机能够动态地学习网络中各设备的mac地址\",{\"1\":{\"174\":1}}],[\"这个广播帧会被该广播域的所有主机收到\",{\"1\":{\"168\":1,\"583\":1}}],[\"这个查询请求报文就发送给本地域名服务器\",{\"1\":{\"71\":1}}],[\"这个流程描述了dhcp客户端和服务器之间交互的整个过程\",{\"1\":{\"64\":1}}],[\"这些锁机制都提供了线程同步和控制并发访问的手段\",{\"1\":{\"832\":1}}],[\"这些变量不同之处在于每一个线程读取的变量是对应的互相独立的\",{\"1\":{\"831\":1}}],[\"这些原语是不可中断的\",{\"1\":{\"853\":1}}],[\"这些原子类内部使用了底层的\",{\"1\":{\"829\":1}}],[\"这些原则和准则的目标是提高软件系统的质量\",{\"1\":{\"458\":1}}],[\"这些操作之间可能会被其他线程打断\",{\"1\":{\"829\":1}}],[\"这些程序在宏观上是同时发生的\",{\"1\":{\"805\":1}}],[\"这些异常发生时\",{\"1\":{\"793\":1}}],[\"这些数据结构在查找\",{\"1\":{\"787\":1}}],[\"这些\",{\"1\":{\"754\":1}}],[\"这些位置就叫作安全点\",{\"1\":{\"747\":1}}],[\"这些特定的位置主要在\",{\"1\":{\"747\":1}}],[\"这些信息包括类\",{\"1\":{\"722\":1}}],[\"这些线程负责将热点代码编译成高效的本地代码\",{\"1\":{\"721\":1}}],[\"这些调制技术都有各自的优势和应用场景\",{\"1\":{\"619\":1}}],[\"这些介质负责承载数据传输的物理信号\",{\"1\":{\"618\":1}}],[\"这些介质是用来传输信号的通道\",{\"1\":{\"240\":1}}],[\"这些分组可以通过不同的路径传输\",{\"1\":{\"593\":1}}],[\"这些具体销售渠道类都继承自\",{\"1\":{\"506\":1}}],[\"这些具体商品类都实现了\",{\"1\":{\"506\":1}}],[\"这些具体案例展示了责任链设计模式在实际项目中的灵活应用\",{\"1\":{\"352\":1}}],[\"这些类使用了\",{\"1\":{\"831\":1}}],[\"这些类库只对该应用程序可见\",{\"1\":{\"760\":1}}],[\"这些类库是所有web应用程序共享的\",{\"1\":{\"759\":1}}],[\"这些类和接口通过组合关系\",{\"1\":{\"500\":1}}],[\"这些类实现元素接口\",{\"1\":{\"372\":1}}],[\"这些设计模式提供了在软件开发中常见问题的解决方案\",{\"1\":{\"490\":1}}],[\"这些额外的代码是lombok库根据注解自动生成的\",{\"1\":{\"450\":1}}],[\"这些术语与备忘录设计模式的关系在于\",{\"1\":{\"375\":1}}],[\"这些步骤可以看作是一个责任链\",{\"1\":{\"355\":1}}],[\"这些处理器按照添加的顺序依次处理请求\",{\"1\":{\"353\":1}}],[\"这些方法都可以接受一个函数作为参数\",{\"1\":{\"713\":1}}],[\"这些方法是由子类来实现的\",{\"1\":{\"338\":1}}],[\"这些方法由子类负责实现\",{\"1\":{\"331\":1}}],[\"这些报告的生成过程有一定的共性\",{\"1\":{\"336\":1}}],[\"这些场景中\",{\"1\":{\"333\":1}}],[\"这些抽象方法由子类负责实现\",{\"1\":{\"332\":1}}],[\"这些模式涉及到对象之间的算法\",{\"1\":{\"320\":2}}],[\"这些因素都会影响代码的运行效率\",{\"1\":{\"315\":1}}],[\"这些机制一起工作\",{\"1\":{\"287\":1}}],[\"这些可编程的硬件能够用来传送多种不同类型的数据\",{\"1\":{\"257\":1}}],[\"这些命令称为服务原语\",{\"1\":{\"251\":1}}],[\"这些站点的发送都会失败\",{\"1\":{\"152\":1}}],[\"这些子信道之间相互独立\",{\"1\":{\"150\":1}}],[\"这些优化措施使得http\",{\"1\":{\"113\":1}}],[\"这些端口号是dhcp协议规定的默认端口号\",{\"1\":{\"63\":1}}],[\"这些协议包括http\",{\"1\":{\"56\":1}}],[\"是无效的\",{\"1\":{\"864\":1}}],[\"是无序的\",{\"1\":{\"671\":2}}],[\"是具有优先级的无界阻塞队列\",{\"1\":{\"862\":1}}],[\"是具体工厂类\",{\"1\":{\"436\":1}}],[\"是具体产品类\",{\"1\":{\"436\":1}}],[\"是具体的元素\",{\"1\":{\"372\":1}}],[\"是具体的访问者\",{\"1\":{\"372\":1}}],[\"是具体的订阅者实现类\",{\"1\":{\"326\":1}}],[\"是具体处理器类\",{\"1\":{\"353\":2}}],[\"是用来控制同时访问特定资源的线程数量\",{\"1\":{\"853\":1}}],[\"是用\",{\"1\":{\"846\":1}}],[\"是用于解析ip地址与mac地址之间对应关系的协议\",{\"1\":{\"583\":1}}],[\"是用于在以太网交换网络中防止环路的协议\",{\"1\":{\"175\":1}}],[\"是隐式加锁的\",{\"1\":{\"843\":1}}],[\"是显式的\",{\"1\":{\"843\":1}}],[\"是允许的\",{\"1\":{\"833\":1}}],[\"是类成员\",{\"1\":{\"833\":1}}],[\"是juc包下面的\",{\"1\":{\"838\":1}}],[\"是juc\",{\"1\":{\"832\":1}}],[\"是java定义的出来的用来屏蔽各种硬件和操作系统的内存访问差异\",{\"1\":{\"824\":1}}],[\"是java对hash表的一种实现\",{\"1\":{\"685\":1}}],[\"是强引用回收不掉\",{\"1\":{\"818\":1}}],[\"是我们java实现线程安全的一种无同步方案\",{\"1\":{\"817\":1}}],[\"是让当前线程暂停执行\",{\"1\":{\"813\":1}}],[\"是静态的文件\",{\"1\":{\"804\":1}}],[\"是进程内的一个独立执行单元\",{\"1\":{\"804\":1}}],[\"是所有错误的父类\",{\"1\":{\"793\":1}}],[\"是可重入的\",{\"1\":{\"836\":1}}],[\"是可重入锁\",{\"1\":{\"836\":1}}],[\"是可变的\",{\"1\":{\"789\":1}}],[\"是可以回收的\",{\"1\":{\"733\":1}}],[\"是不可变的\",{\"1\":{\"789\":1}}],[\"是不能通过mac地址的\",{\"1\":{\"191\":1}}],[\"是在计算机中执行时的实例\",{\"1\":{\"804\":1}}],[\"是在哈希表等数据结构中配套使用的\",{\"1\":{\"788\":1}}],[\"是在软件开发中常见的术语\",{\"1\":{\"375\":1}}],[\"是等待时间\",{\"1\":{\"785\":1}}],[\"是属于类的\",{\"1\":{\"779\":1}}],[\"是整个验证过程中最复杂的一个阶段\",{\"1\":{\"754\":1}}],[\"是针对整个对空间\",{\"1\":{\"751\":1}}],[\"是空白的\",{\"1\":{\"749\":1}}],[\"是直接将整个堆空间切成一个一个的小内存\",{\"1\":{\"749\":1}}],[\"是直接在操作方法上加\",{\"1\":{\"708\":1}}],[\"是以卡精度的方式实现的记忆集\",{\"1\":{\"742\":1}}],[\"是程序无法处理的\",{\"1\":{\"731\":1}}],[\"是怎么设计来保证线程安全的\",{\"0\":{\"728\":1},\"1\":{\"728\":1}}],[\"是被所有线程共享的一块内存区域\",{\"1\":{\"722\":1}}],[\"是线程执行\",{\"1\":{\"722\":1}}],[\"是线程安全的\",{\"1\":{\"713\":1,\"789\":2}}],[\"是线程安全的类\",{\"1\":{\"706\":1}}],[\"是当前线程所执行的字节码的行号指示器\",{\"1\":{\"722\":1}}],[\"是继承自\",{\"1\":{\"711\":1,\"714\":1}}],[\"是使用\",{\"1\":{\"708\":1}}],[\"是使用示例\",{\"1\":{\"510\":1}}],[\"是非线程安全的类\",{\"1\":{\"706\":1}}],[\"是非常重要的\",{\"1\":{\"144\":1}}],[\"是基于链表结构的阻塞队列\",{\"1\":{\"862\":1}}],[\"是基于jdk的api层面实现的\",{\"1\":{\"843\":1}}],[\"是基于红黑树的实现\",{\"1\":{\"705\":1}}],[\"是基于红黑树实现的\",{\"1\":{\"703\":1}}],[\"是基于哈希表的实现\",{\"1\":{\"705\":1}}],[\"是基于哈希表的存储结构\",{\"1\":{\"704\":1}}],[\"是基于键值对的存储结构\",{\"1\":{\"704\":1}}],[\"是基于tcp\",{\"1\":{\"87\":1}}],[\"是因为\",{\"1\":{\"836\":1}}],[\"是因为jvm的两个字节码指令帮我们把这个事情做了\",{\"1\":{\"835\":1}}],[\"是因为新生代采用复制收集算法\",{\"1\":{\"743\":1}}],[\"是因为如果这个阈值也设置成8\",{\"1\":{\"697\":1}}],[\"是因特网的核心部分\",{\"1\":{\"161\":1}}],[\"是则向树中插入节点\",{\"1\":{\"695\":1}}],[\"是根据初始化传的参数来计算的\",{\"1\":{\"689\":1}}],[\"是同一个元素\",{\"1\":{\"686\":1}}],[\"是唯一的\",{\"1\":{\"683\":1}}],[\"是如何保证可靠性的\",{\"0\":{\"651\":1}}],[\"是通信和信号处理中常用的两个概念\",{\"1\":{\"620\":1}}],[\"是安装在计算机或设备上的硬件\",{\"1\":{\"618\":1}}],[\"是的话就返回遍历\",{\"1\":{\"709\":1}}],[\"是的\",{\"1\":{\"594\":1,\"687\":1}}],[\"是互联网中最基本的协议之一\",{\"1\":{\"593\":1}}],[\"是网络层\",{\"1\":{\"574\":1}}],[\"是网络设计中的一个重要概念\",{\"1\":{\"221\":1}}],[\"是数据链路层\",{\"1\":{\"574\":1}}],[\"是数据的电磁表现\",{\"1\":{\"238\":1}}],[\"是多态的体现\",{\"1\":{\"573\":1}}],[\"是个瞎子\",{\"1\":{\"573\":1}}],[\"是app的运行配置文件\",{\"1\":{\"539\":1}}],[\"是电商平台的订单类\",{\"1\":{\"510\":1}}],[\"是适配器类\",{\"1\":{\"510\":1}}],[\"是新的支付接口的实现类\",{\"1\":{\"510\":1}}],[\"是新的支付接口\",{\"1\":{\"510\":1}}],[\"是旧的支付接口的实现类\",{\"1\":{\"510\":1}}],[\"是旧的支付接口\",{\"1\":{\"510\":1}}],[\"是删除操作才做增强\",{\"1\":{\"497\":1,\"498\":1}}],[\"是面向对象设计中的一条重要原则\",{\"1\":{\"478\":1}}],[\"是抽象工厂接口\",{\"1\":{\"436\":1}}],[\"是抽象产品类\",{\"1\":{\"436\":1}}],[\"是抽象处理器类\",{\"1\":{\"353\":1}}],[\"是否偏向锁是1\",{\"1\":{\"837\":1}}],[\"是否偏向锁那一位是0\",{\"1\":{\"837\":1}}],[\"是否集成了不被继承的类等\",{\"1\":{\"754\":1}}],[\"是否为daemon线程等等\",{\"1\":{\"860\":1}}],[\"是否为树节点\",{\"1\":{\"695\":1}}],[\"是否为空\",{\"1\":{\"422\":1}}],[\"是否相同\",{\"1\":{\"686\":1}}],[\"是否允许其他应用启动该活动\",{\"1\":{\"539\":1}}],[\"是否启用代码缩小\",{\"1\":{\"539\":1}}],[\"是否使用可靠传输取决于应用需求\",{\"1\":{\"136\":1}}],[\"是备忘录设计模式的实际应用场景\",{\"1\":{\"375\":1}}],[\"是处理器链类\",{\"1\":{\"353\":1}}],[\"是责任链的末端\",{\"1\":{\"350\":2}}],[\"是发布者类\",{\"1\":{\"326\":1}}],[\"是事件总线类\",{\"1\":{\"326\":1}}],[\"是算法运行时间随着数据量变大时的增长趋势\",{\"1\":{\"316\":1}}],[\"是对象级别的\",{\"1\":{\"816\":1}}],[\"是对象最初分配的区域\",{\"1\":{\"737\":1}}],[\"是对象固有的排序方法\",{\"1\":{\"674\":1}}],[\"是对udp数据报在发送和接收过程中进行完整性检查的方法\",{\"1\":{\"305\":1}}],[\"是对smtp协议的一个重要扩展\",{\"1\":{\"96\":1}}],[\"是约等于的关系\",{\"1\":{\"297\":1}}],[\"是传输层的sap\",{\"1\":{\"279\":1}}],[\"是世界上最大的互连网络\",{\"1\":{\"248\":1}}],[\"是关于信号频谱特性的描述\",{\"1\":{\"240\":1}}],[\"是运送消息的实体\",{\"1\":{\"238\":1}}],[\"是运行在因特网上的一个分布式应用\",{\"1\":{\"103\":1}}],[\"是由实物所承载的\",{\"1\":{\"226\":1,\"227\":1}}],[\"是stp的改进版本\",{\"1\":{\"175\":1}}],[\"是手工设置的条目\",{\"1\":{\"168\":1,\"583\":1}}],[\"是连接不同地区局域网或城域网计算机通信的远程网\",{\"1\":{\"161\":1}}],[\"是802\",{\"1\":{\"152\":1}}],[\"是将ip地址解析为以太网mac地址\",{\"1\":{\"196\":1}}],[\"是将单一媒体的频带资源划分成很多子信道\",{\"1\":{\"150\":1}}],[\"是将来自网络层的数据分组封装成数据帧\",{\"1\":{\"129\":1}}],[\"是局域网体系结构中划分的子层\",{\"1\":{\"144\":1}}],[\"是考虑到在接收端还需要对来自物理层的比特流进行一系列的处理\",{\"1\":{\"140\":1}}],[\"是真正用于数据传输的逻辑通道\",{\"1\":{\"117\":1,\"119\":1}}],[\"是计算机之间实现访问互联的关键和基础\",{\"1\":{\"81\":1}}],[\"是\",{\"1\":{\"72\":1,\"375\":1,\"581\":1,\"705\":2,\"706\":1,\"710\":1,\"760\":1,\"787\":1,\"812\":1,\"829\":1,\"832\":2}}],[\"是指四位著名的计算机科学家\",{\"1\":{\"490\":1}}],[\"是指数阶增长的典型例子\",{\"1\":{\"316\":1}}],[\"是指数性的增长\",{\"1\":{\"298\":1}}],[\"是指数据的传输不需要发送端和接收端之间保持严格的时钟同步\",{\"1\":{\"235\":1}}],[\"是指数据是1个比特1个比特依次发送\",{\"1\":{\"232\":1}}],[\"是指至少需要两台计算机\",{\"1\":{\"257\":1}}],[\"是指独立的计算机\",{\"1\":{\"257\":1}}],[\"是指计算机之间可以通过有线或无线的方式进行数据通信\",{\"1\":{\"257\":1}}],[\"是指将数字信号转换为模拟信号\",{\"1\":{\"239\":1}}],[\"是指将一个域名转换为对应的ip地址的过程\",{\"1\":{\"68\":1}}],[\"是指一次发送n个比特而不是一个比特\",{\"1\":{\"233\":1}}],[\"是指在程序代码之中普遍存在的引用赋值\",{\"1\":{\"735\":1}}],[\"是指在通信中将数字信号转换为模拟信号的过程\",{\"1\":{\"619\":1}}],[\"是指在一个较小的地理范围\",{\"1\":{\"155\":1}}],[\"是指在网络中的各个节点\",{\"1\":{\"59\":1}}],[\"是负责将域名解析为相应ip地址的服务器\",{\"1\":{\"68\":1}}],[\"是一块较小的内存空间\",{\"1\":{\"722\":1}}],[\"是一次函数\",{\"1\":{\"316\":1}}],[\"是一个不存储元素的阻塞队列\",{\"1\":{\"862\":1}}],[\"是一个任务定时周期的延迟执行的队列\",{\"1\":{\"862\":1}}],[\"是一个用数组实现的有界阻塞队列\",{\"1\":{\"862\":1}}],[\"是一个用于线程间协作的工具类\",{\"1\":{\"854\":1}}],[\"是一个用于标识资源位置的字符串\",{\"1\":{\"104\":1}}],[\"是一个用于在互联网上唯一标识一个设备\",{\"1\":{\"68\":1}}],[\"是一个native方法\",{\"1\":{\"847\":1}}],[\"是一个提供了构建同步器的框架\",{\"1\":{\"839\":1}}],[\"是一个可重入的读写锁\",{\"1\":{\"842\":1}}],[\"是一个可重入且独占式的锁\",{\"1\":{\"838\":1}}],[\"是一个可以按照插入顺序或者访问顺序遍历的有序\",{\"1\":{\"714\":1}}],[\"是一个复合操作\",{\"1\":{\"829\":1}}],[\"是一个以threadlocal对象为键\",{\"1\":{\"811\":1}}],[\"是一个\",{\"1\":{\"791\":1}}],[\"是一个特殊的值\",{\"1\":{\"712\":1}}],[\"是一个特殊的ip地址段\",{\"1\":{\"205\":1}}],[\"是一个32位的int类型的数值\",{\"1\":{\"693\":1}}],[\"是一个个的node节点\",{\"1\":{\"678\":1}}],[\"是一个位于网络层和数据链路层之间的协议\",{\"1\":{\"583\":1}}],[\"是一个有权自主地决定在本系统中应采用各种路由协议的小型单位\",{\"1\":{\"211\":1}}],[\"是一个网站的url\",{\"1\":{\"104\":1}}],[\"是一个网站的人类可读形式的名称\",{\"1\":{\"68\":1}}],[\"是一种抽象的模型\",{\"1\":{\"824\":1}}],[\"是一种在运行时动态获取类信息\",{\"1\":{\"798\":1}}],[\"是一种在运行时动态生成代理类的设计模式\",{\"1\":{\"496\":1}}],[\"是一种在编程中提供更强大类型安全性的特性\",{\"1\":{\"797\":1}}],[\"是一种用于控制多个设备在共享传输介质上进行数据传输的协议\",{\"1\":{\"581\":1}}],[\"是一种用于将域名\",{\"1\":{\"67\":1}}],[\"是一种结构性设计模式\",{\"1\":{\"514\":1,\"528\":1}}],[\"是一种结构型设计模式\",{\"1\":{\"494\":1,\"500\":1,\"504\":1,\"508\":1}}],[\"是一种软件设计原则\",{\"1\":{\"486\":1}}],[\"是一种设计原则\",{\"1\":{\"482\":1}}],[\"是一种创建型设计模式\",{\"1\":{\"416\":1,\"424\":1,\"430\":1,\"432\":1,\"439\":1,\"446\":1,\"453\":1}}],[\"是一种同步阻塞的实现方式\",{\"1\":{\"327\":1}}],[\"是一种行为型设计模式\",{\"1\":{\"322\":1,\"341\":1,\"348\":1,\"357\":1,\"363\":1,\"369\":1,\"375\":1,\"388\":1,\"398\":1}}],[\"是一种通过公共因特网创建安全连接的技术\",{\"1\":{\"223\":1}}],[\"是一种滑动窗口协议\",{\"1\":{\"139\":1}}],[\"是一种联机协议\",{\"1\":{\"98\":1}}],[\"是一种功能更强大的邮件读取协议\",{\"1\":{\"98\":1}}],[\"是一种简单\",{\"1\":{\"97\":1}}],[\"是一种网络协议\",{\"1\":{\"62\":1}}],[\"是什么和有什么作用\",{\"1\":{\"722\":1}}],[\"是什么\",{\"1\":{\"62\":1,\"67\":1,\"573\":1,\"719\":1,\"722\":5}}],[\"是提供特定网络应用程序所需的服务和功能\",{\"1\":{\"56\":1}}],[\"是为用户提供特定网络应用程序所需的服务和功能所产生的\",{\"1\":{\"54\":1}}],[\"网卡的发送速率为100mbps\",{\"1\":{\"260\":1}}],[\"网卡\",{\"1\":{\"238\":1,\"240\":1,\"618\":1}}],[\"网关再在主机b所在网络询问主机b的地址\",{\"1\":{\"198\":1}}],[\"网桥被具有更多端口\",{\"1\":{\"171\":1}}],[\"网桥除了可以扩展网络的物理连接范围外\",{\"1\":{\"171\":1}}],[\"网桥是两端口二层网络设备\",{\"1\":{\"171\":1}}],[\"网桥介绍\",{\"1\":{\"171\":1}}],[\"网桥\",{\"0\":{\"171\":1},\"1\":{\"169\":1}}],[\"网页链接等各种形式的信息\",{\"1\":{\"96\":1}}],[\"网页浏览等\",{\"1\":{\"56\":1}}],[\"网页浏览\",{\"1\":{\"54\":1}}],[\"网络通讯传输等\",{\"1\":{\"866\":1}}],[\"网络波动\",{\"1\":{\"845\":1}}],[\"网络划分\",{\"1\":{\"595\":1}}],[\"网络聊天室实现了用户之间的解耦\",{\"1\":{\"325\":1}}],[\"网络拓扑变化\",{\"1\":{\"296\":1}}],[\"网络拥塞\",{\"1\":{\"294\":1}}],[\"网络设备配置\",{\"1\":{\"285\":1}}],[\"网络设备和通信协议组成的互联网\",{\"1\":{\"257\":1}}],[\"网络和主机共同编址的问题\",{\"1\":{\"268\":1}}],[\"网络地址分配\",{\"1\":{\"268\":1}}],[\"网络时延由几部分组成\",{\"1\":{\"263\":1}}],[\"网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的\",{\"1\":{\"261\":1}}],[\"网络前缀越长\",{\"1\":{\"221\":1}}],[\"网络位全1\",{\"1\":{\"220\":1}}],[\"网络号20位\",{\"1\":{\"220\":1}}],[\"网络号前缀长度32保证了这是第一个被匹配的静态条目\",{\"1\":{\"205\":1}}],[\"网络主机号位32\",{\"1\":{\"220\":1}}],[\"网络类别\",{\"1\":{\"217\":1}}],[\"网络类型\",{\"1\":{\"210\":1}}],[\"网络id部分全是1表示\",{\"1\":{\"216\":1}}],[\"网络中各个结点不必交换通往目的站点的距离\",{\"1\":{\"210\":1}}],[\"网络中的路由器并不向邻居路由器传递路由表项\",{\"1\":{\"210\":1}}],[\"网络中的所有交换机会选择一条到根桥的最短路径作为活动路径\",{\"1\":{\"175\":1}}],[\"网络确保了通信的可靠性\",{\"1\":{\"184\":1}}],[\"网络编号\",{\"1\":{\"167\":1}}],[\"网络\",{\"0\":{\"246\":1},\"1\":{\"153\":1,\"246\":1}}],[\"网络层提供了哪些服务\",{\"0\":{\"588\":1},\"1\":{\"588\":1}}],[\"网络层之下\",{\"1\":{\"573\":1}}],[\"网络层为不同网络间的数据通信提供了数据包的路由\",{\"1\":{\"274\":1}}],[\"网络层将ip数据报的首部去掉后成为tcp报文段\",{\"1\":{\"268\":1}}],[\"网络层将ip数据报交付给数据链路层\",{\"1\":{\"268\":1}}],[\"网络层将ip数据报交付给数据链路层处理\",{\"1\":{\"268\":1}}],[\"网络层解析ip数据报的首部\",{\"1\":{\"268\":1}}],[\"网络层给tcp报文段添加一个ip首部\",{\"1\":{\"268\":1}}],[\"网络层协议及报文格式\",{\"0\":{\"188\":1}}],[\"网络层向传输层提供的服务\",{\"1\":{\"184\":1,\"589\":1}}],[\"网络层能够为上层传输层解决不同网络的规范要求差异\",{\"1\":{\"184\":1,\"589\":1}}],[\"网络层也能根据不同的条件选择最佳的数据传输路径\",{\"1\":{\"182\":1}}],[\"网络层就像是连接不同城市之间的高速公路系统\",{\"1\":{\"182\":1}}],[\"网络层传输单位是数据报\",{\"1\":{\"180\":1,\"587\":1}}],[\"网络层的主要作用是什么\",{\"0\":{\"587\":1},\"1\":{\"587\":1}}],[\"网络层的主要任务是确定数据的最佳路径\",{\"1\":{\"182\":1}}],[\"网络层的主要任务是实现不同网络之间的互连\",{\"1\":{\"180\":1,\"587\":1}}],[\"网络层的主要任务\",{\"1\":{\"180\":1}}],[\"网络层的服务访问点为p数据报首部中的\",{\"1\":{\"251\":1}}],[\"网络层的就是是为了实现不同网络之间的互连\",{\"1\":{\"178\":1}}],[\"网络层的数据包到达数据链路层后加上数据链路层的协议头和协议尾就构成了一个数据帧\",{\"1\":{\"130\":1}}],[\"网络层\",{\"0\":{\"178\":1},\"1\":{\"120\":1,\"162\":1,\"181\":1,\"268\":3}}],[\"网络层相邻的是llc子层\",{\"1\":{\"120\":1}}],[\"网络服务的提供者和网络服务的请求者分别扮演着不同的角色\",{\"1\":{\"58\":1}}],[\"网络应用模型\",{\"0\":{\"57\":1}}],[\"网站\",{\"1\":{\"372\":1}}],[\"网站数据统计\",{\"1\":{\"372\":1}}],[\"网站上有不同类型的页面\",{\"1\":{\"372\":1}}],[\"网站建设\",{\"2\":{\"25\":1,\"51\":1}}],[\"网站默认打开自带80\",{\"1\":{\"8\":1,\"34\":1}}],[\"思维导图\",{\"1\":{\"53\":1,\"458\":1}}],[\"源码中模运算就是把散列值和数组长度\",{\"1\":{\"694\":1}}],[\"源mac地址\",{\"1\":{\"575\":1}}],[\"源ip地址\",{\"1\":{\"304\":1}}],[\"源端口号\",{\"1\":{\"302\":1}}],[\"源端的设备一直要参与传输\",{\"1\":{\"275\":1}}],[\"源端就可以发送数据\",{\"1\":{\"275\":1}}],[\"源端可直接把数据传给与它直接相连的设备\",{\"1\":{\"275\":1}}],[\"源点抑制\",{\"1\":{\"201\":1}}],[\"源主机收到后将此映射写入arp缓存\",{\"1\":{\"198\":1}}],[\"源地址为dhcp服务器的地址\",{\"1\":{\"64\":2}}],[\"源地址为0\",{\"1\":{\"64\":2}}],[\"源\",{\"1\":{\"24\":1,\"50\":1,\"575\":1}}],[\"七\",{\"0\":{\"24\":1,\"50\":1,\"368\":1,\"483\":1,\"527\":1}}],[\"后续业务操作\",{\"1\":{\"845\":1}}],[\"后续维护可能修改源代码\",{\"1\":{\"495\":1}}],[\"后被其他进入的线程获得\",{\"1\":{\"835\":1}}],[\"后可能升入老年代的对象大小\",{\"1\":{\"739\":1}}],[\"后台运行的系统线程包括\",{\"1\":{\"721\":1}}],[\"后台运行的系统线程主要有哪些\",{\"0\":{\"721\":1},\"1\":{\"721\":1}}],[\"后台启动运行\",{\"1\":{\"23\":1,\"49\":1}}],[\"后文中我会结合源码对这一过程进行分析\",{\"1\":{\"706\":1}}],[\"后面的流程\",{\"1\":{\"711\":1}}],[\"后面的0变成1\",{\"1\":{\"688\":1}}],[\"后面1个字节为帧开始定界符\",{\"1\":{\"129\":1}}],[\"后添加的值会覆盖先前的值\",{\"1\":{\"687\":1}}],[\"后\",{\"1\":{\"286\":1,\"707\":1,\"765\":1,\"840\":1}}],[\"后来\",{\"1\":{\"171\":1}}],[\"后24位是由获得该组织唯一标识符的厂商自行随意分配的网络接口标识符\",{\"1\":{\"166\":1}}],[\"后再转发\",{\"1\":{\"159\":1}}],[\"后再次尝试发送\",{\"1\":{\"152\":1}}],[\"后端部署\",{\"0\":{\"23\":1,\"49\":1}}],[\"项目的构建和属性\",{\"1\":{\"539\":1}}],[\"项目的本地配置文件\",{\"1\":{\"539\":1}}],[\"项目结构\",{\"0\":{\"539\":1}}],[\"项目目录结构没有图标显示\",{\"1\":{\"538\":1}}],[\"项目名\",{\"1\":{\"538\":1}}],[\"项目打jar包上传到具体目录\",{\"1\":{\"23\":1,\"49\":1}}],[\"项目修改配置文件application\",{\"1\":{\"23\":1,\"49\":1}}],[\"项目部署及远程连接\",{\"1\":{\"1\":1,\"27\":1}}],[\"quantity\",{\"1\":{\"518\":3}}],[\"queryresult\",{\"1\":{\"497\":2,\"498\":2}}],[\"query\",{\"1\":{\"495\":13,\"497\":18,\"498\":15}}],[\"querydata\",{\"1\":{\"495\":6}}],[\"queue队列\",{\"1\":{\"671\":1}}],[\"queue\",{\"1\":{\"327\":1,\"670\":1,\"671\":1,\"735\":6}}],[\"q表示退出\",{\"1\":{\"343\":1,\"346\":1}}],[\"qam\",{\"1\":{\"239\":1,\"619\":1}}],[\"qquser\",{\"1\":{\"325\":6}}],[\"qqgroup\",{\"1\":{\"325\":2}}],[\"qq\",{\"1\":{\"91\":1}}],[\"qpan\",{\"1\":{\"23\":1,\"49\":1}}],[\"q\",{\"1\":{\"22\":3,\"48\":3,\"343\":1,\"346\":1}}],[\"将是一个无边界的阻塞队列\",{\"1\":{\"862\":1}}],[\"将本线程生产出来的数据传递给对方\",{\"1\":{\"854\":1}}],[\"将\",{\"1\":{\"844\":1}}],[\"将清空工作内存中共享变量的值\",{\"1\":{\"836\":1}}],[\"将控制权交给操作系统内核\",{\"1\":{\"809\":1}}],[\"将线程池状态置为stop\",{\"1\":{\"864\":1}}],[\"将线程池状态置为shutdown\",{\"1\":{\"864\":1}}],[\"将线程\",{\"1\":{\"769\":1}}],[\"将符号引用到直接引用的转换动作\",{\"1\":{\"754\":1}}],[\"将符号引用转换为直接引用\",{\"1\":{\"720\":1}}],[\"将该二进制流中的静态存储结构转化为方法去运行时数据结构\",{\"1\":{\"754\":1}}],[\"将该服务器块与特定的域名\",{\"1\":{\"8\":1,\"34\":1}}],[\"将被引用的对象标记为灰色\",{\"1\":{\"748\":1}}],[\"将根对象标记为灰色\",{\"1\":{\"748\":1}}],[\"将可用内存按容量划分为大小相等的两块\",{\"1\":{\"744\":1}}],[\"将堆内存划分为年轻代和老年代\",{\"1\":{\"743\":1}}],[\"将存活的对象从eden空间和survivor空间移动到另一个survivor空间\",{\"1\":{\"741\":1}}],[\"将会看到线程的死锁信息\",{\"1\":{\"849\":1}}],[\"将会逐步晋升到老年代中存放\",{\"1\":{\"737\":1}}],[\"将会导致remove\",{\"1\":{\"367\":1}}],[\"将会导致illegalstateexception异常\",{\"1\":{\"367\":1}}],[\"将分配的内存空间初始化为零值\",{\"1\":{\"726\":1}}],[\"将分布在不同地理位置的计算机\",{\"1\":{\"257\":1}}],[\"将字节码编译成本地机器代码时\",{\"1\":{\"721\":1}}],[\"将元素放置到链表的最后\",{\"1\":{\"701\":1}}],[\"将新元素放到数组中\",{\"1\":{\"701\":1}}],[\"将新的支付接口适配到旧的支付接口上\",{\"1\":{\"510\":1}}],[\"将新的支付接口适配到老的支付接口上\",{\"1\":{\"510\":2}}],[\"将新的ip地址封装在dhcp确认消息中\",{\"1\":{\"64\":1}}],[\"将时间复杂度由o\",{\"1\":{\"701\":1}}],[\"将时间划分为等长的时分复用帧\",{\"1\":{\"148\":1}}],[\"将key分割成位数相同的几段\",{\"1\":{\"691\":1}}],[\"将已经产生hash碰撞的元素完美的转移到新的table中去\",{\"1\":{\"688\":1}}],[\"将已知的ip地址和mac地址对应关系存储一段时间\",{\"1\":{\"583\":1}}],[\"将链表转换为红黑树\",{\"1\":{\"711\":1}}],[\"将链表转换成红黑树前会判断\",{\"1\":{\"686\":1,\"706\":1}}],[\"将链表转化为红黑树\",{\"1\":{\"686\":1,\"706\":1}}],[\"将自动进行扩容操作\",{\"1\":{\"685\":1}}],[\"将自己作为访问者传递给城市的对象结构\",{\"1\":{\"372\":1}}],[\"将原数组拷贝一份\",{\"1\":{\"682\":1}}],[\"将原始网络划分为多个子网\",{\"1\":{\"596\":1}}],[\"将所有连接到它的设备组成一个广播域\",{\"1\":{\"580\":1}}],[\"将子系统与客户端解耦\",{\"1\":{\"519\":1}}],[\"将订单处理系统的复杂性隐藏起来\",{\"1\":{\"518\":1}}],[\"将老的支付接口2022的调用转换为新的支付接口2023的调用\",{\"1\":{\"510\":1}}],[\"将旧的接口迁移成新的接口\",{\"1\":{\"510\":1}}],[\"将旧的接口适配成新的接口\",{\"1\":{\"510\":1}}],[\"将拒绝访问\",{\"1\":{\"495\":1}}],[\"将结果存入缓存\",{\"1\":{\"495\":1}}],[\"将查询结果存入缓存\",{\"1\":{\"495\":1}}],[\"将实现类的选择和创建交给容器管理\",{\"1\":{\"477\":1}}],[\"将大型接口拆分成多个小接口\",{\"1\":{\"474\":1}}],[\"将复杂的子系统封装起来\",{\"1\":{\"515\":1}}],[\"将复杂的\",{\"1\":{\"419\":1}}],[\"将复杂功能置于网络边缘\",{\"1\":{\"184\":1}}],[\"将类的构造函数设置为私有\",{\"1\":{\"418\":1}}],[\"将它们封装成独立的策略类\",{\"1\":{\"386\":1}}],[\"将它们与事件类型\",{\"1\":{\"326\":1}}],[\"将命令对象传递给调用者\",{\"1\":{\"382\":1}}],[\"将状态的保存和恢复逻辑封装在备忘录对象中\",{\"1\":{\"379\":1}}],[\"将遍历算法与聚合对象分离\",{\"1\":{\"367\":1}}],[\"将对象放入该包装器中\",{\"1\":{\"501\":1}}],[\"将对象写到字节数组当中\",{\"1\":{\"455\":1}}],[\"将对象序列化为字节流\",{\"1\":{\"455\":1}}],[\"将对象的标记状态分为三个不同的颜色\",{\"1\":{\"748\":1}}],[\"将对象的构建过程与其表示分离\",{\"1\":{\"452\":1}}],[\"将对象的创建逻辑集中在一个工厂类中\",{\"1\":{\"430\":1}}],[\"将对象的创建和使用分离\",{\"1\":{\"430\":2}}],[\"将对象的状态保存在一个备忘录对象中\",{\"1\":{\"376\":1}}],[\"将对象的状态抽象成独立的类\",{\"1\":{\"361\":1}}],[\"将对象之间的直接通信转为通过中介者来进行\",{\"1\":{\"410\":1}}],[\"将对象之间的依赖关系解耦\",{\"1\":{\"323\":1}}],[\"将每一个修改状态的动作抽象成个接口\",{\"1\":{\"360\":1}}],[\"将每个ip地址都分割成网络id和主机id两部分\",{\"1\":{\"216\":1}}],[\"将策略模式引入其中\",{\"1\":{\"346\":1}}],[\"将算法的具体实现封装在策略类中\",{\"1\":{\"342\":1}}],[\"将通用的审批步骤放在抽象类中实现\",{\"1\":{\"333\":1}}],[\"将共性的关卡元素放在抽象类中实现\",{\"1\":{\"333\":1}}],[\"将共性步骤放在抽象类中实现\",{\"1\":{\"333\":1}}],[\"将一些步骤的具体实现延迟到子类中\",{\"1\":{\"330\":1}}],[\"将一个long值分解成多个部分\",{\"1\":{\"855\":1}}],[\"将一个局域网划分成多个虚拟的\",{\"1\":{\"579\":1}}],[\"将一个接口转换为另一个接口\",{\"1\":{\"512\":1}}],[\"将一个大的ip地址范围分割成多个小的子网\",{\"1\":{\"222\":1}}],[\"将一个比特位用一组特定的码片发送\",{\"1\":{\"150\":1}}],[\"将消息发布到消息总线\",{\"1\":{\"326\":1}}],[\"将这些用户加入聊天室\",{\"1\":{\"325\":1}}],[\"将这些信息添加到自己的链路状态数据库中\",{\"1\":{\"210\":1}}],[\"将缓冲区中的字节组成若干个tcp段\",{\"1\":{\"289\":1}}],[\"将ip数据报封装的协议数据单元上交传输层的过程叫ip分用\",{\"1\":{\"280\":1}}],[\"将不同应用进程进行对应的\",{\"1\":{\"274\":1}}],[\"将计算机与网络物理连接起来\",{\"1\":{\"240\":1}}],[\"将数字信号转化为模拟信号\",{\"1\":{\"240\":1}}],[\"将数字数据转换成模拟信号或数字信号的过程\",{\"1\":{\"227\":1,\"229\":1}}],[\"将数据结构和操作分离\",{\"1\":{\"373\":1}}],[\"将数据通过这种方式的编码转换为0\",{\"1\":{\"238\":1}}],[\"将数据移除\",{\"1\":{\"153\":1}}],[\"将数据附加在令牌后\",{\"1\":{\"153\":1}}],[\"将数据0编码成低\",{\"1\":{\"131\":1}}],[\"将数据1编码成高\",{\"1\":{\"131\":1}}],[\"将划分子网的ipv4地址与其相应的子网掩码\",{\"1\":{\"218\":1}}],[\"将源节点到网络中所有结点的最短通路都找出来\",{\"1\":{\"205\":1}}],[\"将多个变量封装成一个对象\",{\"1\":{\"845\":1}}],[\"将多个连续的加锁\",{\"1\":{\"837\":1}}],[\"将多个处理器组成一个链条\",{\"1\":{\"349\":1}}],[\"将多个处理器\",{\"1\":{\"348\":1}}],[\"将多个分组交换网络\",{\"1\":{\"189\":1}}],[\"将多个信号组合在一个信道上进行传输\",{\"1\":{\"144\":1}}],[\"将局域网内的设备划分成与物理位置无关的逻辑组的技术\",{\"1\":{\"159\":1}}],[\"将各种计算机\",{\"1\":{\"155\":1}}],[\"将令牌占用\",{\"1\":{\"153\":1}}],[\"将其接口转换为客户端所期望的接口形式\",{\"1\":{\"512\":1}}],[\"将其交付给应用层\",{\"1\":{\"268\":1}}],[\"将其交付给运输层\",{\"1\":{\"268\":1}}],[\"将其交付给网络层\",{\"1\":{\"268\":2}}],[\"将其交付给数据链路层\",{\"1\":{\"268\":1}}],[\"将其丢弃\",{\"1\":{\"174\":1}}],[\"将其丢弃并等待发送方的超时重传\",{\"1\":{\"137\":1}}],[\"将其添加到待传输数据的后面一起传输\",{\"1\":{\"135\":1,\"576\":1}}],[\"将fcs校验码放在原始帧最后\",{\"1\":{\"135\":1,\"576\":1}}],[\"将来自物理层的一个个比特流组装成数据帧\",{\"1\":{\"129\":1}}],[\"将有差错的物理线路改进成逻辑上无差错的数据链路\",{\"1\":{\"119\":1}}],[\"将jar包上传服务器指定目录\",{\"1\":{\"23\":1,\"49\":1}}],[\"将打包的文件上传到服务器\",{\"1\":{\"22\":1,\"48\":1}}],[\"如等待可中断\",{\"1\":{\"843\":1}}],[\"如增加了适应性自旋\",{\"1\":{\"837\":1}}],[\"如哈希码\",{\"1\":{\"837\":1}}],[\"如可中断锁\",{\"1\":{\"831\":1}}],[\"如请求层和数据层\",{\"1\":{\"816\":1}}],[\"如动态代理设计模式\",{\"1\":{\"800\":1}}],[\"如方法\",{\"1\":{\"799\":1}}],[\"如类\",{\"1\":{\"799\":1}}],[\"如visualvm\",{\"1\":{\"767\":1}}],[\"如对象重用\",{\"1\":{\"767\":1}}],[\"如多个应用都要依赖\",{\"1\":{\"760\":1}}],[\"如热更新\",{\"1\":{\"758\":1}}],[\"如cpu时间\",{\"1\":{\"804\":1}}],[\"如cpu和内存\",{\"1\":{\"233\":1}}],[\"如class\",{\"1\":{\"755\":1}}],[\"如静态方法\",{\"1\":{\"755\":1}}],[\"如这个类是\",{\"1\":{\"754\":1}}],[\"如栈中的对象引用\",{\"1\":{\"748\":1}}],[\"如将自己或者某个属性赋值\",{\"1\":{\"742\":1}}],[\"如从新生代晋升过来的对象或者是大对象直接分配到老年代\",{\"1\":{\"737\":1}}],[\"如lambda\",{\"1\":{\"702\":1}}],[\"如线程安全\",{\"1\":{\"673\":1}}],[\"如电缆\",{\"1\":{\"619\":1}}],[\"如光\",{\"1\":{\"618\":1}}],[\"如双绞线\",{\"1\":{\"618\":1}}],[\"如帧起始和结束标志\",{\"1\":{\"584\":1}}],[\"如帧封装\",{\"1\":{\"140\":1}}],[\"如路由器\",{\"1\":{\"579\":1,\"596\":1}}],[\"如网卡\",{\"1\":{\"574\":1}}],[\"如网络拓扑\",{\"1\":{\"273\":1}}],[\"如地址\",{\"1\":{\"573\":1,\"577\":1}}],[\"如服装\",{\"1\":{\"506\":1}}],[\"如添加缓存的功能\",{\"1\":{\"500\":1}}],[\"如byteinputstream\",{\"1\":{\"500\":1}}],[\"如bgp\",{\"1\":{\"211\":1}}],[\"如inputstream有很多子类\",{\"1\":{\"500\":1}}],[\"如ip电话\",{\"1\":{\"301\":1}}],[\"如我们想要给fileinputstream添加一个新的能力时\",{\"1\":{\"500\":1}}],[\"如我们有一个缓存结构\",{\"1\":{\"500\":1}}],[\"如我们要给所有的service层添加日志\",{\"1\":{\"500\":1}}],[\"如记录日志\",{\"1\":{\"495\":1}}],[\"如机器人分为\",{\"1\":{\"473\":1}}],[\"如行走\",{\"1\":{\"473\":1}}],[\"如酱料\",{\"1\":{\"452\":1}}],[\"如列表\",{\"1\":{\"363\":1,\"797\":1}}],[\"如垃圾邮件过滤\",{\"1\":{\"355\":1}}],[\"如身份验证\",{\"1\":{\"355\":1}}],[\"如控制台\",{\"1\":{\"355\":1}}],[\"如日志记录\",{\"1\":{\"352\":1,\"496\":1}}],[\"如权限验证\",{\"1\":{\"352\":1}}],[\"如put\",{\"1\":{\"713\":1}}],[\"如pdfreport和wordreport\",{\"1\":{\"336\":1}}],[\"如pdf报告\",{\"1\":{\"336\":1}}],[\"如pop3\",{\"1\":{\"90\":1}}],[\"如提交申请\",{\"1\":{\"333\":1}}],[\"如敌人生成\",{\"1\":{\"333\":1}}],[\"如生成订单号\",{\"1\":{\"333\":1}}],[\"如打开数据源\",{\"1\":{\"333\":1}}],[\"如dns\",{\"1\":{\"301\":1}}],[\"如发送方窗口2\",{\"1\":{\"298\":1}}],[\"如微软远程桌面使用的端口是3389\",{\"1\":{\"279\":1}}],[\"如上图的主机a与主机b\",{\"1\":{\"275\":1}}],[\"如上图的主机a与路由器1\",{\"1\":{\"275\":1}}],[\"如上传更多文件\",{\"1\":{\"86\":1}}],[\"如上传\",{\"1\":{\"86\":1}}],[\"如频率\",{\"1\":{\"239\":1}}],[\"如曼彻斯特编码\",{\"1\":{\"236\":1}}],[\"如在我的项目经历中有这样一条描述\",{\"1\":{\"511\":1}}],[\"如在线商店\",{\"1\":{\"506\":1}}],[\"如在rfc1918标准中定义的10\",{\"1\":{\"223\":1}}],[\"如在帧的头部加上了两个syn控制字符\",{\"1\":{\"131\":1}}],[\"如互联网\",{\"1\":{\"223\":1}}],[\"如回环地址等\",{\"1\":{\"222\":1}}],[\"如该主机向其所在子网发送广播分组\",{\"1\":{\"218\":1}}],[\"如中国的数据报尽量要绕开美国的自治系统\",{\"1\":{\"212\":1}}],[\"如以太网\",{\"1\":{\"618\":1}}],[\"如以太网链路或串行点对点链路\",{\"1\":{\"210\":1}}],[\"如以太局域网\",{\"1\":{\"144\":1}}],[\"如主机1的默认路由是r1\",{\"1\":{\"201\":1}}],[\"如127\",{\"1\":{\"200\":1}}],[\"如避免路由器缓存空间爆满而造成丢包的情况\",{\"1\":{\"187\":1,\"592\":1}}],[\"如曾经的x\",{\"1\":{\"184\":1}}],[\"如所学校\",{\"1\":{\"155\":1}}],[\"如此循环下去\",{\"1\":{\"142\":1,\"576\":1}}],[\"如01111110\",{\"1\":{\"131\":1}}],[\"如局域网中的链路\",{\"1\":{\"126\":1}}],[\"如何排查死锁\",{\"0\":{\"849\":1},\"1\":{\"849\":1}}],[\"如何预防死锁\",{\"1\":{\"848\":1}}],[\"如何避免死锁\",{\"1\":{\"848\":2}}],[\"如何避免\",{\"0\":{\"848\":1}}],[\"如何保证多线程下i++\",{\"0\":{\"844\":1}}],[\"如何定位内存溢出问题\",{\"0\":{\"770\":1},\"1\":{\"770\":1}}],[\"如何定位内存泄漏问题\",{\"0\":{\"769\":1},\"1\":{\"769\":1}}],[\"如何判断对象是垃圾\",{\"0\":{\"733\":1},\"1\":{\"733\":1}}],[\"如何才能找到类的元数据信息\",{\"1\":{\"726\":1}}],[\"如何是无参构造则默认大小为10\",{\"1\":{\"677\":1}}],[\"如何挑选合适的集合\",{\"0\":{\"673\":1},\"1\":{\"673\":1}}],[\"如何解决\",{\"0\":{\"656\":1}}],[\"如何进行子网划分\",{\"0\":{\"596\":1},\"1\":{\"596\":1}}],[\"如何进行路由选择问题\",{\"1\":{\"268\":1}}],[\"如何实现长连接\",{\"0\":{\"564\":1}}],[\"如何处理\",{\"1\":{\"268\":1}}],[\"如何从信号所表示的一连串比特流中区分出地址和数据\",{\"1\":{\"268\":1}}],[\"如何从串行数据比特流中正确地划分出发送的一个个字符\",{\"1\":{\"234\":1}}],[\"如何标识网络中的各主机\",{\"1\":{\"268\":1}}],[\"如何协调各主机争用总线\",{\"1\":{\"268\":1}}],[\"如何协调多个发送和接收站点对一个共享传输媒体的占用的问题成为媒体接入控制mac\",{\"1\":{\"144\":1}}],[\"如何合理地分配和管理ip地址以满足网络通信的需求\",{\"1\":{\"222\":1}}],[\"如何到达目的地\",{\"1\":{\"119\":1}}],[\"如何发送报文\",{\"1\":{\"56\":1}}],[\"如下是\",{\"1\":{\"769\":1}}],[\"如下图\",{\"1\":{\"232\":1,\"233\":1}}],[\"如下\",{\"1\":{\"107\":1}}],[\"如smtp\",{\"1\":{\"90\":1}}],[\"如命令\",{\"1\":{\"87\":1}}],[\"如用户认证\",{\"1\":{\"85\":1}}],[\"如访问文件的用户必须经过授权\",{\"1\":{\"83\":1}}],[\"如指明是否使用ascii码\",{\"1\":{\"83\":1}}],[\"如\",{\"1\":{\"71\":1,\"78\":1,\"131\":2,\"221\":1,\"249\":1,\"468\":1,\"497\":1,\"498\":1,\"696\":1,\"710\":2,\"713\":1,\"754\":2,\"764\":2,\"769\":2,\"831\":1,\"832\":1,\"834\":1}}],[\"如果限制了配置中心的使用\",{\"1\":{\"869\":1}}],[\"如果去办业务\",{\"1\":{\"868\":1}}],[\"如果队列满了\",{\"1\":{\"868\":1}}],[\"如果正在运行的线程数量大于或等于\",{\"1\":{\"868\":1}}],[\"如果正在运行的线程数量小于\",{\"1\":{\"868\":1}}],[\"如果正好让最后几个低位呈现规律性重复\",{\"1\":{\"694\":1}}],[\"如果执行时间相差不大\",{\"1\":{\"866\":1}}],[\"如果执行完启发式清理工作后\",{\"1\":{\"821\":1}}],[\"如果workqueue也满了则尝试用非核心线程执行任务\",{\"1\":{\"860\":1}}],[\"如果任务到达了\",{\"1\":{\"857\":1}}],[\"如果更新失败\",{\"1\":{\"855\":1}}],[\"如果第一个线程先执行exchange\",{\"1\":{\"854\":1}}],[\"如果信号量的值大于零\",{\"1\":{\"853\":1}}],[\"如果系统只有一台打印机可用\",{\"1\":{\"853\":1}}],[\"如果申请不到\",{\"1\":{\"848\":1}}],[\"如果共享资源被占用\",{\"1\":{\"846\":1}}],[\"如果共享数据确实被征用产生了冲突\",{\"1\":{\"831\":1,\"832\":1}}],[\"如果被请求的共享资源被占用\",{\"1\":{\"846\":1}}],[\"如果被请求的共享资源空闲\",{\"1\":{\"846\":1}}],[\"如果全部相等\",{\"1\":{\"845\":1}}],[\"如果一直循环执行\",{\"1\":{\"845\":1}}],[\"如果一个操作happens\",{\"1\":{\"826\":1}}],[\"如果一个线程a执行了thread\",{\"1\":{\"807\":1,\"811\":1}}],[\"如果一个类加载器收到了类加载的请求\",{\"1\":{\"758\":1}}],[\"如果一个类的子类初始化了\",{\"1\":{\"755\":1}}],[\"如果一个类满足以下条件\",{\"1\":{\"733\":1}}],[\"如果一个帧来自一个access端口\",{\"1\":{\"159\":1}}],[\"如果没变我就修改\",{\"1\":{\"845\":1}}],[\"如果没有其他线程征用共享数据\",{\"1\":{\"831\":1,\"832\":1}}],[\"如果没有正确的同步机制\",{\"1\":{\"814\":1}}],[\"如果没有使用\",{\"1\":{\"775\":1}}],[\"如果没有\",{\"1\":{\"726\":1,\"795\":1}}],[\"如果没有红黑树\",{\"1\":{\"685\":1,\"686\":1}}],[\"如果没有遵循开闭原则\",{\"1\":{\"465\":1}}],[\"如果没有任何处理器能够处理该请求\",{\"1\":{\"350\":1}}],[\"如果没有找到更具体的路由匹配某个目标地址\",{\"1\":{\"205\":1}}],[\"如果没有则进入下一级域名服务器进行查找\",{\"1\":{\"80\":1}}],[\"如果失败了\",{\"1\":{\"845\":1}}],[\"如果失败\",{\"1\":{\"839\":1}}],[\"如果失败则继续执行步骤7\",{\"1\":{\"837\":1}}],[\"如果成功获取锁\",{\"1\":{\"839\":1}}],[\"如果成员变量是使用\",{\"1\":{\"775\":1}}],[\"如果获取失败\",{\"1\":{\"839\":1}}],[\"如果获取锁失败则尝试自旋\",{\"1\":{\"711\":1}}],[\"如果保存失败\",{\"1\":{\"837\":1}}],[\"如果保存成功\",{\"1\":{\"837\":1}}],[\"如果抢锁失败\",{\"1\":{\"837\":1}}],[\"如果抢锁成功则执行同步锁代码\",{\"1\":{\"837\":1}}],[\"如果抢锁成功\",{\"1\":{\"837\":1}}],[\"如果⼀个线程\",{\"1\":{\"833\":1}}],[\"如果能保证这一点\",{\"1\":{\"831\":1}}],[\"如果能够处理\",{\"1\":{\"350\":2}}],[\"如果重排序之后的执行结果\",{\"1\":{\"826\":1}}],[\"如果父线程的inheritablethreadlocals不为空\",{\"1\":{\"822\":1}}],[\"如果缺乏可见性\",{\"1\":{\"814\":1}}],[\"如果将wait\",{\"1\":{\"813\":1}}],[\"如果将该对象用作哈希表的键\",{\"1\":{\"788\":1}}],[\"如果子类没有覆盖该方法\",{\"1\":{\"794\":1}}],[\"如果字符串常量池中没有保存了对应的字符串对象的引用\",{\"1\":{\"791\":1}}],[\"如果字符串常量池中保存了对应的字符串对象的引用\",{\"1\":{\"791\":1}}],[\"如果字符串常量池中不存在字符串对象\",{\"1\":{\"791\":1}}],[\"如果字符串中包含的汉字没有超过\",{\"1\":{\"789\":1}}],[\"如果两个对象在\",{\"1\":{\"788\":1}}],[\"如果两个设备同时发送数据\",{\"1\":{\"581\":1}}],[\"如果每次回收的内存非常少\",{\"1\":{\"766\":1}}],[\"如果每次\",{\"1\":{\"766\":1}}],[\"如果线程池已满\",{\"1\":{\"870\":1}}],[\"如果线程池数太大\",{\"1\":{\"866\":1}}],[\"如果线程调用了\",{\"1\":{\"835\":1}}],[\"如果线程a调用共享对象的wait\",{\"1\":{\"807\":1}}],[\"如果线程a遍历过程中\",{\"1\":{\"709\":1}}],[\"如果线程长期处于\",{\"1\":{\"765\":1}}],[\"如果到这个时间了\",{\"1\":{\"764\":1}}],[\"如果采用默认的双亲委派类加载机制\",{\"1\":{\"760\":1}}],[\"如果采用100米高的天线塔\",{\"1\":{\"230\":1}}],[\"如果用户自己也编写了一个名为\",{\"1\":{\"758\":1}}],[\"如果用户注册成功之后\",{\"1\":{\"327\":1}}],[\"如果该类还没有被加载到内存中\",{\"1\":{\"755\":1}}],[\"如果响应时间是高优先级的\",{\"1\":{\"752\":1}}],[\"如果响应时间比吞吐量优先级高\",{\"1\":{\"752\":1}}],[\"如果优先考虑应用程序的峰值性能\",{\"1\":{\"752\":1}}],[\"如果应用程序有一个很小的内存空间\",{\"1\":{\"752\":1}}],[\"如果浮动垃圾太多\",{\"1\":{\"751\":1}}],[\"如果handlepromotionfailure=true\",{\"1\":{\"743\":1}}],[\"如果hash==moved\",{\"1\":{\"711\":1}}],[\"如果小于或者handlepromotionfailure=false\",{\"1\":{\"743\":1}}],[\"如果小于\",{\"1\":{\"743\":1}}],[\"如果大于\",{\"1\":{\"743\":2}}],[\"如果大数据征信系统提供了发送用户注册信息的\",{\"1\":{\"327\":1}}],[\"如果方法区由永久代实现\",{\"1\":{\"739\":1}}],[\"如果这时候队列满了\",{\"1\":{\"868\":1}}],[\"如果这个时候恰巧锁没有被占用\",{\"1\":{\"840\":1}}],[\"如果这次回收还没有足够的内存\",{\"1\":{\"735\":1}}],[\"如果这些常量不再被任何活动对象或类所引用\",{\"1\":{\"733\":1}}],[\"如果无法及时回收不再使用的类\",{\"1\":{\"731\":1}}],[\"如果持续不断地生成新的类\",{\"1\":{\"731\":1}}],[\"如果单例对象持有外部的引用\",{\"1\":{\"731\":1}}],[\"如果可以使用的额度用换了还不还\",{\"1\":{\"731\":1}}],[\"如果可以处理\",{\"1\":{\"348\":1}}],[\"如果我要访问一个对象的有几种方式\",{\"1\":{\"730\":1}}],[\"如果我们插入一个value=27的数据\",{\"1\":{\"820\":1}}],[\"如果我们内存足还没事\",{\"1\":{\"818\":1}}],[\"如果我们一种使用继承\",{\"1\":{\"782\":1}}],[\"如果我们使用一个方法内总是无限制条件递归调用本方法\",{\"1\":{\"731\":1}}],[\"如果我们使用的不是不变类型的key\",{\"1\":{\"731\":1}}],[\"如果我们需要新的功能\",{\"1\":{\"473\":1}}],[\"如果我们需要更改或替换邮件发送方式\",{\"1\":{\"461\":1}}],[\"如果我们将一个\",{\"1\":{\"469\":1}}],[\"如果我们执行了撤销操作\",{\"1\":{\"375\":1}}],[\"如果我们不使用设计模式\",{\"1\":{\"360\":1}}],[\"如果我们把物理层和数据链路层比作市内交通\",{\"1\":{\"182\":1}}],[\"如果我们要是信息送达给对方\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"如果已售罄\",{\"1\":{\"728\":1}}],[\"如果你用\",{\"1\":{\"712\":2}}],[\"如果都不满足\",{\"1\":{\"711\":1}}],[\"如果node是空的话\",{\"1\":{\"711\":1}}],[\"如果发生冲突\",{\"1\":{\"855\":1}}],[\"如果发现当前的读锁被占用\",{\"1\":{\"842\":1}}],[\"如果发现锁这个时候被释放了\",{\"1\":{\"840\":1}}],[\"如果发现\",{\"1\":{\"769\":1}}],[\"如果发现迭代器所记录的修改次数与集合实际的修改次数不一致\",{\"1\":{\"710\":1}}],[\"如果发送方一直等待接收方的窗口变为非零\",{\"1\":{\"294\":1}}],[\"如果发送方没有收到接收方的确认信息\",{\"1\":{\"291\":1}}],[\"如果发送方未收到确认\",{\"1\":{\"138\":1,\"139\":1}}],[\"如果发送成功\",{\"1\":{\"152\":1}}],[\"如果集合发生变化时修改modcount值刚好又设置为了expectedmodcount值\",{\"1\":{\"709\":1}}],[\"如果尝试将\",{\"1\":{\"706\":1}}],[\"如果想使用有序的map\",{\"1\":{\"703\":1}}],[\"如果数组位置上已经有元素\",{\"1\":{\"701\":1}}],[\"如果数组的元素过少\",{\"1\":{\"690\":1}}],[\"如果链表中插入节点的时候\",{\"1\":{\"695\":1}}],[\"如果链表非常长\",{\"1\":{\"685\":1}}],[\"如果对多个变量操作时\",{\"1\":{\"845\":1}}],[\"如果对象在在\",{\"1\":{\"736\":1}}],[\"如果对象在进行可达性分析后发现没有与\",{\"1\":{\"736\":1}}],[\"如果对象是一个\",{\"1\":{\"729\":1}}],[\"如果对象内有引用类型的成员变量\",{\"1\":{\"454\":1}}],[\"如果对应小标正好没有存放数据\",{\"1\":{\"695\":1}}],[\"如果散列本身做得不好\",{\"1\":{\"694\":1}}],[\"如果初始化hashmap\",{\"0\":{\"689\":1},\"1\":{\"689\":1}}],[\"如果添加相同的键\",{\"1\":{\"687\":1}}],[\"如果当前运行的线程数大于\",{\"1\":{\"868\":1}}],[\"如果当前线程是最后一个持有锁的线程\",{\"1\":{\"839\":1}}],[\"如果当前对象内部的属性是引用类型的话\",{\"1\":{\"784\":1}}],[\"如果当前数组位置是空则直接通过cas自旋写入数据\",{\"1\":{\"711\":1}}],[\"如果当前数组的长度小于\",{\"1\":{\"686\":1,\"706\":1}}],[\"如果当前位置存在元素的话\",{\"1\":{\"686\":1}}],[\"如果相同的话\",{\"1\":{\"686\":1}}],[\"如果传一个值不是2的倍数\",{\"1\":{\"685\":1}}],[\"如果传输介质闲置\",{\"1\":{\"581\":1}}],[\"如果多个设备同时尝试发送数据\",{\"1\":{\"581\":1}}],[\"如果您还有其他问题\",{\"1\":{\"526\":1}}],[\"如果验证失败\",{\"1\":{\"495\":1}}],[\"如果验证通过\",{\"1\":{\"495\":1}}],[\"如果存在锁竞争\",{\"1\":{\"837\":1}}],[\"如果存在\",{\"1\":{\"495\":1}}],[\"如果缓存中不存在查询结果\",{\"1\":{\"495\":1}}],[\"如果代码的相似之处只是因为业务上的差异或上下文的变化\",{\"1\":{\"486\":1}}],[\"如果遵循里氏替换原则\",{\"1\":{\"469\":1}}],[\"如果不一致\",{\"1\":{\"820\":1}}],[\"如果不足则可用内存就一直减少\",{\"1\":{\"818\":1}}],[\"如果不使用threadlocal\",{\"1\":{\"817\":1}}],[\"如果不进行隔离\",{\"1\":{\"759\":1}}],[\"如果不进行调制\",{\"1\":{\"619\":1}}],[\"如果不断往常量池添加数据\",{\"1\":{\"731\":1}}],[\"如果不可以\",{\"0\":{\"703\":1},\"1\":{\"703\":1}}],[\"如果不是\",{\"1\":{\"597\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"826\":1}}],[\"如果不存在\",{\"1\":{\"495\":1}}],[\"如果不遵循开闭原则\",{\"1\":{\"465\":1}}],[\"如果不能处理请求\",{\"1\":{\"350\":1}}],[\"如果不能处理\",{\"1\":{\"348\":1,\"350\":1}}],[\"如果以后需要更改或替换发送电子邮件的方式\",{\"1\":{\"461\":1}}],[\"如果\",{\"1\":{\"436\":1,\"727\":1,\"739\":1,\"744\":1,\"769\":1}}],[\"如果是方法底层会自动声明为acc\",{\"1\":{\"843\":1}}],[\"如果是正常的响应没有问题\",{\"1\":{\"817\":1}}],[\"如果是成员变量\",{\"1\":{\"773\":1}}],[\"如果是红黑树按照红黑树获取\",{\"1\":{\"711\":1}}],[\"如果是则进行扩容操作\",{\"1\":{\"695\":1}}],[\"如果是\",{\"1\":{\"422\":1}}],[\"如果是开启状态\",{\"1\":{\"360\":1}}],[\"如果前缀不匹配任何条件\",{\"1\":{\"422\":1}}],[\"如果未来需要创建更多实例以满足不同需求\",{\"1\":{\"421\":1}}],[\"如果实例已存在\",{\"1\":{\"418\":1}}],[\"如果实例不存在\",{\"1\":{\"418\":1}}],[\"如果备忘录对象过多或状态较大\",{\"1\":{\"379\":1}}],[\"如果需要频繁操作字符串\",{\"1\":{\"789\":1}}],[\"如果需要线程安全的操作\",{\"1\":{\"706\":1}}],[\"如果需要有序的键值对集合\",{\"1\":{\"705\":1}}],[\"如果需要快速的插入\",{\"1\":{\"705\":1}}],[\"如果需要安卓其他盘\",{\"1\":{\"538\":1}}],[\"如果需要对子系统进行更细粒度的控制或定制化操作\",{\"1\":{\"519\":1}}],[\"如果需要创建类似但略有差异的单例\",{\"1\":{\"421\":1}}],[\"如果需要取消之前的某些操作\",{\"1\":{\"375\":1}}],[\"如果需要在遍历过程中修改集合\",{\"1\":{\"367\":1}}],[\"如果需要将信号在模拟信道传输\",{\"1\":{\"239\":1}}],[\"如果在多线程环境下需要对字符串进行操作\",{\"1\":{\"789\":1}}],[\"如果在使用\",{\"1\":{\"788\":1}}],[\"如果在代码中通过类名引用了某个类的静态成员\",{\"1\":{\"755\":1}}],[\"如果在\",{\"1\":{\"740\":1}}],[\"如果在同一次迭代中多次调用remove\",{\"1\":{\"367\":1}}],[\"如果在调用remove\",{\"1\":{\"367\":2}}],[\"如果在这种通信方式下使用了可靠传输的网络协议\",{\"1\":{\"184\":1}}],[\"如果状态发生改变\",{\"1\":{\"359\":1}}],[\"如果版本不兼容\",{\"1\":{\"346\":1}}],[\"如果策略选择逻辑复杂\",{\"1\":{\"345\":1}}],[\"如果策略较多\",{\"1\":{\"345\":1}}],[\"如果算法的变化点过多\",{\"1\":{\"339\":1}}],[\"如果观察者较多或处理逻辑较复杂\",{\"1\":{\"328\":1}}],[\"如果继续发送大量数据包\",{\"1\":{\"296\":1}}],[\"如果某个数据在类的多个方法中需要共享或者访问\",{\"1\":{\"816\":1}}],[\"如果某个子网需要容纳更多主机\",{\"1\":{\"222\":1}}],[\"如果某条线路出现故障\",{\"1\":{\"255\":1}}],[\"如果某条静态路由中间经过的跳数大于1\",{\"1\":{\"205\":1}}],[\"如果使用对象作为键\",{\"1\":{\"788\":1}}],[\"如果使用\",{\"1\":{\"222\":1}}],[\"如果主机所在的网络要接入因特网\",{\"1\":{\"167\":1}}],[\"如果只是一个单独网络\",{\"1\":{\"167\":1}}],[\"如果帧中的vid与端口的pvid相等\",{\"1\":{\"159\":1}}],[\"如果帧内部恰好也出现了标志位\",{\"1\":{\"132\":1}}],[\"如果要保证一个代码块的原子性\",{\"1\":{\"825\":1}}],[\"如果要在无线网卡上实现碰撞检测cd\",{\"1\":{\"152\":1}}],[\"如果要发送的数据非常少\",{\"1\":{\"152\":1}}],[\"如果检测到总线空闲\",{\"1\":{\"152\":1}}],[\"如果恰巧有两个或更多的站点在同一时刻发送数据\",{\"1\":{\"152\":1}}],[\"如果接收到的分组有误\",{\"1\":{\"139\":1}}],[\"如果接收方检测到分组失序\",{\"1\":{\"138\":1}}],[\"如果丢失一个分组\",{\"1\":{\"138\":1}}],[\"如果有则不去抢锁\",{\"1\":{\"840\":1}}],[\"如果有多个线程在等待只会任意唤醒一个\",{\"1\":{\"785\":1}}],[\"如果有其他线程对集合进行了修改\",{\"1\":{\"710\":1}}],[\"如果有的话\",{\"1\":{\"526\":1}}],[\"如果有偶数个位发生误码\",{\"1\":{\"134\":1,\"576\":1}}],[\"如果有奇数个位发生误码\",{\"1\":{\"134\":1,\"576\":1}}],[\"如果有帧丢失了怎么办\",{\"1\":{\"133\":1}}],[\"如果有帧出现了错误怎么办\",{\"1\":{\"133\":1}}],[\"如果有可用的ip地址\",{\"1\":{\"64\":1}}],[\"如果文档没有发生变化\",{\"1\":{\"114\":1}}],[\"如果文档在代理服务器中已经过期或者被标记为无效\",{\"1\":{\"114\":1}}],[\"如果文档在代理服务器中未过期\",{\"1\":{\"114\":1}}],[\"如果它们一致\",{\"1\":{\"114\":1}}],[\"如果原始服务器中文档的修改时间与代理服务器缓存的文档的修改时间不一致\",{\"1\":{\"114\":1}}],[\"如果原始服务器中的文档已经被修改\",{\"1\":{\"114\":2}}],[\"如果原始服务器中的文档已经修改\",{\"1\":{\"114\":1}}],[\"如果本地域名服务器无法对域名进行解析\",{\"1\":{\"71\":1}}],[\"如文件共享网络\",{\"1\":{\"59\":1}}],[\"如npm\",{\"1\":{\"22\":1,\"48\":1}}],[\"如需开放其他软件的端口也是在此操作\",{\"1\":{\"3\":1,\"5\":1,\"29\":1,\"31\":1}}],[\"六个窗口都满了\",{\"1\":{\"868\":1}}],[\"六\",{\"0\":{\"21\":1,\"47\":1,\"101\":1,\"163\":1,\"169\":1,\"362\":1,\"479\":1,\"521\":1,\"856\":1}}],[\"测试库\",{\"1\":{\"539\":1}}],[\"测试扩展库\",{\"1\":{\"539\":1}}],[\"测试对象的行为变得更加容易\",{\"1\":{\"490\":1}}],[\"测试困难\",{\"1\":{\"465\":1}}],[\"测试的简化\",{\"1\":{\"461\":1}}],[\"测试性强的代码即可\",{\"1\":{\"458\":1}}],[\"测试部分\",{\"1\":{\"436\":1}}],[\"测试\",{\"1\":{\"372\":2,\"436\":1,\"539\":1}}],[\"测试安装效果\",{\"1\":{\"20\":1,\"46\":1}}],[\"测试在\",{\"1\":{\"8\":1,\"34\":1}}],[\"使每个线程都可顺利完成\",{\"1\":{\"848\":1}}],[\"使操作系统重新夺回对cpu\",{\"1\":{\"809\":1}}],[\"使数据能够通过物理媒介进行传输\",{\"1\":{\"617\":1}}],[\"使客户端与子系统之间的交互更加简单和直观\",{\"1\":{\"520\":1}}],[\"使它们可以独立地变化\",{\"1\":{\"504\":1,\"505\":1,\"506\":1}}],[\"使系统的各个部分更加独立和解耦\",{\"1\":{\"486\":1}}],[\"使系统更具灵活性和可维护性\",{\"1\":{\"482\":1}}],[\"使构建过程更加灵活和可控\",{\"1\":{\"451\":1}}],[\"使代码更具弹性和适应性\",{\"1\":{\"465\":1}}],[\"使代码更加灵活和可维护\",{\"1\":{\"361\":1}}],[\"使代码更加清晰和易于维护\",{\"1\":{\"360\":1,\"361\":1}}],[\"使代码更加清晰\",{\"1\":{\"346\":1}}],[\"使代码难以扩展和维护\",{\"1\":{\"422\":1}}],[\"使应用程序能够与其运行的环境相连接\",{\"1\":{\"419\":1}}],[\"使发送方尽快进行重传\",{\"1\":{\"299\":1}}],[\"使之成为帧\",{\"1\":{\"268\":2}}],[\"使之成为ip数据报\",{\"1\":{\"268\":1}}],[\"使之成为tcp报文段\",{\"1\":{\"268\":1}}],[\"使通信初始化\",{\"1\":{\"212\":1}}],[\"使源点知道应当把数据报发送速率放慢\",{\"1\":{\"201\":1}}],[\"使多对主机能同时通信\",{\"1\":{\"173\":1}}],[\"使整个以太网仍然能正常工作\",{\"1\":{\"170\":1}}],[\"使帧长不小于64字节\",{\"1\":{\"152\":1}}],[\"使两对节点之间的通信不会发生互相干扰\",{\"1\":{\"144\":1}}],[\"使其进入安全状态\",{\"1\":{\"848\":1}}],[\"使其能够在正确的情况下释放相应的锁\",{\"1\":{\"813\":1}}],[\"使其能够处理更多种类的信息\",{\"1\":{\"96\":1}}],[\"使其更容易被团队成员理解和使用\",{\"1\":{\"482\":1}}],[\"使其数据发送速率不超过接收端所能承受的数据接收能力\",{\"1\":{\"140\":1,\"576\":1}}],[\"使接收端的数据链路层对从物理层传输而来的一串串比特流以帧为单位进行区分\",{\"1\":{\"131\":1}}],[\"使tcp连接中的空闲时间减少\",{\"1\":{\"112\":1}}],[\"使同一个客户\",{\"1\":{\"112\":1}}],[\"使得在第一个线程看来\",{\"1\":{\"845\":1}}],[\"使得最终结果不是期望的\",{\"1\":{\"829\":1}}],[\"使得难以确定其他对象是否存在锁\",{\"1\":{\"813\":1}}],[\"使得操作系统可以在多个任务之间快速切换\",{\"1\":{\"809\":1}}],[\"使得哈希表的性能下降\",{\"1\":{\"696\":1}}],[\"使得哈希表的性能更高效\",{\"1\":{\"696\":1}}],[\"使得添加的元素均匀分布在hashmap的每个位置上\",{\"1\":{\"688\":1}}],[\"使得数据能够在长距离传输时更可靠\",{\"1\":{\"618\":1}}],[\"使得数据能够在网络中准确地路由到目标设备\",{\"1\":{\"593\":1}}],[\"使得数据能够正确地从源设备传输到目标设备\",{\"1\":{\"593\":1}}],[\"使得数据可以在物理介质上传输\",{\"1\":{\"573\":1,\"577\":1}}],[\"使得数据结构中的元素可以接受不同类型的访问者对象\",{\"1\":{\"370\":1}}],[\"使得单个对象和组合对象能够以一致的方式进行处理\",{\"1\":{\"526\":1}}],[\"使得客户端更加方便地与子系统进行交互\",{\"1\":{\"517\":1}}],[\"使得客户端代码与具体产品的实现解耦\",{\"1\":{\"439\":1,\"443\":1}}],[\"使得不兼容的类或接口可以协同工作\",{\"1\":{\"512\":1}}],[\"使得原本由于接口不匹配而无法合作的类可以一起工作\",{\"1\":{\"508\":1}}],[\"使得每个接口和实现类都专注于特定的任务\",{\"1\":{\"474\":1}}],[\"使得类或模块只需实现与其业务相关的接口\",{\"1\":{\"472\":1}}],[\"使得修改复制后的对象不会影响原始对象\",{\"1\":{\"455\":1}}],[\"使得复制后的对象与原始对象完全独立\",{\"1\":{\"455\":1}}],[\"使得一个对象的状态变化可以通知到多个观察者对象\",{\"1\":{\"411\":1}}],[\"使得一个对象的变化可以通知到多个观察者对象\",{\"1\":{\"411\":2}}],[\"使得对象之间的通信更加简单和灵活\",{\"1\":{\"411\":1}}],[\"使得对象之间的通信更加灵活和解耦\",{\"1\":{\"411\":1}}],[\"使得对象之间的通信更加灵活和可扩展\",{\"1\":{\"399\":1}}],[\"使得对象之间不需要直接相互通信\",{\"1\":{\"411\":1}}],[\"使得对象在不同状态下具有不同的行为\",{\"1\":{\"357\":1}}],[\"使得我们能够根据不同的规则条件进行灵活的评估和处理\",{\"1\":{\"395\":1}}],[\"使得我们可以轻松地添加新的动物子类\",{\"1\":{\"469\":1}}],[\"使得我们可以方便地新增其他的访问者来处理不同的操作\",{\"1\":{\"372\":1}}],[\"使得我们可以灵活地扩展和修改报告生成的某些步骤\",{\"1\":{\"336\":1}}],[\"使得我们可以通过易于记忆的域名来访问网站\",{\"1\":{\"67\":1}}],[\"使得系统的结构更加清晰\",{\"1\":{\"410\":1}}],[\"使得系统更加灵活和易于扩展\",{\"1\":{\"506\":1}}],[\"使得系统更加灵活和可扩展\",{\"1\":{\"384\":1,\"473\":1}}],[\"使得系统更加灵活可扩展\",{\"1\":{\"432\":1}}],[\"使得系统更加易于维护和扩展\",{\"1\":{\"385\":2}}],[\"使得系统具有更好的扩展性和可维护性\",{\"1\":{\"355\":1}}],[\"使得扩展和修改更加方便\",{\"1\":{\"451\":1}}],[\"使得扩展和添加新功能变得非常简单\",{\"1\":{\"361\":1}}],[\"使得扩展新功能更加灵活\",{\"1\":{\"373\":1}}],[\"使得聚合对象可以专注于管理元素\",{\"1\":{\"364\":1}}],[\"使得代码变得复杂和难以维护\",{\"1\":{\"465\":1}}],[\"使得代码结构变得更加复杂\",{\"1\":{\"367\":1}}],[\"使得代码更具可读性\",{\"1\":{\"458\":1}}],[\"使得代码更易于扩展和维护\",{\"1\":{\"361\":1}}],[\"使得代码更加专注和可理解\",{\"1\":{\"473\":1}}],[\"使得代码更加清晰\",{\"1\":{\"473\":1}}],[\"使得代码更加清晰和易于维护\",{\"1\":{\"357\":1,\"366\":1}}],[\"使得代码更加可扩展和可维护\",{\"1\":{\"465\":1}}],[\"使得代码更加模块化\",{\"1\":{\"461\":1,\"474\":1}}],[\"使得代码更加灵活和易于维护\",{\"1\":{\"367\":1}}],[\"使得代码更加灵活和可扩展\",{\"1\":{\"346\":1}}],[\"使得代码更加灵活\",{\"1\":{\"333\":1,\"500\":1}}],[\"使得代码的含义更加明确\",{\"1\":{\"361\":1}}],[\"使得请求的发送者和接收者解耦\",{\"1\":{\"382\":1}}],[\"使得请求依次经过各个filter进行处理\",{\"1\":{\"352\":1}}],[\"使得请求发送者无需知道是哪个接收者处理了请求\",{\"1\":{\"351\":1}}],[\"使得发布\",{\"1\":{\"326\":1}}],[\"使得主题\",{\"1\":{\"323\":1}}],[\"使得当一个对象的状态发生变化时\",{\"1\":{\"322\":1}}],[\"使得它们按照线性顺序排列\",{\"1\":{\"311\":1}}],[\"使得邮件客户端能够正确地解析和显示邮件内容\",{\"1\":{\"96\":1}}],[\"使得邮件可以包含二进制文件\",{\"1\":{\"96\":1}}],[\"使得用户能够方便地完成特定的网络任务\",{\"1\":{\"56\":1}}],[\"使设备能够顺利地进行通信\",{\"1\":{\"62\":1}}],[\"使更改的配置立即生效\",{\"1\":{\"19\":1,\"45\":1}}],[\"使用原子的方式更新数组里的某个元素\",{\"1\":{\"847\":1}}],[\"使用原子的方式更新基本类型\",{\"1\":{\"847\":1}}],[\"使用原子类\",{\"1\":{\"844\":1}}],[\"使用cas实现\",{\"1\":{\"847\":1}}],[\"使用crc校验算法计算的校验值\",{\"1\":{\"575\":1}}],[\"使用volatile修饰变量\",{\"1\":{\"844\":1}}],[\"使用vim命令修改\",{\"1\":{\"19\":1,\"45\":1}}],[\"使用同步机制\",{\"1\":{\"844\":1}}],[\"使用一个整型变量\",{\"1\":{\"839\":1}}],[\"使用无锁算法\",{\"1\":{\"832\":1}}],[\"使用诸如\",{\"1\":{\"832\":1}}],[\"使用起来很简单\",{\"1\":{\"822\":1}}],[\"使用锁来保护共享资源\",{\"1\":{\"811\":1}}],[\"使用反射来实现各种功能\",{\"1\":{\"800\":1}}],[\"使用通配符来表示未知类型或者限制类型的上界或下界\",{\"1\":{\"797\":1}}],[\"使用介绍一下\",{\"0\":{\"795\":1},\"1\":{\"795\":2}}],[\"使用日志打印异常之后就不要再抛出异常了\",{\"1\":{\"793\":1}}],[\"使用abstract\",{\"1\":{\"783\":1}}],[\"使用arp协议可以通过该ip地址获取到设备的mac地址\",{\"1\":{\"168\":1,\"583\":1}}],[\"使用jstack查看线程堆栈信息\",{\"1\":{\"849\":1}}],[\"使用jstat\",{\"1\":{\"769\":1}}],[\"使用jps查找运行的java进程\",{\"1\":{\"849\":1}}],[\"使用java的反射机制\",{\"1\":{\"755\":1}}],[\"使用threadlocal\",{\"1\":{\"811\":1}}],[\"使用thread\",{\"1\":{\"811\":1}}],[\"使用top\",{\"1\":{\"769\":1}}],[\"使用tcp连接交换路由信息的两个bgp发言人\",{\"1\":{\"212\":1}}],[\"使用tcp实现可靠传输\",{\"1\":{\"83\":1}}],[\"使用率飙升\",{\"1\":{\"769\":1}}],[\"使用内存分析工具\",{\"1\":{\"767\":1}}],[\"使用web\",{\"1\":{\"760\":1}}],[\"使用双亲委派机制可以防止恶意类替换系统核心类\",{\"1\":{\"758\":1}}],[\"使用三色标记法\",{\"1\":{\"748\":1}}],[\"使用这个平均值与老年代剩余空间进行比较\",{\"1\":{\"743\":1}}],[\"使用完调用remove\",{\"1\":{\"818\":1}}],[\"使用完threadlocal后\",{\"1\":{\"818\":1}}],[\"使用完\",{\"1\":{\"731\":1}}],[\"使用不当\",{\"1\":{\"731\":1}}],[\"使用句柄来访问的最大好处就是栈中的引用存储的是稳定句柄地址\",{\"1\":{\"730\":1}}],[\"使用永久代实现方法区\",{\"1\":{\"723\":1}}],[\"使用即时编译器\",{\"1\":{\"721\":1}}],[\"使用哈希表\",{\"1\":{\"715\":1}}],[\"使用哈希表存储键值对\",{\"1\":{\"705\":1}}],[\"使用reentrantlock加锁\",{\"1\":{\"711\":1}}],[\"使用线程安全的集合类\",{\"1\":{\"844\":1}}],[\"使用线程安全的集合\",{\"1\":{\"710\":1}}],[\"使用的\",{\"1\":{\"764\":1}}],[\"使用的是链表\",{\"1\":{\"706\":1}}],[\"使用的还是csma\",{\"1\":{\"170\":1}}],[\"使用链表或红黑树来解决冲突\",{\"1\":{\"706\":1}}],[\"使用键来唯一标识每个值\",{\"1\":{\"704\":1}}],[\"使用键值对\",{\"1\":{\"671\":1}}],[\"使用扰动函数\",{\"1\":{\"700\":1}}],[\"使用随机哈希码\",{\"1\":{\"697\":1}}],[\"使用xml文件描述app界面\",{\"1\":{\"540\":1}}],[\"使用享元设计模式可以有效地减少系统资源的消耗\",{\"1\":{\"533\":1}}],[\"使用适配器设计模式进行适配\",{\"1\":{\"511\":1}}],[\"使用新的支付接口实现进行支付操作\",{\"1\":{\"510\":1}}],[\"使用新的支付接口支付的\",{\"1\":{\"510\":2}}],[\"使用新的支付接口进行支付\",{\"1\":{\"510\":1}}],[\"使用老的支付接口支付的\",{\"1\":{\"510\":1}}],[\"使用老的支付接口进行支付\",{\"1\":{\"510\":1}}],[\"使用示例\",{\"1\":{\"506\":1,\"510\":1}}],[\"使用组合替代继承对某些原生对象的方法做增强\",{\"1\":{\"500\":1}}],[\"使用proxy类的静态方法newproxyinstance\",{\"1\":{\"496\":1}}],[\"使用成熟的代码库和框架可以避免从零开始编写一些通用功能\",{\"1\":{\"485\":1}}],[\"使用继承和接口\",{\"1\":{\"485\":1}}],[\"使用方法\",{\"1\":{\"485\":1}}],[\"使用单一责任原则的代码在维护时具有更高的可维护性\",{\"1\":{\"461\":1}}],[\"使用单一责任原则的代码降低了引入错误的风险\",{\"1\":{\"461\":1}}],[\"使用单一责任原则的代码示例\",{\"1\":{\"461\":1}}],[\"使用单例模式可以控制对象的创建和访问\",{\"1\":{\"421\":1}}],[\"使用浅拷贝来创建歌曲和歌单对象\",{\"1\":{\"454\":1}}],[\"使用工厂模式\",{\"1\":{\"452\":1}}],[\"使用工厂设计模式可以将对象的创建逻辑封装到工厂类中\",{\"1\":{\"422\":1}}],[\"使用该模式可能会带来一定的开销\",{\"1\":{\"451\":1}}],[\"使用该示例\",{\"1\":{\"450\":1}}],[\"使用builder模式可能会显得过于复杂\",{\"1\":{\"451\":1}}],[\"使用builder模式可以将这些步骤分解为独立的方法\",{\"1\":{\"447\":1}}],[\"使用简单工厂模式\",{\"1\":{\"429\":1}}],[\"使用了线程池的话可让多个不相关联的任务同时执行\",{\"1\":{\"857\":1}}],[\"使用了\",{\"1\":{\"785\":1}}],[\"使用了简单工厂模式\",{\"1\":{\"429\":1}}],[\"使用了icmp回送请求和回答报文以及差错报告报文\",{\"1\":{\"200\":1}}],[\"使用冒号进行分割\",{\"1\":{\"422\":1}}],[\"使用条件语句判断前缀是什么\",{\"1\":{\"422\":1}}],[\"使用客户端\",{\"1\":{\"393\":1}}],[\"使用命令模式\",{\"1\":{\"385\":1}}],[\"使用迭代器自身的\",{\"1\":{\"710\":1}}],[\"使用迭代器遍历\",{\"1\":{\"702\":1}}],[\"使用迭代器遍历并输出superarray对象中的元素\",{\"1\":{\"366\":1}}],[\"使用迭代器的remove\",{\"1\":{\"367\":1}}],[\"使用迭代器模式可能会增加代码复杂性\",{\"1\":{\"367\":1}}],[\"使用迭代器模式可能会显得过于繁琐\",{\"1\":{\"367\":1}}],[\"使用状态设计模式可以将复杂的对象行为拆分成独立的类\",{\"1\":{\"361\":1}}],[\"使用状态模式可以避免大量的条件语句\",{\"1\":{\"360\":1}}],[\"使用场景和案例\",{\"0\":{\"510\":1}}],[\"使用场景和具体案例\",{\"0\":{\"325\":1,\"333\":1,\"344\":1,\"351\":1,\"366\":1,\"372\":1,\"378\":1,\"384\":1,\"391\":1,\"405\":1}}],[\"使用场景\",{\"0\":{\"360\":1,\"419\":1,\"428\":1,\"435\":1,\"442\":1,\"449\":1,\"517\":1,\"531\":1},\"1\":{\"495\":1,\"496\":1,\"581\":1,\"704\":1}}],[\"使用策略设计模式和工厂设计模式可以有效消除代码中的\",{\"1\":{\"346\":1}}],[\"使用策略设计模式可以使代码更加清晰\",{\"1\":{\"345\":1}}],[\"使用策略设计模式能够更好地组织和管理这些复杂的支付流程\",{\"1\":{\"344\":1}}],[\"使用信用卡支付\",{\"1\":{\"344\":1}}],[\"使用微信支付\",{\"1\":{\"344\":1}}],[\"使用支付宝支付\",{\"1\":{\"344\":1}}],[\"使用模板方法可能会导致类的层次结构变得复杂\",{\"1\":{\"339\":1}}],[\"使用模板方法设计模式\",{\"1\":{\"336\":1}}],[\"使用函数t\",{\"1\":{\"316\":1}}],[\"使用大o计数法表示\",{\"1\":{\"313\":1}}],[\"使用udp进行数据传输时不能进行流量控制和拥塞控制\",{\"1\":{\"301\":1}}],[\"使用慢开始算法\",{\"1\":{\"299\":1}}],[\"使用快重传可以使整个网络的吞吐量提高约20\",{\"1\":{\"299\":1}}],[\"使用相应的确认号即可\",{\"1\":{\"290\":1}}],[\"使用时登记\",{\"1\":{\"279\":1}}],[\"使用ospf的各路由器基于lsdb进行最短路径优先spf计算\",{\"1\":{\"210\":1}}],[\"使用ospf的每个路由器都有一个链路状态数据库lsdb\",{\"1\":{\"210\":1}}],[\"使用ospf的每个路由器都会产生链路状态通告lsa\",{\"1\":{\"210\":1}}],[\"使用洪泛法向自治系统内所有路由器发送信息\",{\"1\":{\"210\":1}}],[\"使用跳数作为度量来衡量到达目的网络的距离\",{\"1\":{\"208\":1}}],[\"使用icmp回送请求和回答报文\",{\"1\":{\"200\":1}}],[\"使用集线器的以太网在逻辑上仍是一个总线网\",{\"1\":{\"170\":1}}],[\"使用集中器收集各个用户的数据\",{\"1\":{\"148\":1}}],[\"使用sifs的帧类型由ack帧\",{\"1\":{\"152\":1}}],[\"使用卫星链路及重传时\",{\"1\":{\"137\":1}}],[\"使用广播信道的数据链路层\",{\"1\":{\"121\":1,\"144\":1}}],[\"使用供应商的邮件服务器而不是自己的\",{\"1\":{\"99\":1}}],[\"使用浏览器登录电子邮箱来收发电子邮件\",{\"1\":{\"99\":1}}],[\"使用\",{\"1\":{\"94\":1,\"212\":1,\"326\":1,\"343\":1,\"346\":1,\"485\":1,\"498\":1,\"681\":3,\"702\":3,\"706\":1,\"731\":1,\"754\":1,\"762\":1,\"766\":1,\"769\":4,\"788\":3,\"789\":1,\"794\":1,\"816\":6,\"831\":2,\"839\":2,\"842\":1}}],[\"使用和续约ip地址以及释放ip地址等步骤\",{\"1\":{\"64\":1}}],[\"使用外网地址和用户名密码进行登录\",{\"1\":{\"3\":1,\"29\":1}}],[\"使用终端模拟器\",{\"1\":{\"3\":1,\"29\":1}}],[\"使用云服务器\",{\"1\":{\"1\":1,\"27\":1}}],[\"在帮你调整格式和完善代码前\",{\"1\":{\"870\":1}}],[\"在于提交的任务是否需要返回值\",{\"1\":{\"863\":1}}],[\"在最终获取结果时\",{\"1\":{\"855\":1}}],[\"在它们结束后都可以执行特定动作\",{\"1\":{\"852\":1}}],[\"在读多写少的情况下\",{\"1\":{\"842\":1}}],[\"在轻量级锁升级为重量级锁时\",{\"1\":{\"837\":1}}],[\"在没有多线程竞争时\",{\"1\":{\"837\":1}}],[\"在没有遵循开闭原则的情况下\",{\"1\":{\"465\":1}}],[\"在无竞争的情况下\",{\"1\":{\"837\":1}}],[\"在无线局域网中\",{\"1\":{\"152\":2}}],[\"在执行完对应的代码块之后\",{\"1\":{\"836\":1}}],[\"在执行该方法时\",{\"1\":{\"495\":2}}],[\"在判断拥有同步标识\",{\"1\":{\"835\":1}}],[\"在我们微服务的架构下\",{\"1\":{\"869\":1}}],[\"在我们这个工作当中\",{\"1\":{\"831\":1}}],[\"在我们的旅行团场景中\",{\"1\":{\"372\":1}}],[\"在多线程的访问情况下\",{\"1\":{\"826\":1}}],[\"在多线程环境中使用时\",{\"1\":{\"715\":1}}],[\"在多线程环境下提供了安全的并发访问\",{\"1\":{\"844\":1}}],[\"在多线程环境下执行\",{\"1\":{\"844\":1}}],[\"在多线程环境下\",{\"1\":{\"706\":1,\"707\":1,\"710\":1}}],[\"在多线程环境下使用时\",{\"1\":{\"706\":1}}],[\"在子线程中就可以拿到了\",{\"1\":{\"822\":1}}],[\"在thread\",{\"1\":{\"822\":1}}],[\"在thread类里还有另外一个变量\",{\"1\":{\"822\":1}}],[\"在threadlocalmap\",{\"1\":{\"821\":1}}],[\"在tcp\",{\"1\":{\"273\":1}}],[\"在get的时候\",{\"1\":{\"820\":1}}],[\"在控制层可以根据这个token\",{\"1\":{\"817\":1}}],[\"在控制台上打印\",{\"1\":{\"794\":1}}],[\"在自己的map里找对应的key\",{\"1\":{\"816\":1}}],[\"在并发编程中\",{\"1\":{\"858\":1}}],[\"在并发环境下\",{\"1\":{\"814\":1}}],[\"在并发标记阶段\",{\"1\":{\"748\":1}}],[\"在当前线程下再通过get\",{\"1\":{\"811\":1}}],[\"在微观上是交替进行的\",{\"1\":{\"805\":1}}],[\"在性能要求高的场景下\",{\"1\":{\"799\":1}}],[\"在底层\",{\"1\":{\"799\":1}}],[\"在许多编程语言中都有反射机制\",{\"1\":{\"798\":1}}],[\"在循环内使用\",{\"1\":{\"790\":1}}],[\"在实现自定义类并将其用作哈希表的键时\",{\"1\":{\"788\":1}}],[\"在实现自定义类时\",{\"1\":{\"788\":1}}],[\"在实际设计中\",{\"1\":{\"474\":1}}],[\"在实际项目中\",{\"1\":{\"473\":1,\"474\":1}}],[\"在实际应用中\",{\"1\":{\"353\":1,\"403\":1,\"408\":1}}],[\"在实际的电商平台中\",{\"1\":{\"344\":1}}],[\"在实际统计中通常忽略不计\",{\"1\":{\"317\":1}}],[\"在实际中较少使用\",{\"1\":{\"152\":1}}],[\"在哈希表中\",{\"1\":{\"787\":1}}],[\"在线程持有写锁的情况下\",{\"1\":{\"842\":1}}],[\"在线程持有读锁的情况下\",{\"1\":{\"842\":1}}],[\"在线程栈信息中找到对应线程号的\",{\"1\":{\"769\":1}}],[\"在线商店渠道\",{\"1\":{\"506\":1}}],[\"在重写的方法中\",{\"1\":{\"759\":1}}],[\"在重构后的代码中\",{\"1\":{\"481\":1}}],[\"在初始化阶段才会变为\",{\"1\":{\"754\":1}}],[\"在准备阶段\",{\"1\":{\"754\":1}}],[\"在内存中生成该类的\",{\"1\":{\"754\":1}}],[\"在内部使用了\",{\"1\":{\"839\":1}}],[\"在内部实现\",{\"1\":{\"705\":1}}],[\"在内部断开与出故障网卡的连线\",{\"1\":{\"170\":1}}],[\"在哪使用的\",{\"0\":{\"748\":1},\"1\":{\"748\":2}}],[\"在哪种网络中使用\",{\"0\":{\"581\":1},\"1\":{\"581\":1}}],[\"在即时编译过程中\",{\"1\":{\"747\":1}}],[\"在引用对象赋值时会产生一个环形通知\",{\"1\":{\"742\":1}}],[\"在年轻代gc中\",{\"1\":{\"741\":1}}],[\"在对象层面来说就是非收集区域对象对收集区域对象的引用的记录\",{\"1\":{\"742\":1}}],[\"在对象的对象头信息中存储着对象的迭代年龄\",{\"1\":{\"740\":1}}],[\"在对象被移动\",{\"1\":{\"730\":1}}],[\"在要进行\",{\"1\":{\"739\":1}}],[\"在新生代的垃圾收集过程中\",{\"1\":{\"737\":1}}],[\"在人犯被处决之前\",{\"1\":{\"736\":1}}],[\"在系统将要发生内存溢出异常前\",{\"1\":{\"735\":1}}],[\"在系统演进中\",{\"1\":{\"510\":1}}],[\"在动态加载大量类文件时\",{\"1\":{\"731\":1}}],[\"在分配的时候从列表中找到一块足够大的空间划分给对象实例\",{\"1\":{\"727\":1}}],[\"在分级路由算法的思想下\",{\"1\":{\"211\":1}}],[\"在分级路由算法中\",{\"1\":{\"211\":1}}],[\"在构造器方法<init>中进行对象的初始化工作\",{\"1\":{\"726\":1}}],[\"在堆内存中为新创建的对象分配内存空间\",{\"1\":{\"726\":1}}],[\"在堆中分配的内存\",{\"1\":{\"724\":1}}],[\"在堆中分配的内存实际用于建立这个对象\",{\"1\":{\"724\":1}}],[\"在虚拟机启动时创建\",{\"1\":{\"722\":1}}],[\"在虚拟电路通信中\",{\"1\":{\"184\":2}}],[\"在程序运行过程中\",{\"1\":{\"720\":1}}],[\"在维护顺序的情况下\",{\"1\":{\"715\":1}}],[\"在添加\",{\"1\":{\"715\":1}}],[\"在保留\",{\"1\":{\"714\":1}}],[\"在迭代器进行遍历时\",{\"1\":{\"710\":1}}],[\"在迭代器遍历过程中\",{\"1\":{\"710\":1}}],[\"在创建迭代器时\",{\"1\":{\"710\":1}}],[\"在遍历期间原集合发生的修改迭代器是不知道的\",{\"1\":{\"709\":1}}],[\"在遍历时不是直接在集合内容上访问的\",{\"1\":{\"709\":1}}],[\"在拷贝的集合上进行遍历\",{\"1\":{\"709\":1}}],[\"在用迭代器遍历一个集合对象时\",{\"1\":{\"709\":1}}],[\"在jvm\",{\"1\":{\"810\":1}}],[\"在jvm中\",{\"1\":{\"741\":1}}],[\"在jdk1\",{\"1\":{\"708\":2,\"711\":1,\"837\":1,\"843\":1}}],[\"在java虚拟机\",{\"1\":{\"835\":1}}],[\"在java当中\",{\"1\":{\"831\":1}}],[\"在java中\",{\"1\":{\"455\":1,\"733\":1,\"799\":1,\"808\":1,\"845\":1}}],[\"在java\",{\"1\":{\"352\":1}}],[\"在java的标准库中\",{\"1\":{\"335\":1}}],[\"在单线程环境下\",{\"1\":{\"706\":1,\"789\":1}}],[\"在解决哈希冲突时有了较大的变化\",{\"1\":{\"706\":1}}],[\"在插入时\",{\"1\":{\"701\":1}}],[\"在冲突的位置拉一个链表\",{\"1\":{\"692\":1}}],[\"在必要的时候进行扩容\",{\"1\":{\"690\":1}}],[\"在hashmap的初始化中\",{\"1\":{\"689\":1}}],[\"在http\",{\"1\":{\"113\":1}}],[\"在扩容后的效果\",{\"1\":{\"688\":1}}],[\"在扩容时\",{\"1\":{\"688\":1}}],[\"在键值对中\",{\"1\":{\"687\":1}}],[\"在大多数情况下\",{\"1\":{\"685\":1}}],[\"在元素数量超过负载因子\",{\"1\":{\"685\":1}}],[\"在什么情况下会选择使用tcp或udp\",{\"0\":{\"637\":1}}],[\"在什么时候会超时\",{\"0\":{\"564\":1}}],[\"在数字通信中\",{\"1\":{\"620\":1}}],[\"在数据库访问中\",{\"1\":{\"858\":1}}],[\"在数据库连接池中\",{\"1\":{\"421\":1}}],[\"在数据传输过程中\",{\"1\":{\"573\":1,\"577\":1}}],[\"在数据发送结束时也无须释放连接了\",{\"1\":{\"301\":1}}],[\"在数据链路层\",{\"1\":{\"580\":1}}],[\"在数据链路层传输数据时\",{\"1\":{\"577\":1}}],[\"在数据链路层提到了流量控制功能\",{\"1\":{\"187\":1,\"592\":1}}],[\"在数据链路层中要形成一条更有利于数据传输的数据链路\",{\"1\":{\"123\":1}}],[\"在数据链路层中\",{\"0\":{\"581\":1},\"1\":{\"120\":1,\"581\":1}}],[\"在计算机或网络配置中设置默认网关是很重要的\",{\"1\":{\"597\":1}}],[\"在计算机网络中\",{\"1\":{\"296\":1,\"617\":1}}],[\"在服务器上设置不同的虚拟主机或网站\",{\"1\":{\"594\":1}}],[\"在互联网中\",{\"1\":{\"594\":1}}],[\"在全双工通信中\",{\"1\":{\"582\":1}}],[\"在半双工通信中\",{\"1\":{\"582\":1}}],[\"在交换机的\",{\"1\":{\"579\":1}}],[\"在传统的双亲委派机制下\",{\"1\":{\"759\":1}}],[\"在传统的以太网中\",{\"1\":{\"581\":1}}],[\"在传统的网络设置中\",{\"1\":{\"579\":1}}],[\"在传输层使用udp协议进行封装\",{\"1\":{\"280\":1}}],[\"在传输层内部\",{\"1\":{\"274\":1}}],[\"在此层制定统一协议\",{\"1\":{\"573\":1}}],[\"在此tcp连接上交换bgp报文以建立bgp会话\",{\"1\":{\"212\":1}}],[\"在组合类中实现对子节点的管理操作\",{\"1\":{\"524\":1}}],[\"在酒店预订系统中\",{\"1\":{\"517\":1}}],[\"在电商系统中\",{\"1\":{\"517\":1}}],[\"在电话通信中\",{\"1\":{\"239\":1}}],[\"在桥接模式中\",{\"1\":{\"504\":1}}],[\"在示例中\",{\"1\":{\"502\":1,\"510\":2}}],[\"在打印\",{\"1\":{\"502\":4}}],[\"在装饰器模式\",{\"1\":{\"500\":1}}],[\"在代理设计模式中\",{\"1\":{\"500\":1}}],[\"在代理类中添加远程通信的逻辑\",{\"1\":{\"495\":2}}],[\"在代理类中创建远程服务对象\",{\"1\":{\"495\":1}}],[\"在代理类中\",{\"1\":{\"495\":5}}],[\"在代理类中实现接口中的方法\",{\"1\":{\"494\":1,\"495\":1}}],[\"在运行时可以通过反射机制\",{\"1\":{\"799\":1}}],[\"在运行时\",{\"1\":{\"722\":1}}],[\"在运行代码时\",{\"1\":{\"498\":1}}],[\"在运行该示例代码时\",{\"1\":{\"498\":1}}],[\"在运输层使用udp协议\",{\"1\":{\"200\":1}}],[\"在方法调用后的逻辑处理\",{\"1\":{\"497\":1,\"498\":1}}],[\"在方法调用前的逻辑处理\",{\"1\":{\"497\":1,\"498\":1}}],[\"在相同的查询被频繁执行时\",{\"1\":{\"495\":1}}],[\"在调用代理对象的\",{\"1\":{\"497\":1}}],[\"在调用远程服务对象的方法之前和之后\",{\"1\":{\"495\":1}}],[\"在调用父类方法之前和之后\",{\"1\":{\"495\":1}}],[\"在调用父类方法之前添加额外的逻辑\",{\"1\":{\"495\":1}}],[\"在调用父类方法之后添加额外的逻辑\",{\"1\":{\"495\":1}}],[\"在调用remove\",{\"1\":{\"367\":2}}],[\"在静态代理中\",{\"1\":{\"495\":1}}],[\"在静态代码块中\",{\"1\":{\"436\":1}}],[\"在评估重复代码时\",{\"1\":{\"486\":1}}],[\"在编写代码时\",{\"1\":{\"480\":1}}],[\"在不修改现有代码的情况下实现接口之间的互操作性和交互\",{\"1\":{\"512\":1}}],[\"在不符合里氏替换原则的示例中\",{\"1\":{\"469\":1}}],[\"在不遵循里氏替换原则的情况下\",{\"1\":{\"469\":1}}],[\"在不同自治系统内\",{\"1\":{\"212\":1}}],[\"在不同网络中只能通过三层地址\",{\"1\":{\"191\":1}}],[\"在改进后的代码中\",{\"1\":{\"465\":1}}],[\"在前端开发中\",{\"1\":{\"455\":1}}],[\"在订单管理系统中\",{\"1\":{\"455\":1}}],[\"在转成内存模型的对象\",{\"1\":{\"455\":1}}],[\"在促销活动中的clone方法需要克隆里边所有的非基础数据类型\",{\"1\":{\"455\":1}}],[\"在进行深拷贝时\",{\"1\":{\"455\":1}}],[\"在playlist类中\",{\"1\":{\"454\":1}}],[\"在p2p网络中\",{\"1\":{\"59\":1}}],[\"在userbuilder类中\",{\"1\":{\"450\":1}}],[\"在user类中\",{\"1\":{\"450\":3}}],[\"在lombok中\",{\"1\":{\"450\":1}}],[\"在llc子层中提供了\",{\"1\":{\"120\":1}}],[\"在basiccomputerbuilder类中\",{\"1\":{\"448\":1}}],[\"在类的非静态成员不存在的时候静态方法就已经存在了\",{\"1\":{\"778\":1}}],[\"在类加载时\",{\"1\":{\"443\":1}}],[\"在类加载的时候就会分配内存\",{\"1\":{\"778\":1,\"779\":1}}],[\"在类加载的时候\",{\"1\":{\"436\":1}}],[\"在类内部创建一个私有静态成员变量\",{\"1\":{\"418\":1}}],[\"在简单工厂模式中\",{\"1\":{\"430\":1}}],[\"在简单的情况下\",{\"1\":{\"367\":1}}],[\"在resourceloader类中\",{\"1\":{\"429\":1}}],[\"在工厂方法中根据不同的参数\",{\"1\":{\"427\":1}}],[\"在日志记录中\",{\"1\":{\"421\":1}}],[\"在容器中管理单例实例\",{\"1\":{\"421\":1}}],[\"在输出结果中\",{\"1\":{\"403\":1}}],[\"在飞机交通管制系统中\",{\"1\":{\"401\":1}}],[\"在命令模式中\",{\"1\":{\"386\":1}}],[\"在需要访问远程对象时\",{\"1\":{\"495\":1}}],[\"在需要对敏感操作进行访问控制和验证的场景下\",{\"1\":{\"495\":1}}],[\"在需要执行命令时调用其execute方法\",{\"1\":{\"383\":1}}],[\"在需要执行命令时调用command的execute方法\",{\"1\":{\"383\":1}}],[\"在需要的时候又可把数据传给与之直接相连的下一台设备\",{\"1\":{\"275\":1}}],[\"在软件开发中\",{\"1\":{\"375\":1}}],[\"在文本编辑器中\",{\"1\":{\"375\":2}}],[\"在文件末尾加入如下配置\",{\"1\":{\"19\":1,\"45\":1}}],[\"在测试部分\",{\"1\":{\"372\":2}}],[\"在上面的代码中\",{\"1\":{\"497\":1}}],[\"在上面的示例中\",{\"1\":{\"372\":1}}],[\"在上面的java代码中\",{\"1\":{\"372\":1}}],[\"在上述代码中\",{\"1\":{\"461\":2,\"465\":1,\"481\":1}}],[\"在上述示例中\",{\"1\":{\"350\":1,\"359\":1,\"495\":5,\"525\":1}}],[\"在上述实现中\",{\"1\":{\"346\":1}}],[\"在删除元素之前\",{\"1\":{\"367\":1}}],[\"在每个\",{\"1\":{\"827\":4}}],[\"在每个应用程序的web\",{\"1\":{\"760\":1}}],[\"在每个分支中\",{\"1\":{\"422\":1}}],[\"在每个数据帧的前部加上一个帧头部\",{\"1\":{\"130\":1}}],[\"在每次调用next\",{\"1\":{\"367\":1}}],[\"在使用之前就对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理\",{\"1\":{\"871\":1}}],[\"在使用线程池处理任务的时候\",{\"1\":{\"865\":1}}],[\"在使用哈希表时\",{\"1\":{\"788\":1}}],[\"在使用\",{\"1\":{\"681\":1,\"788\":1}}],[\"在使用该模式时需要注意外部状态的处理和线程安全性\",{\"1\":{\"533\":1}}],[\"在使用该模式时\",{\"1\":{\"519\":1}}],[\"在使用第三方库或组件时\",{\"1\":{\"510\":1}}],[\"在使用单一责任原则的代码中\",{\"1\":{\"461\":3}}],[\"在使用单例模式时\",{\"1\":{\"421\":2}}],[\"在使用简单工厂模式时\",{\"1\":{\"430\":1}}],[\"在使用中介者模式时\",{\"1\":{\"410\":1}}],[\"在使用时需要权衡其优缺点\",{\"1\":{\"396\":1}}],[\"在使用迭代器遍历集合的同时\",{\"1\":{\"367\":1}}],[\"在使用迭代器内的remove\",{\"1\":{\"367\":1}}],[\"在使用状态模式时\",{\"1\":{\"361\":1}}],[\"在下列案例中\",{\"1\":{\"429\":1}}],[\"在下列示例中\",{\"1\":{\"325\":1}}],[\"在下面这个简单的案例中\",{\"1\":{\"400\":1}}],[\"在下面例子中\",{\"1\":{\"366\":1}}],[\"在具体抽象部分类中使用实现部分对象\",{\"1\":{\"505\":1}}],[\"在具体聚合对象中实现迭代器接口\",{\"1\":{\"365\":1}}],[\"在具体的子类中\",{\"1\":{\"338\":1}}],[\"在处理复杂的状态逻辑时\",{\"1\":{\"361\":1}}],[\"在关机的状态下执行以下的操作\",{\"1\":{\"360\":1}}],[\"在object类中有一些函数可以用于线程的等待与通知\",{\"1\":{\"807\":1}}],[\"在on状态下\",{\"1\":{\"360\":1}}],[\"在osi\",{\"1\":{\"276\":1}}],[\"在任务调度系统中\",{\"1\":{\"355\":1}}],[\"在企业软件开发过程中\",{\"1\":{\"355\":1}}],[\"在企业中\",{\"1\":{\"333\":1}}],[\"在应用程序中\",{\"1\":{\"355\":1}}],[\"在spring框架中\",{\"1\":{\"352\":1}}],[\"在合适的场景下\",{\"1\":{\"345\":1}}],[\"在设计时需要权衡灵活性和复杂性之间的平衡\",{\"1\":{\"444\":1}}],[\"在设计和实现时\",{\"1\":{\"385\":1}}],[\"在设计和开发过程中\",{\"1\":{\"339\":1}}],[\"在设计ipv4地址时就专门在前面介绍的a\",{\"1\":{\"217\":1}}],[\"在一些情况下\",{\"1\":{\"696\":1}}],[\"在一些简单的场景下\",{\"1\":{\"339\":1}}],[\"在一个在线支付系统中\",{\"1\":{\"845\":1}}],[\"在一个事件驱动的系统中\",{\"1\":{\"355\":1}}],[\"在一个电子邮件处理系统中\",{\"1\":{\"355\":1}}],[\"在一个工作流引擎中\",{\"1\":{\"355\":1}}],[\"在一个字符代码的最后加上一个\",{\"1\":{\"235\":1}}],[\"在main类的main方法中\",{\"1\":{\"502\":1}}],[\"在main类中\",{\"1\":{\"448\":1}}],[\"在mac地址中\",{\"1\":{\"166\":1}}],[\"在myservletimpl中\",{\"1\":{\"338\":1}}],[\"在游戏开发中\",{\"1\":{\"333\":1}}],[\"在原来的实现方式中\",{\"1\":{\"327\":1}}],[\"在原始的\",{\"1\":{\"119\":1}}],[\"在该方法内部\",{\"1\":{\"418\":1}}],[\"在该方式下\",{\"1\":{\"111\":1,\"112\":1}}],[\"在该模式中\",{\"1\":{\"326\":1}}],[\"在主线程的inheritablethreadlocal实例设置值\",{\"1\":{\"822\":1}}],[\"在主程序中\",{\"1\":{\"346\":2}}],[\"在主类中\",{\"1\":{\"325\":1}}],[\"在主动模式下\",{\"1\":{\"85\":1}}],[\"在n>1000000时比算法\",{\"1\":{\"316\":1}}],[\"在\",{\"1\":{\"316\":1,\"326\":1,\"327\":1,\"344\":1,\"353\":1,\"405\":1,\"422\":1,\"436\":2,\"443\":1,\"450\":1,\"469\":1,\"485\":1,\"497\":1,\"510\":1,\"525\":1,\"687\":2,\"707\":1,\"714\":2,\"715\":2,\"726\":1,\"731\":1,\"735\":3,\"742\":1,\"747\":1,\"769\":1,\"777\":1,\"793\":1,\"827\":1,\"831\":1,\"839\":2,\"840\":1}}],[\"在某些场景下\",{\"1\":{\"758\":1}}],[\"在某些业务场景下\",{\"1\":{\"355\":1}}],[\"在某些情况下\",{\"1\":{\"294\":1,\"361\":1}}],[\"在某运行平台下\",{\"1\":{\"315\":1}}],[\"在因特网中不同计算机的相同端口是没有联系的\",{\"1\":{\"279\":1}}],[\"在web服务器中\",{\"1\":{\"858\":1}}],[\"在web应用程序中\",{\"1\":{\"355\":1}}],[\"在web\",{\"1\":{\"268\":1}}],[\"在路由器中\",{\"1\":{\"268\":3}}],[\"在同一\",{\"1\":{\"580\":1}}],[\"在同一系统中相邻两层的实体交换信息的逻辑接口\",{\"1\":{\"251\":1}}],[\"在同一以太局域网内部\",{\"1\":{\"191\":1}}],[\"在协议的控制下\",{\"1\":{\"251\":1}}],[\"在通信领域中\",{\"1\":{\"240\":1}}],[\"在通信结束后\",{\"1\":{\"184\":1}}],[\"在整个码元时间内\",{\"1\":{\"238\":1}}],[\"在整个ftp会话期间保持打开状态\",{\"1\":{\"85\":1}}],[\"在收发双方之间加一条单独的时钟信号线\",{\"1\":{\"236\":1}}],[\"在flsm中\",{\"1\":{\"222\":1}}],[\"在斜线后面写上网络前缀所占比特数量\",{\"1\":{\"220\":1}}],[\"在a\",{\"1\":{\"217\":1}}],[\"在配置bgp时\",{\"1\":{\"212\":1}}],[\"在其路由表中\",{\"1\":{\"211\":1}}],[\"在网络层\",{\"1\":{\"580\":1}}],[\"在网络层仍然可以根据网络的mtu值进行分割\",{\"1\":{\"301\":1}}],[\"在网络层都需要使用ip协议封装成ip数据报\",{\"1\":{\"280\":1}}],[\"在网络出现拥堵时\",{\"1\":{\"296\":1}}],[\"在网络拥塞的情况下\",{\"1\":{\"294\":1}}],[\"在网络中传输速度相对较慢\",{\"1\":{\"580\":1}}],[\"在网络中丢失的数据包会导致重传\",{\"1\":{\"296\":1}}],[\"在网络中采用发送方和接收方的套接字组合来识别端点\",{\"1\":{\"279\":1}}],[\"在网络中某条路由所包括的路由器同时启动了某种动态路由协议\",{\"1\":{\"206\":1}}],[\"在网络拓扑结构发生变化时及时更新拓扑图即可\",{\"1\":{\"210\":1}}],[\"在网际层使用\",{\"1\":{\"200\":1}}],[\"在ipv4中\",{\"1\":{\"595\":1}}],[\"在ipv4网络中\",{\"1\":{\"205\":1}}],[\"在ip数据报首部设置ttl字段\",{\"1\":{\"205\":1}}],[\"在icmp时间戳回答报文中有一个32比特的字段\",{\"1\":{\"201\":1}}],[\"在局域网中实现虚拟局域网\",{\"1\":{\"575\":1}}],[\"在局域网中的身份\",{\"1\":{\"574\":1}}],[\"在局域网中\",{\"1\":{\"196\":1}}],[\"在这段代码中\",{\"1\":{\"443\":1}}],[\"在这些设备中\",{\"1\":{\"582\":1}}],[\"在这些方法中\",{\"1\":{\"495\":1}}],[\"在这些场景中\",{\"1\":{\"355\":1}}],[\"在这些情况下\",{\"1\":{\"316\":1}}],[\"在这种情况下\",{\"1\":{\"355\":1,\"518\":1,\"525\":1}}],[\"在这种网络中\",{\"1\":{\"223\":1}}],[\"在这种通信方式下\",{\"1\":{\"184\":1}}],[\"在这个同步点\",{\"1\":{\"854\":1}}],[\"在这个状态下\",{\"1\":{\"837\":1}}],[\"在这个阶段执行类构造器\",{\"1\":{\"720\":1}}],[\"在这个没有使用工厂设计模式的例子中\",{\"1\":{\"422\":1}}],[\"在这个客户端代码中\",{\"1\":{\"408\":1}}],[\"在这个聊天应用程序中\",{\"1\":{\"406\":1}}],[\"在这个场景中\",{\"1\":{\"378\":1}}],[\"在这个案例中\",{\"1\":{\"344\":1}}],[\"在这个示例中\",{\"1\":{\"327\":1,\"346\":1,\"354\":1,\"448\":1,\"450\":2,\"518\":2,\"524\":1}}],[\"在这个例子中\",{\"1\":{\"221\":1,\"335\":1,\"383\":1,\"391\":1,\"395\":1,\"405\":1,\"465\":1,\"485\":2,\"489\":2,\"525\":2}}],[\"在这个时间里由接收状态转变为发送状态\",{\"1\":{\"152\":1}}],[\"在连接建立阶段\",{\"1\":{\"184\":1}}],[\"在帧交换表中查找帧的目的mac地址所对应的接口号\",{\"1\":{\"173\":1}}],[\"在帧的结尾处加上一个帧尾部\",{\"1\":{\"130\":1}}],[\"在华为交换机上称为port\",{\"1\":{\"159\":1}}],[\"在思科交换机上称为native\",{\"1\":{\"159\":1}}],[\"在difs时间后他们会同时发送\",{\"1\":{\"152\":1}}],[\"在dcf方式中用来发送数据帧和管理帧\",{\"1\":{\"152\":1}}],[\"在dcf方式下\",{\"1\":{\"152\":1}}],[\"在发生minor\",{\"1\":{\"743\":1}}],[\"在发生冲突后\",{\"1\":{\"152\":1}}],[\"在发送每一字符代码的前面均加上一个\",{\"1\":{\"235\":1}}],[\"在发送前\",{\"1\":{\"132\":1}}],[\"在发送端添加帧头和帧尾等控制信息\",{\"1\":{\"573\":1}}],[\"在发送端和接收端之间要有n条传输线路\",{\"1\":{\"233\":1}}],[\"在发送端数据链路层中的帧到达物理层后就会以比特位为单位进行传输\",{\"1\":{\"131\":1}}],[\"在发送端\",{\"1\":{\"129\":1}}],[\"在随机接入中\",{\"1\":{\"152\":1}}],[\"在信道永久地分配给用户的应用中\",{\"1\":{\"150\":1}}],[\"在广播信道中所有主机共享通信介质\",{\"1\":{\"144\":1}}],[\"在待发送的传输的二进制代码最后专门设置1个奇偶校验位\",{\"1\":{\"134\":1,\"576\":1}}],[\"在物理层工作\",{\"1\":{\"618\":1}}],[\"在物理层采用特定的比特编码方法时采用\",{\"1\":{\"131\":1}}],[\"在物理层发送前会添加前导码8个\",{\"1\":{\"129\":1}}],[\"在结束位置加了etx控制字符\",{\"1\":{\"131\":1}}],[\"在接收端不被解释为控制字符\",{\"1\":{\"132\":1,\"577\":1}}],[\"在接收端\",{\"1\":{\"129\":1,\"239\":1,\"573\":1}}],[\"在被动模式下\",{\"1\":{\"85\":1}}],[\"在租约过程中\",{\"1\":{\"64\":1}}],[\"在csma的基础上增加了一个碰撞避免ca功能\",{\"1\":{\"152\":1}}],[\"在c\",{\"1\":{\"58\":2}}],[\"在客户端代码中\",{\"1\":{\"344\":1,\"404\":1,\"409\":1,\"524\":1}}],[\"在客户端中使用组合类来构建组合对象的树形结构\",{\"1\":{\"524\":1}}],[\"在客户端中使用抽象工厂接口声明工厂对象\",{\"1\":{\"441\":1}}],[\"在客户端中\",{\"1\":{\"332\":1,\"365\":1,\"371\":1,\"434\":1}}],[\"在客户\",{\"1\":{\"58\":1}}],[\"在本地访问服务器地址即可\",{\"1\":{\"8\":1,\"34\":1}}],[\"进⼊同步代码前要获得当前\",{\"1\":{\"833\":1}}],[\"进制的字符串\",{\"1\":{\"785\":1}}],[\"进制的线程\",{\"1\":{\"765\":1}}],[\"进制值\",{\"1\":{\"769\":1}}],[\"进制\",{\"1\":{\"765\":1,\"769\":1}}],[\"进制表示是\",{\"1\":{\"694\":1}}],[\"进程可以对共享资源的访问进行控制\",{\"1\":{\"853\":1}}],[\"进程通常有两个任务\",{\"1\":{\"804\":1}}],[\"进程是程序的动态存在的状态\",{\"1\":{\"804\":1}}],[\"进程\",{\"0\":{\"804\":1},\"1\":{\"769\":1,\"804\":2}}],[\"进程上\",{\"1\":{\"766\":1}}],[\"进程id\",{\"1\":{\"765\":1,\"849\":1}}],[\"进程何时\",{\"1\":{\"56\":1}}],[\"进⾏计算\",{\"1\":{\"689\":1}}],[\"进而导致数据覆盖的问题\",{\"1\":{\"707\":1}}],[\"进而导致死机\",{\"1\":{\"285\":1}}],[\"进而可能引发concurrentmodificationexception异常\",{\"1\":{\"367\":1}}],[\"进出站\",{\"1\":{\"119\":1}}],[\"进站出站检测\",{\"1\":{\"119\":1}}],[\"进站\",{\"1\":{\"119\":1}}],[\"进入terminated状态\",{\"1\":{\"867\":1}}],[\"进入tidying状态\",{\"1\":{\"867\":2}}],[\"进入阻塞状态\",{\"1\":{\"837\":1}}],[\"进入\",{\"1\":{\"834\":1}}],[\"进入同步代码前要获得\",{\"1\":{\"833\":1}}],[\"进入该状态表示当前线程需要等待其他线程做出一些特定动作\",{\"1\":{\"808\":1}}],[\"进入上传的目录\",{\"1\":{\"23\":1,\"49\":1}}],[\"进入解压后的目录\",{\"1\":{\"18\":1,\"44\":1}}],[\"进行线程上下文切换跟任务调度\",{\"1\":{\"866\":1}}],[\"进行原子性的累加操作\",{\"1\":{\"855\":1}}],[\"进行原子更新时可能出现的\",{\"1\":{\"847\":1}}],[\"进行补偿\",{\"1\":{\"845\":1}}],[\"进行一次抢锁\",{\"1\":{\"840\":1}}],[\"进行操作\",{\"1\":{\"829\":1}}],[\"进行自增操作\",{\"1\":{\"829\":2}}],[\"进行消息的发送和接收\",{\"1\":{\"811\":1}}],[\"进行字符串的拼接的话\",{\"1\":{\"790\":1}}],[\"进行垃圾回收\",{\"1\":{\"750\":1}}],[\"进行垃圾回收的过程中\",{\"1\":{\"747\":1}}],[\"进行扫描\",{\"1\":{\"742\":1}}],[\"进行\",{\"1\":{\"723\":1}}],[\"进行与运算时\",{\"1\":{\"688\":1}}],[\"进行解耦\",{\"1\":{\"540\":1}}],[\"进行支付操作的适配\",{\"1\":{\"510\":1}}],[\"进行安全验证的逻辑\",{\"1\":{\"495\":1}}],[\"进行安全验证\",{\"1\":{\"495\":1}}],[\"进行交互\",{\"1\":{\"436\":1}}],[\"进行了两个规则条件的判断\",{\"1\":{\"395\":1}}],[\"进行条件判断\",{\"1\":{\"395\":1}}],[\"进行的数据校验\",{\"1\":{\"353\":2,\"354\":1}}],[\"进行数据传输前是不需要建立专门的传输连接的\",{\"1\":{\"301\":1}}],[\"进行同步\",{\"1\":{\"238\":1}}],[\"进行双方的通信\",{\"1\":{\"229\":1}}],[\"进行逻辑与运算就可得到ipv4地址所在子网的网络地址\",{\"1\":{\"218\":1}}],[\"进行分配\",{\"1\":{\"215\":1}}],[\"进行复制扩散\",{\"1\":{\"205\":1}}],[\"进行寻址\",{\"1\":{\"191\":1}}],[\"进行校验\",{\"1\":{\"153\":1}}],[\"进行碰撞检测的意义也不大\",{\"1\":{\"152\":1}}],[\"进行访问\",{\"1\":{\"144\":1}}],[\"进行计算\",{\"1\":{\"135\":1,\"576\":1}}],[\"进行文件传送的计算机\",{\"1\":{\"83\":1}}],[\"进行通信\",{\"1\":{\"63\":2,\"223\":1}}],[\"进行相应的处理并将结果返回给客户端\",{\"1\":{\"58\":1}}],[\"进行配置\",{\"1\":{\"14\":1,\"40\":1}}],[\"进行各种软件的安装\",{\"1\":{\"1\":1,\"27\":1}}],[\"五\",{\"0\":{\"15\":1,\"41\":1,\"88\":1,\"160\":1,\"223\":1,\"356\":1,\"475\":1,\"513\":1,\"850\":1}}],[\"四者的区别\",{\"1\":{\"671\":1}}],[\"四次挥手过程中\",{\"0\":{\"646\":1}}],[\"四次挥手过程消息描述\",{\"1\":{\"286\":1}}],[\"四次挥手的过程\",{\"0\":{\"644\":1}}],[\"四次挥手\",{\"1\":{\"286\":1}}],[\"四大特性包括了物理层相关内容的规范和定义\",{\"1\":{\"227\":1}}],[\"四级域名\",{\"1\":{\"69\":1}}],[\"四\",{\"0\":{\"12\":1,\"38\":1,\"82\":1,\"154\":1,\"213\":1,\"347\":1,\"453\":1,\"471\":1,\"507\":1,\"761\":1,\"830\":1}}],[\"zgc\",{\"1\":{\"752\":1}}],[\"zip\",{\"1\":{\"538\":2}}],[\"zhangsan\",{\"1\":{\"455\":1}}],[\"zero\",{\"1\":{\"294\":1}}],[\"zxvf\",{\"1\":{\"18\":1,\"44\":1}}],[\"zz172425\",{\"1\":{\"11\":1,\"37\":1}}],[\"zone=perserver\",{\"1\":{\"8\":1,\"34\":1}}],[\"zone=perip\",{\"1\":{\"8\":1,\"34\":1}}],[\"zone\",{\"1\":{\"8\":2,\"34\":2}}],[\"ilp\",{\"1\":{\"826\":1}}],[\"illegalaccessexception\",{\"1\":{\"436\":1,\"443\":1,\"793\":1}}],[\"illegalargumentexception的子类\",{\"1\":{\"793\":1}}],[\"illegalargumentexception\",{\"1\":{\"343\":1,\"346\":3,\"793\":1}}],[\"ic\",{\"1\":{\"539\":2}}],[\"icon=\",{\"1\":{\"539\":1}}],[\"icmp时间戳请求报文是请某个主机或路由器回答当前的日期和时间\",{\"1\":{\"201\":1}}],[\"icmp回送请求报文是由主机或路由器向一个特定的目的主机发出的询问\",{\"1\":{\"201\":1}}],[\"icmp报文首部\",{\"1\":{\"202\":1}}],[\"icmp报文组成过程\",{\"1\":{\"202\":1}}],[\"icmp报文格式\",{\"0\":{\"202\":1}}],[\"icmp报文类型\",{\"0\":{\"201\":1}}],[\"icmp报文被封装在ip数据报中发送\",{\"1\":{\"200\":1}}],[\"icmp依靠ip协议来完成其任务\",{\"1\":{\"200\":1}}],[\"icmp是\",{\"1\":{\"200\":1}}],[\"icmp协议及报文格式\",{\"0\":{\"199\":1}}],[\"it\",{\"1\":{\"480\":1,\"482\":1}}],[\"items\",{\"1\":{\"384\":5}}],[\"item\",{\"1\":{\"384\":18}}],[\"iterator<map\",{\"1\":{\"436\":1,\"443\":1,\"702\":1}}],[\"iterator\",{\"1\":{\"363\":1,\"365\":9,\"366\":10,\"436\":4,\"443\":4,\"490\":1,\"702\":4}}],[\"iresource\",{\"1\":{\"443\":6}}],[\"iresourcefactory>\",{\"1\":{\"436\":1,\"443\":1}}],[\"iresourcefactory\",{\"1\":{\"436\":8,\"443\":6}}],[\"ibatis\",{\"1\":{\"419\":2}}],[\"io密集型\",{\"1\":{\"866\":3}}],[\"iostat\",{\"1\":{\"762\":1}}],[\"io库提供了一组用于处理输入和输出的类和接口\",{\"1\":{\"500\":1}}],[\"ioc\",{\"1\":{\"477\":1}}],[\"ioexception\",{\"1\":{\"335\":8,\"338\":9,\"436\":1,\"443\":1,\"793\":2}}],[\"io\",{\"1\":{\"335\":2,\"419\":2,\"762\":1,\"768\":1,\"838\":1,\"842\":1}}],[\"immutable\",{\"1\":{\"831\":2}}],[\"immutableperson\",{\"1\":{\"450\":14}}],[\"imageproxy\",{\"1\":{\"495\":5}}],[\"image\",{\"1\":{\"495\":11}}],[\"imap4\",{\"1\":{\"98\":2}}],[\"imap\",{\"0\":{\"98\":1},\"1\":{\"90\":1,\"98\":1}}],[\"implementation\",{\"1\":{\"539\":3}}],[\"implementor\",{\"1\":{\"504\":2,\"505\":1}}],[\"implements\",{\"1\":{\"325\":2,\"326\":2,\"327\":2,\"343\":2,\"344\":3,\"346\":6,\"350\":3,\"359\":2,\"360\":2,\"365\":1,\"366\":1,\"372\":9,\"383\":2,\"384\":2,\"390\":3,\"394\":4,\"403\":2,\"408\":2,\"436\":1,\"443\":4,\"448\":1,\"454\":1,\"455\":3,\"465\":2,\"473\":1,\"489\":2,\"495\":8,\"497\":2,\"498\":1,\"502\":2,\"506\":5,\"510\":3,\"511\":2,\"524\":2,\"525\":5,\"838\":1,\"842\":1,\"870\":2}}],[\"import\",{\"1\":{\"327\":4,\"335\":1,\"870\":2}}],[\"i++\",{\"1\":{\"314\":1,\"315\":2,\"316\":5,\"366\":1,\"844\":3,\"870\":1}}],[\"i\",{\"1\":{\"314\":2,\"315\":2,\"316\":11,\"366\":3,\"695\":2,\"819\":1,\"821\":1,\"844\":9,\"870\":3}}],[\"igrp\",{\"1\":{\"211\":1}}],[\"igp协议包括rip\",{\"1\":{\"211\":1}}],[\"igp间交换路由信息的协议\",{\"1\":{\"211\":1}}],[\"isinterrupted\",{\"1\":{\"807\":2}}],[\"isis协议分层展示\",{\"1\":{\"211\":1}}],[\"isis协议\",{\"0\":{\"211\":1},\"1\":{\"206\":1,\"211\":1}}],[\"isempty\",{\"1\":{\"378\":1}}],[\"isendofstream\",{\"1\":{\"335\":3}}],[\"ison\",{\"1\":{\"360\":7}}],[\"iso\",{\"1\":{\"268\":1}}],[\"is\",{\"1\":{\"211\":2,\"360\":7,\"372\":6,\"383\":2}}],[\"isp提高了代码的内聚性\",{\"1\":{\"474\":1}}],[\"isp的目标是避免客户端依赖不需要的方法\",{\"1\":{\"474\":1}}],[\"isp的作用\",{\"1\":{\"249\":1}}],[\"isp可以从因特网管理机构申请到成块的ip地址\",{\"1\":{\"249\":1}}],[\"isp\",{\"0\":{\"249\":1},\"1\":{\"77\":1,\"249\":3,\"474\":3}}],[\"id等字段\",{\"1\":{\"575\":1}}],[\"ideal\",{\"1\":{\"240\":2}}],[\"identified\",{\"1\":{\"11\":3,\"37\":3}}],[\"id由优先级和mac地址组成\",{\"1\":{\"175\":1}}],[\"id\",{\"1\":{\"159\":4,\"175\":1,\"461\":1,\"497\":5,\"498\":5,\"539\":1,\"729\":1,\"765\":3,\"769\":2,\"855\":1}}],[\"ieee\",{\"1\":{\"158\":3,\"166\":1}}],[\"ifs\",{\"1\":{\"152\":1}}],[\"if\",{\"1\":{\"114\":2,\"326\":2,\"343\":4,\"346\":8,\"350\":5,\"353\":2,\"360\":3,\"365\":1,\"366\":1,\"378\":2,\"384\":1,\"422\":4,\"429\":4,\"436\":1,\"443\":1,\"465\":3,\"495\":2,\"497\":1,\"498\":1,\"511\":2,\"525\":1,\"695\":1,\"707\":2,\"821\":3,\"822\":1,\"826\":3,\"836\":1,\"870\":6}}],[\"ip是身份证号\",{\"1\":{\"594\":1}}],[\"ip最重要的一些应用程序\",{\"1\":{\"279\":1}}],[\"ip体系的应用进程进行标识\",{\"1\":{\"279\":1}}],[\"ip体系结构的传输层中还是把其中传输的数据单元称为数据段\",{\"1\":{\"278\":1}}],[\"ip体系结构的网际层\",{\"1\":{\"168\":1,\"583\":1}}],[\"ip体系结构的网际层所使用的的地址\",{\"1\":{\"167\":1}}],[\"ip体系结构中\",{\"1\":{\"273\":1}}],[\"ip首部\",{\"1\":{\"194\":1}}],[\"ipv4和ipv6的区别是什么\",{\"0\":{\"599\":1}}],[\"ipv4应用规划\",{\"0\":{\"222\":1}}],[\"ipv4的分类编址主要分为五类\",{\"1\":{\"217\":1}}],[\"ipv4\",{\"0\":{\"602\":1},\"1\":{\"215\":1}}],[\"ipv4地址在设计时就考虑到地址分配的层次特点\",{\"1\":{\"216\":1}}],[\"ipv4地址编址经历了三个主要历史阶段\",{\"1\":{\"215\":1}}],[\"ipv4地址编址方法\",{\"1\":{\"215\":1}}],[\"ipv4地址是一个32位二进制数\",{\"1\":{\"574\":1}}],[\"ipv4地址是一个32比特的标识符\",{\"1\":{\"215\":1}}],[\"ipv4地址是是什么\",{\"1\":{\"215\":1}}],[\"ipv4地址介绍\",{\"0\":{\"215\":1}}],[\"ipv4地址\",{\"0\":{\"213\":1}}],[\"ipv4数据报首部格式\",{\"1\":{\"194\":1}}],[\"ipv4数据报首部\",{\"0\":{\"194\":1}}],[\"ipv4协议\",{\"0\":{\"189\":1},\"1\":{\"189\":1}}],[\"ip协议是互联网中的基础协议之一\",{\"1\":{\"593\":1}}],[\"ip协议是一种网络层协议\",{\"1\":{\"593\":1}}],[\"ip协议将数据拆分为多个分组\",{\"1\":{\"593\":1}}],[\"ip协议允许在不同的物理网络之间进行通信\",{\"1\":{\"593\":1}}],[\"ip协议为数据包提供了地址信息\",{\"1\":{\"593\":1}}],[\"ip协议的定义和作用\",{\"0\":{\"593\":1},\"1\":{\"593\":1}}],[\"ip协议的应用层协议\",{\"1\":{\"87\":1}}],[\"ip协议栈中的许多协议都会使用广播\",{\"1\":{\"159\":1}}],[\"ip数据报的首部格式作用是使ip数据报可以在互联网传输\",{\"1\":{\"268\":1}}],[\"ip数据报进入路由器后\",{\"1\":{\"205\":1}}],[\"ip数据报永久兜圈\",{\"1\":{\"205\":1}}],[\"ip数据报\",{\"1\":{\"131\":1,\"194\":1}}],[\"ip\",{\"0\":{\"594\":2,\"601\":1},\"1\":{\"71\":2,\"74\":1,\"75\":2,\"76\":1,\"77\":1,\"78\":1,\"79\":1,\"81\":1,\"268\":1,\"579\":2,\"580\":2,\"593\":1,\"594\":2}}],[\"ip地址分类\",{\"1\":{\"595\":1}}],[\"ip地址分配\",{\"1\":{\"222\":1}}],[\"ip地址标识计算机\",{\"1\":{\"594\":1}}],[\"ip地址的分类有哪些\",{\"0\":{\"600\":1}}],[\"ip地址的分配和管理是网络运行的基础\",{\"1\":{\"593\":1}}],[\"ip地址的应用规划是指在一个网络环境中\",{\"1\":{\"222\":1}}],[\"ip地址到mac地址的映射\",{\"1\":{\"583\":1}}],[\"ip地址通常分为ipv4和ipv6两种格式\",{\"1\":{\"574\":1}}],[\"ip地址由因特网名字和数字分配机构icann\",{\"1\":{\"215\":1}}],[\"ip地址是网络通信的基础\",{\"1\":{\"594\":1}}],[\"ip地址是在网络中唯一标识设备的地址\",{\"1\":{\"593\":1}}],[\"ip地址是在网络通信中用来识别和定位设备的数字标签\",{\"1\":{\"574\":1}}],[\"ip地址是internet上的主机和路由器所使用的的地址\",{\"1\":{\"167\":1}}],[\"ip地址是tcp\",{\"1\":{\"167\":1}}],[\"ip地址\",{\"0\":{\"163\":1,\"167\":1},\"1\":{\"68\":1,\"71\":1}}],[\"ip地址释放\",{\"1\":{\"64\":1}}],[\"ip地址续约\",{\"1\":{\"64\":1}}],[\"ip地址租用\",{\"1\":{\"64\":1}}],[\"instruction\",{\"1\":{\"826\":1}}],[\"instantiationexception\",{\"1\":{\"436\":1,\"443\":1,\"793\":1}}],[\"instance=new\",{\"1\":{\"826\":1}}],[\"instanceof\",{\"1\":{\"525\":1}}],[\"instance\",{\"1\":{\"436\":2,\"443\":2}}],[\"installer\",{\"1\":{\"538\":1}}],[\"install\",{\"1\":{\"3\":5,\"24\":3,\"29\":5,\"50\":3}}],[\"inheritthreadlocals\",{\"1\":{\"822\":1}}],[\"inheritablethreadlocals\",{\"1\":{\"822\":4}}],[\"inheritablethreadlocaltest\",{\"1\":{\"822\":1}}],[\"inheritablethreadlocal\",{\"1\":{\"822\":2}}],[\"init的时候\",{\"1\":{\"822\":1}}],[\"initiatepayment\",{\"1\":{\"510\":4}}],[\"initialization\",{\"1\":{\"720\":1}}],[\"initialcapacity\",{\"1\":{\"689\":2}}],[\"initial\",{\"1\":{\"8\":1,\"34\":1}}],[\"inf\",{\"1\":{\"760\":2}}],[\"information\",{\"1\":{\"207\":1,\"372\":1}}],[\"invalid\",{\"1\":{\"495\":1}}],[\"inventorysystem\",{\"1\":{\"518\":7}}],[\"inventoryservice\",{\"1\":{\"489\":3}}],[\"inventory\",{\"1\":{\"489\":23}}],[\"inversion\",{\"1\":{\"476\":1}}],[\"invoke\",{\"1\":{\"497\":4,\"498\":1}}],[\"invoker\",{\"1\":{\"382\":1,\"383\":2,\"386\":1}}],[\"invocationhandler\",{\"1\":{\"497\":1}}],[\"invocationtargetexception\",{\"1\":{\"436\":1,\"443\":1}}],[\"incrementandget\",{\"1\":{\"844\":1,\"870\":1}}],[\"increment\",{\"1\":{\"819\":2,\"844\":1}}],[\"inch\",{\"1\":{\"448\":1}}],[\"include\",{\"1\":{\"8\":4,\"34\":4}}],[\"inputpassword\",{\"1\":{\"495\":2}}],[\"input\",{\"1\":{\"343\":4,\"346\":6,\"378\":8}}],[\"inputstream那么多子类\",{\"1\":{\"500\":1}}],[\"inputstream类是一个抽象类\",{\"1\":{\"335\":1}}],[\"inputstream类\",{\"1\":{\"335\":1}}],[\"inputstream\",{\"0\":{\"335\":1},\"1\":{\"335\":2,\"436\":5,\"443\":10}}],[\"in\",{\"1\":{\"343\":1,\"346\":1,\"495\":1,\"720\":1}}],[\"intent\",{\"1\":{\"539\":3}}],[\"integer>\",{\"1\":{\"844\":1}}],[\"integer\",{\"1\":{\"450\":6,\"774\":1}}],[\"interrupted\",{\"1\":{\"807\":1}}],[\"interruptedexception\",{\"1\":{\"327\":1,\"785\":3,\"793\":1,\"863\":1,\"870\":2}}],[\"interrupt\",{\"1\":{\"807\":2}}],[\"internalerror\",{\"1\":{\"793\":1}}],[\"intern\",{\"1\":{\"725\":1,\"791\":3}}],[\"internet控制报文协议\",{\"1\":{\"200\":1}}],[\"internet\",{\"1\":{\"94\":1,\"96\":1,\"200\":1,\"215\":1,\"248\":1,\"249\":1,\"574\":1,\"593\":1}}],[\"inter\",{\"1\":{\"436\":1,\"443\":1}}],[\"interpret\",{\"1\":{\"390\":10,\"393\":1,\"394\":11}}],[\"interpreter\",{\"1\":{\"388\":1,\"490\":1}}],[\"interface\",{\"1\":{\"240\":1,\"325\":2,\"326\":1,\"327\":2,\"343\":1,\"344\":1,\"346\":3,\"350\":1,\"359\":1,\"360\":1,\"365\":1,\"366\":1,\"372\":6,\"383\":1,\"384\":1,\"390\":1,\"394\":1,\"403\":2,\"408\":2,\"436\":1,\"443\":2,\"448\":1,\"465\":1,\"472\":1,\"473\":4,\"474\":1,\"489\":1,\"495\":4,\"497\":1,\"502\":1,\"506\":2,\"510\":2,\"511\":1,\"524\":1,\"525\":2,\"797\":2,\"842\":1}}],[\"interceptor用于在请求被处理之前或之后进行一些公共的处理逻辑\",{\"1\":{\"352\":1}}],[\"interceptor也是一种责任链模式的应用\",{\"1\":{\"352\":1}}],[\"interceptor\",{\"1\":{\"352\":1}}],[\"intercept\",{\"1\":{\"8\":1,\"34\":1,\"498\":2}}],[\"intranet\",{\"1\":{\"223\":1}}],[\"int\",{\"1\":{\"69\":1,\"314\":3,\"315\":3,\"316\":13,\"335\":5,\"343\":15,\"346\":21,\"350\":6,\"360\":6,\"365\":1,\"366\":12,\"372\":3,\"377\":1,\"390\":7,\"394\":10,\"450\":4,\"455\":2,\"461\":4,\"489\":11,\"518\":2,\"689\":4,\"693\":2,\"694\":5,\"726\":1,\"754\":1,\"785\":2,\"795\":2,\"807\":1,\"811\":1,\"819\":3,\"821\":2,\"827\":1,\"829\":2,\"844\":2,\"846\":1,\"847\":4,\"867\":5,\"870\":7}}],[\"indexfor\",{\"1\":{\"694\":2}}],[\"index\",{\"1\":{\"8\":9,\"34\":9,\"366\":2,\"377\":2}}],[\"开关变量等\",{\"1\":{\"834\":1}}],[\"开发者可以根据具体需求选择合适的锁来保证线程安全性\",{\"1\":{\"832\":1}}],[\"开发者选项\",{\"1\":{\"538\":1}}],[\"开中断指令\",{\"1\":{\"809\":1}}],[\"开启用户线程\",{\"1\":{\"746\":1}}],[\"开启访问权限\",{\"1\":{\"11\":2,\"37\":2}}],[\"开闭原则是面向对象设计中的重要原则之一\",{\"1\":{\"466\":1}}],[\"开闭原则\",{\"0\":{\"463\":1},\"1\":{\"464\":1}}],[\"开始\",{\"1\":{\"748\":1}}],[\"开始执行程序的主要逻辑\",{\"1\":{\"720\":1}}],[\"开始执行拥塞避免算法\",{\"1\":{\"299\":1}}],[\"开始发货\",{\"1\":{\"518\":2}}],[\"开始传递\",{\"1\":{\"350\":1}}],[\"开始通话\",{\"1\":{\"125\":1}}],[\"开销小\",{\"1\":{\"205\":1}}],[\"开放地址解决冲突\",{\"1\":{\"821\":1}}],[\"开放定址法就是从冲突的位置再接着往下找\",{\"1\":{\"692\":1}}],[\"开放定址法\",{\"1\":{\"692\":1,\"820\":1}}],[\"开放\",{\"1\":{\"14\":1,\"40\":1}}],[\"开放3306端口\",{\"1\":{\"11\":1,\"37\":1}}],[\"开放端口\",{\"1\":{\"5\":1,\"14\":1,\"31\":1,\"40\":1}}],[\"终止状态\",{\"1\":{\"808\":1}}],[\"终止遍历\",{\"1\":{\"709\":1}}],[\"终结符表达式\",{\"1\":{\"390\":2,\"394\":2}}],[\"终点不可达\",{\"1\":{\"201\":1}}],[\"终端与外部设备等通过双绞线\",{\"1\":{\"155\":1}}],[\"终端登录mysql\",{\"1\":{\"11\":1,\"37\":1}}],[\"终不似\",{\"1\":{\"0\":1}}],[\"7开始\",{\"1\":{\"837\":1}}],[\"731f\",{\"1\":{\"769\":2}}],[\"7及其之前使用永久代\",{\"1\":{\"722\":1}}],[\"7分段锁\",{\"1\":{\"711\":1}}],[\"7中使用分段锁\",{\"1\":{\"708\":1}}],[\"75作为hashmap的默认加载因子呢\",{\"1\":{\"696\":1}}],[\"75=12时\",{\"1\":{\"696\":1}}],[\"75\",{\"0\":{\"696\":1},\"1\":{\"685\":1,\"690\":2,\"696\":6}}],[\"75ω\",{\"1\":{\"230\":1}}],[\"7是基于一个数组+链表形式\",{\"1\":{\"685\":1,\"686\":1}}],[\"7字节的前导码\",{\"1\":{\"575\":1}}],[\"700\",{\"1\":{\"262\":1}}],[\"7090\",{\"1\":{\"8\":3,\"34\":3}}],[\"79\",{\"1\":{\"218\":2}}],[\"76\",{\"1\":{\"218\":3}}],[\"77\",{\"1\":{\"218\":2}}],[\"777\",{\"1\":{\"217\":1}}],[\"7\",{\"0\":{\"80\":1,\"239\":1,\"266\":1,\"328\":1,\"346\":1,\"430\":1,\"452\":1,\"520\":1,\"533\":1,\"553\":1,\"579\":1,\"599\":1,\"623\":1,\"641\":1,\"683\":1,\"691\":1,\"723\":1,\"725\":1,\"739\":1,\"760\":1,\"768\":1,\"779\":1,\"810\":1,\"822\":1,\"837\":1,\"863\":1},\"1\":{\"220\":2,\"221\":1,\"290\":1,\"390\":2,\"455\":3,\"701\":5,\"707\":2,\"711\":3,\"713\":1,\"723\":2,\"760\":1,\"769\":2,\"779\":1}}],[\"7版本的concurrenthashmap采用分段锁机制\",{\"1\":{\"711\":1}}],[\"7版本是基于分段锁实现\",{\"1\":{\"711\":1}}],[\"7版本\",{\"1\":{\"10\":1,\"36\":1}}],[\"三色标记法的引入主要是为了在并发标记的过程中解决引用关系变化的问题\",{\"1\":{\"748\":1}}],[\"三色标记法的核心思想\",{\"1\":{\"748\":1}}],[\"三色标记法主要用于并发标记阶段\",{\"1\":{\"748\":1}}],[\"三色标记法了解吗\",{\"0\":{\"748\":1},\"1\":{\"748\":1}}],[\"三个核心概念\",{\"1\":{\"489\":1}}],[\"三个要素\",{\"0\":{\"157\":1}}],[\"三次握手中每一次没收到报文会发生什么情况\",{\"0\":{\"640\":1}}],[\"三次握手\",{\"1\":{\"285\":1}}],[\"三次握手方式\",{\"1\":{\"285\":1}}],[\"三种交换方式\",{\"1\":{\"252\":1}}],[\"三种特殊的局域网拓扑实现如下\",{\"1\":{\"158\":1}}],[\"三级域名\",{\"1\":{\"69\":1}}],[\"三\",{\"0\":{\"9\":1,\"35\":1,\"65\":1,\"143\":1,\"203\":1,\"240\":1,\"256\":1,\"300\":1,\"340\":1,\"445\":1,\"467\":1,\"503\":1,\"753\":1,\"823\":1}}],[\"8eden\",{\"1\":{\"750\":1}}],[\"8历史变化中的内存区域有什么变化吗\",{\"1\":{\"723\":1}}],[\"8及其之后的元空间作为方法区的实现\",{\"1\":{\"722\":1}}],[\"8实现线程安全不是在数据结构上下功夫\",{\"1\":{\"711\":1}}],[\"8cas+synchronized\",{\"1\":{\"711\":1}}],[\"8是基于cas+synchronized实现\",{\"1\":{\"711\":1}}],[\"8是基于一个数组+链表+红黑树形式\",{\"1\":{\"685\":1,\"686\":1}}],[\"8中使用cas+synchronized\",{\"1\":{\"708\":1}}],[\"8只做一次\",{\"1\":{\"701\":1}}],[\"8对hashmap主要做了哪些优化呢\",{\"0\":{\"701\":1},\"1\":{\"701\":1}}],[\"8折\",{\"1\":{\"465\":2}}],[\"8位\",{\"1\":{\"304\":2}}],[\"8仍然正常接收\",{\"1\":{\"290\":1}}],[\"8192byte\",{\"1\":{\"260\":1}}],[\"81\",{\"1\":{\"166\":1}}],[\"8u171\",{\"1\":{\"18\":1,\"44\":1}}],[\"8\",{\"0\":{\"81\":1,\"267\":1,\"554\":1,\"580\":1,\"600\":1,\"642\":1,\"692\":1,\"723\":1,\"726\":1,\"740\":1,\"769\":1,\"780\":1,\"811\":1,\"838\":1,\"864\":1},\"1\":{\"8\":1,\"19\":1,\"34\":1,\"45\":1,\"158\":1,\"217\":1,\"223\":1,\"260\":4,\"326\":1,\"436\":1,\"443\":1,\"465\":2,\"538\":3,\"539\":3,\"540\":1,\"686\":1,\"689\":2,\"690\":2,\"701\":4,\"706\":2,\"707\":3,\"711\":3,\"723\":1,\"737\":1,\"769\":1,\"780\":1,\"783\":1,\"789\":1,\"832\":1,\"855\":1}}],[\"8000\",{\"1\":{\"769\":2}}],[\"802标准定义的局域网参考模型只对应于osi参考模型的数据链路层和物理层\",{\"1\":{\"158\":1}}],[\"802\",{\"1\":{\"152\":4,\"158\":3,\"166\":1,\"575\":1,\"578\":1}}],[\"8081\",{\"1\":{\"22\":2,\"48\":2}}],[\"80\",{\"1\":{\"8\":2,\"21\":1,\"22\":3,\"34\":2,\"47\":1,\"48\":3,\"218\":8,\"279\":1}}],[\"ui\",{\"1\":{\"539\":3}}],[\"ui组件\",{\"1\":{\"524\":1}}],[\"uuid\",{\"1\":{\"518\":1}}],[\"uncaughtexceptionhandler处理未检测的异常\",{\"1\":{\"865\":1}}],[\"unchecked\",{\"1\":{\"793\":1}}],[\"unlock方法进行加\",{\"1\":{\"843\":1}}],[\"unlockread\",{\"1\":{\"832\":1}}],[\"unlock\",{\"1\":{\"832\":2,\"839\":1}}],[\"unloading\",{\"1\":{\"720\":1}}],[\"unsafe\",{\"1\":{\"827\":1,\"847\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"793\":1}}],[\"undo\",{\"1\":{\"375\":3,\"377\":3,\"378\":3}}],[\"unix版本\",{\"1\":{\"200\":1}}],[\"unit\",{\"1\":{\"175\":1,\"851\":1,\"860\":1}}],[\"unicast\",{\"1\":{\"166\":1}}],[\"util包下的集合类都是快速失败的\",{\"1\":{\"709\":1}}],[\"util中\",{\"1\":{\"670\":1}}],[\"util\",{\"1\":{\"327\":4,\"674\":1,\"709\":1,\"831\":1,\"832\":2,\"844\":1,\"870\":2}}],[\"utf\",{\"1\":{\"8\":1,\"34\":1,\"539\":1,\"540\":1,\"789\":1}}],[\"upper\",{\"1\":{\"316\":1}}],[\"updateinventory\",{\"1\":{\"518\":2}}],[\"updated\",{\"1\":{\"481\":1}}],[\"updateemail\",{\"1\":{\"481\":1}}],[\"updateuserprofile\",{\"1\":{\"481\":1}}],[\"update\",{\"1\":{\"210\":1,\"212\":1,\"327\":3}}],[\"upd\",{\"1\":{\"72\":1}}],[\"uri和url的区别是什么\",{\"0\":{\"558\":1}}],[\"url不合法\",{\"1\":{\"422\":1,\"429\":1}}],[\"url不区分大小写\",{\"1\":{\"104\":1}}],[\"url\",{\"0\":{\"631\":1},\"1\":{\"107\":1,\"422\":25,\"429\":12,\"436\":23,\"443\":43}}],[\"uroot\",{\"1\":{\"11\":1,\"37\":1}}],[\"uk\",{\"1\":{\"69\":1}}],[\"udp\",{\"0\":{\"663\":1,\"664\":1,\"665\":1}}],[\"udp校验填充\",{\"1\":{\"305\":1}}],[\"udp数据报长度\",{\"1\":{\"304\":1}}],[\"udp检验和\",{\"1\":{\"302\":1}}],[\"udp长度\",{\"1\":{\"302\":1}}],[\"udp的协议号为17\",{\"1\":{\"304\":1}}],[\"udp的校验过程\",{\"0\":{\"303\":1}}],[\"udp的报文格式\",{\"0\":{\"302\":1},\"1\":{\"302\":1}}],[\"udp的应用服务\",{\"1\":{\"301\":1}}],[\"udp的主要特点\",{\"1\":{\"301\":1}}],[\"udp首部开销小\",{\"1\":{\"301\":1}}],[\"udp无拥塞控制\",{\"1\":{\"301\":1}}],[\"udp面向报文\",{\"1\":{\"301\":1}}],[\"udp直接对应用层提交的报文进行封装\",{\"1\":{\"301\":1}}],[\"udp就照样发送\",{\"1\":{\"301\":1}}],[\"udp是报文流\",{\"1\":{\"301\":1}}],[\"udp是面向报文的\",{\"1\":{\"301\":1}}],[\"udp是无连接的\",{\"1\":{\"301\":1}}],[\"udp不保证可靠交付\",{\"1\":{\"301\":1}}],[\"udp只在ip数据报服务之上增加了很少功能\",{\"1\":{\"301\":1}}],[\"udp协议的特性\",{\"0\":{\"301\":1}}],[\"udp协议\",{\"0\":{\"300\":1}}],[\"udp根据端口号将数据交给应用进程叫做udp分用\",{\"1\":{\"280\":1}}],[\"udp目的端口\",{\"1\":{\"63\":2}}],[\"udp源端口\",{\"1\":{\"63\":2}}],[\"uvh\",{\"1\":{\"24\":1,\"50\":1}}],[\"usb调试\",{\"1\":{\"538\":1}}],[\"usage\",{\"1\":{\"450\":1}}],[\"us\",{\"1\":{\"69\":1}}],[\"usr\",{\"1\":{\"18\":3,\"19\":1,\"44\":3,\"45\":1}}],[\"useadaptsizepolicy可控制吞吐量\",{\"1\":{\"745\":1}}],[\"use\",{\"1\":{\"8\":1,\"34\":1}}],[\"userid等\",{\"1\":{\"817\":1}}],[\"username\",{\"1\":{\"481\":11,\"489\":3}}],[\"userrepository负责用户数据的持久化\",{\"1\":{\"481\":1}}],[\"userrepository\",{\"1\":{\"481\":13}}],[\"usermanagementsystem类只关注用户管理的核心逻辑\",{\"1\":{\"481\":1}}],[\"usermanagementsystem类承担了太多的责任\",{\"1\":{\"481\":1}}],[\"usermanagementsystem\",{\"1\":{\"481\":4}}],[\"userbuilder\",{\"1\":{\"450\":12}}],[\"user3\",{\"1\":{\"408\":4}}],[\"user2\",{\"1\":{\"408\":4}}],[\"user1\",{\"1\":{\"408\":6,\"455\":2}}],[\"userservice\",{\"1\":{\"489\":3}}],[\"users\",{\"1\":{\"325\":4,\"538\":1}}],[\"user\",{\"1\":{\"8\":1,\"34\":1,\"325\":8,\"407\":1,\"408\":5,\"409\":2,\"436\":1,\"443\":1,\"450\":16,\"455\":10,\"489\":23,\"756\":1,\"810\":1}}],[\"<p1\",{\"1\":{\"848\":1}}],[\"<=\",{\"1\":{\"774\":1}}],[\"<clinit>\",{\"1\":{\"720\":1}}],[\"<category\",{\"1\":{\"539\":1}}],[\"<<\",{\"1\":{\"689\":1,\"867\":5}}],[\"<intent\",{\"1\":{\"539\":1}}],[\"<androidx\",{\"1\":{\"540\":1}}],[\"<action\",{\"1\":{\"539\":1}}],[\"<activity\",{\"1\":{\"539\":1}}],[\"<application\",{\"1\":{\"539\":1}}],[\"<manifest\",{\"1\":{\"539\":1}}],[\"<meta\",{\"1\":{\"8\":2,\"34\":2}}],[\"<textview\",{\"1\":{\"540\":1}}],[\"<t>\",{\"1\":{\"346\":8,\"797\":1}}],[\"<title>helloworld<\",{\"1\":{\"8\":1,\"34\":1}}],[\"<o\",{\"1\":{\"316\":6}}],[\"<路径>\",{\"1\":{\"104\":1}}],[\"<端口>\",{\"1\":{\"104\":1}}],[\"<主机>\",{\"1\":{\"104\":1}}],[\"<协议>\",{\"1\":{\"104\":1}}],[\"<收件人地址>命令告知服务器收件人地址\",{\"1\":{\"94\":1}}],[\"<发件人地址>命令告知服务器发件人地址\",{\"1\":{\"94\":1}}],[\"<body>\",{\"1\":{\"8\":1,\"34\":1}}],[\"<head>\",{\"1\":{\"8\":1,\"34\":1}}],[\"<html\",{\"1\":{\"8\":1,\"34\":1}}],[\"<\",{\"1\":{\"8\":4,\"34\":4,\"299\":1,\"314\":1,\"315\":1,\"316\":6,\"350\":3,\"365\":1,\"366\":3,\"394\":3,\"539\":22,\"540\":2,\"689\":1,\"739\":1,\"821\":1,\"860\":2,\"870\":2}}],[\"创建对象实例\",{\"1\":{\"799\":1}}],[\"创建对象有几种方式\",{\"0\":{\"757\":1}}],[\"创建的连接不再使用时\",{\"1\":{\"731\":1}}],[\"创建时如果给定了容量初始值\",{\"1\":{\"706\":1}}],[\"创建时如果不指定容量初始值\",{\"1\":{\"706\":1}}],[\"创建时的大小可以传入创建大小\",{\"1\":{\"677\":1}}],[\"创建完成点击运行即可\",{\"1\":{\"538\":1}}],[\"创建安卓虚拟机\",{\"1\":{\"538\":2}}],[\"创建安装目录\",{\"1\":{\"18\":1,\"44\":1}}],[\"创建项目\",{\"1\":{\"538\":2}}],[\"创建第一个项目\",{\"1\":{\"538\":1}}],[\"创建享元工厂\",{\"1\":{\"530\":1}}],[\"创建部门和员工对象\",{\"1\":{\"525\":1}}],[\"创建文件和文件夹对象\",{\"1\":{\"525\":1}}],[\"创建文件夹和index\",{\"1\":{\"8\":1,\"34\":1}}],[\"创建组合对象\",{\"1\":{\"525\":1}}],[\"创建组合类\",{\"1\":{\"524\":1}}],[\"创建组件接口\",{\"1\":{\"524\":1}}],[\"创建叶子类\",{\"1\":{\"524\":1}}],[\"创建门面类\",{\"1\":{\"516\":1}}],[\"创建订单\",{\"1\":{\"510\":1}}],[\"创建适配器\",{\"1\":{\"510\":1}}],[\"创建新的支付接口实现\",{\"1\":{\"510\":1}}],[\"创建新的促销活动\",{\"1\":{\"455\":1}}],[\"创建代理对象\",{\"1\":{\"497\":1,\"498\":2}}],[\"创建代理处理器\",{\"1\":{\"497\":1}}],[\"创建代理类\",{\"1\":{\"494\":1,\"495\":4}}],[\"创建目标对象\",{\"1\":{\"497\":1}}],[\"创建目录\",{\"1\":{\"8\":1,\"34\":1}}],[\"创建被代理类\",{\"1\":{\"494\":1,\"495\":1}}],[\"创建型模式\",{\"1\":{\"490\":1}}],[\"创建型设计模式的核心就是给我们提供了一系列全新的创建对象的方式方法\",{\"1\":{\"414\":1}}],[\"创建型设计模式\",{\"0\":{\"414\":1},\"1\":{\"414\":1}}],[\"创建示例促销活动\",{\"1\":{\"455\":1}}],[\"创建原始促销活动\",{\"1\":{\"455\":1}}],[\"创建相应的具体产品对象\",{\"1\":{\"436\":1}}],[\"创建\",{\"1\":{\"436\":1}}],[\"创建并返回对应的\",{\"1\":{\"422\":1}}],[\"创建并获得迭代器\",{\"1\":{\"366\":1}}],[\"创建用户参与者\",{\"1\":{\"408\":1}}],[\"创建聊天室作为中介者\",{\"1\":{\"408\":1}}],[\"创建飞机参与者\",{\"1\":{\"403\":1}}],[\"创建空中交通管制作为中介者\",{\"1\":{\"403\":1}}],[\"创建规则引擎\",{\"1\":{\"394\":1}}],[\"创建添加商品和移除商品的命令\",{\"1\":{\"384\":1}}],[\"创建购物车对象\",{\"1\":{\"384\":1}}],[\"创建遥控器并设置命令\",{\"1\":{\"383\":1}}],[\"创建电灯和对应的命令对象\",{\"1\":{\"383\":1}}],[\"创建一个对象\",{\"1\":{\"857\":1}}],[\"创建一个对象结构\",{\"1\":{\"372\":1}}],[\"创建一个java对象有几种方式\",{\"1\":{\"757\":1}}],[\"创建一个门面类\",{\"1\":{\"516\":1}}],[\"创建一个原始对象\",{\"1\":{\"502\":2}}],[\"创建一个类继承自fileinputstream再对其做增强\",{\"1\":{\"500\":1}}],[\"创建一个实现了invocationhandler接口的代理处理器类\",{\"1\":{\"496\":1}}],[\"创建一个接口\",{\"1\":{\"494\":1,\"495\":1}}],[\"创建一个新线程时使用的工厂\",{\"1\":{\"860\":1}}],[\"创建一个新歌单\",{\"1\":{\"454\":2}}],[\"创建一个新的策略接口`deserializationstrategy`用于处理反序列化逻辑\",{\"1\":{\"346\":1}}],[\"创建一个director类\",{\"1\":{\"448\":1}}],[\"创建表示不同景点的具体元素类\",{\"1\":{\"372\":1}}],[\"创建元素接口\",{\"1\":{\"372\":1}}],[\"创建访问者接口\",{\"1\":{\"372\":1}}],[\"创建具体实现部分类\",{\"1\":{\"505\":1}}],[\"创建具体抽象部分类\",{\"1\":{\"505\":1}}],[\"创建具体的builder类\",{\"1\":{\"448\":1}}],[\"创建具体的command对象并设置其接收者\",{\"1\":{\"383\":1}}],[\"创建具体工厂类\",{\"1\":{\"434\":1,\"441\":1}}],[\"创建具体产品类\",{\"1\":{\"434\":1,\"441\":1}}],[\"创建具体命令对象并设置其接收者\",{\"1\":{\"382\":1}}],[\"创建具体元素\",{\"1\":{\"372\":1}}],[\"创建具体元素对象并添加到对象结构中\",{\"1\":{\"371\":1}}],[\"创建具体访问者\",{\"1\":{\"372\":1}}],[\"创建具体处理器\",{\"1\":{\"350\":1}}],[\"创建责任链并将请求发送给责任链的头部\",{\"1\":{\"350\":1}}],[\"创建策略\",{\"1\":{\"346\":1}}],[\"创建上下文\",{\"1\":{\"343\":1,\"344\":1,\"346\":1}}],[\"创建了新的支付接口实现对象\",{\"1\":{\"510\":1}}],[\"创建了context对象\",{\"1\":{\"359\":1}}],[\"创建了一个decoratorb对象decoratorb\",{\"1\":{\"502\":1}}],[\"创建了一个decoratora对象decoratora\",{\"1\":{\"502\":1}}],[\"创建了一个computerdirector对象作为指导者\",{\"1\":{\"448\":1}}],[\"创建了一个处理器链\",{\"1\":{\"353\":1}}],[\"创建了一个具体子类myservletimpl\",{\"1\":{\"338\":1}}],[\"创建了这三个处理器\",{\"1\":{\"350\":1}}],[\"创建了\",{\"1\":{\"326\":2}}],[\"创建了几个qquser实例\",{\"1\":{\"325\":1}}],[\"创建qq群\",{\"1\":{\"325\":1}}],[\"创建index\",{\"1\":{\"8\":1,\"34\":1}}],[\"jmm只能保证基本的原子性\",{\"1\":{\"825\":1}}],[\"jmm主要就是线程和主内存之间的抽象关系\",{\"1\":{\"824\":1}}],[\"jmm\",{\"0\":{\"824\":1},\"1\":{\"824\":1}}],[\"jmap\",{\"1\":{\"739\":1,\"762\":1,\"766\":2,\"768\":4,\"769\":4}}],[\"jvisualvm\",{\"1\":{\"767\":1,\"768\":1,\"769\":1}}],[\"jvm发现同步锁处于偏向状态\",{\"1\":{\"837\":1}}],[\"jvm发现同步锁对象的标志位是01\",{\"1\":{\"837\":1}}],[\"jvm一般是这样使用锁和mark\",{\"1\":{\"837\":1}}],[\"jvm采用acc\",{\"1\":{\"835\":1}}],[\"jvm采用monitorenter\",{\"1\":{\"835\":1}}],[\"jvm退出\",{\"1\":{\"810\":1}}],[\"jvm会使用自旋锁\",{\"1\":{\"837\":1}}],[\"jvm会在\",{\"1\":{\"837\":1}}],[\"jvm会正常退出\",{\"1\":{\"810\":1}}],[\"jvm会为每个线程都分配一个栈区\",{\"1\":{\"724\":1}}],[\"jvm调优\",{\"0\":{\"761\":1}}],[\"jvm使用分代收集算法\",{\"1\":{\"743\":1}}],[\"jvm中对象的创建的过程\",{\"0\":{\"726\":1}}],[\"jvm对栈只进行两种操作\",{\"1\":{\"724\":1}}],[\"jvm的内存区域\",{\"0\":{\"722\":1}}],[\"jvm运行过程\",{\"0\":{\"720\":1}}],[\"jvm\",{\"0\":{\"721\":1,\"728\":2,\"764\":1},\"1\":{\"719\":1,\"720\":7,\"721\":7,\"722\":2,\"723\":2,\"726\":1,\"728\":3,\"731\":3,\"741\":1,\"764\":1,\"768\":5,\"778\":1,\"792\":1,\"793\":1,\"810\":1}}],[\"jvm就是我们的java\",{\"1\":{\"719\":1}}],[\"jvm语言\",{\"1\":{\"537\":1}}],[\"jconsole\",{\"1\":{\"763\":1}}],[\"jcmd\",{\"1\":{\"762\":1}}],[\"jhat\",{\"1\":{\"762\":1,\"769\":3}}],[\"jinfo\",{\"1\":{\"762\":1}}],[\"jit\",{\"1\":{\"720\":1,\"721\":1}}],[\"jstack\",{\"1\":{\"762\":1,\"765\":1,\"769\":1,\"849\":1}}],[\"jstat\",{\"1\":{\"762\":2,\"766\":1,\"768\":2,\"769\":1}}],[\"json\",{\"1\":{\"511\":1}}],[\"jsonsmsadapter\",{\"1\":{\"511\":2}}],[\"jprofiler\",{\"1\":{\"769\":1}}],[\"jps\",{\"1\":{\"762\":1,\"769\":1,\"849\":1}}],[\"jpg\",{\"1\":{\"495\":1}}],[\"jdbc\",{\"1\":{\"760\":1}}],[\"jdk自带\",{\"1\":{\"763\":1}}],[\"jdk在1\",{\"1\":{\"723\":1}}],[\"jdk中有一个类的实现是一个标准单例模式\",{\"1\":{\"419\":1}}],[\"jdk中的runtime类\",{\"1\":{\"419\":1}}],[\"jdk11以后改成了compare\",{\"1\":{\"845\":1}}],[\"jdk1\",{\"0\":{\"701\":1,\"723\":1},\"1\":{\"19\":1,\"45\":1,\"701\":3,\"706\":1,\"707\":2,\"711\":3,\"713\":1,\"722\":2,\"723\":3}}],[\"jdk\",{\"0\":{\"497\":1},\"1\":{\"1\":1,\"18\":4,\"19\":1,\"27\":1,\"44\":4,\"45\":1,\"497\":1,\"707\":3,\"711\":4,\"735\":3,\"762\":1,\"768\":1,\"769\":1,\"785\":1,\"789\":1}}],[\"jni\",{\"1\":{\"734\":1}}],[\"jrockit\",{\"1\":{\"725\":1}}],[\"j9\",{\"1\":{\"725\":1}}],[\"just\",{\"1\":{\"720\":1}}],[\"junit\",{\"1\":{\"539\":4}}],[\"join\",{\"1\":{\"807\":3,\"811\":3}}],[\"joinchatgroup\",{\"1\":{\"325\":6}}],[\"johnson和john\",{\"1\":{\"490\":1}}],[\"john\",{\"1\":{\"450\":1}}],[\"jerry\",{\"1\":{\"325\":3}}],[\"j++\",{\"1\":{\"316\":1,\"821\":1}}],[\"j\",{\"1\":{\"316\":2,\"821\":4}}],[\"jx\",{\"1\":{\"69\":1}}],[\"jacksubscribe\",{\"1\":{\"326\":10}}],[\"jack问了大家晚上吃什么\",{\"1\":{\"325\":1}}],[\"jack\",{\"1\":{\"325\":4,\"326\":1,\"450\":2}}],[\"jar\",{\"1\":{\"23\":2,\"49\":2,\"758\":1,\"760\":1}}],[\"java开发手册\",{\"1\":{\"859\":1}}],[\"java提供了atomicstampreference类\",{\"1\":{\"845\":1}}],[\"java对象头里\",{\"1\":{\"837\":1}}],[\"java对象的创建的过程是怎么样的\",{\"1\":{\"726\":1}}],[\"javap\",{\"1\":{\"835\":1}}],[\"java是利用volatile关键字来保证可见性的\",{\"1\":{\"825\":1}}],[\"java主要包括了如下4种具体实现\",{\"1\":{\"811\":1}}],[\"java内存模型\",{\"0\":{\"823\":1,\"824\":1},\"1\":{\"824\":1}}],[\"java内存模型和volatile关键字\",{\"1\":{\"811\":1}}],[\"java内置的等待\",{\"1\":{\"811\":1}}],[\"java线程将操作系统中的就绪和运行两种状态笼统的称作\",{\"1\":{\"808\":1}}],[\"java多线程\",{\"0\":{\"802\":1}}],[\"java异常的体系介绍一下\",{\"0\":{\"793\":1},\"1\":{\"793\":1}}],[\"java基础\",{\"0\":{\"772\":1}}],[\"java方法区溢出\",{\"1\":{\"731\":1}}],[\"java栈溢出\",{\"1\":{\"731\":1}}],[\"java堆溢出\",{\"1\":{\"731\":1}}],[\"java会自动释放掉为该变量所分配的内存空间\",{\"1\":{\"724\":1}}],[\"java就在栈中为这个变量分配内存空间\",{\"1\":{\"724\":1}}],[\"java中的线程分为两类\",{\"1\":{\"810\":1}}],[\"java中的数据类型有两种\",{\"1\":{\"724\":1}}],[\"java中创建线程主要有四种方式\",{\"1\":{\"806\":1}}],[\"java中所有对象的存储空间都是在堆中分配的\",{\"1\":{\"724\":1}}],[\"java中分配堆栈内存是由jvm自动分配和管理的\",{\"1\":{\"724\":1}}],[\"java虚拟机的启动类加载器会加载java标准库的类\",{\"1\":{\"755\":1}}],[\"java虚拟机\",{\"0\":{\"717\":1}}],[\"java里线程安全的集合\",{\"0\":{\"675\":1}}],[\"java集合框架体系\",{\"0\":{\"670\":1}}],[\"java集合框架\",{\"0\":{\"668\":1}}],[\"java类型与js\",{\"1\":{\"540\":1}}],[\"java代码书写程序逻辑\",{\"1\":{\"540\":1}}],[\"javaversion\",{\"1\":{\"539\":2}}],[\"java目录\",{\"1\":{\"539\":1}}],[\"javac\",{\"1\":{\"20\":1,\"46\":1,\"719\":1}}],[\"java环境变量\",{\"1\":{\"19\":1,\"45\":1}}],[\"javase8\",{\"1\":{\"17\":1,\"43\":1}}],[\"javase\",{\"1\":{\"17\":1,\"43\":1}}],[\"javascript是一种脚本语言\",{\"1\":{\"104\":1}}],[\"javascript\",{\"1\":{\"8\":3,\"34\":3,\"104\":1}}],[\"java\",{\"0\":{\"338\":1,\"734\":1,\"737\":1},\"1\":{\"17\":1,\"19\":1,\"20\":1,\"23\":1,\"43\":1,\"45\":1,\"46\":1,\"49\":1,\"327\":4,\"335\":1,\"419\":1,\"485\":2,\"497\":4,\"498\":4,\"537\":1,\"673\":3,\"674\":2,\"705\":2,\"706\":1,\"708\":1,\"709\":2,\"710\":2,\"719\":1,\"721\":1,\"722\":9,\"725\":1,\"727\":4,\"728\":1,\"729\":1,\"730\":2,\"734\":1,\"735\":1,\"737\":2,\"738\":2,\"744\":1,\"754\":2,\"756\":9,\"758\":2,\"762\":1,\"763\":1,\"766\":1,\"769\":2,\"777\":1,\"783\":1,\"787\":1,\"789\":1,\"793\":4,\"804\":1,\"807\":1,\"824\":1,\"827\":1,\"831\":2,\"832\":4,\"834\":1,\"838\":1,\"842\":1,\"844\":1,\"870\":2}}],[\"g1提供称为humongous的region区去存放大对象\",{\"1\":{\"750\":1}}],[\"g1的工作流程是怎么样的\",{\"0\":{\"750\":1}}],[\"g1就没有新生代多少空间\",{\"1\":{\"749\":1}}],[\"g1最大的特点就是可以设置一个垃圾回收的停顿的一个预期时间\",{\"1\":{\"749\":1}}],[\"g1最大的特点就是它对对内存的划分模式和之前的所有垃圾回收器都不一样\",{\"1\":{\"749\":1}}],[\"g1中为什么划分region\",{\"0\":{\"749\":1},\"1\":{\"749\":1}}],[\"g1垃圾收集器了解吗\",{\"0\":{\"749\":1},\"1\":{\"749\":1}}],[\"g1标记清除\",{\"1\":{\"745\":1}}],[\"g1\",{\"1\":{\"738\":1,\"749\":1,\"751\":3,\"752\":1}}],[\"gc分代年龄\",{\"1\":{\"837\":1}}],[\"gceasy\",{\"1\":{\"769\":1}}],[\"gcviewer\",{\"1\":{\"769\":1}}],[\"gcutil\",{\"1\":{\"768\":1,\"769\":1}}],[\"gc方法\",{\"1\":{\"768\":1}}],[\"gctimeratio=n\",{\"1\":{\"764\":1}}],[\"gctimeratio\",{\"1\":{\"745\":1}}],[\"gc的触发条件和机制可能略有不同\",{\"1\":{\"767\":1}}],[\"gc的\",{\"1\":{\"745\":3}}],[\"gc的过程包括\",{\"1\":{\"741\":1}}],[\"gc的过程吗\",{\"0\":{\"741\":1}}],[\"gc来让老年代腾出更多空间\",{\"1\":{\"743\":1}}],[\"gc后仍然存活\",{\"1\":{\"743\":1}}],[\"gc后升入老年代的对象总和的平均大小\",{\"1\":{\"739\":1}}],[\"gc依然是有风险的\",{\"1\":{\"743\":1}}],[\"gc是安全的\",{\"1\":{\"743\":1}}],[\"gc之前\",{\"1\":{\"743\":1}}],[\"gc涉及整个堆内存\",{\"1\":{\"741\":1}}],[\"gc什么时候触发\",{\"1\":{\"739\":1}}],[\"gc和full\",{\"0\":{\"739\":1,\"741\":1},\"1\":{\"741\":1}}],[\"gc\",{\"0\":{\"734\":1,\"738\":4,\"739\":1,\"767\":1,\"768\":1},\"1\":{\"726\":2,\"729\":1,\"731\":3,\"733\":2,\"734\":2,\"736\":1,\"738\":13,\"739\":19,\"740\":1,\"741\":5,\"742\":4,\"743\":2,\"746\":3,\"750\":2,\"764\":1,\"766\":3,\"767\":4,\"768\":4,\"769\":9}}],[\"gccause\",{\"1\":{\"769\":1}}],[\"gcc\",{\"1\":{\"24\":2,\"50\":2}}],[\"garbage\",{\"1\":{\"720\":1,\"721\":3,\"741\":1,\"751\":1}}],[\"gamma\",{\"1\":{\"490\":1}}],[\"gang\",{\"1\":{\"490\":1}}],[\"guava\",{\"1\":{\"485\":1,\"831\":1}}],[\"guide\",{\"1\":{\"372\":9}}],[\"global\",{\"1\":{\"418\":1}}],[\"gradle配置文件注释\",{\"1\":{\"539\":1}}],[\"gradle目录\",{\"1\":{\"539\":1}}],[\"gradle\",{\"1\":{\"538\":6,\"539\":3}}],[\"gradle的问题\",{\"1\":{\"538\":1}}],[\"grant\",{\"1\":{\"11\":5,\"37\":5}}],[\"greaterexpression\",{\"1\":{\"394\":4,\"395\":1}}],[\"giving\",{\"1\":{\"372\":1}}],[\"github\",{\"1\":{\"0\":1,\"543\":1,\"544\":1,\"545\":1}}],[\"generic\",{\"1\":{\"797\":3}}],[\"generics\",{\"1\":{\"797\":1}}],[\"generation\",{\"1\":{\"741\":4}}],[\"generated\",{\"1\":{\"863\":1}}],[\"generateorderid\",{\"1\":{\"518\":2}}],[\"generatereport\",{\"1\":{\"336\":1}}],[\"get接受异常\",{\"1\":{\"865\":1}}],[\"getlocalizedmessage\",{\"1\":{\"794\":1}}],[\"getlength\",{\"1\":{\"366\":3}}],[\"get很简单\",{\"1\":{\"711\":1}}],[\"get查询\",{\"1\":{\"711\":1}}],[\"get也很简单\",{\"1\":{\"711\":1}}],[\"get流程\",{\"1\":{\"711\":1}}],[\"getclassloader\",{\"1\":{\"497\":1}}],[\"getclass\",{\"1\":{\"497\":2,\"722\":1,\"785\":1}}],[\"getcount\",{\"1\":{\"851\":1}}],[\"getcomponents\",{\"1\":{\"525\":2}}],[\"getcomputer\",{\"1\":{\"448\":3}}],[\"getconstructor\",{\"1\":{\"436\":1,\"443\":1}}],[\"getcontextclassloader\",{\"1\":{\"436\":1,\"443\":1}}],[\"getpasswordfromuser\",{\"1\":{\"495\":2}}],[\"getprocessor\",{\"1\":{\"448\":1}}],[\"getprefix\",{\"1\":{\"422\":4,\"429\":2,\"436\":3,\"443\":2}}],[\"getfilename\",{\"1\":{\"495\":1}}],[\"getusername\",{\"1\":{\"489\":4}}],[\"geturl\",{\"1\":{\"436\":2,\"443\":2}}],[\"getdefaultproguardfile\",{\"1\":{\"539\":1}}],[\"getdog\",{\"1\":{\"455\":1}}],[\"getdiscountedamount\",{\"1\":{\"465\":5}}],[\"getdiscount\",{\"1\":{\"455\":1}}],[\"getintvolatile\",{\"1\":{\"847\":1}}],[\"getinterfaces\",{\"1\":{\"497\":1}}],[\"getinstance\",{\"1\":{\"455\":1}}],[\"getinputstream\",{\"1\":{\"436\":4,\"443\":7}}],[\"getenddate\",{\"1\":{\"455\":1}}],[\"getsystemclassloader\",{\"1\":{\"756\":1}}],[\"getstartdate\",{\"1\":{\"455\":1}}],[\"getstate\",{\"1\":{\"377\":5}}],[\"getsongs\",{\"1\":{\"454\":4}}],[\"gettask\",{\"1\":{\"870\":2}}],[\"gettime\",{\"1\":{\"455\":1}}],[\"gettitle\",{\"1\":{\"454\":1}}],[\"getter和setter方法\",{\"1\":{\"455\":3}}],[\"getter\",{\"1\":{\"450\":1}}],[\"gettext\",{\"1\":{\"378\":8}}],[\"getbobby\",{\"1\":{\"450\":2}}],[\"getandincrement\",{\"1\":{\"829\":1,\"847\":1}}],[\"getandaddint\",{\"1\":{\"847\":2}}],[\"getandadd\",{\"1\":{\"819\":1}}],[\"getavailablequantity\",{\"1\":{\"489\":8}}],[\"getartist\",{\"1\":{\"454\":1}}],[\"getaddress\",{\"1\":{\"450\":1}}],[\"getage\",{\"1\":{\"450\":3}}],[\"getmonitor\",{\"1\":{\"448\":1}}],[\"getmemory\",{\"1\":{\"448\":1}}],[\"getmemento\",{\"1\":{\"377\":3}}],[\"getmessage\",{\"1\":{\"346\":1,\"794\":2}}],[\"getharddisk\",{\"1\":{\"448\":1}}],[\"getvalue\",{\"1\":{\"436\":1,\"443\":1,\"702\":3,\"797\":1}}],[\"getkey\",{\"1\":{\"436\":1,\"443\":1,\"702\":3}}],[\"getrules\",{\"1\":{\"455\":1}}],[\"getruntime\",{\"1\":{\"419\":1,\"866\":1}}],[\"getresourceasstream\",{\"1\":{\"436\":1,\"443\":1}}],[\"getname\",{\"1\":{\"403\":3,\"408\":3,\"450\":3,\"454\":2,\"489\":4,\"497\":1,\"498\":1,\"506\":6}}],[\"get请求的http报文\",{\"1\":{\"107\":1}}],[\"get\",{\"0\":{\"555\":1,\"556\":1},\"1\":{\"107\":1,\"326\":5,\"346\":2,\"366\":2,\"377\":1,\"436\":1,\"443\":1,\"454\":2,\"455\":2,\"495\":1,\"702\":1,\"703\":2,\"712\":1,\"713\":1,\"788\":1,\"821\":1,\"822\":1,\"863\":1,\"870\":4}}],[\"gb\",{\"1\":{\"261\":1,\"262\":3}}],[\"ghz\",{\"1\":{\"261\":1}}],[\"gof提出了23种设计模式\",{\"1\":{\"490\":1}}],[\"gof\",{\"1\":{\"490\":1}}],[\"goodbye\",{\"1\":{\"378\":3}}],[\"google\",{\"1\":{\"69\":1,\"71\":2,\"485\":1,\"537\":1,\"539\":1}}],[\"go\",{\"1\":{\"138\":1}}],[\"gov\",{\"1\":{\"69\":2}}],[\"gz\",{\"1\":{\"18\":1,\"44\":1}}],[\"gzip\",{\"1\":{\"8\":9,\"34\":9}}],[\"4来决定是否需要扩容\",{\"1\":{\"821\":1}}],[\"4字节\",{\"1\":{\"575\":3}}],[\"46\",{\"1\":{\"575\":1}}],[\"4d\",{\"1\":{\"574\":1}}],[\"44\",{\"1\":{\"455\":1}}],[\"443\",{\"1\":{\"3\":1,\"5\":1,\"29\":1,\"31\":1}}],[\"4gb\",{\"1\":{\"448\":1,\"725\":1}}],[\"49152~65535\",{\"1\":{\"279\":1}}],[\"4mb\",{\"1\":{\"230\":1}}],[\"4的4中报文\",{\"1\":{\"212\":1}}],[\"4协议\",{\"1\":{\"211\":1}}],[\"40\",{\"1\":{\"394\":2,\"694\":2}}],[\"4096byte\",{\"1\":{\"260\":1}}],[\"40秒未收到来自邻居路由器的hello`分组\",{\"1\":{\"210\":1}}],[\"404\",{\"1\":{\"107\":1}}],[\"47\",{\"1\":{\"21\":2,\"22\":2,\"47\":2,\"48\":2,\"220\":1}}],[\"4\",{\"0\":{\"73\":1,\"77\":1,\"97\":1,\"109\":1,\"112\":1,\"136\":1,\"183\":1,\"211\":1,\"219\":1,\"220\":1,\"221\":1,\"234\":1,\"263\":1,\"268\":1,\"276\":1,\"287\":1,\"291\":1,\"325\":1,\"333\":1,\"334\":1,\"337\":1,\"344\":1,\"351\":1,\"360\":1,\"366\":1,\"372\":1,\"378\":1,\"384\":1,\"391\":1,\"395\":1,\"404\":1,\"405\":1,\"409\":1,\"419\":1,\"427\":1,\"435\":1,\"442\":1,\"449\":1,\"511\":1,\"517\":1,\"525\":1,\"531\":1,\"540\":1,\"550\":1,\"576\":1,\"596\":1,\"638\":1,\"673\":1,\"680\":1,\"688\":1,\"722\":1,\"736\":1,\"757\":1,\"765\":1,\"776\":1,\"807\":1,\"819\":1,\"827\":1,\"834\":1,\"854\":1,\"860\":1},\"1\":{\"8\":3,\"24\":1,\"34\":3,\"50\":1,\"156\":1,\"205\":1,\"221\":5,\"291\":1,\"316\":1,\"539\":2,\"689\":2,\"690\":1,\"701\":1,\"764\":1,\"769\":1,\"776\":1,\"795\":1,\"820\":2,\"821\":2}}],[\"3技术标准\",{\"1\":{\"578\":1}}],[\"3c\",{\"1\":{\"574\":1}}],[\"31\",{\"0\":{\"665\":1,\"715\":1},\"1\":{\"539\":2}}],[\"33\",{\"1\":{\"539\":1}}],[\"3306\",{\"1\":{\"3\":1,\"5\":1,\"29\":1,\"31\":1}}],[\"34\",{\"1\":{\"539\":2}}],[\"30\",{\"0\":{\"664\":1,\"714\":1},\"1\":{\"350\":1,\"394\":2,\"450\":1,\"689\":1}}],[\"300\",{\"1\":{\"8\":3,\"34\":3,\"344\":1}}],[\"3+2n\",{\"1\":{\"316\":1}}],[\"388608s\",{\"1\":{\"260\":1}}],[\"383\",{\"1\":{\"217\":1}}],[\"35\",{\"1\":{\"220\":2,\"350\":1}}],[\"32bit\",{\"1\":{\"694\":1}}],[\"32比特的子网掩码可以表明分类ip地址的主机号部分被借用了几个比特作为子网号\",{\"1\":{\"218\":1}}],[\"32比特的ipv4地址不方便阅读\",{\"1\":{\"215\":1}}],[\"32位\",{\"1\":{\"304\":2}}],[\"32位地址\",{\"1\":{\"215\":1}}],[\"32位bit\",{\"1\":{\"194\":1}}],[\"32\",{\"0\":{\"666\":1},\"1\":{\"205\":1,\"220\":3,\"688\":1,\"725\":1}}],[\"32k\",{\"1\":{\"8\":2,\"34\":2}}],[\"36\",{\"1\":{\"21\":3,\"22\":4,\"47\":3,\"48\":4}}],[\"3\",{\"0\":{\"20\":1,\"46\":1,\"70\":1,\"76\":1,\"87\":1,\"96\":1,\"108\":1,\"111\":1,\"133\":1,\"158\":1,\"168\":1,\"172\":1,\"175\":1,\"182\":1,\"198\":1,\"199\":1,\"202\":1,\"210\":1,\"218\":1,\"221\":1,\"231\":1,\"248\":1,\"250\":1,\"251\":1,\"255\":1,\"259\":1,\"262\":1,\"275\":1,\"284\":1,\"290\":1,\"303\":1,\"324\":1,\"332\":1,\"343\":1,\"350\":1,\"359\":1,\"365\":1,\"371\":1,\"377\":1,\"383\":1,\"390\":1,\"394\":1,\"400\":1,\"403\":1,\"408\":1,\"418\":1,\"426\":1,\"434\":1,\"438\":1,\"439\":1,\"440\":1,\"441\":2,\"442\":1,\"443\":1,\"444\":1,\"448\":1,\"462\":1,\"466\":1,\"470\":1,\"474\":1,\"478\":1,\"482\":1,\"486\":1,\"490\":1,\"502\":1,\"506\":1,\"510\":1,\"516\":1,\"524\":1,\"530\":1,\"539\":1,\"549\":1,\"563\":1,\"575\":1,\"595\":1,\"619\":1,\"629\":1,\"637\":1,\"642\":1,\"672\":1,\"679\":1,\"687\":1,\"721\":1,\"735\":1,\"756\":1,\"764\":1,\"775\":1,\"806\":1,\"818\":1,\"826\":1,\"833\":1,\"853\":1,\"859\":1},\"1\":{\"18\":1,\"24\":1,\"44\":1,\"50\":1,\"94\":1,\"156\":1,\"205\":1,\"217\":1,\"268\":1,\"291\":1,\"327\":1,\"378\":2,\"390\":2,\"485\":1,\"539\":1,\"690\":2,\"724\":1,\"743\":1,\"747\":1,\"749\":1,\"764\":4,\"769\":1,\"775\":1,\"821\":2,\"845\":1,\"867\":1}}],[\"mp4\",{\"1\":{\"525\":6}}],[\"mp3\",{\"1\":{\"525\":9}}],[\"moviefolder\",{\"1\":{\"525\":4}}],[\"movie2\",{\"1\":{\"525\":2}}],[\"movie1\",{\"1\":{\"525\":2}}],[\"mobile\",{\"1\":{\"506\":1}}],[\"mobileappchannel\",{\"1\":{\"506\":3}}],[\"monitor是由objectmonitor实现的\",{\"1\":{\"835\":1}}],[\"monitorexit或者acc\",{\"1\":{\"835\":1}}],[\"monitorexit\",{\"1\":{\"835\":2}}],[\"monitorexit两个指令来实现同步\",{\"1\":{\"835\":1,\"843\":1}}],[\"monitorenter\",{\"1\":{\"835\":3}}],[\"monitor\",{\"1\":{\"448\":6,\"835\":3}}],[\"modcount\",{\"1\":{\"709\":2}}],[\"modification\",{\"1\":{\"709\":3,\"710\":1}}],[\"modified的响应\",{\"1\":{\"114\":1}}],[\"modified\",{\"1\":{\"114\":2}}],[\"model\",{\"1\":{\"824\":1}}],[\"modem\",{\"1\":{\"239\":1,\"240\":1,\"618\":1}}],[\"mode\",{\"1\":{\"85\":2}}],[\"mythreadpoolexecutor\",{\"1\":{\"870\":6}}],[\"mygenericmethod\",{\"1\":{\"797\":1}}],[\"mygenericinterface<t>\",{\"1\":{\"797\":1}}],[\"mygenericclass\",{\"1\":{\"797\":1}}],[\"mygenericclass<t>\",{\"1\":{\"797\":1}}],[\"myheapdump\",{\"1\":{\"766\":1}}],[\"myapplication\",{\"1\":{\"539\":3}}],[\"myclass\",{\"1\":{\"477\":1}}],[\"my\",{\"1\":{\"454\":2}}],[\"mybaits中的org\",{\"1\":{\"419\":2}}],[\"mybatis框架\",{\"0\":{\"887\":1}}],[\"mybatis通过vfs来查找指定路径下的资源\",{\"1\":{\"419\":1}}],[\"mybatis是一个流行的java持久化框架\",{\"1\":{\"352\":1}}],[\"mybatis中的插件\",{\"1\":{\"352\":1}}],[\"myservletimpl\",{\"1\":{\"338\":2}}],[\"myservlet\",{\"1\":{\"338\":2}}],[\"myservlet中有三个模板方法\",{\"1\":{\"338\":1}}],[\"mysql8\",{\"1\":{\"11\":1,\"37\":1}}],[\"mysql5\",{\"1\":{\"11\":1,\"37\":1}}],[\"mysql\",{\"0\":{\"873\":1},\"1\":{\"1\":1,\"11\":2,\"27\":1,\"37\":2,\"760\":2}}],[\"m\",{\"1\":{\"343\":5,\"346\":5}}],[\"ms时间内被其它线程唤醒\",{\"1\":{\"807\":1}}],[\"msg\",{\"1\":{\"325\":10,\"353\":2,\"354\":2,\"511\":3}}],[\"msie\",{\"1\":{\"8\":1,\"34\":1}}],[\"mb\",{\"1\":{\"261\":1,\"262\":1,\"752\":1}}],[\"mhz\",{\"1\":{\"261\":1}}],[\"merge等\",{\"1\":{\"713\":1}}],[\"meows\",{\"1\":{\"469\":3}}],[\"mem\",{\"1\":{\"769\":2}}],[\"memory\",{\"1\":{\"448\":6,\"824\":3,\"828\":1}}],[\"mementos\",{\"1\":{\"377\":3,\"378\":4}}],[\"memento\",{\"1\":{\"375\":1,\"377\":12,\"378\":7,\"490\":1}}],[\"methodproxy\",{\"1\":{\"498\":2}}],[\"methodinterceptor\",{\"1\":{\"498\":2}}],[\"methodname\",{\"1\":{\"497\":3,\"498\":3}}],[\"method\",{\"1\":{\"330\":1,\"432\":1,\"490\":2,\"497\":12,\"498\":11,\"797\":1,\"833\":2,\"863\":1}}],[\"medium\",{\"1\":{\"144\":1}}],[\"mediator\",{\"1\":{\"398\":1,\"400\":2,\"403\":5,\"406\":1,\"407\":1,\"408\":10,\"409\":2,\"490\":1}}],[\"media\",{\"1\":{\"120\":1,\"574\":1}}],[\"message\",{\"1\":{\"94\":1,\"200\":1,\"327\":10,\"346\":2,\"403\":10,\"408\":10,\"461\":3,\"511\":3}}],[\"musicfolder\",{\"1\":{\"525\":6}}],[\"museum\",{\"1\":{\"69\":1,\"372\":12}}],[\"multicast\",{\"1\":{\"166\":1}}],[\"multiple\",{\"1\":{\"581\":2}}],[\"multiplexing\",{\"1\":{\"113\":1,\"280\":1}}],[\"multipurpose\",{\"1\":{\"96\":1}}],[\"multi\",{\"1\":{\"8\":1,\"34\":1}}],[\"mvc\",{\"1\":{\"23\":1,\"49\":1,\"405\":1}}],[\"malformedurlexception\",{\"1\":{\"793\":1}}],[\"mall\",{\"1\":{\"372\":2}}],[\"major\",{\"0\":{\"738\":1},\"1\":{\"738\":2}}],[\"mark\",{\"1\":{\"729\":1,\"733\":1,\"744\":1,\"746\":1,\"751\":1,\"835\":1,\"837\":3}}],[\"mat\",{\"1\":{\"768\":1,\"769\":1}}],[\"match\",{\"1\":{\"540\":2}}],[\"material\",{\"1\":{\"539\":3}}],[\"manifest>\",{\"1\":{\"539\":1}}],[\"manifests子目录\",{\"1\":{\"539\":1}}],[\"manager创建虚拟机\",{\"1\":{\"538\":1}}],[\"manager远程连接\",{\"1\":{\"14\":1,\"40\":1}}],[\"makeanimalsound\",{\"1\":{\"469\":8}}],[\"makesound\",{\"1\":{\"469\":7,\"485\":3}}],[\"makepayment\",{\"1\":{\"344\":4}}],[\"map映射\",{\"1\":{\"671\":1}}],[\"map\",{\"1\":{\"436\":1,\"443\":1,\"670\":1,\"671\":1,\"702\":12,\"703\":6,\"704\":1,\"705\":2,\"706\":3,\"708\":2,\"713\":1,\"714\":1,\"844\":2}}],[\"map<k\",{\"1\":{\"702\":3,\"703\":2}}],[\"map<integer\",{\"1\":{\"346\":2}}],[\"map<string\",{\"1\":{\"326\":5,\"436\":1,\"443\":1,\"495\":1}}],[\"main函数所在的线程就是一个用户线程\",{\"1\":{\"810\":1}}],[\"mainactivity\",{\"1\":{\"539\":1,\"540\":1}}],[\"main类的main\",{\"1\":{\"366\":1}}],[\"main类\",{\"1\":{\"350\":1,\"359\":1}}],[\"main\",{\"1\":{\"325\":2,\"326\":3,\"327\":2,\"343\":2,\"344\":2,\"346\":4,\"350\":2,\"353\":3,\"354\":2,\"359\":2,\"360\":4,\"365\":1,\"366\":2,\"372\":4,\"377\":2,\"378\":2,\"383\":2,\"384\":1,\"390\":2,\"394\":1,\"403\":1,\"408\":1,\"436\":2,\"443\":1,\"448\":2,\"450\":3,\"454\":2,\"455\":2,\"469\":2,\"485\":1,\"495\":10,\"497\":2,\"498\":3,\"502\":3,\"506\":2,\"510\":3,\"518\":2,\"524\":1,\"525\":4,\"539\":1,\"721\":2,\"795\":1,\"810\":1,\"822\":1,\"824\":1,\"870\":1}}],[\"mail\",{\"1\":{\"96\":1}}],[\"machineerror\",{\"1\":{\"793\":1}}],[\"mac地址用于局域网内部设备之间的通信\",{\"1\":{\"574\":1}}],[\"mac地址是一个全球唯一的标识符\",{\"1\":{\"574\":1}}],[\"mac地址是对网络上各接口的唯一标识\",{\"1\":{\"165\":1}}],[\"mac地址不具备区分不同网络的功能\",{\"1\":{\"167\":1}}],[\"mac地址有2^48个可能的组合\",{\"1\":{\"166\":1}}],[\"mac地址位于数据链路层\",{\"1\":{\"165\":1}}],[\"mac地址\",{\"0\":{\"163\":1,\"164\":1},\"1\":{\"166\":3,\"574\":1}}],[\"mac帧\",{\"1\":{\"152\":1}}],[\"mac帧不需要帧定界符\",{\"1\":{\"129\":1}}],[\"mac子层\",{\"1\":{\"120\":1,\"144\":1}}],[\"mac\",{\"0\":{\"601\":1},\"1\":{\"120\":1,\"158\":1,\"165\":1,\"279\":1,\"575\":4,\"579\":3,\"580\":4}}],[\"maxgcpausemillis=n\",{\"1\":{\"764\":1}}],[\"maxtenuringthreshold\",{\"1\":{\"740\":2}}],[\"maxpermsize=n\",{\"1\":{\"764\":1}}],[\"maxpermsize\",{\"1\":{\"725\":1}}],[\"maximumpoolsize都不可用的时候执行的饱和策略\",{\"1\":{\"860\":1}}],[\"maximumpoolsize时候就会再次创建新的线程\",{\"1\":{\"860\":1}}],[\"maximumpoolsize表示允许的最大线程数\",{\"1\":{\"860\":1}}],[\"maximumpoolsize\",{\"1\":{\"860\":3,\"868\":2,\"870\":6}}],[\"maximum\",{\"1\":{\"689\":3}}],[\"max\",{\"1\":{\"8\":1,\"34\":1,\"862\":1}}],[\"mkdir\",{\"1\":{\"8\":1,\"18\":1,\"34\":1,\"44\":1}}],[\"middleware\",{\"0\":{\"895\":1}}],[\"mission\",{\"1\":{\"763\":1}}],[\"mixed\",{\"0\":{\"738\":1},\"1\":{\"738\":2}}],[\"mipmap\",{\"1\":{\"539\":2}}],[\"millis\",{\"1\":{\"807\":1,\"811\":2}}],[\"mil\",{\"1\":{\"69\":1}}],[\"minor\",{\"0\":{\"738\":1,\"739\":1,\"767\":1},\"1\":{\"738\":2,\"739\":2,\"742\":2,\"767\":3}}],[\"minifyenabled\",{\"1\":{\"539\":1}}],[\"minification\",{\"1\":{\"539\":1}}],[\"minsdk\",{\"1\":{\"539\":1}}],[\"min\",{\"1\":{\"8\":1,\"34\":1,\"297\":1}}],[\"mime的引入大大扩展了电子邮件的功能\",{\"1\":{\"96\":1}}],[\"mime允许对邮件内容进行编码\",{\"1\":{\"96\":1}}],[\"mime定义了多种邮件内容的格式\",{\"1\":{\"96\":1}}],[\"mime定义了一种机制来处理非英语国家的文字\",{\"1\":{\"96\":1}}],[\"mime引入了以下功能\",{\"1\":{\"96\":1}}],[\"mime拓展\",{\"0\":{\"96\":1}}],[\"mime\",{\"1\":{\"8\":1,\"34\":1,\"96\":1}}],[\"vmstat\",{\"1\":{\"762\":1}}],[\"vm\",{\"1\":{\"721\":1}}],[\"v\",{\"1\":{\"702\":3,\"703\":2,\"835\":1,\"844\":3,\"853\":1}}],[\"v>\",{\"1\":{\"702\":5,\"703\":2}}],[\"v>>\",{\"1\":{\"702\":2}}],[\"verification\",{\"1\":{\"720\":1}}],[\"version=\",{\"1\":{\"539\":1,\"540\":1}}],[\"versionname\",{\"1\":{\"539\":1}}],[\"versioncode\",{\"1\":{\"539\":1}}],[\"version2deserializationstrategy\",{\"1\":{\"346\":2}}],[\"version1deserializationstrategy\",{\"1\":{\"346\":2}}],[\"version\",{\"1\":{\"8\":1,\"20\":2,\"24\":1,\"34\":1,\"46\":2,\"50\":1,\"94\":1,\"346\":12,\"539\":2}}],[\"vector是一个历史遗留类\",{\"1\":{\"681\":1}}],[\"vector\",{\"1\":{\"681\":1}}],[\"vfs的角色就是对更\",{\"1\":{\"419\":1}}],[\"vfs就是virtual\",{\"1\":{\"419\":1}}],[\"vfs使用到了单例模式\",{\"1\":{\"419\":2}}],[\"volatile保证可见性和有序性的原理涉及到底层的硬件和内存模型\",{\"1\":{\"828\":1}}],[\"volatile实现原理了解吗\",{\"0\":{\"828\":1},\"1\":{\"828\":1}}],[\"volatile就是更轻量的选择\",{\"1\":{\"827\":1}}],[\"volatile\",{\"1\":{\"827\":23,\"828\":3,\"829\":5,\"834\":11,\"844\":2,\"846\":1,\"870\":2}}],[\"volatile有两个作用\",{\"1\":{\"827\":1}}],[\"volatile有什么作用\",{\"0\":{\"827\":1},\"1\":{\"827\":1}}],[\"volume\",{\"1\":{\"360\":18}}],[\"void\",{\"1\":{\"314\":1,\"315\":1,\"316\":5,\"325\":11,\"326\":8,\"327\":10,\"332\":7,\"335\":7,\"336\":10,\"338\":9,\"343\":2,\"344\":7,\"346\":6,\"350\":9,\"353\":6,\"354\":6,\"359\":6,\"360\":18,\"365\":1,\"366\":1,\"372\":30,\"377\":4,\"378\":6,\"383\":8,\"384\":6,\"390\":1,\"394\":1,\"403\":7,\"408\":7,\"436\":1,\"443\":4,\"448\":13,\"450\":3,\"454\":9,\"455\":2,\"461\":5,\"465\":1,\"469\":2,\"473\":8,\"481\":5,\"485\":6,\"489\":2,\"495\":16,\"497\":1,\"498\":1,\"502\":7,\"506\":5,\"510\":7,\"511\":1,\"518\":5,\"524\":6,\"525\":14,\"785\":6,\"794\":1,\"795\":1,\"797\":1,\"807\":1,\"821\":2,\"822\":2,\"827\":3,\"832\":1,\"833\":2,\"844\":1,\"863\":1,\"870\":4}}],[\"vpn\",{\"1\":{\"223\":3}}],[\"vpn虚拟专用网\",{\"1\":{\"223\":1}}],[\"vpn和nat\",{\"0\":{\"223\":1}}],[\"vlissides\",{\"1\":{\"490\":1}}],[\"vlsm可以高效地利用ip地址空间\",{\"1\":{\"222\":1}}],[\"vlsm是现代网络设计的常用方法\",{\"1\":{\"222\":1}}],[\"vlsm允许在同一个网络中使用不同长度的子网掩码\",{\"1\":{\"222\":1}}],[\"vlsm\",{\"1\":{\"222\":1}}],[\"vlan标签\",{\"1\":{\"575\":1}}],[\"vlan\",{\"0\":{\"579\":1},\"1\":{\"159\":3,\"575\":3,\"579\":14,\"580\":2}}],[\"vlan是通过软件的方式实现的\",{\"1\":{\"159\":1,\"579\":1}}],[\"vlan原理\",{\"1\":{\"159\":1,\"579\":1}}],[\"vlan帧\",{\"1\":{\"152\":1}}],[\"var5\",{\"1\":{\"847\":5}}],[\"var4\",{\"1\":{\"847\":2}}],[\"var2\",{\"1\":{\"847\":3}}],[\"var1\",{\"1\":{\"847\":3}}],[\"vary\",{\"1\":{\"8\":1,\"34\":1}}],[\"valatile保证有序性\",{\"1\":{\"827\":1}}],[\"valueoffset\",{\"1\":{\"847\":1}}],[\"value基本都是我们创建的对象\",{\"1\":{\"818\":1}}],[\"value就是我们真正存储的值\",{\"1\":{\"816\":1}}],[\"value=123\",{\"1\":{\"754\":1}}],[\"value为空\",{\"1\":{\"712\":1}}],[\"value可以为null吗\",{\"0\":{\"712\":1},\"1\":{\"712\":1}}],[\"value的能力能指向下一个节点的指针\",{\"1\":{\"711\":1}}],[\"value\",{\"1\":{\"394\":10,\"671\":3,\"683\":2,\"702\":6,\"703\":4,\"712\":1,\"713\":3,\"754\":1,\"795\":3,\"797\":7,\"816\":1,\"862\":1}}],[\"validationhandler\",{\"1\":{\"353\":4,\"354\":2}}],[\"valn表中记录的是各个mac地址和它对应的vlan号\",{\"1\":{\"159\":1,\"579\":1}}],[\"visibility\",{\"1\":{\"814\":1}}],[\"visit\",{\"1\":{\"372\":9}}],[\"visiting\",{\"1\":{\"372\":1}}],[\"visitshoppingmall\",{\"1\":{\"372\":4}}],[\"visitshoppingmall等方法\",{\"1\":{\"372\":1}}],[\"visitmuseum\",{\"1\":{\"372\":4}}],[\"visitpark\",{\"1\":{\"372\":5}}],[\"visitors\",{\"1\":{\"372\":1}}],[\"visitor\",{\"1\":{\"369\":1,\"371\":1,\"372\":38,\"490\":1}}],[\"visualvm\",{\"1\":{\"763\":1,\"766\":1,\"769\":1}}],[\"views\",{\"1\":{\"538\":2}}],[\"viewport\",{\"1\":{\"8\":1,\"34\":1}}],[\"virtualmachineerror\",{\"1\":{\"793\":1}}],[\"virtual\",{\"1\":{\"184\":1,\"538\":1,\"793\":1}}],[\"vim\",{\"1\":{\"8\":1,\"19\":1,\"34\":1,\"45\":1}}],[\"vhost\",{\"1\":{\"8\":2,\"34\":2}}],[\"vuepress\",{\"1\":{\"8\":5,\"34\":5}}],[\"tda\",{\"1\":{\"769\":1}}],[\"tdm\",{\"0\":{\"148\":1}}],[\"tlab\",{\"1\":{\"728\":1}}],[\"txt\",{\"1\":{\"525\":9,\"539\":1,\"769\":1}}],[\"turnoff\",{\"1\":{\"360\":8,\"383\":2}}],[\"turnon\",{\"1\":{\"360\":8,\"383\":2}}],[\"turning\",{\"1\":{\"360\":6}}],[\"tvoffstate\",{\"1\":{\"360\":3}}],[\"tvonstate\",{\"1\":{\"360\":2}}],[\"tvstate\",{\"1\":{\"360\":5}}],[\"tv\",{\"1\":{\"360\":30}}],[\"take\",{\"1\":{\"870\":1}}],[\"tab\",{\"1\":{\"695\":5,\"821\":3}}],[\"table该位置key相同就返回\",{\"1\":{\"711\":1}}],[\"tablesizefor\",{\"1\":{\"689\":3}}],[\"tablet\",{\"1\":{\"538\":1}}],[\"table\",{\"1\":{\"497\":10,\"498\":10,\"694\":1,\"695\":1,\"742\":1,\"819\":1,\"821\":1}}],[\"table1\",{\"1\":{\"495\":2}}],[\"tasknum\",{\"1\":{\"870\":2}}],[\"task\",{\"1\":{\"495\":1,\"721\":1,\"870\":5}}],[\"tail\",{\"1\":{\"353\":5}}],[\"targetapi=\",{\"1\":{\"539\":1}}],[\"targetcompatibility\",{\"1\":{\"539\":1}}],[\"targetsdk\",{\"1\":{\"539\":1}}],[\"target\",{\"1\":{\"497\":8,\"508\":1}}],[\"tar\",{\"1\":{\"18\":2,\"44\":2}}],[\"theorem\",{\"1\":{\"622\":1}}],[\"theme\",{\"1\":{\"539\":1}}],[\"theme=\",{\"1\":{\"539\":1}}],[\"there\",{\"1\":{\"408\":2}}],[\"the\",{\"0\":{\"747\":1},\"1\":{\"360\":6,\"372\":7,\"744\":1,\"747\":1}}],[\"threshold\",{\"1\":{\"689\":2,\"695\":1,\"707\":2,\"821\":6}}],[\"threadfactory\",{\"1\":{\"860\":1}}],[\"thread类中的静态方法\",{\"1\":{\"807\":2}}],[\"thread类也提供了一个方法用于等待的方法\",{\"1\":{\"807\":1}}],[\"threadlocal提供了线程内存储变量的能力\",{\"1\":{\"831\":1}}],[\"threadlocalhashcode\",{\"1\":{\"819\":1}}],[\"threadlocal的使用场景主要是和它本身有关\",{\"1\":{\"817\":1}}],[\"threadlocal的话\",{\"1\":{\"816\":1}}],[\"threadlocal使用场景有哪些\",{\"1\":{\"817\":1}}],[\"threadlocal使用场景\",{\"0\":{\"817\":1},\"1\":{\"817\":1}}],[\"threadlocalmap扩容机制了解吗\",{\"1\":{\"821\":1}}],[\"threadlocalmap没有使用链表\",{\"1\":{\"820\":1}}],[\"threadlocalmap怎么解决hash冲突的\",{\"1\":{\"820\":1}}],[\"threadlocalmap用的是哈希取余法\",{\"1\":{\"819\":1}}],[\"threadlocalmap虽然被叫做map\",{\"1\":{\"819\":1}}],[\"threadlocalmap的扩容机制\",{\"0\":{\"821\":1}}],[\"threadlocalmap的hash冲突\",{\"0\":{\"820\":1}}],[\"threadlocalmap的结构了解吗\",{\"1\":{\"819\":1}}],[\"threadlocalmap的结构\",{\"0\":{\"819\":1}}],[\"threadlocalmap的实例变量threadlocals\",{\"1\":{\"816\":1}}],[\"threadlocalmap生命周期和thread是一样的\",{\"1\":{\"818\":1}}],[\"threadlocalmap\",{\"1\":{\"816\":1,\"822\":1}}],[\"threadlocal本身不存储值\",{\"1\":{\"816\":1}}],[\"threadlocal\",{\"0\":{\"815\":1,\"818\":1},\"1\":{\"731\":3,\"811\":1,\"816\":15,\"818\":3,\"822\":6}}],[\"threadspool\",{\"1\":{\"863\":1}}],[\"threads\",{\"1\":{\"721\":3}}],[\"thread\",{\"0\":{\"813\":1},\"1\":{\"327\":1,\"436\":1,\"443\":1,\"721\":4,\"728\":1,\"769\":2,\"812\":1,\"813\":2,\"822\":2,\"870\":6}}],[\"throwable有哪些常用方法\",{\"0\":{\"794\":1},\"1\":{\"794\":2}}],[\"throwable\",{\"1\":{\"497\":2,\"498\":1,\"785\":1,\"793\":2,\"794\":2}}],[\"throw\",{\"1\":{\"343\":1,\"346\":2,\"422\":1,\"429\":1,\"436\":2,\"443\":2,\"870\":1}}],[\"throws\",{\"1\":{\"335\":7,\"338\":9,\"454\":1,\"455\":1,\"497\":2,\"498\":1,\"785\":5}}],[\"this|object\",{\"1\":{\"833\":1}}],[\"this\",{\"1\":{\"325\":2,\"326\":5,\"327\":1,\"343\":1,\"344\":1,\"346\":1,\"350\":2,\"353\":1,\"354\":1,\"359\":1,\"360\":2,\"365\":3,\"366\":5,\"372\":6,\"377\":2,\"378\":3,\"383\":3,\"384\":5,\"390\":5,\"394\":6,\"403\":3,\"408\":3,\"422\":1,\"436\":1,\"443\":3,\"448\":5,\"450\":31,\"454\":9,\"461\":6,\"465\":3,\"481\":2,\"489\":9,\"495\":7,\"497\":1,\"498\":2,\"502\":1,\"506\":6,\"510\":3,\"518\":3,\"525\":4,\"689\":2,\"736\":1,\"797\":1,\"822\":1,\"833\":1,\"847\":3,\"870\":6}}],[\"tmp\",{\"1\":{\"326\":3}}],[\"t\",{\"1\":{\"316\":4,\"346\":8,\"484\":1,\"486\":1,\"506\":1,\"797\":7,\"811\":1,\"822\":2}}],[\"tftp\",{\"1\":{\"279\":1}}],[\"tpdu与前面几章中介绍的比特\",{\"1\":{\"278\":1}}],[\"tpdu是什么\",{\"1\":{\"278\":1}}],[\"tpdu\",{\"0\":{\"278\":1}}],[\"tsap组成\",{\"1\":{\"277\":1}}],[\"tsap相当于传输层的地址\",{\"1\":{\"277\":1}}],[\"tsap是上层调用传输层服务\",{\"1\":{\"277\":1}}],[\"tsap是什么\",{\"1\":{\"277\":1}}],[\"tsap\",{\"0\":{\"277\":1},\"1\":{\"276\":1}}],[\"tsap和tpdu\",{\"0\":{\"276\":1}}],[\"tb\",{\"1\":{\"261\":1}}],[\"t=100mbps\",{\"1\":{\"260\":1}}],[\"ttl字段的值减1\",{\"1\":{\"205\":1}}],[\"true\",{\"1\":{\"343\":1,\"346\":1,\"360\":1,\"395\":1,\"539\":3,\"774\":1,\"788\":1,\"838\":1,\"839\":1,\"840\":2,\"870\":1}}],[\"trunk端口接收处理方法\",{\"1\":{\"159\":1}}],[\"trunk端口发送处理方法\",{\"1\":{\"159\":1}}],[\"trunk端口的pvid值为1\",{\"1\":{\"159\":1}}],[\"trunk端口的基本特性和工作原理\",{\"1\":{\"159\":1}}],[\"trunk端口可以属于多个vlan\",{\"1\":{\"159\":1}}],[\"trunk端口一般用于交换机之间或交换机与路由器之间的互连\",{\"1\":{\"159\":1}}],[\"trunk\",{\"1\":{\"159\":2}}],[\"treemap<>\",{\"1\":{\"703\":1}}],[\"treemap\",{\"0\":{\"705\":1},\"1\":{\"703\":3,\"705\":11}}],[\"treeifybin\",{\"1\":{\"695\":1}}],[\"treeify的条件\",{\"1\":{\"690\":1}}],[\"tree\",{\"1\":{\"175\":2}}],[\"traversefilesystem\",{\"1\":{\"525\":4}}],[\"travel\",{\"1\":{\"69\":1}}],[\"trafficmediator\",{\"1\":{\"401\":1,\"402\":1,\"403\":5,\"404\":2}}],[\"transient关键字的作用是让被修饰的成员属性不被序列化\",{\"1\":{\"680\":1}}],[\"transformjpg\",{\"1\":{\"443\":2}}],[\"transformutf8\",{\"1\":{\"443\":2}}],[\"transformmp4\",{\"1\":{\"443\":2}}],[\"transfer\",{\"1\":{\"83\":1,\"85\":1,\"87\":1}}],[\"transport\",{\"1\":{\"274\":1}}],[\"transceiver\",{\"1\":{\"240\":1}}],[\"traceroute命令\",{\"1\":{\"200\":1}}],[\"tracert命令\",{\"1\":{\"200\":1}}],[\"tryacquire\",{\"1\":{\"840\":2}}],[\"try块\",{\"1\":{\"795\":1}}],[\"try\",{\"0\":{\"795\":1},\"1\":{\"8\":2,\"34\":2,\"327\":1,\"346\":1,\"436\":2,\"443\":2,\"455\":3,\"795\":8,\"832\":3,\"863\":1,\"865\":1,\"870\":3}}],[\"top\",{\"1\":{\"762\":1,\"765\":2,\"769\":1}}],[\"totopof=\",{\"1\":{\"540\":1}}],[\"totalamount\",{\"1\":{\"461\":8,\"465\":18}}],[\"tostartof=\",{\"1\":{\"540\":1}}],[\"tostring\",{\"1\":{\"436\":2,\"443\":2,\"450\":3,\"454\":5,\"518\":1,\"785\":1,\"792\":1,\"794\":1}}],[\"toendof=\",{\"1\":{\"540\":1}}],[\"tobottomof=\",{\"1\":{\"540\":1}}],[\"tobytearray\",{\"1\":{\"455\":1}}],[\"tools\",{\"1\":{\"539\":2,\"540\":2}}],[\"tools=\",{\"1\":{\"539\":1,\"540\":1}}],[\"todo\",{\"1\":{\"375\":4,\"863\":1}}],[\"tour\",{\"1\":{\"372\":2}}],[\"tourist\",{\"1\":{\"372\":10}}],[\"tomact\",{\"1\":{\"760\":1}}],[\"tomcat\",{\"0\":{\"760\":1},\"1\":{\"760\":3}}],[\"tomcat引入了一个称为common类加载器的特殊类加载器\",{\"1\":{\"759\":1}}],[\"tomcat引入了自定义的类加载机制\",{\"1\":{\"759\":1}}],[\"tomcat打破双亲委派机制是为了在servlet容器中实现类加载的隔离性\",{\"1\":{\"759\":1}}],[\"tomcat打破双亲委派机制主要是为了解决类加载隔离和动态模块化的问题\",{\"1\":{\"759\":1}}],[\"tomcat打破了双亲委派机制\",{\"1\":{\"759\":1}}],[\"tomcat是一个servlet容器\",{\"1\":{\"759\":1}}],[\"tom\",{\"1\":{\"325\":3}}],[\"token\",{\"1\":{\"158\":1}}],[\"tokens\",{\"1\":{\"8\":1,\"34\":1}}],[\"to\",{\"1\":{\"11\":3,\"37\":3,\"91\":1,\"94\":1,\"360\":3,\"375\":1,\"481\":1,\"495\":1,\"539\":1,\"722\":1,\"737\":1,\"739\":1,\"769\":1}}],[\"tidying\",{\"1\":{\"867\":3}}],[\"tid=0x00007fbe2c164000\",{\"1\":{\"769\":1}}],[\"timout\",{\"1\":{\"807\":1}}],[\"timeunit\",{\"1\":{\"851\":1}}],[\"timeout\",{\"1\":{\"8\":4,\"34\":4,\"785\":3,\"807\":4,\"851\":1}}],[\"time\",{\"0\":{\"648\":1,\"649\":1},\"1\":{\"8\":1,\"34\":1,\"316\":1,\"538\":1,\"720\":1,\"808\":1}}],[\"time|$upstream\",{\"1\":{\"8\":1,\"34\":1}}],[\"title\",{\"1\":{\"454\":9}}],[\"title>\",{\"1\":{\"8\":1,\"34\":1}}],[\"tip2\",{\"1\":{\"240\":1}}],[\"tip1\",{\"1\":{\"240\":1}}],[\"tip\",{\"1\":{\"197\":1,\"311\":1,\"312\":1,\"313\":1,\"317\":1}}],[\"terminated\",{\"1\":{\"808\":1,\"867\":4}}],[\"terminalexpression\",{\"1\":{\"393\":1}}],[\"terminal\",{\"1\":{\"390\":2}}],[\"testimplementation\",{\"1\":{\"539\":1}}],[\"testinstrumentationrunner\",{\"1\":{\"539\":1}}],[\"test\",{\"1\":{\"455\":1,\"539\":3}}],[\"telnet\",{\"1\":{\"279\":1}}],[\"technologies\",{\"1\":{\"17\":1,\"43\":1}}],[\"text=\",{\"1\":{\"540\":1}}],[\"texteditor\",{\"1\":{\"378\":4}}],[\"textmemento\",{\"1\":{\"378\":7}}],[\"text\",{\"1\":{\"8\":3,\"34\":3,\"378\":22}}],[\"templatemethod\",{\"1\":{\"332\":1}}],[\"template\",{\"1\":{\"330\":1,\"490\":1}}],[\"temp\",{\"1\":{\"8\":1,\"34\":1}}],[\"type\",{\"1\":{\"8\":1,\"34\":1,\"429\":4,\"455\":1,\"575\":1}}],[\"types\",{\"1\":{\"8\":2,\"34\":2}}],[\"tcp如何进行流量控制\",{\"0\":{\"653\":1}}],[\"tcp如何进行拥塞控制\",{\"0\":{\"652\":1}}],[\"tcp和udp的区别是什么\",{\"0\":{\"637\":1}}],[\"tcp不支持组播\",{\"1\":{\"301\":1}}],[\"tcp为每一个连接设有一个持续计时器\",{\"1\":{\"294\":1}}],[\"tcp利用滑动窗口机制实现流量控制\",{\"1\":{\"294\":1}}],[\"tcp使用校验和和序列号等机制来保证数据在传输过程中的完整性\",{\"1\":{\"291\":1}}],[\"tcp会根据序列号确保接收方按照正确的顺序接收到数据\",{\"1\":{\"291\":1}}],[\"tcp采用自适应算法\",{\"1\":{\"291\":1}}],[\"tcp报文段包含一个校验和字段\",{\"1\":{\"288\":1}}],[\"tcp报文段的首部格式作用是区分应用进程以及实现可靠传输\",{\"1\":{\"268\":1}}],[\"tcp连接释放采用的是四次挥手方式\",{\"1\":{\"286\":1}}],[\"tcp连接释放\",{\"0\":{\"286\":1}}],[\"tcp连接的建立采用的是三次握手方式\",{\"1\":{\"285\":1}}],[\"tcp连接的建立采用客户服务器方式\",{\"1\":{\"284\":1}}],[\"tcp连接的建立\",{\"0\":{\"285\":1}}],[\"tcp能保证可靠传输\",{\"1\":{\"282\":1}}],[\"tcp将要传输的数据分成多个字节\",{\"1\":{\"282\":1}}],[\"tcp把应用程序交下来的数据看成仅仅是一连串的无结构的字节流\",{\"1\":{\"282\":1}}],[\"tcp面向字节流\",{\"1\":{\"282\":1}}],[\"tcp提供全双工通信\",{\"1\":{\"282\":1}}],[\"tcp提供可靠交付的服务\",{\"1\":{\"282\":1}}],[\"tcp通过三次握手建立连接\",{\"1\":{\"282\":1}}],[\"tcp是面向连接\",{\"1\":{\"282\":1}}],[\"tcp的滑动窗口大小如何动态调整\",{\"0\":{\"655\":1}}],[\"tcp的拥塞控制\",{\"0\":{\"295\":1}}],[\"tcp的流量控制\",{\"0\":{\"292\":1}}],[\"tcp的发送方在规定的时间\",{\"1\":{\"291\":1}}],[\"tcp的可靠传输\",{\"0\":{\"287\":1}}],[\"tcp的可靠性来自于序号\",{\"1\":{\"282\":1}}],[\"tcp的连接管理\",{\"0\":{\"284\":1}}],[\"tcp的报文格式\",{\"0\":{\"283\":1},\"1\":{\"283\":1}}],[\"tcp的特点有哪些\",{\"1\":{\"282\":1}}],[\"tcp的协议数据单元仍然为数据段\",{\"1\":{\"273\":1}}],[\"tcp协议的特性\",{\"0\":{\"282\":1}}],[\"tcp协议\",{\"0\":{\"281\":1}}],[\"tcp根据端口号将数据交给应用进程叫做tcp分用\",{\"1\":{\"280\":1}}],[\"tcp\",{\"0\":{\"644\":1,\"645\":1,\"646\":1,\"650\":1,\"651\":1,\"662\":1},\"1\":{\"8\":7,\"14\":1,\"34\":7,\"40\":1,\"159\":1,\"268\":1,\"278\":1,\"296\":3}}],[\"5倍扩容\",{\"1\":{\"677\":1}}],[\"5e\",{\"1\":{\"574\":1}}],[\"5n+1\",{\"1\":{\"316\":1}}],[\"5报文段\",{\"1\":{\"291\":1}}],[\"5000\",{\"1\":{\"769\":2}}],[\"500gb\",{\"1\":{\"448\":1}}],[\"50\",{\"1\":{\"455\":1}}],[\"50ω\",{\"1\":{\"230\":1}}],[\"50m\",{\"1\":{\"8\":1,\"34\":1}}],[\"55\",{\"1\":{\"218\":1}}],[\"53\",{\"1\":{\"279\":1}}],[\"534\",{\"1\":{\"217\":1}}],[\"5379\",{\"1\":{\"3\":1,\"5\":1,\"29\":1,\"31\":1}}],[\"5\",{\"0\":{\"78\":1,\"98\":1,\"99\":1,\"110\":1,\"113\":1,\"140\":1,\"212\":1,\"222\":1,\"237\":1,\"264\":1,\"279\":1,\"292\":1,\"326\":1,\"339\":1,\"355\":1,\"361\":1,\"367\":1,\"379\":1,\"385\":1,\"396\":1,\"410\":1,\"420\":1,\"428\":1,\"436\":1,\"443\":1,\"450\":1,\"512\":1,\"518\":1,\"526\":1,\"551\":1,\"577\":1,\"597\":1,\"620\":1,\"639\":1,\"674\":1,\"681\":1,\"689\":1,\"723\":1,\"737\":1,\"758\":1,\"766\":1,\"777\":1,\"808\":1,\"820\":1,\"828\":1,\"835\":1,\"855\":1,\"861\":1},\"1\":{\"11\":1,\"24\":1,\"37\":1,\"50\":1,\"156\":1,\"158\":1,\"205\":1,\"210\":1,\"221\":1,\"290\":1,\"315\":2,\"316\":1,\"350\":1,\"366\":2,\"539\":2,\"690\":1,\"750\":1,\"760\":2,\"764\":1,\"769\":2,\"777\":1,\"851\":1}}],[\"512比特时间即为争用期\",{\"1\":{\"152\":1}}],[\"512\",{\"1\":{\"8\":1,\"34\":1}}],[\"51200\",{\"1\":{\"8\":2,\"34\":2}}],[\"wrap\",{\"1\":{\"540\":2}}],[\"wrapper\",{\"1\":{\"538\":2}}],[\"writelock\",{\"1\":{\"842\":2}}],[\"writer等\",{\"1\":{\"500\":1}}],[\"writeobject自定义序列化和反序列化策略\",{\"1\":{\"680\":1}}],[\"writeobject\",{\"1\":{\"455\":1}}],[\"write\",{\"1\":{\"8\":1,\"34\":1}}],[\"where\",{\"1\":{\"497\":5,\"498\":5}}],[\"while\",{\"1\":{\"335\":1,\"343\":1,\"346\":1,\"353\":1,\"365\":1,\"366\":1,\"436\":1,\"443\":1,\"702\":1,\"847\":1,\"870\":1}}],[\"weakreference\",{\"1\":{\"735\":3}}],[\"welcome\",{\"1\":{\"481\":1}}],[\"wendy\",{\"1\":{\"454\":2}}],[\"web服务器\",{\"1\":{\"858\":1}}],[\"webappclassloader\",{\"1\":{\"760\":2}}],[\"web\",{\"1\":{\"760\":2}}],[\"web应用程序的类加载器隔离\",{\"1\":{\"759\":1}}],[\"web应用程序\",{\"1\":{\"759\":1}}],[\"web应用中的过滤器和拦截器\",{\"1\":{\"355\":1}}],[\"webparam\",{\"1\":{\"511\":2}}],[\"webmethod\",{\"1\":{\"511\":1}}],[\"websocket\",{\"0\":{\"566\":1}}],[\"webservice\",{\"1\":{\"511\":1}}],[\"website\",{\"1\":{\"372\":10}}],[\"websitestatsvisitor\",{\"1\":{\"372\":6}}],[\"web开发中\",{\"1\":{\"352\":1}}],[\"wechatpaystrategy\",{\"1\":{\"344\":5}}],[\"workqueue\",{\"1\":{\"860\":3,\"870\":10}}],[\"workable\",{\"1\":{\"473\":3}}],[\"work\",{\"1\":{\"473\":3}}],[\"worker\",{\"1\":{\"8\":3,\"34\":3,\"870\":6}}],[\"world\",{\"0\":{\"747\":1},\"1\":{\"378\":8,\"538\":1,\"540\":1,\"744\":1,\"747\":1}}],[\"worldconcert\",{\"1\":{\"326\":11}}],[\"word里的线程id改为线程b的id\",{\"1\":{\"837\":1}}],[\"word里存储当前线程指针\",{\"1\":{\"837\":1}}],[\"word中的锁标志位改成00\",{\"1\":{\"837\":1}}],[\"word中的线程id记录的不是b\",{\"1\":{\"837\":1}}],[\"word中保存指向这片空间的指针\",{\"1\":{\"837\":1}}],[\"word中记录的线程id就是线程a自己的id\",{\"1\":{\"837\":1}}],[\"word记录对象的hashcode\",{\"1\":{\"837\":1}}],[\"word的指针\",{\"1\":{\"837\":1}}],[\"word的\",{\"1\":{\"837\":1}}],[\"word存储对象自身的运行数据\",{\"1\":{\"837\":1}}],[\"word标记字段\",{\"1\":{\"837\":1}}],[\"word指针指向了monitor\",{\"1\":{\"835\":1}}],[\"word\",{\"1\":{\"729\":1,\"835\":1}}],[\"wordreport\",{\"1\":{\"336\":1}}],[\"word报告\",{\"1\":{\"336\":1}}],[\"word报告等\",{\"1\":{\"336\":1}}],[\"watting\",{\"1\":{\"765\":3}}],[\"walkingworkerrobot\",{\"1\":{\"473\":1}}],[\"walkable\",{\"1\":{\"473\":3}}],[\"walk\",{\"1\":{\"473\":3}}],[\"waitset\",{\"1\":{\"835\":4}}],[\"waitind\",{\"1\":{\"808\":1}}],[\"waiting\",{\"1\":{\"808\":2}}],[\"wait状态\",{\"1\":{\"286\":2}}],[\"wait\",{\"0\":{\"648\":2,\"649\":1,\"812\":1,\"813\":1},\"1\":{\"286\":2,\"785\":4,\"807\":8,\"811\":3,\"812\":5,\"813\":4,\"835\":1,\"853\":1}}],[\"wan\",{\"1\":{\"161\":1}}],[\"w\",{\"1\":{\"240\":2}}],[\"wdm\",{\"0\":{\"149\":1}}],[\"wlan\",{\"1\":{\"144\":1,\"158\":1}}],[\"wildcards\",{\"1\":{\"797\":1}}],[\"window\",{\"1\":{\"294\":1}}],[\"windows\",{\"1\":{\"279\":1}}],[\"windows版本\",{\"1\":{\"200\":1}}],[\"wi\",{\"1\":{\"229\":1,\"618\":1}}],[\"widget\",{\"1\":{\"540\":2}}],[\"wide\",{\"1\":{\"161\":1}}],[\"width=\",{\"1\":{\"540\":2}}],[\"width=device\",{\"1\":{\"8\":1,\"34\":1}}],[\"width\",{\"1\":{\"8\":1,\"34\":1}}],[\"with\",{\"1\":{\"11\":2,\"37\":2,\"461\":1,\"581\":1}}],[\"wq保存退出\",{\"1\":{\"8\":1,\"34\":1}}],[\"wwwlogs\",{\"1\":{\"8\":5,\"34\":5}}],[\"www\",{\"1\":{\"8\":8,\"17\":1,\"34\":8,\"43\":1,\"67\":1,\"68\":1,\"69\":1,\"71\":1,\"104\":1}}],[\"wget\",{\"1\":{\"3\":2,\"29\":2}}],[\"availableprocessors\",{\"1\":{\"866\":1}}],[\"availablequantity\",{\"1\":{\"489\":13}}],[\"await\",{\"1\":{\"851\":3}}],[\"aqs是基于一个fifo的双向队列\",{\"1\":{\"846\":1}}],[\"aqs主要包括了\",{\"1\":{\"846\":1}}],[\"aqs\",{\"1\":{\"838\":1,\"839\":10,\"842\":1,\"846\":5}}],[\"a先一步刷回主存\",{\"1\":{\"829\":1}}],[\"aop\",{\"1\":{\"742\":1,\"800\":1}}],[\"afterexcute方法\",{\"1\":{\"865\":1}}],[\"after\",{\"1\":{\"495\":1,\"497\":3,\"498\":3}}],[\"aimpl\",{\"1\":{\"477\":1}}],[\"airtrafficcontroller\",{\"1\":{\"402\":1,\"403\":2,\"404\":3}}],[\"aircraft2\",{\"1\":{\"403\":2}}],[\"aircraft1\",{\"1\":{\"403\":2}}],[\"aircraft\",{\"1\":{\"401\":1,\"402\":1,\"403\":9,\"404\":1}}],[\"again\",{\"1\":{\"538\":1}}],[\"agreement\",{\"1\":{\"538\":1}}],[\"age=\",{\"1\":{\"450\":2}}],[\"age\",{\"1\":{\"450\":24}}],[\"aggregate\",{\"1\":{\"365\":8}}],[\"abortpolicy\",{\"1\":{\"861\":2}}],[\"about\",{\"1\":{\"372\":1}}],[\"aba问题发生在一个线程先检查某个共享变量的值是a\",{\"1\":{\"845\":1}}],[\"aba\",{\"1\":{\"845\":1,\"847\":2}}],[\"abc\",{\"1\":{\"791\":3}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"838\":1,\"846\":1}}],[\"abstractmap\",{\"1\":{\"706\":1}}],[\"abstraction\",{\"1\":{\"504\":2,\"505\":1}}],[\"abstractpictureresource\",{\"1\":{\"443\":16}}],[\"abstracttextresource\",{\"1\":{\"443\":8}}],[\"abstractvideoresource\",{\"1\":{\"443\":8}}],[\"abstractresourcefactory\",{\"1\":{\"443\":4}}],[\"abstractresource\",{\"1\":{\"436\":11}}],[\"abstract\",{\"1\":{\"332\":4,\"335\":4,\"336\":4,\"338\":4,\"353\":2,\"354\":2,\"390\":1,\"434\":2,\"436\":2,\"439\":1,\"441\":2,\"443\":4,\"485\":2,\"490\":1,\"497\":2,\"502\":1}}],[\"abstractclass\",{\"1\":{\"332\":3}}],[\"atomicstampedreference\",{\"1\":{\"847\":1}}],[\"atomicmarkablereference\",{\"1\":{\"847\":1}}],[\"atomicreferencefieldupdater\",{\"1\":{\"847\":1}}],[\"atomicreference\",{\"1\":{\"847\":1}}],[\"atomicreferencearray\",{\"1\":{\"847\":1}}],[\"atomicboolean\",{\"1\":{\"847\":1}}],[\"atomiclong在高并发情况下可能会产生大量的竞争和cas重试\",{\"1\":{\"855\":1}}],[\"atomiclong是基于cas\",{\"1\":{\"855\":1}}],[\"atomiclongfieldupdater\",{\"1\":{\"847\":1}}],[\"atomiclongarray\",{\"1\":{\"847\":1}}],[\"atomiclong\",{\"1\":{\"831\":1,\"847\":1}}],[\"atomic\",{\"1\":{\"831\":1,\"844\":1,\"870\":1}}],[\"atomicintegerfieldupdater\",{\"1\":{\"847\":1}}],[\"atomicintegerarray\",{\"1\":{\"847\":1}}],[\"atomicinteger\",{\"0\":{\"847\":1},\"1\":{\"829\":2,\"831\":1,\"844\":5,\"847\":2,\"870\":3}}],[\"atomicity\",{\"1\":{\"814\":1}}],[\"atc\",{\"1\":{\"403\":6}}],[\"at\",{\"1\":{\"372\":2}}],[\"adaptee\",{\"1\":{\"508\":1}}],[\"adapter\",{\"1\":{\"490\":1,\"508\":2}}],[\"adjust\",{\"1\":{\"360\":3}}],[\"adjusting\",{\"1\":{\"360\":3}}],[\"adjustvolume\",{\"1\":{\"360\":9}}],[\"addworker\",{\"1\":{\"870\":3}}],[\"addcomponent\",{\"1\":{\"524\":5,\"525\":12}}],[\"addcityelement\",{\"1\":{\"372\":4}}],[\"adddays\",{\"1\":{\"455\":4}}],[\"addsong\",{\"1\":{\"454\":8}}],[\"addstrategy\",{\"1\":{\"343\":2,\"346\":2}}],[\"addexpression\",{\"1\":{\"390\":3}}],[\"additem\",{\"1\":{\"384\":2}}],[\"additemcommand\",{\"1\":{\"384\":5}}],[\"addpage\",{\"1\":{\"372\":6}}],[\"addhandler\",{\"1\":{\"353\":3,\"354\":3}}],[\"addobserver\",{\"1\":{\"327\":5}}],[\"add\",{\"1\":{\"325\":1,\"326\":2,\"327\":1,\"354\":1,\"366\":2,\"372\":2,\"377\":1,\"384\":1,\"454\":2,\"455\":2,\"524\":1,\"525\":7,\"710\":1}}],[\"address\",{\"1\":{\"131\":1,\"196\":1,\"450\":9,\"518\":1,\"574\":2,\"575\":3}}],[\"addr|$upstream\",{\"1\":{\"8\":1,\"34\":1}}],[\"addr|$protocol|$status|$bytes\",{\"1\":{\"8\":1,\"34\":1}}],[\"addr\",{\"1\":{\"8\":3,\"34\":3}}],[\"aliasing\",{\"1\":{\"622\":1}}],[\"alipaystrategy\",{\"1\":{\"344\":5}}],[\"already\",{\"1\":{\"360\":4}}],[\"algorithm\",{\"1\":{\"314\":1,\"315\":1,\"316\":5}}],[\"allocation\",{\"1\":{\"728\":1}}],[\"allowbackup=\",{\"1\":{\"539\":1}}],[\"all\",{\"1\":{\"11\":3,\"37\":3}}],[\"a向b发送数据\",{\"1\":{\"294\":1}}],[\"amount\",{\"1\":{\"344\":9,\"510\":13,\"518\":3}}],[\"am\",{\"1\":{\"239\":1,\"619\":1}}],[\"a类\",{\"0\":{\"600\":1},\"1\":{\"218\":1}}],[\"animal2\",{\"1\":{\"469\":2}}],[\"animal1\",{\"1\":{\"469\":2}}],[\"animal\",{\"1\":{\"469\":10,\"485\":4}}],[\"andy\",{\"1\":{\"537\":1}}],[\"android开发\",{\"2\":{\"541\":1}}],[\"android开发语言\",{\"1\":{\"537\":1}}],[\"android使用\",{\"1\":{\"540\":1}}],[\"android=\",{\"1\":{\"539\":1,\"540\":1}}],[\"androidtestimplementation\",{\"1\":{\"539\":2}}],[\"androidjunitrunner\",{\"1\":{\"539\":1}}],[\"androidx\",{\"1\":{\"539\":6,\"540\":1}}],[\"androidmanifest\",{\"1\":{\"539\":2}}],[\"android\",{\"1\":{\"538\":2,\"539\":29,\"540\":9},\"2\":{\"542\":1}}],[\"android起源\",{\"1\":{\"537\":1}}],[\"android之父\",{\"1\":{\"537\":1}}],[\"android学习前应该具备的前置知识\",{\"1\":{\"536\":1}}],[\"android前置知识\",{\"0\":{\"536\":1}}],[\"andexpression\",{\"1\":{\"394\":3,\"395\":1}}],[\"and\",{\"1\":{\"215\":1,\"394\":2,\"538\":1,\"720\":1,\"829\":1,\"839\":1,\"845\":2,\"855\":2}}],[\"anotheraimpl\",{\"1\":{\"477\":1}}],[\"another\",{\"1\":{\"14\":1,\"40\":1}}],[\"assert\",{\"1\":{\"793\":1}}],[\"assertionerror\",{\"1\":{\"793\":1}}],[\"assigned\",{\"1\":{\"215\":1}}],[\"ascii\",{\"1\":{\"777\":1}}],[\"asm等字节码生成工具\",{\"1\":{\"731\":1}}],[\"aslist\",{\"1\":{\"455\":1}}],[\"as之间使用的路由协议\",{\"1\":{\"211\":1}}],[\"as\",{\"1\":{\"211\":1,\"826\":1}}],[\"a主机收到后交由上层处理\",{\"1\":{\"168\":1,\"583\":1}}],[\"a\",{\"0\":{\"125\":1,\"129\":1,\"298\":1},\"1\":{\"217\":2,\"218\":1,\"314\":5,\"315\":5,\"316\":16,\"378\":3,\"477\":1,\"595\":1,\"728\":1,\"760\":1,\"829\":1,\"833\":1,\"845\":6,\"848\":1}}],[\"arithmeticexception\",{\"1\":{\"793\":1}}],[\"arguments\",{\"1\":{\"497\":3,\"498\":3}}],[\"args\",{\"1\":{\"325\":1,\"326\":1,\"327\":1,\"343\":1,\"344\":1,\"346\":2,\"350\":1,\"353\":1,\"354\":1,\"359\":1,\"360\":2,\"365\":1,\"366\":1,\"372\":2,\"377\":1,\"378\":1,\"383\":1,\"384\":1,\"390\":1,\"394\":1,\"403\":1,\"408\":1,\"436\":1,\"443\":1,\"448\":1,\"450\":3,\"454\":2,\"455\":1,\"469\":1,\"485\":1,\"495\":5,\"497\":5,\"498\":1,\"502\":2,\"506\":1,\"510\":1,\"518\":1,\"524\":1,\"525\":2,\"795\":1,\"822\":1,\"870\":1}}],[\"artist\",{\"1\":{\"454\":9}}],[\"article\",{\"1\":{\"372\":1}}],[\"articlepagecount++\",{\"1\":{\"372\":1}}],[\"articlepagecount\",{\"1\":{\"372\":2}}],[\"articlepage\",{\"1\":{\"372\":7}}],[\"arrayblockingqueue<>\",{\"1\":{\"870\":1}}],[\"arrayblockingqueue\",{\"1\":{\"862\":2}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"793\":1}}],[\"arrayiterator\",{\"1\":{\"366\":3}}],[\"arrayiterator类是具体的迭代器类\",{\"1\":{\"366\":1}}],[\"arrays\",{\"1\":{\"455\":1}}],[\"array\",{\"1\":{\"366\":6}}],[\"arraylist是线程不安全的\",{\"1\":{\"681\":1}}],[\"arraylist是线程安全的吗\",{\"1\":{\"681\":1}}],[\"arraylist是不是线程安全的\",{\"0\":{\"681\":1}}],[\"arraylist是java基于数组实现的一种动态数组的数据结构\",{\"1\":{\"677\":1}}],[\"arraylist通过两个方法readobject\",{\"1\":{\"680\":1}}],[\"arraylist的序列化不太一样\",{\"1\":{\"680\":1}}],[\"arraylist怎么序列化的知道吗\",{\"1\":{\"680\":1}}],[\"arraylist序列化\",{\"0\":{\"680\":1}}],[\"arraylist和linkedlist的区别\",{\"0\":{\"679\":1}}],[\"arraylist\",{\"1\":{\"327\":1,\"681\":5}}],[\"arraylist<>\",{\"1\":{\"325\":1,\"326\":1,\"327\":1,\"354\":1,\"372\":2,\"377\":1,\"384\":1,\"454\":5,\"455\":1,\"524\":1,\"525\":2}}],[\"arp是一个独立的三层协议\",{\"1\":{\"197\":1}}],[\"arp映射表工作流程\",{\"1\":{\"198\":1}}],[\"arp映射表\",{\"0\":{\"198\":1},\"1\":{\"196\":1}}],[\"arp报文格式\",{\"0\":{\"197\":1},\"1\":{\"197\":1}}],[\"arp报文\",{\"1\":{\"196\":1}}],[\"arp高速缓存条目有静态与动态两种类型\",{\"1\":{\"168\":1,\"583\":1}}],[\"arp协议主要用于在同一局域网内解析ip地址到mac地址的映射关系\",{\"1\":{\"583\":1}}],[\"arp协议允许设备在需要通信时动态地获取目标设备的mac地址\",{\"1\":{\"583\":1}}],[\"arp协议用于在局域网中确定一个ip地址对应的mac地址\",{\"1\":{\"583\":1}}],[\"arp协议是用来做什么的\",{\"0\":{\"583\":1},\"1\":{\"583\":1}}],[\"arp协议只能在一段链路或一个网络上使用\",{\"1\":{\"168\":1,\"583\":1}}],[\"arp协议\",{\"0\":{\"163\":1,\"168\":1,\"195\":1},\"1\":{\"196\":1}}],[\"arp\",{\"1\":{\"159\":1,\"196\":1,\"579\":1,\"583\":1}}],[\"arpa\",{\"1\":{\"69\":1,\"268\":1}}],[\"area\",{\"1\":{\"155\":1,\"161\":1}}],[\"archive\",{\"1\":{\"17\":1,\"43\":1}}],[\"aero\",{\"1\":{\"69\":1}}],[\"acc\",{\"1\":{\"835\":1}}],[\"accept\",{\"1\":{\"8\":1,\"34\":1,\"372\":15}}],[\"access端口发送处理方法\",{\"1\":{\"159\":1}}],[\"access端口接收并处理\",{\"1\":{\"159\":1}}],[\"access端口只能属于一个vlan\",{\"1\":{\"159\":1}}],[\"access端口通常用于连接用户计算机或其他终端设备\",{\"1\":{\"159\":1}}],[\"access端口的基本特性和工作原理\",{\"1\":{\"159\":1}}],[\"access\",{\"1\":{\"8\":7,\"34\":7,\"94\":1,\"120\":1,\"144\":1,\"159\":2,\"223\":1,\"418\":1,\"495\":1,\"574\":1,\"581\":2}}],[\"action\",{\"1\":{\"539\":1}}],[\"activity>\",{\"1\":{\"539\":1}}],[\"activity是一个应用程序组件\",{\"1\":{\"539\":1}}],[\"activity\",{\"1\":{\"538\":4}}],[\"activemq\",{\"1\":{\"327\":1}}],[\"active\",{\"1\":{\"85\":1}}],[\"ack\",{\"0\":{\"641\":1,\"660\":1},\"1\":{\"297\":1}}],[\"ack状态\",{\"1\":{\"286\":1}}],[\"ack=2\",{\"1\":{\"291\":4}}],[\"ack=w+1\",{\"1\":{\"286\":1}}],[\"ack=u+1\",{\"1\":{\"286\":2}}],[\"ack=y+1\",{\"1\":{\"285\":1}}],[\"ack=x+1\",{\"1\":{\"285\":1}}],[\"ack=1\",{\"1\":{\"285\":2,\"286\":3,\"290\":1}}],[\"ack=0\",{\"1\":{\"285\":1}}],[\"ack无效\",{\"1\":{\"285\":1}}],[\"acknowledgement\",{\"1\":{\"210\":1}}],[\"acknowledgment\",{\"1\":{\"64\":1}}],[\"ac\",{\"1\":{\"69\":1}}],[\"author\",{\"1\":{\"497\":3}}],[\"authenticate\",{\"1\":{\"495\":2}}],[\"auth\",{\"1\":{\"8\":1,\"34\":1}}],[\"auto选择真机\",{\"1\":{\"538\":1}}],[\"autoconf\",{\"1\":{\"24\":1,\"50\":1}}],[\"automake\",{\"1\":{\"24\":1,\"50\":1}}],[\"auto\",{\"1\":{\"8\":1,\"34\":1,\"538\":1,\"540\":1,\"863\":1}}],[\"apollo等等\",{\"1\":{\"869\":1}}],[\"apk\",{\"1\":{\"539\":1,\"540\":2}}],[\"app=\",{\"1\":{\"540\":1}}],[\"appcompat\",{\"1\":{\"539\":3}}],[\"app目录\",{\"1\":{\"539\":1}}],[\"app\",{\"1\":{\"506\":1,\"539\":2,\"540\":4}}],[\"applydiscount\",{\"1\":{\"465\":4}}],[\"application>\",{\"1\":{\"539\":1}}],[\"applicationid\",{\"1\":{\"539\":1}}],[\"application\",{\"1\":{\"8\":4,\"34\":4,\"539\":1}}],[\"append\",{\"1\":{\"454\":12,\"792\":1}}],[\"apache\",{\"1\":{\"419\":2,\"485\":1}}],[\"api版本\",{\"1\":{\"538\":1}}],[\"api地址\",{\"1\":{\"8\":1,\"34\":1}}],[\"api\",{\"0\":{\"554\":1},\"1\":{\"8\":4,\"22\":4,\"34\":4,\"48\":4,\"539\":1,\"811\":1}}],[\"api开头的请求会被导航到此处\",{\"1\":{\"8\":1,\"34\":1}}],[\"$path\",{\"1\":{\"19\":1,\"45\":1}}],[\"$server\",{\"1\":{\"8\":1,\"34\":1}}],[\"$binary\",{\"1\":{\"8\":1,\"34\":1}}],[\"$time\",{\"1\":{\"8\":1,\"34\":1}}],[\"$remote\",{\"1\":{\"8\":2,\"34\":2}}],[\"$uri\",{\"1\":{\"8\":4,\"34\":4}}],[\"xloggc\",{\"1\":{\"764\":1}}],[\"xmn来降低\",{\"1\":{\"767\":1}}],[\"xms\",{\"1\":{\"764\":2}}],[\"xml类似于html\",{\"1\":{\"540\":1}}],[\"xml描绘应用界面\",{\"1\":{\"540\":1}}],[\"xmlns\",{\"1\":{\"539\":2,\"540\":3}}],[\"xml清单文件注释\",{\"1\":{\"539\":1}}],[\"xmlsmsadapter\",{\"1\":{\"511\":2}}],[\"xml\",{\"1\":{\"8\":1,\"34\":1,\"498\":1,\"511\":1,\"539\":4,\"540\":1}}],[\"xx\",{\"0\":{\"663\":1},\"1\":{\"725\":1,\"740\":3,\"764\":16}}],[\"xxxvalue\",{\"1\":{\"773\":1}}],[\"xxxxxx\",{\"1\":{\"765\":1}}],[\"xxx\",{\"1\":{\"168\":2,\"583\":2}}],[\"xoff\",{\"1\":{\"141\":1,\"576\":1}}],[\"xon\",{\"1\":{\"141\":1,\"576\":1}}],[\"x在性能上有了显著的提升\",{\"1\":{\"113\":1}}],[\"x中\",{\"1\":{\"113\":1}}],[\"xftp传输过程\",{\"1\":{\"86\":1}}],[\"x86\",{\"1\":{\"24\":1,\"50\":1}}],[\"x64\",{\"1\":{\"18\":1,\"44\":1}}],[\"x\",{\"1\":{\"8\":3,\"34\":3,\"135\":1,\"166\":1,\"264\":1,\"343\":4,\"346\":4,\"576\":1,\"671\":2,\"765\":1,\"769\":2,\"827\":1}}],[\"xshell远程连接服务器\",{\"1\":{\"3\":1,\"29\":1}}],[\"h20\",{\"1\":{\"768\":1}}],[\"hprof\",{\"1\":{\"766\":1}}],[\"hp\",{\"1\":{\"765\":1,\"769\":1}}],[\"humongous\",{\"1\":{\"750\":1}}],[\"hub\",{\"1\":{\"171\":1,\"240\":1,\"580\":2,\"618\":1}}],[\"h\",{\"1\":{\"691\":1,\"693\":3,\"694\":2,\"695\":2}}],[\"hrdepartment\",{\"1\":{\"525\":2}}],[\"hibernate等\",{\"1\":{\"800\":1}}],[\"histo\",{\"1\":{\"766\":1,\"768\":2,\"769\":1}}],[\"history\",{\"1\":{\"372\":1,\"378\":13}}],[\"high\",{\"1\":{\"584\":1}}],[\"hi\",{\"1\":{\"408\":2}}],[\"harreturnvaluetask\",{\"1\":{\"863\":1}}],[\"hard\",{\"1\":{\"448\":1}}],[\"harddisk\",{\"1\":{\"448\":5}}],[\"hagersten\",{\"1\":{\"839\":1}}],[\"happens\",{\"1\":{\"826\":2}}],[\"hah\",{\"1\":{\"731\":1}}],[\"have\",{\"1\":{\"378\":3}}],[\"has\",{\"1\":{\"461\":1,\"481\":1}}],[\"hasnext\",{\"1\":{\"365\":4,\"366\":3,\"436\":1,\"443\":1,\"702\":1}}],[\"hash计算后应该落入第\",{\"1\":{\"820\":1}}],[\"hash分布非常均匀\",{\"1\":{\"819\":1}}],[\"hash增量为\",{\"1\":{\"819\":1}}],[\"hash一样就覆盖\",{\"1\":{\"711\":1}}],[\"hashentry本身就是一个链表的结构\",{\"1\":{\"711\":1}}],[\"hashtable\",{\"0\":{\"706\":1},\"1\":{\"706\":15,\"708\":2}}],[\"hash表是一种数据结构\",{\"1\":{\"690\":1}}],[\"hash算法\",{\"1\":{\"690\":1}}],[\"hash算法通常是要结合数组来实现hash表\",{\"1\":{\"690\":1}}],[\"hash算法是一种散列算法\",{\"1\":{\"690\":1}}],[\"hashset是collection接口下面的set接口的子实现类\",{\"1\":{\"704\":1}}],[\"hashset\",{\"0\":{\"704\":1},\"1\":{\"683\":3,\"704\":4,\"731\":1,\"787\":1}}],[\"hashset实现就是基于\",{\"1\":{\"683\":1}}],[\"hashset实现原理\",{\"0\":{\"683\":1},\"1\":{\"683\":1}}],[\"hashmap为什么线程不安全\",{\"0\":{\"707\":1},\"1\":{\"707\":1}}],[\"hashmap实现了\",{\"1\":{\"704\":1}}],[\"hashmap可以按照key来排序吗\",{\"0\":{\"703\":1},\"1\":{\"703\":1}}],[\"hashmap可以添加null\",{\"0\":{\"687\":1},\"1\":{\"687\":1}}],[\"hashmap怎么查找元素的呢\",{\"0\":{\"700\":1},\"1\":{\"700\":1}}],[\"hashmap使用链表的原因为了处理哈希冲突\",{\"1\":{\"692\":1}}],[\"hashmap里哈希构造函数的方法叫\",{\"1\":{\"691\":1}}],[\"hashmap会向上寻找离得最近的2的倍数\",{\"1\":{\"689\":1}}],[\"hashmap的查找就简单很多\",{\"1\":{\"700\":1}}],[\"hashmap的put\",{\"0\":{\"695\":1},\"1\":{\"695\":1}}],[\"hashmap的哈希函数是先拿到\",{\"1\":{\"693\":1}}],[\"hashmap的哈希\",{\"0\":{\"693\":1}}],[\"hashmap的容量是2的n次幂时\",{\"1\":{\"688\":1}}],[\"hashmap的实现原理\",{\"0\":{\"686\":1},\"1\":{\"686\":1}}],[\"hashmap是无序的\",{\"1\":{\"703\":1}}],[\"hashmap是用hash值\",{\"1\":{\"688\":1}}],[\"hashmap是map接口下的一个实现类\",{\"1\":{\"685\":1}}],[\"hashmap\",{\"0\":{\"702\":1,\"704\":1,\"705\":1,\"706\":1,\"715\":1},\"1\":{\"683\":4,\"685\":4,\"686\":2,\"687\":4,\"688\":1,\"689\":1,\"694\":2,\"696\":2,\"702\":1,\"704\":6,\"705\":9,\"706\":15,\"707\":4,\"713\":1,\"714\":4,\"715\":8,\"731\":1,\"787\":1,\"788\":3}}],[\"hashmap<string\",{\"1\":{\"326\":1}}],[\"hashmap<>\",{\"1\":{\"326\":2,\"346\":2,\"436\":1,\"443\":1,\"495\":1,\"702\":3}}],[\"hashcode\",{\"0\":{\"788\":1},\"1\":{\"672\":1,\"686\":1,\"687\":1,\"693\":1,\"694\":1,\"695\":1,\"785\":1,\"787\":5,\"788\":20}}],[\"hash\",{\"1\":{\"8\":1,\"34\":1,\"686\":3,\"688\":1,\"693\":1,\"694\":1,\"695\":2,\"701\":2,\"703\":1,\"707\":2,\"711\":1,\"731\":3,\"819\":2}}],[\"handle\",{\"1\":{\"353\":4,\"354\":4,\"359\":4}}],[\"handler这四个\",{\"1\":{\"860\":1}}],[\"handlers\",{\"1\":{\"354\":4}}],[\"handlerchain类持有一个list<handler>\",{\"1\":{\"354\":1}}],[\"handlerchain\",{\"1\":{\"353\":5,\"354\":4}}],[\"handlerc\",{\"1\":{\"350\":2}}],[\"handlerb\",{\"1\":{\"350\":3}}],[\"handlera\",{\"1\":{\"350\":4}}],[\"handlerequest\",{\"1\":{\"350\":7}}],[\"handler\",{\"1\":{\"350\":15,\"353\":17,\"354\":10,\"497\":2,\"860\":1}}],[\"handleputrequest\",{\"1\":{\"338\":3}}],[\"handlepostrequest\",{\"1\":{\"338\":5}}],[\"handlegetrequest\",{\"1\":{\"338\":4}}],[\"hz\",{\"1\":{\"261\":1}}],[\"hdlc在数据帧中使用循环冗余检验\",{\"1\":{\"584\":1}}],[\"hdlc支持基本的流量控制机制\",{\"1\":{\"584\":1}}],[\"hdlc\",{\"1\":{\"162\":1,\"584\":2}}],[\"hdlc协议在数据链路层中起到了数据封装\",{\"1\":{\"584\":1}}],[\"hdlc协议在数据链路层中有什么作用\",{\"0\":{\"584\":1},\"1\":{\"584\":1}}],[\"hdlc协议负责在物理介质上传输数据帧\",{\"1\":{\"584\":1}}],[\"hdlc协议能够将上层数据封装为数据帧\",{\"1\":{\"584\":1}}],[\"hdlc协议\",{\"1\":{\"131\":1}}],[\"hybrid端口接收处理方法\",{\"1\":{\"159\":1}}],[\"hybrid端口发送处理方法\",{\"1\":{\"159\":1}}],[\"hybrid端口的pvid值为1\",{\"1\":{\"159\":1}}],[\"hybrid端口的基本特性和工作原理\",{\"1\":{\"159\":1}}],[\"hybrid端口可以属于多个vlan\",{\"1\":{\"159\":1}}],[\"hybrid端口既可用于交换机之间或交换机与路由器之间的互连\",{\"1\":{\"159\":1}}],[\"hybrid\",{\"1\":{\"159\":2}}],[\"hb\",{\"1\":{\"69\":1}}],[\"hotspot虚拟机开发团队对java中的锁进行优化\",{\"1\":{\"837\":1}}],[\"hotspot\",{\"1\":{\"740\":2,\"742\":1,\"747\":2,\"835\":1}}],[\"hooks\",{\"1\":{\"721\":1}}],[\"hook\",{\"1\":{\"721\":1}}],[\"hosts\",{\"1\":{\"75\":1}}],[\"host\",{\"1\":{\"62\":1}}],[\"homeproduct\",{\"1\":{\"506\":1}}],[\"homepagecount++\",{\"1\":{\"372\":1}}],[\"homepagecount\",{\"1\":{\"372\":2}}],[\"homepage\",{\"1\":{\"372\":7}}],[\"home\",{\"1\":{\"19\":1,\"45\":1,\"372\":1,\"766\":1}}],[\"home=\",{\"1\":{\"19\":1,\"45\":1}}],[\"heap\",{\"1\":{\"769\":3}}],[\"head\",{\"1\":{\"353\":5,\"766\":1,\"768\":1}}],[\"head>\",{\"1\":{\"8\":1,\"34\":1}}],[\"header\",{\"1\":{\"8\":4,\"34\":4,\"113\":1}}],[\"height=\",{\"1\":{\"540\":2}}],[\"helm\",{\"1\":{\"490\":1}}],[\"hello分组封装在ip数据报中\",{\"1\":{\"210\":1}}],[\"hello\",{\"1\":{\"210\":3,\"327\":1,\"378\":5,\"408\":2,\"540\":1}}],[\"helloworld\",{\"1\":{\"8\":1,\"34\":1}}],[\"hey\",{\"1\":{\"408\":2}}],[\"hessianserializer\",{\"1\":{\"346\":4}}],[\"htc\",{\"1\":{\"537\":1}}],[\"htm\",{\"1\":{\"8\":2,\"34\":2}}],[\"html是一种标记语言\",{\"1\":{\"104\":1}}],[\"html文件\",{\"1\":{\"8\":1,\"34\":1}}],[\"html>\",{\"1\":{\"8\":2,\"34\":2}}],[\"html\",{\"1\":{\"8\":8,\"17\":1,\"34\":8,\"43\":1,\"96\":1}}],[\"http和https的区别是什么\",{\"0\":{\"552\":1}}],[\"httpvideoresource\",{\"1\":{\"443\":3}}],[\"httptextresource\",{\"1\":{\"443\":3}}],[\"httppictureresource\",{\"1\":{\"443\":4}}],[\"httpresourcefactory\",{\"1\":{\"443\":2}}],[\"http1\",{\"0\":{\"111\":1,\"112\":1}}],[\"http本身是无连接的\",{\"1\":{\"109\":1}}],[\"http采用tcp作为传输层协议\",{\"1\":{\"109\":1}}],[\"http是面向连接的\",{\"1\":{\"109\":1}}],[\"http是无状态的\",{\"1\":{\"109\":1}}],[\"http是万维网上用于传输数据的协议\",{\"1\":{\"104\":1}}],[\"http报文结构\",{\"1\":{\"107\":1}}],[\"http报文分为请求报文和响应报文两种类型\",{\"1\":{\"107\":1}}],[\"http的报文格式\",{\"0\":{\"548\":1}}],[\"http的报文结构\",{\"0\":{\"107\":1}}],[\"http的特点\",{\"0\":{\"109\":1}}],[\"http的连接过程\",{\"0\":{\"108\":1}}],[\"http的作用\",{\"0\":{\"106\":1}}],[\"http定义了\",{\"1\":{\"106\":1}}],[\"httpservletresponse\",{\"1\":{\"338\":9}}],[\"httpservletrequest\",{\"1\":{\"338\":9}}],[\"httpservlet\",{\"1\":{\"338\":1}}],[\"https\",{\"1\":{\"3\":1,\"5\":1,\"17\":1,\"29\":1,\"31\":1,\"43\":1,\"104\":1,\"538\":1}}],[\"http\",{\"0\":{\"113\":1,\"553\":1,\"557\":1,\"560\":1,\"562\":1,\"564\":1},\"1\":{\"3\":1,\"8\":4,\"24\":1,\"29\":1,\"34\":4,\"50\":1,\"111\":1,\"112\":2,\"113\":2,\"279\":1,\"422\":1,\"429\":1,\"539\":2,\"540\":3}}],[\"pn>\",{\"1\":{\"848\":1}}],[\"pn\",{\"1\":{\"848\":1}}],[\"p3\",{\"1\":{\"848\":2}}],[\"p2\",{\"1\":{\"848\":2}}],[\"p2p方式强调了节点之间的对等关系\",{\"1\":{\"59\":1}}],[\"p2p方式\",{\"1\":{\"59\":1}}],[\"p2p模型\",{\"0\":{\"59\":1}}],[\"p1\",{\"1\":{\"848\":1}}],[\"p<=n\",{\"1\":{\"691\":1}}],[\"pipedreader和pipedwriter\",{\"1\":{\"811\":1}}],[\"pipedinputstream\",{\"1\":{\"811\":1}}],[\"pipedoutputstream\",{\"1\":{\"811\":1}}],[\"ping的工作原理是什么\",{\"0\":{\"614\":1}}],[\"pid\",{\"1\":{\"8\":2,\"34\":2,\"765\":2,\"766\":3,\"768\":3,\"769\":7}}],[\"plugins\",{\"1\":{\"539\":1}}],[\"playlistbycloneableinterface\",{\"1\":{\"454\":9}}],[\"playlist\",{\"1\":{\"454\":29}}],[\"plain\",{\"1\":{\"8\":1,\"34\":1}}],[\"phantomreference\",{\"1\":{\"735\":3}}],[\"phone\",{\"1\":{\"538\":1}}],[\"physical\",{\"1\":{\"506\":1}}],[\"physicalstorechannel\",{\"1\":{\"506\":2}}],[\"psycho\",{\"1\":{\"454\":2,\"525\":6}}],[\"periodic\",{\"1\":{\"721\":1}}],[\"performaction\",{\"1\":{\"797\":1}}],[\"performtask\",{\"1\":{\"495\":5}}],[\"performing\",{\"1\":{\"495\":5}}],[\"performoperation\",{\"1\":{\"495\":12}}],[\"person\",{\"1\":{\"450\":1}}],[\"pen\",{\"1\":{\"464\":1}}],[\"peer\",{\"1\":{\"212\":1}}],[\"pdfreport\",{\"1\":{\"336\":1}}],[\"pdf报告\",{\"1\":{\"336\":1}}],[\"push\",{\"1\":{\"378\":3}}],[\"putifabsent\",{\"1\":{\"713\":1}}],[\"put流程\",{\"1\":{\"711\":2}}],[\"put请求并生成响应\",{\"1\":{\"338\":1}}],[\"put\",{\"1\":{\"326\":2,\"346\":2,\"436\":1,\"443\":1,\"495\":1,\"707\":4}}],[\"publishevent\",{\"1\":{\"326\":2}}],[\"publisher\",{\"1\":{\"326\":1}}],[\"public\",{\"1\":{\"325\":11,\"326\":11,\"327\":9,\"332\":3,\"335\":3,\"336\":4,\"338\":2,\"343\":6,\"344\":7,\"346\":25,\"350\":8,\"353\":9,\"354\":9,\"359\":7,\"360\":20,\"365\":6,\"366\":11,\"372\":24,\"377\":10,\"378\":11,\"383\":10,\"384\":10,\"390\":8,\"394\":10,\"403\":7,\"408\":7,\"422\":3,\"429\":3,\"436\":14,\"443\":47,\"448\":13,\"450\":26,\"454\":26,\"455\":4,\"461\":8,\"465\":11,\"469\":3,\"473\":7,\"481\":9,\"485\":10,\"489\":27,\"495\":25,\"497\":11,\"498\":11,\"502\":15,\"506\":11,\"510\":14,\"511\":9,\"518\":7,\"524\":6,\"525\":19,\"689\":1,\"754\":1,\"783\":1,\"785\":9,\"795\":2,\"797\":6,\"822\":3,\"827\":3,\"832\":1,\"838\":2,\"840\":2,\"842\":2,\"847\":2,\"863\":1,\"870\":6}}],[\"pm\",{\"1\":{\"239\":1,\"619\":1}}],[\"pvid为1\",{\"1\":{\"159\":1}}],[\"pvid\",{\"1\":{\"159\":1}}],[\"pc\",{\"1\":{\"722\":1}}],[\"pc与android\",{\"1\":{\"538\":1}}],[\"pcf方式使用集中控制的接入算法\",{\"1\":{\"152\":1}}],[\"pcc\",{\"1\":{\"134\":1}}],[\"ppp\",{\"1\":{\"162\":1,\"575\":1,\"584\":1}}],[\"ppp同步传输协议\",{\"1\":{\"131\":1}}],[\"ppp帧结构\",{\"1\":{\"131\":1}}],[\"ppp帧结构如下\",{\"1\":{\"131\":1}}],[\"ppp帧\",{\"1\":{\"129\":1}}],[\"ppp协议\",{\"1\":{\"121\":1}}],[\"pom\",{\"1\":{\"498\":1}}],[\"point\",{\"1\":{\"418\":1}}],[\"port\",{\"1\":{\"159\":7,\"769\":1}}],[\"poplast\",{\"1\":{\"378\":2}}],[\"pop3\",{\"1\":{\"97\":2,\"99\":1}}],[\"pop\",{\"0\":{\"97\":1},\"1\":{\"378\":1}}],[\"post请求并生成响应\",{\"1\":{\"338\":1}}],[\"post和put请求的逻辑\",{\"1\":{\"338\":1}}],[\"post和put请求\",{\"1\":{\"338\":2}}],[\"post和put请求时\",{\"1\":{\"338\":1}}],[\"post\",{\"0\":{\"555\":1},\"1\":{\"94\":1}}],[\"p\",{\"1\":{\"8\":1,\"11\":1,\"34\":1,\"37\":1,\"353\":5,\"691\":1,\"769\":1,\"853\":1}}],[\"pretenuresizethreshold\",{\"1\":{\"740\":1}}],[\"preparation\",{\"1\":{\"720\":1}}],[\"present\",{\"1\":{\"683\":1}}],[\"pressbutton\",{\"1\":{\"383\":3}}],[\"preamble\",{\"1\":{\"575\":1}}],[\"prefixkey\",{\"1\":{\"436\":2,\"443\":2}}],[\"prefix\",{\"1\":{\"422\":4,\"429\":2,\"436\":2,\"443\":2}}],[\"priorityblockingqueue\",{\"1\":{\"862\":2}}],[\"prio=0\",{\"1\":{\"769\":1}}],[\"prio=9\",{\"1\":{\"769\":1}}],[\"price\",{\"1\":{\"455\":1,\"506\":8}}],[\"principle\",{\"1\":{\"346\":1,\"460\":1,\"464\":1,\"468\":1,\"472\":1,\"474\":1,\"476\":1,\"488\":1}}],[\"printlist\",{\"1\":{\"797\":1}}],[\"println\",{\"1\":{\"314\":1,\"315\":1,\"316\":6,\"325\":2,\"326\":2,\"327\":1,\"343\":6,\"344\":3,\"346\":7,\"350\":4,\"353\":2,\"354\":2,\"359\":2,\"360\":12,\"366\":1,\"372\":11,\"377\":2,\"378\":5,\"383\":2,\"384\":3,\"390\":1,\"394\":2,\"403\":3,\"408\":3,\"436\":1,\"443\":4,\"448\":4,\"450\":2,\"454\":10,\"455\":2,\"485\":5,\"495\":14,\"497\":12,\"498\":12,\"502\":9,\"506\":2,\"510\":2,\"518\":3,\"525\":4,\"795\":1,\"822\":1,\"870\":2}}],[\"printf\",{\"1\":{\"765\":1,\"769\":2}}],[\"printhello\",{\"1\":{\"485\":4}}],[\"printstacktrace\",{\"1\":{\"327\":1,\"455\":3,\"794\":1,\"870\":2}}],[\"print\",{\"1\":{\"315\":1,\"495\":1}}],[\"privileges\",{\"1\":{\"11\":3,\"37\":3}}],[\"private\",{\"1\":{\"8\":1,\"34\":1,\"325\":3,\"326\":5,\"327\":3,\"343\":1,\"344\":1,\"346\":3,\"350\":2,\"359\":1,\"360\":3,\"365\":3,\"366\":4,\"372\":5,\"377\":3,\"378\":5,\"383\":3,\"384\":5,\"390\":5,\"394\":6,\"403\":2,\"408\":2,\"422\":3,\"429\":2,\"436\":5,\"443\":7,\"448\":5,\"450\":16,\"454\":6,\"455\":12,\"461\":8,\"465\":3,\"481\":4,\"489\":9,\"495\":9,\"497\":1,\"498\":1,\"502\":1,\"506\":6,\"510\":3,\"518\":4,\"524\":1,\"525\":6,\"683\":1,\"775\":1,\"797\":1,\"819\":2,\"821\":2,\"844\":3,\"867\":5,\"870\":8}}],[\"profiling\",{\"1\":{\"720\":1}}],[\"profile\",{\"1\":{\"19\":2,\"45\":2,\"481\":1}}],[\"profile文件\",{\"1\":{\"19\":1,\"45\":1}}],[\"pro\",{\"1\":{\"539\":2}}],[\"proguardfiles\",{\"1\":{\"539\":1}}],[\"proguard\",{\"1\":{\"539\":4}}],[\"project\",{\"0\":{\"896\":1},\"1\":{\"538\":1}}],[\"promotion\",{\"1\":{\"739\":1}}],[\"promotionevent\",{\"1\":{\"455\":9}}],[\"promotionrule\",{\"1\":{\"455\":10}}],[\"properties\",{\"1\":{\"436\":8,\"443\":7,\"538\":1,\"539\":2}}],[\"properties的数据库\",{\"1\":{\"23\":1,\"49\":1}}],[\"productid\",{\"1\":{\"518\":3}}],[\"productsales\",{\"1\":{\"506\":7}}],[\"productpagecount++\",{\"1\":{\"372\":1}}],[\"productpagecount\",{\"1\":{\"372\":2}}],[\"productpage\",{\"1\":{\"372\":6}}],[\"product\",{\"1\":{\"353\":5,\"354\":5,\"372\":1,\"434\":2,\"441\":2,\"448\":1,\"455\":10,\"506\":15}}],[\"processpayment\",{\"1\":{\"510\":5,\"518\":2}}],[\"processed\",{\"1\":{\"461\":1}}],[\"processes\",{\"1\":{\"8\":1,\"34\":1}}],[\"processorderpayment\",{\"1\":{\"510\":3}}],[\"processorder\",{\"1\":{\"461\":2,\"489\":2,\"518\":2}}],[\"processor\",{\"1\":{\"448\":7}}],[\"process\",{\"1\":{\"335\":3}}],[\"prototype\",{\"1\":{\"453\":1,\"490\":1}}],[\"protocol\",{\"1\":{\"62\":1,\"83\":1,\"85\":1,\"87\":1,\"94\":2,\"131\":2,\"175\":3,\"196\":1,\"200\":1,\"207\":1,\"574\":1,\"575\":1,\"593\":1,\"828\":1}}],[\"protected\",{\"1\":{\"332\":6,\"335\":10,\"336\":9,\"338\":9,\"353\":3,\"354\":1,\"455\":2,\"785\":2}}],[\"provider\",{\"1\":{\"249\":1}}],[\"proxied\",{\"1\":{\"8\":1,\"34\":1}}],[\"proxyclass\",{\"1\":{\"495\":5}}],[\"proxy\",{\"1\":{\"8\":5,\"34\":5,\"490\":1,\"494\":1,\"495\":2,\"496\":1,\"497\":8,\"498\":5}}],[\"parnew\",{\"1\":{\"745\":1}}],[\"partial\",{\"1\":{\"738\":1}}],[\"participant\",{\"1\":{\"407\":1,\"408\":7,\"409\":1}}],[\"parallelism\",{\"1\":{\"826\":1}}],[\"parallelgcthreads=n\",{\"1\":{\"764\":2}}],[\"parallel\",{\"1\":{\"721\":1,\"745\":2,\"752\":1}}],[\"param\",{\"1\":{\"497\":5}}],[\"parity\",{\"1\":{\"576\":1}}],[\"parent\",{\"1\":{\"540\":6,\"822\":2}}],[\"parseexception\",{\"1\":{\"793\":1}}],[\"parse\",{\"1\":{\"511\":4}}],[\"park\",{\"1\":{\"372\":12}}],[\"pages\",{\"1\":{\"372\":3}}],[\"page\",{\"1\":{\"372\":13}}],[\"paymentmethod\",{\"1\":{\"518\":3}}],[\"paymentservice\",{\"1\":{\"518\":7}}],[\"paymentstrategy\",{\"1\":{\"344\":15}}],[\"paymentadapter\",{\"1\":{\"510\":5}}],[\"payment2022\",{\"1\":{\"510\":7}}],[\"payment2022implementation\",{\"1\":{\"510\":2}}],[\"payment2022interface\",{\"1\":{\"510\":9}}],[\"payment2023\",{\"1\":{\"510\":7}}],[\"payment2023interface\",{\"1\":{\"510\":5}}],[\"payment2023implementation\",{\"1\":{\"510\":4}}],[\"paymentinterfaceb\",{\"1\":{\"510\":3}}],[\"paymentcontext\",{\"1\":{\"344\":13}}],[\"pay\",{\"1\":{\"344\":7}}],[\"patterns\",{\"1\":{\"490\":4}}],[\"pattern\",{\"1\":{\"322\":1,\"330\":1,\"341\":1,\"348\":1,\"357\":1,\"363\":1,\"369\":1,\"375\":1,\"386\":2,\"388\":1,\"398\":1,\"416\":1,\"424\":1,\"430\":1,\"432\":1,\"439\":1,\"446\":1,\"453\":1,\"494\":1,\"500\":1,\"504\":1,\"508\":1,\"514\":1,\"528\":1}}],[\"path=$java\",{\"1\":{\"19\":1,\"45\":1}}],[\"package打包\",{\"1\":{\"23\":1,\"49\":1}}],[\"pan\",{\"1\":{\"22\":3,\"48\":3}}],[\"panel\",{\"1\":{\"8\":2,\"34\":2}}],[\"password123\",{\"1\":{\"495\":1}}],[\"password\",{\"1\":{\"481\":5,\"495\":9}}],[\"passive\",{\"1\":{\"85\":1}}],[\"pass\",{\"1\":{\"8\":2,\"34\":2}}],[\"rwlock\",{\"1\":{\"832\":3}}],[\"rwnd\",{\"1\":{\"296\":1,\"297\":2}}],[\"rmi\",{\"1\":{\"496\":1}}],[\"rm体系结构的传输层中\",{\"1\":{\"276\":1}}],[\"rm体系结构的传输层中还是把其中传输的数据单元称为tpdu\",{\"1\":{\"273\":1,\"278\":1}}],[\"rabbitmq框架\",{\"0\":{\"877\":1}}],[\"randomuuid\",{\"1\":{\"518\":1}}],[\"ralph\",{\"1\":{\"490\":1}}],[\"rap\",{\"1\":{\"450\":2}}],[\"rapid\",{\"1\":{\"175\":1}}],[\"rhythm\",{\"1\":{\"454\":2}}],[\"rlm\",{\"1\":{\"436\":2,\"443\":2}}],[\"rlimit\",{\"1\":{\"8\":1,\"34\":1}}],[\"rues\",{\"1\":{\"539\":1}}],[\"rubin\",{\"1\":{\"537\":1}}],[\"rule\",{\"1\":{\"455\":2}}],[\"rules\",{\"1\":{\"455\":6,\"539\":3}}],[\"rule2\",{\"1\":{\"394\":2,\"395\":1}}],[\"rule1\",{\"1\":{\"394\":2,\"395\":1}}],[\"running\",{\"1\":{\"867\":3}}],[\"runnable\",{\"1\":{\"769\":2,\"806\":1,\"808\":1,\"863\":1,\"870\":7}}],[\"runner\",{\"1\":{\"539\":1}}],[\"runtime和处理器都必须遵守as\",{\"1\":{\"826\":1}}],[\"runtimeexception\",{\"1\":{\"436\":2,\"443\":2,\"793\":1,\"870\":1}}],[\"runtime\",{\"1\":{\"419\":2,\"866\":1}}],[\"run\",{\"1\":{\"22\":1,\"48\":1,\"822\":2,\"863\":1,\"870\":2}}],[\"rpc\",{\"1\":{\"327\":2}}],[\"rpm\",{\"1\":{\"24\":2,\"50\":2}}],[\"rt\",{\"1\":{\"758\":1}}],[\"rtl\",{\"1\":{\"539\":1}}],[\"rtts本质是加权平均往返时间\",{\"1\":{\"291\":1}}],[\"rtt\",{\"1\":{\"265\":1}}],[\"rts\",{\"1\":{\"152\":1}}],[\"r1\",{\"1\":{\"221\":5}}],[\"r1发现最佳路由不是自己\",{\"1\":{\"201\":1}}],[\"rstp\",{\"1\":{\"175\":1}}],[\"richard\",{\"1\":{\"490\":1}}],[\"right\",{\"1\":{\"390\":12,\"539\":1}}],[\"rip的路由条目的更新规则\",{\"1\":{\"208\":1}}],[\"rip的基本工作过程\",{\"1\":{\"208\":1}}],[\"rip的基本思想如下\",{\"1\":{\"208\":1}}],[\"rip只适用于小型互联网\",{\"1\":{\"208\":1}}],[\"rip概述\",{\"1\":{\"208\":1}}],[\"rip协议\",{\"0\":{\"207\":1},\"1\":{\"207\":1}}],[\"rip\",{\"1\":{\"159\":2,\"206\":1,\"579\":1}}],[\"ring\",{\"1\":{\"158\":1}}],[\"round\",{\"1\":{\"539\":1}}],[\"roundicon=\",{\"1\":{\"539\":1}}],[\"routing\",{\"1\":{\"211\":1}}],[\"router\",{\"1\":{\"580\":1}}],[\"route\",{\"1\":{\"207\":1}}],[\"robot\",{\"1\":{\"473\":1}}],[\"rosesubscribe\",{\"1\":{\"326\":10}}],[\"rose\",{\"1\":{\"325\":3,\"326\":1}}],[\"ro\",{\"1\":{\"24\":1,\"50\":1}}],[\"roots对象能连到的对象加入到扫描栈中\",{\"1\":{\"746\":1}}],[\"roots\",{\"0\":{\"734\":1},\"1\":{\"733\":1,\"734\":2,\"736\":1,\"742\":2}}],[\"rootfolder\",{\"1\":{\"525\":5}}],[\"root密码\",{\"1\":{\"11\":1,\"37\":1}}],[\"root\",{\"1\":{\"8\":3,\"11\":3,\"34\":3,\"37\":3,\"733\":1,\"746\":1,\"750\":1,\"769\":1}}],[\"reject\",{\"1\":{\"870\":3}}],[\"reentrantreadwritelock是什么\",{\"1\":{\"842\":1}}],[\"reentrantreadwritelock\",{\"0\":{\"842\":1},\"1\":{\"831\":1,\"832\":1,\"842\":7}}],[\"reentrantlock需要手工声明来加锁和释放锁\",{\"1\":{\"843\":1}}],[\"reentrantlock类借助condition接口与newcondition\",{\"1\":{\"843\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"843\":1}}],[\"reentrantlock提供了一种能够中断等待锁的线程的机制\",{\"1\":{\"843\":1}}],[\"reentrantlock怎么实现公平和非公平锁\",{\"0\":{\"840\":1},\"1\":{\"840\":1}}],[\"reentrantlock的实现原理是什么\",{\"1\":{\"839\":1}}],[\"reentrantlock实现原理\",{\"0\":{\"839\":1}}],[\"reentrantlock\",{\"1\":{\"711\":1,\"831\":2,\"832\":4,\"838\":6,\"839\":9,\"840\":7,\"841\":1,\"842\":1,\"843\":1,\"844\":1}}],[\"rehash\",{\"1\":{\"821\":2}}],[\"region所属的年龄是动态变化的\",{\"1\":{\"749\":1}}],[\"region就是一块内存空间\",{\"1\":{\"749\":1}}],[\"registeruser\",{\"1\":{\"481\":2}}],[\"registerdeserializationstrategy\",{\"1\":{\"346\":5}}],[\"registersubscribe\",{\"1\":{\"326\":4}}],[\"remembered\",{\"1\":{\"742\":1}}],[\"removecomponent\",{\"1\":{\"524\":1,\"525\":1}}],[\"removesong\",{\"1\":{\"454\":2}}],[\"removesubscribe\",{\"1\":{\"326\":1}}],[\"removeitem\",{\"1\":{\"384\":2}}],[\"removeitemcommand\",{\"1\":{\"384\":5}}],[\"removeobserver\",{\"1\":{\"327\":2}}],[\"remove\",{\"1\":{\"325\":1,\"326\":1,\"327\":1,\"367\":3,\"384\":1,\"454\":2,\"524\":1,\"525\":3,\"710\":3,\"713\":1,\"731\":1,\"788\":1,\"818\":1}}],[\"remoteproxy\",{\"1\":{\"495\":3}}],[\"remoteserviceimpl\",{\"1\":{\"495\":2}}],[\"remoteservice\",{\"1\":{\"495\":10}}],[\"remotecontrol\",{\"1\":{\"383\":8}}],[\"remote\",{\"1\":{\"8\":1,\"34\":1,\"223\":1,\"495\":3}}],[\"reflect包\",{\"1\":{\"799\":1}}],[\"reflection\",{\"1\":{\"798\":1}}],[\"reflavor\",{\"1\":{\"525\":2}}],[\"reference\",{\"1\":{\"735\":3}}],[\"referencequeue\",{\"1\":{\"735\":6}}],[\"refinedabstraction\",{\"1\":{\"505\":1}}],[\"refined\",{\"1\":{\"504\":1}}],[\"retrieving\",{\"1\":{\"495\":1}}],[\"return\",{\"1\":{\"343\":3,\"346\":11,\"365\":4,\"366\":7,\"377\":4,\"378\":8,\"390\":3,\"394\":4,\"403\":1,\"408\":1,\"422\":5,\"429\":6,\"436\":5,\"443\":17,\"448\":2,\"450\":17,\"454\":11,\"455\":8,\"465\":5,\"489\":8,\"495\":5,\"497\":6,\"498\":3,\"506\":3,\"511\":6,\"518\":1,\"525\":1,\"689\":1,\"693\":1,\"694\":1,\"795\":6,\"797\":1,\"819\":1,\"847\":2,\"870\":4}}],[\"realimage\",{\"1\":{\"495\":12}}],[\"readlock\",{\"1\":{\"832\":3,\"842\":2}}],[\"readwritelock\",{\"1\":{\"831\":1,\"832\":3,\"842\":3}}],[\"reader\",{\"1\":{\"500\":1}}],[\"readobject\",{\"1\":{\"455\":1}}],[\"readbyte\",{\"1\":{\"335\":3}}],[\"readdata\",{\"1\":{\"335\":1}}],[\"read\",{\"1\":{\"8\":1,\"34\":1}}],[\"reusable\",{\"1\":{\"490\":1}}],[\"record\",{\"1\":{\"837\":1}}],[\"recording\",{\"1\":{\"497\":3,\"498\":2}}],[\"recursions\",{\"1\":{\"835\":1}}],[\"recipient\",{\"1\":{\"461\":1}}],[\"receivesms\",{\"1\":{\"511\":1}}],[\"receive\",{\"1\":{\"403\":2,\"408\":3}}],[\"receiver类light表示电灯\",{\"1\":{\"383\":1}}],[\"receiver\",{\"1\":{\"382\":1,\"383\":2,\"386\":1}}],[\"receivermsg\",{\"1\":{\"325\":3}}],[\"received\",{\"1\":{\"327\":1,\"495\":1}}],[\"received|$upstream\",{\"1\":{\"8\":1,\"34\":1}}],[\"received|$session\",{\"1\":{\"8\":1,\"34\":1}}],[\"resize\",{\"1\":{\"695\":1,\"821\":1}}],[\"res\",{\"1\":{\"539\":1,\"540\":2}}],[\"res目录\",{\"1\":{\"539\":1}}],[\"resourcefactorycache\",{\"1\":{\"436\":5,\"443\":4}}],[\"resourcefactory\",{\"1\":{\"436\":3,\"443\":2}}],[\"resourceloadfactory\",{\"1\":{\"429\":2}}],[\"resourceloadfactory类是工厂类\",{\"1\":{\"429\":1}}],[\"resourceloadexception\",{\"1\":{\"422\":2,\"429\":1}}],[\"resourceloadermethod\",{\"1\":{\"436\":5,\"443\":4}}],[\"resourceloader类是一个资源加载器\",{\"1\":{\"429\":1}}],[\"resourceloader\",{\"1\":{\"422\":6,\"429\":1}}],[\"resource\",{\"1\":{\"422\":15,\"429\":6}}],[\"resolution\",{\"1\":{\"196\":1,\"720\":1}}],[\"restore\",{\"1\":{\"378\":2}}],[\"responsibility\",{\"1\":{\"348\":1,\"460\":1,\"490\":1}}],[\"response\",{\"1\":{\"338\":12,\"495\":1}}],[\"resultset\",{\"1\":{\"731\":1}}],[\"result2\",{\"1\":{\"394\":2,\"495\":2}}],[\"result1\",{\"1\":{\"394\":2,\"495\":2}}],[\"result\",{\"1\":{\"343\":2,\"346\":2,\"390\":2,\"495\":7,\"497\":16,\"498\":16}}],[\"reporttemplate\",{\"1\":{\"336\":3}}],[\"repolist\",{\"1\":{\"24\":1,\"50\":1}}],[\"repeater\",{\"1\":{\"240\":1,\"618\":1}}],[\"repeat\",{\"1\":{\"139\":1,\"484\":1,\"486\":1}}],[\"redundancy\",{\"1\":{\"576\":1}}],[\"redflavor\",{\"1\":{\"525\":4}}],[\"redo\",{\"1\":{\"375\":3}}],[\"redvelet\",{\"1\":{\"91\":2,\"326\":2,\"454\":6}}],[\"redis等地址为云服务器地址\",{\"1\":{\"23\":1,\"49\":1}}],[\"redis配置\",{\"1\":{\"14\":1,\"40\":1}}],[\"redis\",{\"0\":{\"544\":1,\"875\":1},\"1\":{\"1\":1,\"3\":1,\"5\":1,\"14\":1,\"27\":1,\"29\":1,\"31\":1,\"40\":1}}],[\"requests\",{\"1\":{\"350\":2}}],[\"request\",{\"1\":{\"64\":1,\"210\":1,\"338\":12,\"350\":18,\"359\":3,\"495\":1}}],[\"requirepass\",{\"1\":{\"14\":1,\"40\":1}}],[\"release\",{\"1\":{\"24\":2,\"50\":2,\"539\":1}}],[\"driver\",{\"1\":{\"760\":1}}],[\"dryexample\",{\"1\":{\"485\":1}}],[\"dry\",{\"1\":{\"485\":2}}],[\"dry原则并不意味着完全消除重复代码\",{\"1\":{\"486\":1}}],[\"dry原则还有助于降低代码的耦合性\",{\"1\":{\"486\":1}}],[\"dry原则促进了代码的重用和模块化\",{\"1\":{\"486\":1}}],[\"dry原则\",{\"0\":{\"483\":1},\"1\":{\"484\":1,\"486\":1}}],[\"dumping\",{\"1\":{\"769\":1}}],[\"dump堆内存文件\",{\"1\":{\"768\":1}}],[\"dump\",{\"1\":{\"739\":1,\"766\":3,\"768\":2,\"769\":11}}],[\"daemon\",{\"1\":{\"769\":1,\"810\":1}}],[\"date\",{\"1\":{\"455\":11}}],[\"dataextractionrules=\",{\"1\":{\"539\":1}}],[\"databasemethodinterceptor\",{\"1\":{\"498\":5}}],[\"databaseinvocationhandler\",{\"1\":{\"497\":5}}],[\"databaseimpl\",{\"1\":{\"495\":2,\"497\":2,\"498\":10}}],[\"databaseproxy\",{\"1\":{\"495\":3}}],[\"database\",{\"1\":{\"210\":1,\"495\":12,\"497\":12,\"498\":10}}],[\"data\",{\"1\":{\"85\":1,\"119\":1,\"175\":1,\"335\":4,\"366\":2,\"394\":18,\"395\":1,\"436\":1,\"443\":3,\"539\":1,\"575\":2,\"584\":1}}],[\"days\",{\"1\":{\"455\":2}}],[\"day\",{\"1\":{\"378\":3}}],[\"dd\",{\"1\":{\"210\":1}}],[\"dictionary\",{\"1\":{\"706\":1}}],[\"digital\",{\"1\":{\"506\":1}}],[\"digitalproduct\",{\"1\":{\"506\":2}}],[\"dip\",{\"1\":{\"478\":1}}],[\"director\",{\"1\":{\"448\":3}}],[\"divstrategy\",{\"1\":{\"343\":2,\"346\":2}}],[\"difs\",{\"1\":{\"152\":1}}],[\"discardpolicy\",{\"1\":{\"861\":2}}],[\"discardoldestpolicy\",{\"1\":{\"861\":2}}],[\"discountstrategy\",{\"1\":{\"465\":13}}],[\"discountedamount\",{\"1\":{\"465\":4}}],[\"discounttype\",{\"1\":{\"465\":3}}],[\"discount\",{\"1\":{\"455\":1}}],[\"discover\",{\"1\":{\"64\":1}}],[\"disk\",{\"1\":{\"448\":1}}],[\"dispatcher\",{\"1\":{\"721\":1}}],[\"dispatcherservlet\",{\"1\":{\"405\":1}}],[\"displaying\",{\"1\":{\"495\":1}}],[\"display\",{\"1\":{\"495\":10,\"525\":12}}],[\"displayuserinfo\",{\"1\":{\"481\":1}}],[\"displaystats\",{\"1\":{\"372\":2}}],[\"disable\",{\"1\":{\"8\":1,\"34\":1}}],[\"dists\",{\"1\":{\"538\":1}}],[\"distributions\",{\"1\":{\"538\":2}}],[\"distributionurl=https\",{\"1\":{\"538\":1}}],[\"dist\",{\"1\":{\"8\":3,\"22\":3,\"34\":3,\"48\":3}}],[\"dist目录下创建index\",{\"1\":{\"8\":1,\"34\":1}}],[\"dist目录下\",{\"1\":{\"8\":1,\"34\":1}}],[\"d\",{\"0\":{\"132\":1},\"1\":{\"181\":1,\"217\":2,\"218\":1,\"525\":5,\"574\":1,\"587\":1}}],[\"dns服务器会将这个域名解析成对应的ip地址\",{\"1\":{\"594\":1}}],[\"dns服务器等网络配置信息\",{\"1\":{\"62\":1}}],[\"dns解析出ip地址\",{\"1\":{\"108\":1}}],[\"dns解析的安全对于维持网络稳定运行至关重要\",{\"1\":{\"81\":1}}],[\"dns解析过程\",{\"0\":{\"73\":1}}],[\"dns系统承担着将域名解析成ip地址的重要作用\",{\"1\":{\"81\":1}}],[\"dns递归查询的整个过程结束\",{\"1\":{\"81\":1}}],[\"dns协议使用\",{\"1\":{\"72\":1}}],[\"dns相关名词\",{\"0\":{\"68\":1}}],[\"dns它起到了互联网中类似\",{\"1\":{\"67\":1}}],[\"dns\",{\"0\":{\"67\":1,\"77\":1,\"632\":1,\"665\":1},\"1\":{\"67\":1,\"71\":1,\"75\":1,\"76\":1,\"77\":2,\"78\":1,\"79\":1,\"279\":1,\"594\":1}}],[\"dynamicproxy\",{\"1\":{\"497\":2,\"498\":2}}],[\"dynamic\",{\"1\":{\"62\":1,\"496\":1}}],[\"dhcp和rip等\",{\"1\":{\"301\":1}}],[\"dhcp和udp的端口号\",{\"1\":{\"63\":1}}],[\"dhcp和udp\",{\"0\":{\"63\":1}}],[\"dhcp等\",{\"1\":{\"159\":1}}],[\"dhcp协议\",{\"1\":{\"159\":1,\"579\":1}}],[\"dhcp确认\",{\"1\":{\"64\":1}}],[\"dhcp请求\",{\"1\":{\"64\":1}}],[\"dhcp服务器从地址池中分配一个ip地址\",{\"1\":{\"64\":1}}],[\"dhcp服务器接收到客户端的请求后\",{\"1\":{\"64\":1}}],[\"dhcp服务器接收到广播后\",{\"1\":{\"64\":1}}],[\"dhcp服务器使用端口号67\",{\"1\":{\"63\":1}}],[\"dhcp提供\",{\"1\":{\"64\":1}}],[\"dhcp发现\",{\"1\":{\"64\":1}}],[\"dhcp的工作流程\",{\"1\":{\"64\":1}}],[\"dhcp客户端使用端口号68\",{\"1\":{\"63\":1}}],[\"dhcp使用udp作为传输层协议来进行通信\",{\"1\":{\"63\":1}}],[\"dhcp是一种协议\",{\"1\":{\"63\":1}}],[\"dhcp是什么\",{\"0\":{\"62\":1}}],[\"dhcp与udp的关系\",{\"1\":{\"63\":1}}],[\"dhcp还可以自动分配子网掩码\",{\"1\":{\"62\":1}}],[\"dhcp允许网络中的设备在连接到网络时自动获取ip地址\",{\"1\":{\"62\":1}}],[\"dhcp\",{\"1\":{\"62\":1,\"64\":4}}],[\"decrementandget\",{\"1\":{\"870\":1}}],[\"decoratorb是另一个继承自decorator的具体装饰类\",{\"1\":{\"502\":1}}],[\"decoratorb\",{\"1\":{\"502\":7}}],[\"decoratora和decoratorb是具体的装饰器类\",{\"1\":{\"502\":1}}],[\"decoratora是一个继承自decorator的具体装饰类\",{\"1\":{\"502\":1}}],[\"decoratora\",{\"1\":{\"502\":8}}],[\"decorator是一个抽象类\",{\"1\":{\"502\":1}}],[\"decorator\",{\"1\":{\"490\":1,\"500\":1,\"501\":2,\"502\":10}}],[\"detection\",{\"1\":{\"581\":2}}],[\"details下面是各层需要解决的问题\",{\"1\":{\"268\":1}}],[\"delayqueue\",{\"1\":{\"862\":2}}],[\"delayed\",{\"0\":{\"660\":1}}],[\"delimiter\",{\"1\":{\"575\":1}}],[\"deletion\",{\"1\":{\"497\":3,\"498\":2}}],[\"deleteresult\",{\"1\":{\"497\":2,\"498\":2}}],[\"delete\",{\"1\":{\"497\":25,\"498\":21}}],[\"debug\",{\"1\":{\"538\":1}}],[\"device\",{\"1\":{\"538\":1}}],[\"devel\",{\"1\":{\"24\":1,\"50\":1}}],[\"dependencies\",{\"1\":{\"539\":1}}],[\"dependency\",{\"1\":{\"476\":1}}],[\"department\",{\"1\":{\"525\":4}}],[\"denied\",{\"1\":{\"495\":1}}],[\"demeter\",{\"1\":{\"488\":1}}],[\"demultiplexing\",{\"1\":{\"280\":1}}],[\"dear\",{\"1\":{\"461\":1}}],[\"deepcopytest\",{\"1\":{\"455\":1}}],[\"destination\",{\"1\":{\"575\":1}}],[\"design\",{\"1\":{\"363\":1,\"375\":1,\"432\":1,\"453\":1,\"490\":1,\"494\":1,\"500\":1,\"508\":1,\"539\":1}}],[\"deserializationstrategies\",{\"1\":{\"346\":6}}],[\"deserializationstrategy>\",{\"1\":{\"346\":2}}],[\"deserializationstrategy\",{\"1\":{\"346\":8}}],[\"deserialized\",{\"1\":{\"346\":1}}],[\"deserializedmessage\",{\"1\":{\"346\":2}}],[\"deserialize\",{\"1\":{\"346\":15}}],[\"description\",{\"1\":{\"210\":1,\"497\":3}}],[\"desktop\",{\"1\":{\"14\":1,\"40\":1}}],[\"dextop\",{\"1\":{\"24\":2,\"50\":2}}],[\"defaultconfig\",{\"1\":{\"539\":1}}],[\"default\",{\"1\":{\"8\":1,\"34\":1,\"422\":1,\"429\":1,\"436\":1,\"443\":1,\"511\":1,\"783\":2}}],[\"don\",{\"1\":{\"484\":1,\"486\":1}}],[\"dog\",{\"1\":{\"455\":1,\"469\":5,\"485\":2}}],[\"doget\",{\"1\":{\"338\":2}}],[\"do\",{\"1\":{\"375\":1,\"847\":1}}],[\"dochain方法遍历链中的处理器\",{\"1\":{\"354\":1}}],[\"dochain\",{\"1\":{\"353\":3,\"354\":2}}],[\"doctype\",{\"1\":{\"8\":1,\"34\":1}}],[\"double\",{\"1\":{\"344\":5,\"455\":2,\"461\":4,\"465\":13,\"506\":4,\"510\":7,\"518\":2,\"724\":1,\"774\":1}}],[\"doput\",{\"1\":{\"338\":1}}],[\"dopost\",{\"1\":{\"338\":2}}],[\"domain\",{\"1\":{\"67\":1,\"211\":1}}],[\"downloads\",{\"1\":{\"17\":1,\"43\":1}}],[\"download\",{\"1\":{\"3\":1,\"24\":1,\"29\":1,\"50\":1}}],[\"b线程读取操作count\",{\"1\":{\"829\":1}}],[\"b两个线程都对\",{\"1\":{\"829\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"870\":2}}],[\"blocked\",{\"1\":{\"765\":1,\"808\":1}}],[\"blog\",{\"1\":{\"8\":3,\"34\":3}}],[\"bbg7u40eoinfdyxsxr3z4i7ta\",{\"1\":{\"538\":1}}],[\"before关系来执行的结果一致\",{\"1\":{\"826\":1}}],[\"before关系指定的顺序来执行\",{\"1\":{\"826\":1}}],[\"before关系\",{\"1\":{\"826\":1}}],[\"before另一个操作\",{\"1\":{\"826\":1}}],[\"before的定义\",{\"1\":{\"826\":1}}],[\"before来约束\",{\"1\":{\"826\":1}}],[\"before\",{\"1\":{\"495\":1,\"497\":3,\"498\":3}}],[\"behavioral\",{\"1\":{\"490\":1}}],[\"been\",{\"1\":{\"461\":1,\"481\":1}}],[\"best\",{\"1\":{\"372\":1}}],[\"bellman\",{\"1\":{\"207\":1}}],[\"bootstrap\",{\"1\":{\"756\":1}}],[\"boot项目\",{\"1\":{\"498\":1}}],[\"boolean\",{\"1\":{\"335\":2,\"360\":1,\"365\":2,\"366\":2,\"394\":7,\"495\":1,\"724\":1,\"774\":1,\"785\":1,\"807\":2,\"838\":2,\"840\":1,\"847\":1,\"851\":1,\"870\":1}}],[\"boy为人员为wendy\",{\"1\":{\"454\":2}}],[\"boy\",{\"1\":{\"454\":4}}],[\"bobby=\",{\"1\":{\"450\":2}}],[\"bobby\",{\"1\":{\"450\":15}}],[\"bound\",{\"1\":{\"316\":1}}],[\"body>\",{\"1\":{\"8\":1,\"34\":1}}],[\"body\",{\"1\":{\"8\":1,\"34\":1}}],[\"b的初始rwnd=400\",{\"1\":{\"294\":1}}],[\"bps\",{\"1\":{\"260\":1}}],[\"bio的优化\",{\"1\":{\"858\":1}}],[\"birthday\",{\"1\":{\"525\":6}}],[\"bits\",{\"1\":{\"867\":5}}],[\"bit\",{\"1\":{\"260\":6}}],[\"bin\",{\"1\":{\"19\":1,\"45\":1,\"538\":3}}],[\"bind\",{\"1\":{\"14\":1,\"40\":1}}],[\"barrier\",{\"1\":{\"828\":3,\"852\":1}}],[\"barks\",{\"1\":{\"469\":2}}],[\"bandwidth\",{\"1\":{\"620\":2}}],[\"bandpass\",{\"1\":{\"240\":2}}],[\"base\",{\"1\":{\"495\":1}}],[\"baseclass\",{\"1\":{\"495\":3}}],[\"basic\",{\"1\":{\"448\":1}}],[\"basiccomputerbuilder\",{\"1\":{\"448\":3}}],[\"bad\",{\"1\":{\"454\":2}}],[\"baud\",{\"1\":{\"240\":2}}],[\"backup\",{\"1\":{\"539\":1}}],[\"back\",{\"1\":{\"138\":1}}],[\"backend\",{\"1\":{\"23\":1,\"49\":1}}],[\"b类和c类地址的范围是多少\",{\"0\":{\"600\":1}}],[\"b类和c类地址\",{\"1\":{\"220\":1}}],[\"b类\",{\"1\":{\"218\":1}}],[\"bgp\",{\"1\":{\"212\":1}}],[\"bgp发言人交换网络可达性的信息\",{\"1\":{\"212\":1}}],[\"bgp发言人除了运行bgp外\",{\"1\":{\"212\":1}}],[\"bgp发言人\",{\"1\":{\"212\":1}}],[\"bgp工作原理\",{\"1\":{\"212\":1}}],[\"bgp协议\",{\"0\":{\"212\":1},\"1\":{\"212\":1}}],[\"b系统是带宽\",{\"1\":{\"212\":1}}],[\"break\",{\"1\":{\"343\":1,\"346\":1,\"870\":1}}],[\"bridge进行通信\",{\"1\":{\"538\":1}}],[\"bridge\",{\"1\":{\"175\":2,\"490\":1,\"504\":1}}],[\"broadcast\",{\"1\":{\"166\":1}}],[\"b0是位是1则为多播地址\",{\"1\":{\"166\":1}}],[\"b0\",{\"1\":{\"166\":3}}],[\"b1\",{\"1\":{\"166\":3}}],[\"bsc协议\",{\"1\":{\"131\":1}}],[\"b\",{\"0\":{\"126\":1,\"130\":1,\"299\":1},\"1\":{\"217\":4,\"218\":1,\"260\":5,\"261\":1,\"294\":1,\"316\":8,\"595\":1,\"728\":1,\"760\":1,\"833\":1,\"845\":3,\"848\":1}}],[\"bj\",{\"1\":{\"69\":1}}],[\"bytecode\",{\"1\":{\"720\":1}}],[\"bytearrayinputstream\",{\"1\":{\"455\":4}}],[\"bytearrayinputstream等\",{\"1\":{\"335\":1}}],[\"bytearrayoutputstream\",{\"1\":{\"455\":2}}],[\"byte\",{\"1\":{\"260\":1,\"346\":12,\"455\":1,\"724\":1,\"789\":3}}],[\"bytes\",{\"1\":{\"8\":2,\"34\":2,\"346\":16,\"455\":2}}],[\"by\",{\"1\":{\"11\":3,\"37\":3}}],[\"bug\",{\"1\":{\"768\":1}}],[\"buildtypes\",{\"1\":{\"539\":1}}],[\"buildcomputer\",{\"1\":{\"448\":2}}],[\"buildmonitor\",{\"1\":{\"448\":4}}],[\"buildmemory\",{\"1\":{\"448\":4}}],[\"buildharddisk\",{\"1\":{\"448\":4}}],[\"buildprocessor\",{\"1\":{\"448\":4}}],[\"builder注解的示例代码\",{\"1\":{\"450\":1}}],[\"builder注解会自动生成一个建造者模式的构建者类\",{\"1\":{\"450\":1}}],[\"builder设计模式在构建复杂对象时非常有用\",{\"1\":{\"451\":1}}],[\"builder设计模式也存在一些缺点\",{\"1\":{\"451\":1}}],[\"builder设计模式适用于以下情况\",{\"1\":{\"449\":1}}],[\"builder设计模式的优点包括\",{\"1\":{\"451\":1}}],[\"builder设计模式的基本流程和简单示例如下\",{\"1\":{\"448\":1}}],[\"builder设计模式的核心思想是将对象的构建过程从其实际表示中解耦\",{\"1\":{\"447\":1}}],[\"builder设计模式包含以下几个主要组成部分\",{\"1\":{\"448\":1}}],[\"builder\",{\"1\":{\"446\":1,\"448\":9,\"450\":23,\"490\":1}}],[\"build\",{\"1\":{\"22\":1,\"48\":1,\"450\":7,\"539\":2}}],[\"busy\",{\"1\":{\"8\":1,\"34\":1}}],[\"buffers\",{\"1\":{\"8\":4,\"34\":4}}],[\"buffer\",{\"1\":{\"8\":2,\"34\":2,\"728\":1}}],[\"bucketindex\",{\"1\":{\"694\":1}}],[\"bucket\",{\"1\":{\"8\":1,\"34\":1,\"707\":1}}],[\"bt\",{\"1\":{\"3\":1,\"29\":1}}],[\"eofexception\",{\"1\":{\"793\":1}}],[\"eot\",{\"1\":{\"132\":1,\"577\":1}}],[\"eclipse\",{\"1\":{\"769\":1}}],[\"espresso\",{\"1\":{\"539\":3}}],[\"empty\",{\"1\":{\"538\":4}}],[\"employee2\",{\"1\":{\"525\":2}}],[\"employee1\",{\"1\":{\"525\":2}}],[\"employee\",{\"1\":{\"525\":4}}],[\"emailservice负责发送邮件\",{\"1\":{\"481\":1}}],[\"emailservice\",{\"1\":{\"481\":13}}],[\"emailsender\",{\"1\":{\"461\":8}}],[\"erich\",{\"1\":{\"490\":1}}],[\"errors\",{\"1\":{\"8\":1,\"34\":1}}],[\"error\",{\"1\":{\"0\":1,\"8\":4,\"34\":4,\"793\":3}}],[\"eat\",{\"1\":{\"485\":2}}],[\"everyone\",{\"1\":{\"408\":2}}],[\"event\",{\"1\":{\"455\":2}}],[\"eventtype\",{\"1\":{\"326\":7}}],[\"eventcontext\",{\"1\":{\"326\":7}}],[\"eventbus\",{\"1\":{\"326\":19}}],[\"events\",{\"1\":{\"8\":1,\"34\":1}}],[\"eden\",{\"1\":{\"737\":1,\"739\":3,\"764\":2,\"768\":1}}],[\"eden空间\",{\"1\":{\"722\":1,\"737\":1}}],[\"editor\",{\"1\":{\"378\":14}}],[\"edu\",{\"1\":{\"69\":1}}],[\"equals\",{\"0\":{\"786\":1,\"788\":1},\"1\":{\"343\":2,\"346\":2,\"422\":4,\"429\":4,\"436\":1,\"443\":1,\"465\":2,\"495\":1,\"497\":1,\"498\":1,\"511\":2,\"672\":2,\"687\":1,\"785\":1,\"786\":2,\"787\":3,\"788\":20}}],[\"equalsignorecase\",{\"1\":{\"343\":1,\"346\":1}}],[\"electronicsproduct\",{\"1\":{\"506\":2}}],[\"element\",{\"1\":{\"365\":1,\"371\":1,\"372\":1}}],[\"elements\",{\"1\":{\"365\":3,\"372\":1,\"490\":1}}],[\"else语句\",{\"1\":{\"344\":1,\"345\":1}}],[\"else\",{\"1\":{\"326\":1,\"343\":2,\"346\":6,\"350\":3,\"360\":3,\"384\":1,\"422\":3,\"429\":3,\"465\":1,\"495\":1,\"511\":2}}],[\"el7\",{\"1\":{\"24\":2,\"50\":2}}],[\"e\",{\"1\":{\"217\":2,\"327\":2,\"346\":2,\"436\":4,\"443\":4,\"455\":6,\"821\":3,\"863\":2,\"870\":4}}],[\"eigrp\",{\"1\":{\"211\":1}}],[\"epoch\",{\"1\":{\"837\":1}}],[\"epoll\",{\"1\":{\"8\":1,\"34\":1}}],[\"epel\",{\"1\":{\"24\":1,\"50\":1}}],[\"etc\",{\"1\":{\"19\":3,\"45\":3}}],[\"exchange方法交换数据\",{\"1\":{\"854\":1}}],[\"exchanger可以用于校对工作\",{\"1\":{\"854\":1}}],[\"exchanger可以用于遗传算法\",{\"1\":{\"854\":1}}],[\"exchanger用于进行线程间的数据交换\",{\"1\":{\"854\":1}}],[\"exchanger\",{\"0\":{\"854\":1},\"1\":{\"854\":2}}],[\"exclusive\",{\"1\":{\"846\":1}}],[\"exceptionininitializererror\",{\"1\":{\"793\":1}}],[\"exception\",{\"1\":{\"455\":1,\"709\":3,\"793\":4}}],[\"executor\",{\"1\":{\"863\":2,\"870\":1}}],[\"executors\",{\"1\":{\"327\":2}}],[\"executorservice\",{\"1\":{\"327\":6}}],[\"executionexception\",{\"1\":{\"863\":1}}],[\"execution\",{\"1\":{\"720\":1}}],[\"executing\",{\"1\":{\"495\":1,\"497\":4,\"498\":4}}],[\"execute\",{\"1\":{\"343\":4,\"346\":4,\"383\":4,\"384\":5,\"863\":2,\"868\":1,\"870\":3}}],[\"expungestaleentry\",{\"1\":{\"821\":1}}],[\"expungestaleentries\",{\"1\":{\"821\":2}}],[\"exported=\",{\"1\":{\"539\":1}}],[\"exportreport\",{\"1\":{\"336\":4}}],[\"expr2\",{\"1\":{\"394\":10}}],[\"expr1\",{\"1\":{\"394\":10}}],[\"expression\",{\"1\":{\"390\":20,\"393\":1,\"394\":15,\"395\":1}}],[\"explaining\",{\"1\":{\"372\":1}}],[\"expired\",{\"1\":{\"8\":1,\"34\":1}}],[\"extraction\",{\"1\":{\"539\":1}}],[\"extranet\",{\"1\":{\"223\":1}}],[\"ext\",{\"1\":{\"539\":1}}],[\"extends\",{\"1\":{\"332\":1,\"335\":1,\"336\":2,\"338\":2,\"353\":2,\"354\":2,\"436\":1,\"443\":8,\"485\":2,\"495\":1,\"502\":2,\"797\":1}}],[\"extensions\",{\"1\":{\"96\":1,\"756\":1}}],[\"example1\",{\"1\":{\"268\":1}}],[\"example\",{\"1\":{\"67\":1,\"68\":1,\"450\":1,\"495\":1,\"539\":2}}],[\"exitchatgroup\",{\"1\":{\"325\":2}}],[\"exit\",{\"1\":{\"11\":1,\"37\":1,\"796\":1}}],[\"encoding=\",{\"1\":{\"539\":1,\"540\":1}}],[\"enhancer\",{\"1\":{\"498\":7}}],[\"enter\",{\"1\":{\"495\":1}}],[\"entrylist\",{\"1\":{\"835\":2}}],[\"entry为\",{\"1\":{\"820\":1}}],[\"entry数据\",{\"1\":{\"820\":1}}],[\"entry是threalocal弱引用作为key\",{\"1\":{\"819\":1}}],[\"entry\",{\"1\":{\"702\":6,\"714\":1,\"821\":2}}],[\"entry<k\",{\"1\":{\"702\":4}}],[\"entry<object\",{\"1\":{\"436\":3,\"443\":3}}],[\"entryset\",{\"1\":{\"436\":1,\"443\":1,\"702\":6}}],[\"entries\",{\"1\":{\"436\":2,\"443\":2}}],[\"entity\",{\"1\":{\"274\":1}}],[\"enjoying\",{\"1\":{\"372\":1}}],[\"ensp的ping命令\",{\"1\":{\"200\":1}}],[\"en\",{\"1\":{\"8\":1,\"34\":1}}],[\"enddate\",{\"1\":{\"455\":3}}],[\"end\",{\"1\":{\"8\":5,\"22\":3,\"34\":5,\"48\":3}}],[\"f\",{\"1\":{\"795\":2}}],[\"fgc\",{\"1\":{\"768\":4}}],[\"framework\",{\"0\":{\"897\":1}}],[\"frame\",{\"1\":{\"575\":3}}],[\"from\",{\"1\":{\"91\":1,\"94\":1,\"495\":3,\"497\":10,\"498\":10,\"722\":1,\"737\":1,\"739\":1}}],[\"front\",{\"1\":{\"8\":5,\"22\":3,\"34\":5,\"48\":3}}],[\"future\",{\"1\":{\"863\":2,\"865\":1}}],[\"future<object>\",{\"1\":{\"863\":1}}],[\"future对象可以判断任务是否执行成功\",{\"1\":{\"863\":1}}],[\"fullfence\",{\"1\":{\"827\":1}}],[\"fullgc\",{\"1\":{\"739\":1}}],[\"full\",{\"0\":{\"738\":1,\"768\":1},\"1\":{\"738\":2,\"739\":7,\"741\":3,\"768\":2,\"769\":7}}],[\"fullbackupcontent=\",{\"1\":{\"539\":1}}],[\"fulkerson算法\",{\"1\":{\"207\":1}}],[\"functions\",{\"1\":{\"485\":1}}],[\"festivaldiscountstrategy\",{\"1\":{\"465\":2}}],[\"festival\",{\"1\":{\"465\":1}}],[\"feel\",{\"1\":{\"454\":2}}],[\"fetchdata\",{\"1\":{\"336\":4}}],[\"fair\",{\"1\":{\"838\":2,\"840\":2}}],[\"fairsync\",{\"1\":{\"838\":2,\"839\":1,\"840\":3}}],[\"failure\",{\"1\":{\"739\":1}}],[\"fail\",{\"0\":{\"709\":2},\"1\":{\"709\":4,\"710\":1}}],[\"facade\",{\"1\":{\"490\":1,\"514\":1,\"516\":1}}],[\"factory\",{\"1\":{\"424\":1,\"426\":1,\"430\":1,\"432\":1,\"434\":2,\"439\":1,\"441\":2,\"490\":2,\"530\":1}}],[\"false\",{\"1\":{\"360\":2,\"395\":1,\"539\":1,\"672\":1,\"774\":1,\"788\":1,\"838\":1,\"839\":1,\"840\":1,\"870\":1}}],[\"fast\",{\"0\":{\"709\":1},\"1\":{\"709\":2,\"710\":1}}],[\"fastjsonserializer\",{\"1\":{\"346\":2}}],[\"fastjson2serializer\",{\"1\":{\"346\":2}}],[\"fastcgi\",{\"1\":{\"8\":8,\"34\":8}}],[\"fm\",{\"1\":{\"239\":2,\"619\":1}}],[\"firsttask\",{\"1\":{\"870\":7}}],[\"fi\",{\"1\":{\"618\":1}}],[\"field\",{\"1\":{\"575\":1}}],[\"filter>\",{\"1\":{\"539\":2}}],[\"filter用于在servlet请求被处理之前或之后对请求和响应进行预处理和后处理\",{\"1\":{\"352\":1}}],[\"filter是一种典型的责任链模式的应用\",{\"1\":{\"352\":1}}],[\"filter\",{\"1\":{\"352\":1}}],[\"fillcontent\",{\"1\":{\"336\":4}}],[\"filenotfoundexception\",{\"1\":{\"793\":1}}],[\"filename\",{\"1\":{\"495\":7,\"764\":1}}],[\"file=29471\",{\"1\":{\"769\":1}}],[\"file=heap\",{\"1\":{\"768\":1}}],[\"file=\",{\"1\":{\"766\":1}}],[\"filepictureresource\",{\"1\":{\"443\":4}}],[\"filevideoresource\",{\"1\":{\"443\":1}}],[\"filetextresource\",{\"1\":{\"443\":1}}],[\"fileresourcefactory\",{\"1\":{\"436\":2,\"443\":2}}],[\"fileresource\",{\"1\":{\"436\":6}}],[\"fileinputstream等\",{\"1\":{\"500\":1}}],[\"fileinputstream\",{\"1\":{\"335\":2}}],[\"file\",{\"1\":{\"8\":1,\"34\":1,\"83\":1,\"85\":1,\"87\":1,\"419\":1,\"422\":1,\"429\":1,\"436\":1,\"443\":1,\"525\":10,\"769\":1}}],[\"filesystemcomponent\",{\"1\":{\"525\":15}}],[\"files\",{\"1\":{\"8\":2,\"34\":2}}],[\"financedepartment\",{\"1\":{\"525\":2}}],[\"final和synchronized也能保证可见性\",{\"1\":{\"825\":1}}],[\"finally\",{\"0\":{\"795\":1,\"796\":1},\"1\":{\"795\":9,\"796\":5,\"832\":3,\"843\":1,\"863\":1,\"870\":1}}],[\"final修饰的char数组\",{\"1\":{\"789\":1}}],[\"finalize\",{\"0\":{\"736\":1},\"1\":{\"721\":1,\"736\":4,\"785\":1}}],[\"finalizer\",{\"1\":{\"721\":2}}],[\"final\",{\"1\":{\"332\":1,\"335\":1,\"336\":1,\"450\":5,\"510\":2,\"683\":1,\"689\":1,\"693\":1,\"775\":2,\"783\":1,\"785\":7,\"819\":1,\"822\":1,\"844\":1,\"847\":2,\"867\":5,\"870\":4}}],[\"fin=1\",{\"1\":{\"286\":2}}],[\"fi等\",{\"1\":{\"229\":1}}],[\"ff的帧封装并广播arp请求分组\",{\"1\":{\"198\":1}}],[\"ff\",{\"1\":{\"168\":5,\"198\":4,\"583\":5}}],[\"ffmpeg\",{\"1\":{\"1\":1,\"24\":3,\"27\":1,\"50\":3}}],[\"fddi\",{\"1\":{\"158\":1}}],[\"fdm\",{\"0\":{\"147\":1}}],[\"fcs\",{\"1\":{\"131\":1,\"575\":2}}],[\"floating\",{\"1\":{\"751\":1}}],[\"float\",{\"1\":{\"689\":1,\"724\":1,\"774\":1}}],[\"flood\",{\"0\":{\"643\":1}}],[\"flyweight\",{\"1\":{\"490\":1,\"528\":1,\"530\":2}}],[\"flyable\",{\"1\":{\"473\":1}}],[\"fly\",{\"1\":{\"473\":2}}],[\"flight\",{\"1\":{\"403\":6}}],[\"flsm常用于早期的网络设计\",{\"1\":{\"222\":1}}],[\"flsm\",{\"1\":{\"222\":1}}],[\"flag\",{\"1\":{\"131\":1,\"575\":1}}],[\"flush\",{\"1\":{\"11\":1,\"37\":1}}],[\"folder\",{\"1\":{\"525\":12}}],[\"folder类表示树状结构中的组合节点\",{\"1\":{\"525\":1}}],[\"four\",{\"1\":{\"490\":1}}],[\"found等\",{\"1\":{\"107\":1}}],[\"forname\",{\"1\":{\"436\":1,\"443\":1,\"755\":2}}],[\"ford路由算法和ford\",{\"1\":{\"207\":1}}],[\"format=b\",{\"1\":{\"766\":1,\"768\":1,\"769\":1}}],[\"format\",{\"1\":{\"8\":3,\"34\":3,\"511\":6}}],[\"for\",{\"1\":{\"8\":2,\"34\":2,\"215\":1,\"314\":1,\"315\":1,\"316\":6,\"325\":1,\"326\":1,\"327\":1,\"350\":1,\"354\":1,\"366\":1,\"372\":2,\"454\":2,\"455\":1,\"495\":2,\"497\":6,\"498\":6,\"524\":1,\"525\":2,\"702\":2,\"703\":2,\"821\":1,\"870\":2}}],[\"forwarded\",{\"1\":{\"8\":2,\"34\":2}}],[\"ftp默认使用了两个端口\",{\"1\":{\"87\":1}}],[\"ftp使用tcp作为传输层协议\",{\"1\":{\"87\":1}}],[\"ftp和tcp\",{\"0\":{\"87\":1}}],[\"ftp屏蔽了各计算机系统的细节\",{\"1\":{\"83\":1}}],[\"ftp也可用于在不同用户之间共享文件\",{\"1\":{\"83\":1}}],[\"ftp提供交互式的访问\",{\"1\":{\"83\":1}}],[\"ftp的工作原理\",{\"0\":{\"84\":1}}],[\"ftp的另一个常见用途是让网站设计者将构成网站内容的大量文件批量上传到他们的web服务器\",{\"1\":{\"83\":1}}],[\"ftp的常见用途是在计算机之间传输文件\",{\"1\":{\"83\":1}}],[\"ftp允许用户将文件从本地计算机上传至远程服务器\",{\"1\":{\"83\":1}}],[\"ftp有什么作用和应用\",{\"1\":{\"83\":1}}],[\"ftp客户端\",{\"1\":{\"83\":1}}],[\"ftp服务器\",{\"1\":{\"83\":1}}],[\"ftp由什么组成\",{\"1\":{\"83\":1}}],[\"ftp是在tcp协议的基础上实现的文件传输协议\",{\"1\":{\"87\":1}}],[\"ftp是基于c\",{\"1\":{\"83\":1}}],[\"ftp是一种用于在网络上进行文件传输的标准通信协议\",{\"1\":{\"83\":1}}],[\"ftp是什么\",{\"0\":{\"83\":1}}],[\"ftp\",{\"1\":{\"56\":1,\"83\":1,\"85\":1,\"87\":1,\"279\":1}}],[\"l\",{\"1\":{\"835\":1,\"849\":2}}],[\"lru\",{\"1\":{\"714\":1}}],[\"lyric3\",{\"1\":{\"525\":2}}],[\"lyric2\",{\"1\":{\"525\":2}}],[\"lyric1\",{\"1\":{\"525\":2}}],[\"lyricsfolder\",{\"1\":{\"525\":5}}],[\"lsp\",{\"1\":{\"468\":1}}],[\"lsa被封装在链路状态更新分组lsu中\",{\"1\":{\"210\":1}}],[\"lsu\",{\"1\":{\"210\":1}}],[\"lsr\",{\"1\":{\"210\":1}}],[\"llc子层\",{\"1\":{\"158\":1}}],[\"llc\",{\"1\":{\"120\":1,\"158\":1}}],[\"latch数量减1\",{\"1\":{\"851\":1}}],[\"latin\",{\"1\":{\"789\":5}}],[\"layout\",{\"1\":{\"540\":8}}],[\"label=\",{\"1\":{\"539\":1}}],[\"launcher\",{\"1\":{\"539\":3}}],[\"law\",{\"1\":{\"488\":1}}],[\"landin\",{\"1\":{\"839\":1}}],[\"lang包下的处理字符串的类\",{\"1\":{\"789\":1}}],[\"lang包\",{\"1\":{\"674\":1}}],[\"lang\",{\"1\":{\"497\":4,\"498\":4,\"756\":1,\"758\":2,\"769\":1,\"793\":1,\"799\":1}}],[\"lang=\",{\"1\":{\"8\":1,\"34\":1}}],[\"lan和valn格式\",{\"1\":{\"159\":1}}],[\"large\",{\"1\":{\"8\":1,\"34\":1}}],[\"live\",{\"1\":{\"766\":1,\"769\":2}}],[\"lib目录下放置应用程序所需的第三方类库\",{\"1\":{\"760\":1}}],[\"libtool\",{\"1\":{\"24\":1,\"50\":1}}],[\"liskov\",{\"1\":{\"468\":1}}],[\"list列表\",{\"1\":{\"671\":1}}],[\"list\",{\"1\":{\"326\":3,\"327\":1,\"671\":1,\"681\":1,\"797\":1}}],[\"list<\",{\"1\":{\"797\":1}}],[\"list<filesystemcomponent>\",{\"1\":{\"525\":2}}],[\"list<promotionrule>\",{\"1\":{\"455\":3}}],[\"list<page>\",{\"1\":{\"372\":1}}],[\"list<song>\",{\"1\":{\"454\":4}}],[\"list<string>\",{\"1\":{\"384\":1}}],[\"list<subscribe>\",{\"1\":{\"326\":4}}],[\"list<subscribe>>\",{\"1\":{\"326\":1}}],[\"list<memento>\",{\"1\":{\"377\":1}}],[\"list<component>\",{\"1\":{\"524\":1,\"525\":1}}],[\"list<cityelement>\",{\"1\":{\"372\":1}}],[\"list<chatuser>\",{\"1\":{\"325\":1}}],[\"list<handler>\",{\"1\":{\"354\":1}}],[\"list<observer>\",{\"1\":{\"327\":1}}],[\"listen\",{\"1\":{\"8\":2,\"34\":2}}],[\"lightoffcommand\",{\"1\":{\"383\":5}}],[\"lightoncommand\",{\"1\":{\"383\":5}}],[\"light\",{\"1\":{\"383\":22}}],[\"linkageerror\",{\"1\":{\"793\":1}}],[\"linkedblockingqueue\",{\"1\":{\"862\":2}}],[\"linkedhashmap和\",{\"0\":{\"715\":1},\"1\":{\"715\":1}}],[\"linkedhashmap<>\",{\"1\":{\"703\":1}}],[\"linkedhashmap\",{\"0\":{\"714\":1},\"1\":{\"703\":2,\"714\":8,\"715\":8}}],[\"linkedlist是java基于数组实现的一种动态数组的数据结构\",{\"1\":{\"678\":1}}],[\"link\",{\"1\":{\"119\":2,\"120\":1,\"210\":3,\"246\":1,\"584\":1}}],[\"linux\",{\"1\":{\"18\":1,\"44\":1,\"279\":1}}],[\"li\",{\"1\":{\"24\":1,\"50\":1}}],[\"limit\",{\"1\":{\"8\":2,\"34\":2}}],[\"len\",{\"1\":{\"821\":3}}],[\"length\",{\"1\":{\"8\":1,\"34\":1,\"365\":1,\"366\":3,\"575\":1,\"694\":3,\"695\":2,\"819\":1,\"821\":1}}],[\"leaf3\",{\"1\":{\"524\":2}}],[\"leaf2\",{\"1\":{\"524\":2}}],[\"leaf1\",{\"1\":{\"524\":2}}],[\"leaf\",{\"1\":{\"524\":7,\"526\":1}}],[\"least\",{\"1\":{\"488\":1}}],[\"lessexpression\",{\"1\":{\"394\":4,\"395\":1}}],[\"left\",{\"1\":{\"390\":12,\"539\":1}}],[\"level\",{\"1\":{\"8\":1,\"34\":1,\"584\":1,\"826\":1}}],[\"lockinterruptibly\",{\"1\":{\"843\":1}}],[\"lock\",{\"1\":{\"832\":5,\"837\":1,\"838\":2,\"839\":1,\"840\":2,\"842\":2,\"844\":1}}],[\"local\",{\"1\":{\"18\":3,\"19\":1,\"44\":3,\"45\":1,\"155\":1,\"539\":1,\"728\":1,\"824\":1}}],[\"local|$remote\",{\"1\":{\"8\":1,\"34\":1}}],[\"localhost\",{\"1\":{\"8\":5,\"22\":1,\"34\":5,\"48\":1}}],[\"location\",{\"1\":{\"8\":4,\"34\":4}}],[\"long类型\",{\"1\":{\"855\":1}}],[\"longadder在获取最终结果时\",{\"1\":{\"855\":1}}],[\"longadder能够比atomiclong更高效地处理累加操作\",{\"1\":{\"855\":1}}],[\"longadder实现的关键点在于通过分段的方式降低了线程之间的竞争\",{\"1\":{\"855\":1}}],[\"longadder会根据当前线程的哈希码\",{\"1\":{\"855\":1}}],[\"longadder\",{\"1\":{\"855\":1}}],[\"longadder的实现基于分段锁\",{\"1\":{\"855\":1}}],[\"longadder是java\",{\"1\":{\"855\":1}}],[\"longadder原理\",{\"0\":{\"855\":1},\"1\":{\"855\":1}}],[\"long\",{\"1\":{\"724\":1,\"785\":2,\"807\":5,\"811\":2,\"832\":1,\"847\":1,\"851\":1}}],[\"lombok例子\",{\"1\":{\"450\":1}}],[\"loadfence\",{\"1\":{\"827\":1}}],[\"loadfactor\",{\"1\":{\"689\":3}}],[\"loadstore\",{\"1\":{\"827\":1}}],[\"loadstore屏障\",{\"1\":{\"827\":1}}],[\"loadload\",{\"1\":{\"827\":1}}],[\"loadload屏障\",{\"1\":{\"827\":1}}],[\"loader\",{\"1\":{\"756\":3}}],[\"loadclass\",{\"1\":{\"755\":1}}],[\"loading\",{\"1\":{\"495\":1,\"720\":1}}],[\"loadtext\",{\"1\":{\"443\":3}}],[\"loadvideo\",{\"1\":{\"443\":3}}],[\"loadpicture\",{\"1\":{\"443\":3}}],[\"load\",{\"1\":{\"422\":3,\"429\":1,\"436\":8,\"443\":7,\"828\":1}}],[\"lowpass\",{\"1\":{\"240\":2}}],[\"logisticsservice\",{\"1\":{\"518\":7}}],[\"loginuser\",{\"1\":{\"481\":1}}],[\"logical\",{\"1\":{\"120\":1}}],[\"logginghandler\",{\"1\":{\"353\":4,\"354\":2}}],[\"logginghandler和validationhandler\",{\"1\":{\"353\":1}}],[\"logarithmic\",{\"1\":{\"316\":1}}],[\"log2⁡n\",{\"1\":{\"316\":1}}],[\"log2​\",{\"1\":{\"240\":1}}],[\"logn\",{\"1\":{\"316\":1,\"698\":1,\"701\":1}}],[\"logs\",{\"1\":{\"8\":1,\"34\":1}}],[\"log\",{\"1\":{\"8\":12,\"34\":12,\"497\":3,\"498\":2,\"705\":1}}],[\"nid=0x731f\",{\"1\":{\"769\":1}}],[\"nid\",{\"1\":{\"769\":1}}],[\"nic\",{\"1\":{\"618\":1}}],[\"nice\",{\"1\":{\"378\":3}}],[\"nyquist\",{\"1\":{\"622\":1}}],[\"ndk的本地路径等\",{\"1\":{\"539\":1}}],[\"nguide\",{\"1\":{\"372\":1}}],[\"nginx\",{\"1\":{\"1\":1,\"8\":7,\"27\":1,\"34\":7}}],[\"n以线性级别增长\",{\"1\":{\"316\":1}}],[\"nlogn\",{\"1\":{\"316\":1}}],[\"n20\",{\"1\":{\"768\":1}}],[\"n2\",{\"1\":{\"316\":2}}],[\"n2次方为主导\",{\"1\":{\"316\":1}}],[\"n+1\",{\"1\":{\"316\":1}}],[\"n前面的系数对时间复杂度没有影响\",{\"1\":{\"316\":1}}],[\"n>1\",{\"1\":{\"316\":1}}],[\"n增大而增长\",{\"1\":{\"316\":1}}],[\"ns\",{\"1\":{\"315\":9}}],[\"n个字符\",{\"1\":{\"233\":1}}],[\"number>\",{\"1\":{\"797\":1}}],[\"numberformatexception\",{\"1\":{\"793\":1}}],[\"number\",{\"1\":{\"390\":5}}],[\"numberexpression\",{\"1\":{\"390\":5}}],[\"numbers\",{\"1\":{\"215\":1}}],[\"null的槽位才会停止查找\",{\"1\":{\"820\":1}}],[\"nullpointerexception\",{\"1\":{\"706\":1,\"793\":1}}],[\"null\",{\"1\":{\"326\":2,\"346\":2,\"350\":2,\"353\":4,\"365\":1,\"366\":1,\"378\":2,\"422\":1,\"429\":1,\"436\":4,\"443\":15,\"455\":3,\"465\":1,\"511\":3,\"687\":3,\"693\":1,\"695\":2,\"698\":1,\"704\":3,\"705\":5,\"706\":6,\"712\":6,\"726\":1,\"735\":3,\"821\":2,\"822\":2,\"835\":3,\"844\":1,\"870\":3}}],[\"nux\",{\"1\":{\"24\":4,\"50\":4}}],[\"nexthashcode\",{\"1\":{\"819\":2}}],[\"nexthandler\",{\"1\":{\"350\":14}}],[\"next指针和data数据\",{\"1\":{\"678\":1}}],[\"next\",{\"1\":{\"353\":6,\"365\":3,\"366\":4,\"367\":1,\"436\":4,\"443\":4,\"702\":1,\"709\":1}}],[\"nextint\",{\"1\":{\"343\":2,\"346\":2}}],[\"nextline\",{\"1\":{\"343\":2,\"346\":2,\"495\":1}}],[\"newscheduledthreadpool线程池使用了这个队列\",{\"1\":{\"862\":1}}],[\"newscheduledthreadpool\",{\"1\":{\"859\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"859\":1}}],[\"newsize=n\",{\"1\":{\"764\":1}}],[\"newfixedthreadpool线程池使用了这个队列\",{\"1\":{\"862\":1}}],[\"newfixedthreadpool\",{\"1\":{\"859\":1}}],[\"newratio=n\",{\"1\":{\"764\":1}}],[\"newrules\",{\"1\":{\"455\":3}}],[\"newcapacity\",{\"1\":{\"688\":1}}],[\"newcachedthreadpool线程池使用了这个队列\",{\"1\":{\"862\":1}}],[\"newcachedthreadpool\",{\"1\":{\"327\":1,\"859\":1}}],[\"newproxyinstance\",{\"1\":{\"497\":1}}],[\"newplaylist\",{\"1\":{\"454\":13}}],[\"newemail\",{\"1\":{\"481\":2}}],[\"newevent\",{\"1\":{\"455\":7}}],[\"newname\",{\"1\":{\"454\":4}}],[\"newinstance\",{\"1\":{\"436\":1,\"443\":1}}],[\"new\",{\"0\":{\"728\":1},\"1\":{\"325\":6,\"326\":7,\"327\":5,\"343\":5,\"344\":4,\"346\":12,\"350\":3,\"353\":3,\"354\":4,\"359\":3,\"360\":5,\"365\":2,\"366\":3,\"372\":15,\"377\":4,\"378\":4,\"383\":4,\"384\":4,\"390\":5,\"394\":6,\"403\":3,\"408\":4,\"422\":5,\"429\":5,\"436\":6,\"443\":7,\"448\":3,\"450\":6,\"454\":16,\"455\":12,\"461\":1,\"469\":2,\"481\":2,\"495\":11,\"497\":2,\"498\":3,\"502\":6,\"506\":3,\"510\":3,\"511\":2,\"518\":4,\"524\":6,\"525\":19,\"538\":1,\"683\":1,\"702\":3,\"703\":2,\"726\":1,\"728\":2,\"735\":9,\"757\":1,\"791\":2,\"793\":1,\"808\":1,\"822\":2,\"832\":3,\"833\":1,\"838\":2,\"840\":5,\"844\":3,\"851\":1,\"863\":1,\"870\":6}}],[\"neighbor\",{\"1\":{\"212\":1}}],[\"netstat\",{\"1\":{\"762\":1}}],[\"networks\",{\"1\":{\"247\":1}}],[\"network\",{\"1\":{\"155\":1,\"161\":1,\"240\":1,\"246\":1,\"247\":1}}],[\"net\",{\"1\":{\"69\":2}}],[\"n\",{\"1\":{\"138\":1,\"240\":2,\"314\":2,\"315\":3,\"316\":37,\"343\":6,\"346\":6,\"454\":4,\"677\":4,\"678\":1,\"685\":1,\"686\":2,\"688\":2,\"689\":14,\"690\":1,\"695\":3,\"698\":1,\"701\":1,\"705\":1,\"765\":1,\"769\":2}}],[\"nanos\",{\"1\":{\"785\":3,\"807\":1,\"811\":1}}],[\"navigablemap\",{\"1\":{\"705\":1}}],[\"navicate远程连接云服务器数据库\",{\"1\":{\"11\":1,\"37\":1}}],[\"navicate远程连接\",{\"1\":{\"11\":1,\"37\":1}}],[\"native方法\",{\"1\":{\"785\":1}}],[\"native\",{\"1\":{\"722\":1,\"785\":11,\"791\":1,\"827\":3}}],[\"nat允许在ipv4地址有限的情况下\",{\"1\":{\"223\":1}}],[\"nat允许内部网络使用私有ip地址\",{\"1\":{\"223\":1}}],[\"nat设备将内部主机的私有ip地址和端口号转换为nat设备的公共ip地址和一个唯一的端口号\",{\"1\":{\"223\":1}}],[\"nat网络地址转换\",{\"1\":{\"223\":1}}],[\"name=\",{\"1\":{\"8\":1,\"34\":1,\"450\":2,\"539\":3}}],[\"namespace\",{\"1\":{\"539\":1}}],[\"names\",{\"1\":{\"8\":1,\"34\":1,\"215\":1}}],[\"name\",{\"1\":{\"8\":3,\"34\":3,\"67\":1,\"325\":6,\"326\":18,\"327\":5,\"403\":7,\"408\":7,\"450\":24,\"454\":15,\"455\":2,\"485\":2,\"489\":10,\"506\":10,\"511\":2,\"525\":20,\"539\":1}}],[\"noclassdeffounderror\",{\"1\":{\"793\":2}}],[\"nosuchfieldexception\",{\"1\":{\"793\":1}}],[\"nosuchmethodexception\",{\"1\":{\"436\":1,\"443\":1,\"793\":1}}],[\"nonfairsync\",{\"1\":{\"838\":2,\"839\":1,\"840\":4}}],[\"nonterminalexpression\",{\"1\":{\"393\":1}}],[\"non\",{\"1\":{\"390\":1}}],[\"node\",{\"1\":{\"246\":1,\"711\":2,\"846\":1}}],[\"nodelay\",{\"1\":{\"8\":1,\"34\":1}}],[\"notifyall\",{\"1\":{\"785\":1,\"807\":3,\"843\":1}}],[\"notifyalluser\",{\"1\":{\"325\":3}}],[\"notify\",{\"1\":{\"785\":2,\"807\":4,\"811\":2}}],[\"notifyobservers\",{\"1\":{\"327\":4}}],[\"notification\",{\"1\":{\"212\":1}}],[\"notationj\",{\"1\":{\"316\":1}}],[\"not\",{\"1\":{\"107\":1,\"114\":1,\"870\":1}}],[\"noarch\",{\"1\":{\"24\":1,\"50\":1}}],[\"nohup\",{\"1\":{\"23\":1,\"49\":1}}],[\"no\",{\"1\":{\"8\":2,\"34\":2}}],[\"nopush\",{\"1\":{\"8\":1,\"34\":1}}],[\"nofile\",{\"1\":{\"8\":1,\"34\":1}}],[\"sz\",{\"1\":{\"821\":2}}],[\"s1\",{\"1\":{\"791\":2}}],[\"sqlexception\",{\"1\":{\"793\":1}}],[\"sql\",{\"1\":{\"768\":1}}],[\"s标志\",{\"1\":{\"575\":1}}],[\"schemas\",{\"1\":{\"539\":2,\"540\":3}}],[\"scavenge\",{\"1\":{\"745\":1}}],[\"scanner\",{\"1\":{\"343\":8,\"346\":8,\"495\":4}}],[\"scale=1\",{\"1\":{\"8\":1,\"34\":1}}],[\"sdk\",{\"1\":{\"539\":1}}],[\"sdk版本\",{\"1\":{\"538\":1}}],[\"sdlc\",{\"1\":{\"131\":1}}],[\"smsparamsdto\",{\"1\":{\"511\":5}}],[\"smsadapterfactory\",{\"1\":{\"511\":2}}],[\"smsadapter\",{\"1\":{\"511\":7}}],[\"smsservice\",{\"1\":{\"511\":1}}],[\"smtp和pop3是什么协议\",{\"0\":{\"568\":1}}],[\"smtp原始协议只能传送ascii码文本\",{\"1\":{\"96\":1}}],[\"smtp仅限于传送7位ascii码\",{\"1\":{\"95\":1}}],[\"smtp不能传送可执行文件或者其他二进制对象\",{\"1\":{\"95\":1}}],[\"smtp协议的缺点\",{\"0\":{\"95\":1}}],[\"smtp协议主要负责邮件的发送\",{\"1\":{\"94\":1}}],[\"smtp详细工作流程\",{\"1\":{\"94\":1}}],[\"smtp工作流程\",{\"1\":{\"94\":1}}],[\"smtp使用的端口号为25\",{\"1\":{\"93\":1}}],[\"smtp服务器会拒绝超过一定长度的邮件\",{\"1\":{\"95\":1}}],[\"smtp服务器\",{\"1\":{\"93\":1,\"94\":1}}],[\"smtp客户\",{\"1\":{\"93\":1}}],[\"smtp是用于在网络上传输电子邮件的协议\",{\"1\":{\"92\":1}}],[\"smtp\",{\"0\":{\"92\":1},\"1\":{\"92\":1,\"279\":1}}],[\"smtp等\",{\"1\":{\"56\":1}}],[\"safepoint\",{\"1\":{\"747\":1}}],[\"safe\",{\"0\":{\"709\":1},\"1\":{\"709\":2}}],[\"saleschannel\",{\"1\":{\"506\":12}}],[\"saveuser\",{\"1\":{\"481\":2}}],[\"save\",{\"1\":{\"378\":4}}],[\"savememento\",{\"1\":{\"377\":3}}],[\"savestatetomemento\",{\"1\":{\"377\":3}}],[\"sb\",{\"1\":{\"454\":8}}],[\"slf4j\",{\"1\":{\"436\":1,\"443\":1}}],[\"sleep\",{\"0\":{\"812\":1},\"1\":{\"327\":1,\"785\":1,\"807\":1,\"812\":3,\"813\":2,\"870\":1}}],[\"survivorratio=n\",{\"1\":{\"764\":1}}],[\"survivor\",{\"1\":{\"740\":3,\"764\":4}}],[\"survivor空间\",{\"1\":{\"722\":2,\"737\":1}}],[\"supportsrtl=\",{\"1\":{\"539\":1}}],[\"super\",{\"1\":{\"436\":2,\"443\":8,\"455\":3,\"495\":2,\"502\":4,\"822\":1}}],[\"superarray\",{\"1\":{\"366\":16}}],[\"superarray类表示一个简单的数组聚合对象\",{\"1\":{\"366\":1}}],[\"subcomponent\",{\"1\":{\"525\":3}}],[\"subsystems\",{\"1\":{\"516\":1}}],[\"substitution\",{\"1\":{\"468\":1}}],[\"subscribelist\",{\"1\":{\"326\":8}}],[\"subscribes\",{\"1\":{\"326\":5}}],[\"subscribe\",{\"1\":{\"326\":15}}],[\"subscriber\",{\"1\":{\"326\":1}}],[\"subtractexpression\",{\"1\":{\"390\":3}}],[\"submit执行\",{\"1\":{\"865\":1}}],[\"submit\",{\"1\":{\"327\":1,\"863\":2}}],[\"subject\",{\"1\":{\"91\":1,\"324\":1,\"327\":9,\"461\":1}}],[\"spectrum\",{\"1\":{\"620\":2}}],[\"split\",{\"1\":{\"422\":3,\"429\":3,\"436\":3,\"443\":3}}],[\"springboot框架\",{\"0\":{\"891\":1}}],[\"spring框架\",{\"0\":{\"889\":1,\"893\":1}}],[\"spring容器的单例\",{\"1\":{\"419\":1}}],[\"spring\",{\"0\":{\"897\":1},\"1\":{\"352\":1,\"405\":1,\"477\":1}}],[\"space\",{\"1\":{\"317\":1}}],[\"spanning\",{\"1\":{\"175\":2}}],[\"ssthresh时\",{\"1\":{\"299\":3}}],[\"swap的缩写\",{\"1\":{\"845\":1}}],[\"swap\",{\"1\":{\"829\":1}}],[\"sweep\",{\"1\":{\"744\":1,\"746\":1,\"751\":1}}],[\"swnd\",{\"1\":{\"297\":1}}],[\"switch\",{\"1\":{\"171\":1,\"253\":1,\"580\":3}}],[\"synchronousqueue\",{\"1\":{\"862\":2}}],[\"synchronized与wait\",{\"1\":{\"843\":1}}],[\"synchronized的性能比reentrantlock差很多\",{\"1\":{\"843\":1}}],[\"synchronized的实现直接调用objectmonitor的enter和exit\",{\"1\":{\"837\":1}}],[\"synchronized的实现原理是什么\",{\"1\":{\"835\":1}}],[\"synchronized的实现原理\",{\"0\":{\"835\":1}}],[\"synchronized不需要手动加\",{\"1\":{\"843\":1}}],[\"synchronized是java语言的关键字\",{\"1\":{\"843\":1}}],[\"synchronized是怎么加锁的呢\",{\"1\":{\"835\":1}}],[\"synchronized做了哪些优化\",{\"1\":{\"837\":1}}],[\"synchronized优化就是引入锁升级的过程\",{\"1\":{\"837\":1}}],[\"synchronized优化了解吗\",{\"0\":{\"837\":1},\"1\":{\"837\":1}}],[\"synchronized同步的代码块\",{\"1\":{\"836\":1}}],[\"synchronized怎么实现可重入的呢\",{\"1\":{\"836\":1}}],[\"synchronized怎么保证有序性\",{\"1\":{\"836\":1}}],[\"synchronized怎么保证可见性\",{\"1\":{\"836\":1}}],[\"synchronized怎么使用\",{\"0\":{\"833\":1},\"1\":{\"833\":1}}],[\"synchronized可见性\",{\"0\":{\"836\":1}}],[\"synchronized都是基于monitor实现的\",{\"1\":{\"835\":1}}],[\"synchronized标记符来实现同步\",{\"1\":{\"835\":1}}],[\"synchronized修饰同步方法时\",{\"1\":{\"835\":1}}],[\"synchronized修饰代码块时\",{\"1\":{\"835\":1}}],[\"synchronizeddemo\",{\"1\":{\"835\":1}}],[\"synchronized和volatile的区别\",{\"0\":{\"834\":1}}],[\"synchronized主要有三种用法\",{\"1\":{\"833\":1}}],[\"synchronizedmethod\",{\"1\":{\"832\":1}}],[\"synchronizedmap\",{\"1\":{\"708\":3}}],[\"synchronized或者volatile都可以保证多线程之间操作的有序性\",{\"1\":{\"825\":1}}],[\"synchronized关键字\",{\"1\":{\"811\":1}}],[\"synchronized\",{\"1\":{\"708\":1,\"711\":2,\"831\":2,\"832\":6,\"833\":9,\"834\":10,\"835\":1,\"836\":3,\"838\":1,\"841\":1,\"843\":2,\"844\":2}}],[\"synchronizedlist\",{\"1\":{\"681\":1}}],[\"sync\",{\"1\":{\"838\":5,\"839\":4,\"840\":2}}],[\"syn\",{\"0\":{\"641\":1,\"643\":1},\"1\":{\"285\":1}}],[\"syn洪泛攻击是一种常见的网络攻击方式\",{\"1\":{\"285\":1}}],[\"syn洪泛攻击\",{\"1\":{\"285\":1}}],[\"syn=0\",{\"1\":{\"285\":1}}],[\"syn=1\",{\"1\":{\"285\":2}}],[\"system的意思\",{\"1\":{\"419\":1}}],[\"system\",{\"1\":{\"67\":1,\"314\":1,\"315\":1,\"316\":6,\"325\":2,\"326\":2,\"327\":1,\"343\":7,\"344\":3,\"346\":8,\"350\":4,\"353\":2,\"354\":2,\"359\":2,\"360\":12,\"366\":1,\"372\":11,\"377\":2,\"378\":5,\"383\":2,\"384\":3,\"390\":1,\"394\":2,\"403\":3,\"408\":3,\"436\":1,\"443\":4,\"448\":4,\"450\":2,\"454\":10,\"455\":2,\"481\":1,\"485\":5,\"495\":16,\"497\":12,\"498\":12,\"502\":9,\"506\":2,\"510\":2,\"518\":3,\"525\":4,\"739\":2,\"756\":1,\"795\":1,\"796\":1,\"822\":1,\"870\":2}}],[\"snmp\",{\"1\":{\"279\":1,\"301\":1}}],[\"snapshot\",{\"1\":{\"23\":1,\"49\":1}}],[\"s的以太网\",{\"1\":{\"262\":2}}],[\"s的协议一个大规模的\",{\"1\":{\"103\":1}}],[\"s的协议\",{\"1\":{\"83\":1}}],[\"s~16mb\",{\"1\":{\"230\":1}}],[\"srp关注类或模块的职责和功能的划分\",{\"1\":{\"474\":1}}],[\"srp的目标是将功能划分清晰\",{\"1\":{\"474\":1}}],[\"srp\",{\"1\":{\"474\":2}}],[\"sr\",{\"1\":{\"139\":1}}],[\"softreference\",{\"1\":{\"735\":3}}],[\"software\",{\"1\":{\"490\":1}}],[\"song3\",{\"1\":{\"525\":2}}],[\"song2\",{\"1\":{\"525\":2}}],[\"song1\",{\"1\":{\"525\":2}}],[\"songs\",{\"1\":{\"454\":17}}],[\"song\",{\"1\":{\"454\":34,\"674\":1}}],[\"socket\",{\"0\":{\"566\":1},\"1\":{\"279\":1}}],[\"soh\",{\"1\":{\"132\":1,\"577\":1}}],[\"sourcecompatibility\",{\"1\":{\"539\":1}}],[\"source\",{\"1\":{\"19\":1,\"45\":1,\"575\":1}}],[\"situation\",{\"0\":{\"896\":1}}],[\"signal\",{\"1\":{\"721\":1,\"853\":1}}],[\"simple\",{\"1\":{\"424\":1,\"430\":1,\"480\":1,\"482\":1}}],[\"single\",{\"1\":{\"460\":1}}],[\"singleton\",{\"1\":{\"416\":1,\"418\":1,\"490\":1,\"826\":2}}],[\"since\",{\"1\":{\"114\":2}}],[\"sifs是最短的帧间间隔\",{\"1\":{\"152\":1}}],[\"sif\",{\"1\":{\"152\":1}}],[\"size\",{\"1\":{\"8\":6,\"34\":6,\"707\":6,\"728\":1,\"821\":1,\"870\":4}}],[\"s应用中\",{\"1\":{\"58\":2}}],[\"s方式的应用服务通常是服务集中型的\",{\"1\":{\"58\":1}}],[\"s方式强调了服务提供者和请求者之间的层次关系\",{\"1\":{\"58\":1}}],[\"s\",{\"1\":{\"58\":1,\"230\":1,\"240\":1,\"260\":12,\"261\":5,\"262\":2,\"372\":2,\"622\":1,\"768\":1,\"835\":1,\"853\":6,\"863\":1}}],[\"s模型\",{\"0\":{\"58\":1}}],[\"stw\",{\"1\":{\"747\":1,\"750\":1}}],[\"stub\",{\"1\":{\"863\":1}}],[\"studio上预览界面效果\",{\"1\":{\"540\":1}}],[\"studio\",{\"1\":{\"538\":2}}],[\"stupid\",{\"1\":{\"480\":1,\"482\":1}}],[\"stop\",{\"1\":{\"744\":1,\"867\":3}}],[\"stock\",{\"1\":{\"455\":1}}],[\"storefence\",{\"1\":{\"827\":1}}],[\"storeload\",{\"1\":{\"827\":1}}],[\"storeload屏障\",{\"1\":{\"827\":1}}],[\"storestore\",{\"1\":{\"827\":1}}],[\"storestore屏障\",{\"1\":{\"827\":1}}],[\"store\",{\"1\":{\"8\":1,\"34\":1,\"506\":2,\"828\":1}}],[\"step3\",{\"1\":{\"332\":3}}],[\"step2\",{\"1\":{\"332\":3}}],[\"step1\",{\"1\":{\"332\":3}}],[\"staic\",{\"1\":{\"833\":1}}],[\"stamp\",{\"1\":{\"832\":2,\"845\":1}}],[\"stampedlock\",{\"1\":{\"832\":8}}],[\"stackoverflowerror\",{\"1\":{\"793\":1}}],[\"stack<>\",{\"1\":{\"378\":1}}],[\"stack<textmemento>\",{\"1\":{\"378\":1}}],[\"start\",{\"1\":{\"575\":1,\"822\":1,\"870\":1}}],[\"startdate\",{\"1\":{\"455\":3}}],[\"starttopic\",{\"1\":{\"326\":10}}],[\"static修饰\",{\"1\":{\"779\":1}}],[\"static修饰的\",{\"1\":{\"773\":2}}],[\"static\",{\"1\":{\"325\":1,\"326\":1,\"327\":1,\"343\":1,\"344\":1,\"346\":3,\"350\":1,\"353\":1,\"354\":1,\"359\":1,\"360\":2,\"365\":1,\"366\":1,\"372\":2,\"377\":1,\"378\":1,\"383\":1,\"384\":1,\"390\":1,\"394\":1,\"403\":1,\"408\":1,\"429\":1,\"436\":3,\"443\":3,\"448\":1,\"450\":6,\"454\":2,\"455\":3,\"469\":2,\"485\":2,\"495\":5,\"497\":1,\"498\":1,\"502\":2,\"506\":1,\"510\":1,\"511\":1,\"518\":1,\"524\":1,\"525\":3,\"683\":1,\"689\":1,\"693\":1,\"694\":1,\"754\":1,\"775\":4,\"776\":1,\"783\":1,\"795\":2,\"816\":9,\"819\":2,\"822\":1,\"833\":1,\"844\":3,\"867\":5,\"870\":1}}],[\"statement\",{\"1\":{\"731\":1}}],[\"state接口定义了一个handle方法\",{\"1\":{\"359\":1}}],[\"state\",{\"1\":{\"210\":3,\"357\":1,\"359\":7,\"360\":8,\"377\":20,\"490\":1,\"769\":1,\"839\":6,\"840\":1,\"846\":1}}],[\"striped\",{\"1\":{\"855\":1}}],[\"stringbuffer\",{\"0\":{\"789\":1},\"1\":{\"789\":5}}],[\"stringbuilder\",{\"0\":{\"789\":1,\"790\":1},\"1\":{\"454\":4,\"789\":4,\"790\":4,\"792\":1}}],[\"string>\",{\"1\":{\"495\":1}}],[\"string\",{\"0\":{\"789\":1,\"792\":1},\"1\":{\"325\":9,\"326\":11,\"327\":8,\"343\":2,\"344\":1,\"346\":4,\"350\":1,\"353\":5,\"354\":5,\"359\":1,\"360\":2,\"365\":1,\"366\":1,\"372\":2,\"377\":7,\"378\":7,\"383\":1,\"384\":7,\"390\":1,\"394\":1,\"403\":11,\"408\":11,\"422\":7,\"429\":7,\"436\":13,\"443\":30,\"448\":9,\"450\":25,\"454\":22,\"455\":4,\"461\":8,\"465\":1,\"469\":1,\"481\":9,\"485\":2,\"489\":11,\"495\":22,\"497\":16,\"498\":12,\"502\":2,\"506\":9,\"510\":1,\"511\":6,\"518\":10,\"524\":1,\"525\":10,\"539\":1,\"722\":1,\"725\":1,\"731\":1,\"785\":2,\"789\":9,\"791\":7,\"792\":3,\"794\":3,\"795\":1,\"822\":1,\"870\":1}}],[\"structuraldesignpattern\",{\"1\":{\"497\":2,\"498\":2}}],[\"structural\",{\"1\":{\"490\":1}}],[\"structure\",{\"1\":{\"371\":1,\"372\":1}}],[\"street\",{\"1\":{\"450\":1}}],[\"stream流\",{\"1\":{\"702\":1}}],[\"stream\",{\"1\":{\"8\":2,\"34\":2}}],[\"strategyfactory\",{\"1\":{\"346\":2}}],[\"strategy\",{\"1\":{\"341\":1,\"343\":16,\"346\":25,\"386\":2,\"490\":1}}],[\"stp保证了数据在网络中的有效传输\",{\"1\":{\"175\":1}}],[\"stp是构建现代局域网的基础\",{\"1\":{\"175\":1}}],[\"stp可以快速重新计算生成树\",{\"1\":{\"175\":1}}],[\"stp会定期发送bpdu\",{\"1\":{\"175\":1}}],[\"stp会将一些端口设为阻塞状态\",{\"1\":{\"175\":1}}],[\"stp使用bridge\",{\"1\":{\"175\":1}}],[\"stp\",{\"1\":{\"175\":1}}],[\"stp生成树协议\",{\"0\":{\"175\":1}}],[\"stdm帧大小小于连接在集中器上的用户数\",{\"1\":{\"148\":1}}],[\"stdm\",{\"1\":{\"148\":1}}],[\"style\",{\"1\":{\"104\":1,\"539\":1}}],[\"semaphore\",{\"1\":{\"853\":1}}],[\"semaphore了解吗\",{\"0\":{\"853\":1},\"1\":{\"853\":1}}],[\"securityexception\",{\"1\":{\"793\":1}}],[\"securityproxy\",{\"1\":{\"495\":3}}],[\"segment\",{\"1\":{\"711\":4}}],[\"segment如果是空就先初始化\",{\"1\":{\"711\":1}}],[\"segment之间相互不会受到影响\",{\"1\":{\"711\":1}}],[\"segment则包含hashentry的数组\",{\"1\":{\"711\":1}}],[\"segment继承于reentrantlock\",{\"1\":{\"711\":1}}],[\"segregation\",{\"1\":{\"472\":1,\"474\":1}}],[\"sequence\",{\"1\":{\"575\":2}}],[\"seq=w\",{\"1\":{\"286\":1}}],[\"seq=v\",{\"1\":{\"286\":1}}],[\"seq=u+1\",{\"1\":{\"286\":1}}],[\"seq=u\",{\"1\":{\"286\":1}}],[\"seq=y\",{\"1\":{\"285\":1}}],[\"seq=x+1\",{\"1\":{\"285\":1}}],[\"seq=x\",{\"1\":{\"285\":1}}],[\"session\",{\"0\":{\"561\":1},\"1\":{\"731\":1}}],[\"selling\",{\"1\":{\"506\":2}}],[\"sell\",{\"1\":{\"506\":7}}],[\"select\",{\"1\":{\"495\":2,\"497\":5,\"498\":5}}],[\"selective\",{\"1\":{\"139\":1}}],[\"seasonaldiscountstrategy\",{\"1\":{\"465\":2}}],[\"seasonal\",{\"1\":{\"465\":1}}],[\"serial语义的存在\",{\"1\":{\"836\":1}}],[\"serial语义的意思是\",{\"1\":{\"826\":1}}],[\"serial语义\",{\"1\":{\"826\":1}}],[\"serial和happens\",{\"1\":{\"826\":1}}],[\"serial\",{\"1\":{\"721\":1,\"745\":2,\"752\":1}}],[\"serializable\",{\"1\":{\"454\":1,\"455\":1,\"838\":1,\"842\":1}}],[\"serialize\",{\"1\":{\"346\":3}}],[\"serializer\",{\"1\":{\"346\":10}}],[\"servlet\",{\"1\":{\"352\":2}}],[\"servlet的基类\",{\"1\":{\"338\":1}}],[\"servlet的示例\",{\"1\":{\"338\":1}}],[\"servelt\",{\"0\":{\"338\":1}}],[\"server\",{\"1\":{\"8\":14,\"22\":3,\"34\":14,\"48\":3,\"495\":2}}],[\"services\",{\"1\":{\"538\":2}}],[\"service\",{\"1\":{\"249\":1,\"769\":1}}],[\"sense\",{\"1\":{\"581\":2}}],[\"sensitive\",{\"1\":{\"495\":1}}],[\"sensitiveoperationimpl\",{\"1\":{\"495\":2}}],[\"sensitiveoperation\",{\"1\":{\"495\":8}}],[\"sending\",{\"1\":{\"495\":1}}],[\"sendwelcomeemail\",{\"1\":{\"481\":1}}],[\"sendemail\",{\"1\":{\"461\":2,\"481\":2}}],[\"sender\",{\"1\":{\"408\":3}}],[\"sendconfirmationemail\",{\"1\":{\"461\":4}}],[\"sendmessage\",{\"1\":{\"403\":3,\"404\":1,\"408\":3,\"409\":1}}],[\"sendmsg\",{\"1\":{\"325\":3}}],[\"send\",{\"1\":{\"8\":1,\"34\":1,\"403\":4,\"408\":6}}],[\"sendfile\",{\"1\":{\"8\":1,\"34\":1}}],[\"sent|$upstream\",{\"1\":{\"8\":1,\"34\":1}}],[\"sent|$bytes\",{\"1\":{\"8\":1,\"34\":1}}],[\"set<k>\",{\"1\":{\"702\":1}}],[\"set<map\",{\"1\":{\"436\":1,\"443\":1,\"702\":1}}],[\"set集\",{\"1\":{\"671\":1}}],[\"setsuperclass\",{\"1\":{\"498\":1}}],[\"setstartdate\",{\"1\":{\"455\":1}}],[\"setstate\",{\"1\":{\"360\":3,\"377\":3}}],[\"setstrategy\",{\"1\":{\"343\":2,\"346\":2}}],[\"setdog\",{\"1\":{\"455\":1}}],[\"setdiscountstrategy\",{\"1\":{\"465\":1}}],[\"setdiscount\",{\"1\":{\"455\":1}}],[\"setenddate\",{\"1\":{\"455\":1}}],[\"setter方法来设置线程池的参数\",{\"1\":{\"869\":1}}],[\"settext\",{\"1\":{\"378\":4}}],[\"settings\",{\"1\":{\"539\":1}}],[\"settime\",{\"1\":{\"455\":1}}],[\"settitle\",{\"1\":{\"454\":1}}],[\"setartist\",{\"1\":{\"454\":3}}],[\"setaddress\",{\"1\":{\"450\":2}}],[\"setage\",{\"1\":{\"450\":2,\"455\":2}}],[\"setname\",{\"1\":{\"450\":2,\"454\":2,\"455\":1}}],[\"setnexthandler\",{\"1\":{\"350\":6}}],[\"setmonitor\",{\"1\":{\"448\":2}}],[\"setmemory\",{\"1\":{\"448\":2}}],[\"setmessage\",{\"1\":{\"327\":2}}],[\"setharddisk\",{\"1\":{\"448\":2}}],[\"setproduct\",{\"1\":{\"455\":1}}],[\"setprocessor\",{\"1\":{\"448\":2}}],[\"setpaymentstrategy\",{\"1\":{\"344\":5}}],[\"setcallback\",{\"1\":{\"498\":1}}],[\"setcommand\",{\"1\":{\"383\":3}}],[\"setcurrentstate\",{\"1\":{\"359\":2}}],[\"set等\",{\"1\":{\"107\":1}}],[\"set\",{\"1\":{\"8\":2,\"34\":2,\"670\":1,\"671\":1,\"733\":1,\"742\":1,\"821\":1,\"822\":1,\"845\":1,\"855\":2}}],[\"shutdownnow\",{\"1\":{\"864\":2}}],[\"shutdown\",{\"1\":{\"721\":2,\"863\":1,\"864\":3,\"867\":3}}],[\"shipping\",{\"1\":{\"518\":1}}],[\"shippingaddress\",{\"1\":{\"518\":3}}],[\"shiporder\",{\"1\":{\"518\":2}}],[\"shirt\",{\"1\":{\"506\":1}}],[\"shared\",{\"1\":{\"846\":1}}],[\"sha256等\",{\"1\":{\"690\":1}}],[\"shannon\",{\"1\":{\"622\":1}}],[\"shawn\",{\"1\":{\"497\":3}}],[\"shallowcopy\",{\"1\":{\"454\":3}}],[\"short\",{\"1\":{\"724\":1}}],[\"shops\",{\"1\":{\"372\":1}}],[\"shoppingcart\",{\"1\":{\"384\":8}}],[\"shopping\",{\"1\":{\"372\":1}}],[\"shoppingmall\",{\"1\":{\"372\":10}}],[\"showing\",{\"1\":{\"372\":1}}],[\"sheets\",{\"1\":{\"104\":1}}],[\"sh\",{\"1\":{\"3\":4,\"29\":4}}],[\"二进制代码\",{\"1\":{\"804\":1}}],[\"二进制除法运算\",{\"1\":{\"135\":1,\"576\":1}}],[\"二叉树不平衡\",{\"1\":{\"698\":1}}],[\"二者平等\",{\"1\":{\"162\":1}}],[\"二级域名的样子\",{\"1\":{\"594\":1}}],[\"二级域名\",{\"1\":{\"69\":1}}],[\"二\",{\"0\":{\"6\":1,\"32\":1,\"60\":1,\"122\":1,\"188\":1,\"228\":1,\"252\":1,\"281\":1,\"329\":1,\"422\":1,\"463\":1,\"499\":1,\"630\":1,\"676\":1,\"684\":1,\"732\":1,\"815\":1}}],[\"添加锁和释放锁的大部分操作实际上都是在\",{\"1\":{\"838\":1}}],[\"添加键值对\",{\"1\":{\"703\":2}}],[\"添加必要的控制信息\",{\"1\":{\"573\":1,\"577\":1,\"584\":1}}],[\"添加子节点\",{\"1\":{\"524\":1}}],[\"添加新的能力\",{\"1\":{\"500\":1}}],[\"添加新的产品家族可能需要修改抽象工厂的接口和所有的具体工厂\",{\"1\":{\"444\":1}}],[\"添加安全验证的逻辑\",{\"1\":{\"495\":1}}],[\"添加查询缓存的逻辑\",{\"1\":{\"495\":1}}],[\"添加了背景颜色\",{\"1\":{\"502\":5}}],[\"添加了构造函数\",{\"1\":{\"450\":1}}],[\"添加了静态的builder\",{\"1\":{\"450\":1}}],[\"添加了getter方法和tostring\",{\"1\":{\"450\":1}}],[\"添加了私有构造函数以及对应的属性赋值操作\",{\"1\":{\"450\":1}}],[\"添加商品命令类\",{\"1\":{\"384\":1}}],[\"添加商品到购物车\",{\"1\":{\"384\":1}}],[\"添加更多版本的策略类\",{\"1\":{\"346\":1}}],[\"添加\",{\"1\":{\"208\":1}}],[\"添加内容\",{\"1\":{\"8\":1,\"34\":1}}],[\"添加端口规则\",{\"1\":{\"5\":1,\"11\":1,\"31\":1,\"37\":1}}],[\"添加图中端口放行\",{\"1\":{\"3\":1,\"29\":1}}],[\"2surivior\",{\"1\":{\"750\":1}}],[\"2的倍数意味着该数的二进制位只有一位为1\",{\"1\":{\"688\":1}}],[\"27\",{\"0\":{\"661\":1,\"711\":1,\"798\":1,\"799\":1},\"1\":{\"798\":1,\"799\":1}}],[\"2msl\",{\"0\":{\"646\":1}}],[\"2msl的意义\",{\"1\":{\"286\":1}}],[\"2字节\",{\"1\":{\"575\":2}}],[\"29452\",{\"1\":{\"769\":2}}],[\"29471\",{\"1\":{\"769\":3}}],[\"29\",{\"0\":{\"663\":1,\"713\":1},\"1\":{\"506\":1}}],[\"2n+1\",{\"1\":{\"706\":1}}],[\"2n\",{\"1\":{\"316\":2}}],[\"2b\",{\"1\":{\"302\":4,\"574\":1}}],[\"2状态\",{\"1\":{\"286\":1}}],[\"23\",{\"0\":{\"569\":1,\"657\":1,\"707\":1,\"794\":1},\"1\":{\"279\":1,\"794\":1}}],[\"233\",{\"1\":{\"217\":1}}],[\"2w\",{\"1\":{\"240\":2}}],[\"28\",{\"0\":{\"662\":1,\"712\":1,\"800\":1},\"1\":{\"222\":1,\"800\":1}}],[\"26\",{\"0\":{\"660\":1,\"710\":1,\"797\":1},\"1\":{\"222\":1,\"797\":1}}],[\"22\",{\"0\":{\"568\":1,\"614\":1,\"656\":1,\"706\":1,\"793\":1},\"1\":{\"221\":1}}],[\"22版本\",{\"1\":{\"7\":1,\"33\":1}}],[\"24的子网掩码\",{\"1\":{\"222\":1}}],[\"24\",{\"0\":{\"570\":1,\"658\":1,\"708\":1,\"795\":1},\"1\":{\"221\":3,\"596\":1,\"795\":1}}],[\"240\",{\"1\":{\"217\":1,\"220\":1}}],[\"200ms\",{\"1\":{\"750\":1}}],[\"200\",{\"1\":{\"344\":1}}],[\"2048byte\",{\"1\":{\"260\":1}}],[\"20\",{\"0\":{\"566\":1,\"612\":1,\"654\":1,\"704\":1,\"751\":1,\"791\":1},\"1\":{\"220\":3,\"350\":2,\"394\":2,\"766\":2,\"791\":1}}],[\"20的全部细节\",{\"1\":{\"220\":1}}],[\"20min更新一次\",{\"1\":{\"198\":1}}],[\"2^n\",{\"1\":{\"316\":2}}],[\"2^40byte\",{\"1\":{\"260\":1}}],[\"2^30byte\",{\"1\":{\"260\":1}}],[\"2^20\",{\"1\":{\"260\":2}}],[\"2^20byte\",{\"1\":{\"260\":1}}],[\"2^21\",{\"1\":{\"217\":1}}],[\"2^10byte\",{\"1\":{\"260\":1}}],[\"2^14\",{\"1\":{\"217\":1}}],[\"2^\",{\"1\":{\"218\":1,\"220\":2}}],[\"2^6个\",{\"1\":{\"218\":1}}],[\"2^7\",{\"1\":{\"217\":1}}],[\"256\",{\"1\":{\"222\":1}}],[\"256k\",{\"1\":{\"8\":1,\"34\":1}}],[\"25共享相同的前缀172\",{\"1\":{\"221\":1}}],[\"25和172\",{\"1\":{\"221\":1}}],[\"252\",{\"1\":{\"218\":2}}],[\"254\",{\"1\":{\"217\":1}}],[\"25\",{\"0\":{\"659\":1,\"709\":1,\"796\":1},\"1\":{\"184\":1,\"221\":2,\"279\":1,\"350\":1,\"596\":1,\"796\":1}}],[\"255\",{\"1\":{\"64\":6,\"217\":7,\"218\":12,\"220\":3,\"596\":6}}],[\"2147483648~2147483647\",{\"1\":{\"694\":1}}],[\"214\",{\"1\":{\"217\":1}}],[\"21\",{\"0\":{\"567\":1,\"613\":1,\"655\":1,\"705\":1,\"752\":1,\"792\":1},\"1\":{\"21\":3,\"22\":4,\"47\":3,\"48\":4,\"279\":1,\"792\":1}}],[\"2版本\",{\"1\":{\"13\":1,\"39\":1}}],[\"2\",{\"0\":{\"4\":1,\"5\":1,\"8\":1,\"11\":1,\"14\":1,\"18\":1,\"19\":1,\"23\":1,\"30\":1,\"31\":1,\"34\":1,\"37\":1,\"40\":1,\"44\":1,\"45\":1,\"49\":1,\"57\":1,\"59\":1,\"63\":1,\"64\":1,\"68\":1,\"69\":1,\"72\":1,\"75\":1,\"84\":1,\"86\":1,\"91\":1,\"92\":1,\"104\":1,\"105\":1,\"107\":1,\"113\":1,\"120\":1,\"121\":1,\"128\":1,\"145\":1,\"151\":1,\"157\":1,\"159\":1,\"162\":1,\"166\":1,\"167\":1,\"171\":1,\"174\":1,\"181\":1,\"194\":1,\"195\":1,\"197\":1,\"201\":1,\"206\":1,\"207\":1,\"209\":1,\"216\":1,\"217\":1,\"230\":1,\"233\":1,\"236\":1,\"247\":1,\"249\":1,\"254\":1,\"258\":1,\"261\":1,\"274\":1,\"278\":1,\"283\":1,\"286\":1,\"289\":1,\"294\":1,\"297\":1,\"302\":1,\"305\":1,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":2,\"317\":2,\"323\":1,\"331\":1,\"337\":1,\"342\":1,\"349\":1,\"358\":1,\"364\":1,\"370\":1,\"376\":1,\"382\":1,\"389\":1,\"393\":1,\"399\":1,\"402\":1,\"407\":1,\"417\":1,\"425\":1,\"431\":1,\"432\":1,\"433\":2,\"434\":1,\"435\":1,\"436\":1,\"437\":1,\"440\":1,\"447\":1,\"455\":1,\"461\":1,\"465\":1,\"469\":1,\"473\":1,\"477\":1,\"481\":1,\"485\":1,\"489\":1,\"496\":1,\"501\":1,\"505\":1,\"509\":1,\"515\":1,\"523\":1,\"529\":1,\"538\":1,\"548\":1,\"562\":1,\"574\":1,\"588\":1,\"593\":1,\"594\":1,\"618\":1,\"628\":1,\"632\":1,\"636\":1,\"671\":1,\"678\":1,\"686\":1,\"688\":1,\"720\":1,\"734\":1,\"755\":1,\"763\":1,\"774\":1,\"805\":1,\"817\":1,\"825\":1,\"832\":1,\"852\":1,\"858\":1},\"1\":{\"8\":1,\"18\":1,\"24\":1,\"34\":1,\"44\":1,\"50\":1,\"113\":4,\"121\":1,\"156\":1,\"205\":1,\"217\":3,\"220\":1,\"268\":1,\"291\":1,\"314\":2,\"315\":2,\"316\":4,\"327\":1,\"346\":3,\"377\":2,\"378\":4,\"454\":2,\"455\":1,\"485\":1,\"495\":1,\"518\":1,\"538\":3,\"539\":2,\"688\":1,\"689\":2,\"690\":2,\"694\":2,\"706\":3,\"707\":5,\"724\":3,\"725\":1,\"735\":3,\"743\":1,\"747\":1,\"764\":1,\"769\":1,\"774\":1,\"777\":1,\"785\":1,\"789\":1,\"791\":3,\"795\":1,\"807\":1,\"821\":1,\"848\":1,\"866\":1,\"867\":1,\"870\":2}}],[\"安卓系统版本\",{\"1\":{\"538\":1}}],[\"安全状态\",{\"1\":{\"848\":1}}],[\"安全错误比如权限不够\",{\"1\":{\"793\":1}}],[\"安全性\",{\"1\":{\"758\":1}}],[\"安全失败\",{\"1\":{\"709\":1}}],[\"安全验证密码\",{\"1\":{\"495\":1}}],[\"安全代理当涉及到安全性验证时\",{\"1\":{\"495\":1}}],[\"安全代理示例代码\",{\"1\":{\"495\":1}}],[\"安全访问控制\",{\"1\":{\"494\":1,\"495\":1}}],[\"安全等\",{\"1\":{\"212\":1}}],[\"安全\",{\"1\":{\"5\":1,\"11\":1,\"14\":1,\"31\":1,\"37\":1,\"40\":1}}],[\"安全组\",{\"1\":{\"3\":1,\"29\":1}}],[\"安装android\",{\"1\":{\"538\":1}}],[\"安装第三方更新源\",{\"1\":{\"24\":1,\"50\":1}}],[\"安装epel\",{\"1\":{\"24\":1,\"50\":1}}],[\"安装所需软件\",{\"1\":{\"24\":1,\"50\":1}}],[\"安装ffmpeg\",{\"0\":{\"24\":1,\"50\":1},\"1\":{\"24\":1,\"50\":1}}],[\"安装jdk\",{\"0\":{\"15\":1,\"41\":1}}],[\"安装redis\",{\"0\":{\"12\":1,\"38\":1}}],[\"安装mysql\",{\"0\":{\"9\":1,\"35\":1}}],[\"安装完成让其显示在首页\",{\"1\":{\"7\":1,\"10\":1,\"13\":1,\"33\":1,\"36\":1,\"39\":1}}],[\"安装完成牢记不要清除界面\",{\"1\":{\"3\":1,\"29\":1}}],[\"安装\",{\"0\":{\"7\":1,\"10\":1,\"13\":1,\"33\":1,\"36\":1,\"39\":1}}],[\"安装nginx\",{\"0\":{\"6\":1,\"32\":1}}],[\"安装成功测试\",{\"0\":{\"20\":1,\"46\":1}}],[\"安装成功效果\",{\"1\":{\"3\":1,\"29\":1}}],[\"安装成功\",{\"1\":{\"3\":1,\"29\":1}}],[\">a\",{\"1\":{\"845\":1}}],[\">b\",{\"1\":{\"845\":1}}],[\">重量级锁\",{\"1\":{\"837\":1}}],[\">偏向锁\",{\"1\":{\"837\":1}}],[\">对象指向分配的内存空间\",{\"1\":{\"826\":1}}],[\">初始化对象\",{\"1\":{\"826\":1}}],[\">0\",{\"1\":{\"690\":1}}],[\">>>\",{\"1\":{\"689\":5,\"693\":1,\"695\":1}}],[\">runtime类\",{\"1\":{\"419\":1}}],[\">=\",{\"1\":{\"350\":3,\"689\":1,\"821\":4}}],[\">∞\",{\"1\":{\"316\":1}}],[\">系统防火墙\",{\"1\":{\"5\":1,\"11\":1,\"31\":1,\"37\":1}}],[\">\",{\"1\":{\"3\":2,\"5\":2,\"8\":3,\"11\":5,\"22\":4,\"29\":2,\"31\":2,\"34\":3,\"37\":5,\"48\":4,\"133\":2,\"181\":1,\"220\":1,\"296\":1,\"299\":1,\"327\":1,\"346\":1,\"394\":3,\"436\":1,\"443\":1,\"538\":3,\"539\":23,\"540\":3,\"574\":1,\"587\":1,\"690\":3,\"707\":2,\"725\":1,\"757\":1,\"769\":3,\"785\":1,\"837\":1,\"844\":1,\"870\":3}}],[\"011111\",{\"1\":{\"688\":1}}],[\"01111\",{\"1\":{\"688\":1}}],[\"01001111\",{\"1\":{\"218\":1}}],[\"01001100\",{\"1\":{\"218\":1}}],[\"0元\",{\"1\":{\"510\":1}}],[\"0~1023\",{\"1\":{\"279\":1}}],[\"0000\",{\"1\":{\"694\":7}}],[\"00000110\",{\"1\":{\"221\":1}}],[\"00000111\",{\"1\":{\"220\":1,\"221\":1}}],[\"00000101\",{\"1\":{\"221\":1}}],[\"00000100\",{\"1\":{\"221\":3}}],[\"00000006\",{\"1\":{\"697\":1}}],[\"00000001\",{\"1\":{\"215\":1}}],[\"00000000\",{\"1\":{\"215\":1,\"218\":2,\"220\":2}}],[\"00\",{\"1\":{\"574\":1}}],[\"002\",{\"1\":{\"403\":3}}],[\"001\",{\"1\":{\"403\":3}}],[\"00101111\",{\"1\":{\"220\":1}}],[\"00100000\",{\"1\":{\"220\":1}}],[\"00100011\",{\"1\":{\"220\":1}}],[\"097\",{\"1\":{\"217\":1}}],[\"0的数目等于主机id的长度\",{\"1\":{\"216\":1}}],[\"0或0\",{\"1\":{\"200\":1}}],[\"0x61c88647\",{\"1\":{\"819\":1}}],[\"0x0000000000000000\",{\"1\":{\"769\":1}}],[\"0x0021\",{\"1\":{\"131\":1}}],[\"0x8021\",{\"1\":{\"131\":1}}],[\"0xc021\",{\"1\":{\"131\":1}}],[\"0x7e\",{\"1\":{\"131\":1}}],[\"0相对于http\",{\"1\":{\"113\":1}}],[\"0还引入了头部压缩\",{\"1\":{\"113\":1}}],[\"0允许在同一个连接上同时传输多个请求和响应\",{\"1\":{\"113\":1}}],[\"0是http协议的下一代标准\",{\"1\":{\"113\":1}}],[\"0采用非持续连接方式\",{\"1\":{\"111\":1}}],[\"0\",{\"0\":{\"111\":1,\"113\":1,\"562\":2},\"1\":{\"3\":1,\"8\":1,\"11\":1,\"14\":9,\"19\":1,\"23\":1,\"24\":1,\"29\":1,\"34\":1,\"37\":1,\"40\":9,\"45\":1,\"49\":1,\"50\":1,\"64\":6,\"166\":2,\"200\":5,\"205\":15,\"210\":2,\"215\":1,\"217\":22,\"218\":10,\"220\":2,\"221\":10,\"223\":7,\"304\":1,\"314\":2,\"315\":2,\"316\":12,\"343\":1,\"344\":3,\"346\":1,\"350\":1,\"360\":1,\"365\":1,\"366\":2,\"372\":3,\"377\":1,\"422\":1,\"429\":1,\"436\":1,\"443\":1,\"455\":3,\"465\":4,\"497\":1,\"498\":1,\"510\":1,\"518\":1,\"539\":3,\"540\":1,\"574\":1,\"596\":1,\"685\":1,\"689\":1,\"693\":1,\"695\":2,\"696\":5,\"726\":1,\"754\":1,\"760\":1,\"777\":1,\"785\":1,\"821\":1,\"827\":1,\"829\":1,\"835\":3,\"839\":2,\"840\":1,\"844\":3,\"867\":1,\"870\":2}}],[\"6锁优化以前\",{\"1\":{\"843\":1}}],[\"6之前\",{\"1\":{\"837\":1}}],[\"6字节\",{\"1\":{\"575\":2}}],[\"6n+12\",{\"1\":{\"315\":1}}],[\"69\",{\"1\":{\"279\":1}}],[\"6位\",{\"1\":{\"218\":1}}],[\"65\",{\"1\":{\"217\":1}}],[\"64\",{\"1\":{\"24\":1,\"50\":1,\"686\":1,\"690\":1,\"706\":1}}],[\"64k\",{\"1\":{\"8\":2,\"34\":2}}],[\"6379\",{\"1\":{\"14\":3,\"40\":3}}],[\"60\",{\"1\":{\"8\":1,\"34\":1}}],[\"6\",{\"0\":{\"79\":1,\"100\":1,\"114\":1,\"238\":1,\"265\":1,\"280\":1,\"295\":1,\"327\":1,\"345\":1,\"373\":1,\"386\":1,\"411\":1,\"421\":1,\"429\":1,\"437\":1,\"444\":1,\"451\":1,\"519\":1,\"532\":1,\"552\":1,\"578\":1,\"598\":1,\"622\":1,\"640\":1,\"675\":1,\"682\":1,\"690\":1,\"723\":1,\"724\":1,\"738\":1,\"759\":1,\"767\":1,\"778\":1,\"809\":1,\"821\":1,\"829\":1,\"836\":1,\"862\":1},\"1\":{\"3\":1,\"8\":1,\"29\":1,\"34\":1,\"218\":1,\"221\":1,\"290\":1,\"539\":1,\"723\":2,\"769\":1,\"778\":1}}],[\"ctl\",{\"1\":{\"870\":8}}],[\"cts\",{\"1\":{\"152\":1}}],[\"cts帧\",{\"1\":{\"152\":1}}],[\"cms会产生内存碎片\",{\"1\":{\"751\":1}}],[\"cms是只针对老年代的\",{\"1\":{\"751\":1}}],[\"cms和g1有什么区别\",{\"0\":{\"751\":1},\"1\":{\"751\":2}}],[\"cms\",{\"1\":{\"746\":1,\"748\":1,\"751\":4,\"752\":1}}],[\"cms标记清除\",{\"1\":{\"745\":1}}],[\"cmsa\",{\"1\":{\"144\":2,\"152\":2}}],[\"cpu负载\",{\"1\":{\"763\":1}}],[\"cpu\",{\"0\":{\"765\":1},\"1\":{\"707\":1,\"751\":1,\"762\":1,\"764\":3,\"765\":5,\"769\":3,\"796\":1,\"807\":2,\"809\":3,\"845\":1}}],[\"cpu和内存传输的信号\",{\"1\":{\"238\":1}}],[\"c等\",{\"1\":{\"595\":1}}],[\"cyclicbarrier的字面意思是可循环使用\",{\"1\":{\"852\":1}}],[\"cyclicbarrier了解吗\",{\"0\":{\"852\":1},\"1\":{\"852\":1}}],[\"cyclic\",{\"1\":{\"576\":1,\"852\":1}}],[\"c标志\",{\"1\":{\"575\":1}}],[\"cglib通过enhancer\",{\"1\":{\"498\":1}}],[\"cglib\",{\"0\":{\"498\":1},\"1\":{\"498\":9}}],[\"customername\",{\"1\":{\"461\":10}}],[\"currindex++\",{\"1\":{\"366\":1}}],[\"currindex\",{\"1\":{\"366\":4}}],[\"curr\",{\"1\":{\"366\":2}}],[\"currentthread\",{\"1\":{\"436\":1,\"443\":1}}],[\"current\",{\"1\":{\"377\":4,\"378\":10}}],[\"currentindex++\",{\"1\":{\"365\":1}}],[\"currentindex\",{\"1\":{\"365\":3}}],[\"currentstate\",{\"1\":{\"359\":6}}],[\"clh\",{\"1\":{\"839\":2,\"846\":4}}],[\"clh队列\",{\"1\":{\"839\":1}}],[\"cleansomeslots\",{\"1\":{\"821\":1}}],[\"clothing\",{\"1\":{\"506\":1}}],[\"clothingproduct\",{\"1\":{\"506\":6}}],[\"clonedevent\",{\"1\":{\"455\":6}}],[\"clone\",{\"1\":{\"454\":1,\"455\":11,\"722\":1,\"785\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"454\":1,\"455\":3,\"785\":1,\"793\":1}}],[\"cloneable\",{\"1\":{\"454\":1,\"455\":3}}],[\"closed\",{\"0\":{\"646\":1},\"1\":{\"346\":1,\"464\":1}}],[\"close\",{\"0\":{\"648\":1},\"1\":{\"335\":3,\"343\":1,\"346\":1,\"731\":1,\"768\":1}}],[\"clazz\",{\"1\":{\"346\":16,\"436\":3,\"443\":3}}],[\"classcastexception\",{\"1\":{\"793\":1}}],[\"classes目录放置应用程序的自定义类\",{\"1\":{\"760\":1}}],[\"class对象\",{\"1\":{\"757\":1}}],[\"classloader\",{\"1\":{\"755\":1,\"756\":3}}],[\"classnotfoundexception\",{\"1\":{\"436\":1,\"443\":1,\"793\":1}}],[\"classname\",{\"1\":{\"436\":2,\"443\":2}}],[\"classpath\",{\"1\":{\"422\":1,\"429\":1,\"756\":1,\"758\":1}}],[\"class<\",{\"1\":{\"346\":1,\"436\":1,\"443\":1,\"785\":1}}],[\"class<t>\",{\"1\":{\"346\":8}}],[\"class\",{\"1\":{\"325\":3,\"326\":5,\"327\":3,\"332\":2,\"335\":2,\"336\":3,\"338\":2,\"343\":4,\"344\":5,\"346\":10,\"350\":4,\"353\":5,\"354\":5,\"359\":4,\"360\":6,\"365\":3,\"366\":3,\"372\":13,\"377\":4,\"378\":4,\"383\":5,\"384\":4,\"390\":4,\"394\":5,\"403\":3,\"408\":3,\"418\":1,\"422\":2,\"426\":1,\"429\":2,\"434\":4,\"436\":5,\"443\":14,\"448\":4,\"450\":5,\"454\":3,\"455\":4,\"461\":3,\"465\":4,\"469\":1,\"473\":1,\"481\":2,\"485\":4,\"489\":8,\"495\":15,\"497\":3,\"498\":4,\"502\":5,\"506\":7,\"510\":5,\"511\":4,\"518\":5,\"524\":3,\"525\":7,\"719\":2,\"720\":1,\"754\":3,\"756\":3,\"760\":1,\"783\":1,\"785\":1,\"797\":2,\"822\":1,\"833\":3,\"835\":1,\"838\":1,\"842\":1,\"870\":2}}],[\"client\",{\"1\":{\"8\":3,\"34\":3,\"350\":2,\"359\":2,\"365\":1,\"371\":1,\"382\":1,\"383\":1,\"384\":2,\"393\":1,\"394\":1,\"403\":1,\"408\":1,\"524\":1}}],[\"c的时间增长趋势图\",{\"1\":{\"316\":1}}],[\"cwnd是发送方维护的一个的状态变量\",{\"1\":{\"297\":1}}],[\"cwnd\",{\"1\":{\"297\":5}}],[\"c=w∗log2​\",{\"1\":{\"240\":1}}],[\"city是对象结构\",{\"1\":{\"372\":1}}],[\"cityelements\",{\"1\":{\"372\":3}}],[\"cityelement\",{\"1\":{\"372\":10}}],[\"city\",{\"1\":{\"372\":10}}],[\"cidr使用\",{\"1\":{\"220\":1}}],[\"cidr可以更加有效地分配ipv4地址空间\",{\"1\":{\"220\":1}}],[\"cidr消除了传统的a类\",{\"1\":{\"220\":1}}],[\"circuit\",{\"1\":{\"184\":1}}],[\"c类\",{\"1\":{\"218\":1}}],[\"c类地址中各自划分的局域网专用地址段如下\",{\"1\":{\"217\":1}}],[\"c这类ipv4地址中各自划分了一段专用于各组织局域网内部的地址段\",{\"1\":{\"217\":1}}],[\"c两个路由器\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"c收到后交由上层处理\",{\"1\":{\"168\":1,\"583\":1}}],[\"craig\",{\"1\":{\"839\":1}}],[\"credit\",{\"1\":{\"518\":1}}],[\"creditcardpaystrategy\",{\"1\":{\"344\":5}}],[\"creational\",{\"1\":{\"490\":1}}],[\"createinheritedmap\",{\"1\":{\"822\":1}}],[\"createiterator\",{\"1\":{\"365\":2}}],[\"created\",{\"1\":{\"769\":1}}],[\"createadapter\",{\"1\":{\"511\":2}}],[\"createsamplepromotionevent\",{\"1\":{\"455\":2}}],[\"createstrategy\",{\"1\":{\"346\":2}}],[\"create\",{\"1\":{\"429\":2,\"436\":7,\"443\":5,\"498\":2}}],[\"crc\",{\"1\":{\"135\":1,\"573\":1,\"576\":1,\"584\":1}}],[\"crc计算出的校验位\",{\"1\":{\"131\":1}}],[\"criterion\",{\"1\":{\"622\":1}}],[\"crit\",{\"1\":{\"8\":1,\"34\":1}}],[\"can\",{\"1\":{\"870\":1}}],[\"cannot\",{\"1\":{\"360\":3}}],[\"cas的经典三大问题\",{\"1\":{\"845\":1}}],[\"cas有什么问题\",{\"0\":{\"845\":1},\"1\":{\"845\":1}}],[\"cas操作都不做\",{\"1\":{\"837\":1}}],[\"cas\",{\"1\":{\"711\":1,\"728\":1,\"829\":1,\"831\":1,\"832\":1,\"839\":3,\"840\":3,\"845\":5,\"847\":1}}],[\"cascading\",{\"1\":{\"104\":1}}],[\"cap\",{\"1\":{\"689\":2}}],[\"capacity\",{\"1\":{\"366\":2,\"689\":3}}],[\"category\",{\"1\":{\"539\":1}}],[\"cat\",{\"1\":{\"469\":10,\"485\":2}}],[\"catch捕获异常\",{\"1\":{\"865\":1}}],[\"catch块\",{\"1\":{\"795\":1}}],[\"catch\",{\"0\":{\"795\":1},\"1\":{\"327\":1,\"346\":1,\"436\":2,\"443\":2,\"455\":3,\"793\":2,\"795\":5,\"863\":2,\"870\":2}}],[\"callerrunspolicy\",{\"1\":{\"861\":2}}],[\"call\",{\"1\":{\"747\":1}}],[\"calendar\",{\"1\":{\"455\":7}}],[\"calculator\",{\"1\":{\"343\":2,\"346\":2}}],[\"carrier\",{\"1\":{\"581\":2}}],[\"cart\",{\"1\":{\"384\":13}}],[\"caretaker\",{\"1\":{\"377\":9}}],[\"card\",{\"1\":{\"240\":1,\"518\":1,\"742\":1}}],[\"ca协议通过争用信道来获取发送权\",{\"1\":{\"152\":1}}],[\"ca协议\",{\"1\":{\"152\":2}}],[\"ca等\",{\"1\":{\"144\":1}}],[\"cached\",{\"1\":{\"495\":1}}],[\"cache\",{\"1\":{\"8\":1,\"34\":1,\"495\":5,\"828\":1}}],[\"checked\",{\"1\":{\"793\":1}}],[\"check\",{\"1\":{\"575\":2,\"576\":2}}],[\"character\",{\"1\":{\"774\":1}}],[\"char\",{\"1\":{\"724\":1,\"777\":1,\"789\":3}}],[\"charset=\",{\"1\":{\"8\":1,\"34\":1}}],[\"chain\",{\"1\":{\"348\":1,\"353\":6,\"354\":4,\"490\":1}}],[\"chatroom\",{\"1\":{\"325\":5,\"406\":1,\"407\":1,\"408\":6,\"409\":3}}],[\"chatuser\",{\"1\":{\"325\":11}}],[\"chatgroup\",{\"1\":{\"325\":14}}],[\"chatgpt🤖\",{\"1\":{\"285\":1,\"294\":1,\"296\":1}}],[\"channel\",{\"1\":{\"240\":2,\"506\":10}}],[\"chiou\",{\"1\":{\"104\":1}}],[\"c++等高级语言\",{\"1\":{\"804\":1}}],[\"c++\",{\"1\":{\"24\":1,\"50\":1}}],[\"cd在现代网络中的使用已经减少\",{\"1\":{\"581\":1}}],[\"cd是什么\",{\"0\":{\"581\":1},\"1\":{\"581\":1}}],[\"cd协议来协调数据的发送\",{\"1\":{\"581\":1}}],[\"cd协议允许设备检测到这种碰撞并立即停止发送\",{\"1\":{\"581\":1}}],[\"cd协议\",{\"1\":{\"152\":1,\"170\":1,\"173\":1}}],[\"cdma\",{\"1\":{\"150\":1}}],[\"cdm\",{\"0\":{\"150\":1}}],[\"cd\",{\"1\":{\"18\":1,\"44\":1,\"144\":1,\"158\":1,\"578\":1,\"581\":2}}],[\"c\",{\"0\":{\"58\":1,\"127\":1,\"131\":1},\"1\":{\"18\":1,\"44\":1,\"58\":2,\"217\":2,\"218\":1,\"316\":9,\"538\":1,\"798\":1,\"835\":1,\"845\":2,\"870\":2}}],[\"csma\",{\"0\":{\"581\":1},\"1\":{\"581\":4}}],[\"csv文件\",{\"1\":{\"333\":1}}],[\"css是一种样式表语言\",{\"1\":{\"104\":1}}],[\"css\",{\"1\":{\"8\":1,\"34\":1,\"104\":1}}],[\"csdn\",{\"1\":{\"0\":1,\"543\":1,\"544\":1,\"545\":1}}],[\"coherence\",{\"1\":{\"828\":1}}],[\"collector\",{\"1\":{\"721\":3}}],[\"collections\",{\"1\":{\"681\":1,\"708\":3}}],[\"collection接口下面的基于单值集合的list\",{\"1\":{\"670\":1}}],[\"collection\",{\"1\":{\"670\":1,\"720\":1,\"741\":1}}],[\"colleague\",{\"1\":{\"400\":1}}],[\"collision\",{\"1\":{\"581\":2}}],[\"corepoolsize时\",{\"1\":{\"860\":3}}],[\"corepoolsize\",{\"1\":{\"860\":3,\"868\":4,\"870\":5}}],[\"core\",{\"1\":{\"539\":1}}],[\"corporation\",{\"1\":{\"215\":1}}],[\"copyonwritearraylist就是线程安全版本的arraylist\",{\"1\":{\"682\":1}}],[\"copyonwritearraylist了解多少\",{\"1\":{\"682\":1}}],[\"copyonwritearraylist\",{\"1\":{\"681\":1,\"844\":1}}],[\"copy\",{\"1\":{\"454\":6}}],[\"countdown\",{\"1\":{\"851\":2}}],[\"countdownlatch中的各个子线程不可以等待其他线程\",{\"1\":{\"852\":1}}],[\"countdownlatch允许一个或多个线程等待其他线程完成操作\",{\"1\":{\"851\":1}}],[\"countdownlatch\",{\"1\":{\"851\":2}}],[\"countdownlatch了解吗\",{\"0\":{\"851\":1},\"1\":{\"851\":1}}],[\"count++\",{\"1\":{\"829\":3,\"834\":1}}],[\"counted\",{\"1\":{\"747\":1}}],[\"count\",{\"1\":{\"372\":3,\"710\":1,\"829\":6,\"835\":3,\"867\":5,\"870\":1}}],[\"cost\",{\"1\":{\"210\":1}}],[\"cookie机制\",{\"1\":{\"285\":1}}],[\"cookie工作原理\",{\"1\":{\"110\":1}}],[\"cookie是一种对无状态的http进行状态化的技术\",{\"1\":{\"110\":1}}],[\"cookie\",{\"0\":{\"561\":1},\"1\":{\"110\":1,\"285\":1}}],[\"cookie状态\",{\"0\":{\"110\":1}}],[\"commonclassloader\",{\"1\":{\"760\":1}}],[\"common类加载器\",{\"1\":{\"759\":1}}],[\"commons\",{\"1\":{\"485\":1}}],[\"command接口\",{\"1\":{\"384\":1}}],[\"command接口定义了执行命令的方法execute\",{\"1\":{\"383\":1}}],[\"command\",{\"1\":{\"382\":1,\"383\":14,\"384\":5,\"386\":2,\"490\":1,\"870\":4}}],[\"com等\",{\"1\":{\"71\":1}}],[\"com等顶级域名服务器所在的地址\",{\"1\":{\"71\":1}}],[\"com域名下的所有子域名\",{\"1\":{\"71\":1}}],[\"com\",{\"1\":{\"17\":1,\"43\":1,\"67\":1,\"68\":1,\"69\":3,\"71\":2,\"78\":1,\"91\":2,\"104\":1,\"539\":6,\"540\":3,\"760\":1}}],[\"compilation\",{\"1\":{\"720\":1}}],[\"compiler\",{\"1\":{\"721\":1}}],[\"compileoptions\",{\"1\":{\"539\":1}}],[\"compilesdk\",{\"1\":{\"539\":1}}],[\"computeifpresent\",{\"1\":{\"713\":1}}],[\"computeifabsent\",{\"1\":{\"713\":1}}],[\"compute\",{\"1\":{\"713\":1,\"844\":1}}],[\"computerdirector\",{\"1\":{\"448\":3}}],[\"computerbuilder\",{\"1\":{\"448\":4}}],[\"computer\",{\"1\":{\"343\":7,\"346\":6,\"448\":19}}],[\"compareandswapint\",{\"1\":{\"847\":2}}],[\"compare\",{\"1\":{\"829\":1,\"845\":1,\"855\":2}}],[\"compareto\",{\"1\":{\"674\":1}}],[\"comparator接口实际上是出自\",{\"1\":{\"674\":1}}],[\"comparator\",{\"0\":{\"674\":1},\"1\":{\"674\":3}}],[\"comparable\",{\"0\":{\"674\":1},\"1\":{\"674\":3}}],[\"components\",{\"1\":{\"524\":4,\"525\":8}}],[\"component\",{\"1\":{\"501\":2,\"502\":26,\"524\":18,\"525\":24,\"526\":1}}],[\"composite类表示树状结构中的组合节点\",{\"1\":{\"525\":1}}],[\"composite2\",{\"1\":{\"524\":4}}],[\"composite1\",{\"1\":{\"524\":4}}],[\"composite\",{\"1\":{\"490\":1,\"524\":8,\"525\":3,\"526\":1}}],[\"complexity\",{\"1\":{\"316\":1,\"317\":1}}],[\"compression\",{\"1\":{\"113\":1}}],[\"comp\",{\"1\":{\"8\":1,\"34\":1}}],[\"constrainttop\",{\"1\":{\"540\":1}}],[\"constraintstart\",{\"1\":{\"540\":1}}],[\"constraintend\",{\"1\":{\"540\":1}}],[\"constraintbottom\",{\"1\":{\"540\":1}}],[\"constraintlayout>\",{\"1\":{\"540\":1}}],[\"constraintlayout\",{\"1\":{\"539\":3,\"540\":3}}],[\"concurrentmodificationexception\",{\"1\":{\"710\":3}}],[\"concurrent包下的容器都是安全失败\",{\"1\":{\"709\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"844\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"844\":1}}],[\"concurrenthashmap能保证复合性操作吗\",{\"0\":{\"713\":1},\"1\":{\"713\":1}}],[\"concurrenthashmap线程安全在jdk1\",{\"1\":{\"711\":1}}],[\"concurrenthashmap的底层实现原理是什么\",{\"0\":{\"711\":1},\"1\":{\"711\":1}}],[\"concurrenthashmap\",{\"0\":{\"712\":1},\"1\":{\"706\":1,\"708\":2,\"710\":1,\"712\":4,\"713\":3,\"844\":1}}],[\"concurrent\",{\"1\":{\"327\":2,\"746\":1,\"831\":1,\"832\":2,\"844\":1,\"870\":2}}],[\"concreteimplementor\",{\"1\":{\"505\":1}}],[\"concreteiterator\",{\"1\":{\"365\":3}}],[\"concretebuilder\",{\"1\":{\"448\":1}}],[\"concreteaircraft\",{\"1\":{\"402\":1,\"403\":4,\"404\":2}}],[\"concreteaggregate\",{\"1\":{\"365\":5}}],[\"concretecomponent是一个实现了component接口的具体类\",{\"1\":{\"502\":1}}],[\"concretecomponent\",{\"1\":{\"502\":3}}],[\"concretecommand类lightoncommand和lightoffcommand分别用于控制电灯开启和关闭\",{\"1\":{\"383\":1}}],[\"concretecommand\",{\"1\":{\"382\":1,\"383\":3}}],[\"concreteclass\",{\"1\":{\"332\":2}}],[\"concreteelement\",{\"1\":{\"371\":1}}],[\"concretevisitor\",{\"1\":{\"371\":1}}],[\"concreteobject\",{\"1\":{\"366\":2}}],[\"concreteobserver\",{\"1\":{\"324\":1,\"327\":8}}],[\"concrete\",{\"1\":{\"365\":1,\"372\":2,\"400\":1,\"434\":2,\"441\":2,\"501\":2,\"504\":1}}],[\"concretehandlerc\",{\"1\":{\"350\":6}}],[\"concretehandlerb\",{\"1\":{\"350\":4}}],[\"concretehandlera\",{\"1\":{\"350\":4}}],[\"concretehandler\",{\"1\":{\"350\":2}}],[\"concretestateb\",{\"1\":{\"359\":2}}],[\"concretestatea和concretestateb是两个具体状态类\",{\"1\":{\"359\":1}}],[\"concretestatea\",{\"1\":{\"359\":2}}],[\"concretestate\",{\"1\":{\"359\":2}}],[\"concretestrategy\",{\"1\":{\"343\":1,\"386\":1}}],[\"concretesubject\",{\"1\":{\"324\":1}}],[\"containskey等\",{\"1\":{\"713\":1}}],[\"containskey\",{\"1\":{\"495\":1}}],[\"contains\",{\"1\":{\"384\":1,\"422\":1,\"429\":1,\"436\":1,\"443\":1}}],[\"continue\",{\"1\":{\"343\":1}}],[\"content\",{\"1\":{\"540\":2}}],[\"content=\",{\"1\":{\"8\":1,\"34\":1}}],[\"context=\",{\"1\":{\"540\":1}}],[\"context类是上下文类\",{\"1\":{\"359\":1}}],[\"context对象切换到新的具体状态对象进行处理\",{\"1\":{\"359\":1}}],[\"context对象接收客户端的请求\",{\"1\":{\"359\":1}}],[\"context\",{\"1\":{\"326\":3,\"343\":1,\"359\":10,\"386\":1}}],[\"control\",{\"1\":{\"85\":1,\"120\":2,\"131\":1,\"144\":1,\"200\":1,\"574\":1,\"575\":1,\"584\":1,\"763\":1}}],[\"conn\",{\"1\":{\"8\":2,\"34\":2}}],[\"connecter\",{\"1\":{\"760\":1}}],[\"connection\",{\"1\":{\"85\":2,\"731\":1}}],[\"connections\",{\"1\":{\"8\":1,\"34\":1}}],[\"connect\",{\"1\":{\"8\":2,\"34\":2,\"538\":1}}],[\"confirmation\",{\"1\":{\"461\":1}}],[\"configuration\",{\"1\":{\"62\":1}}],[\"conf\",{\"1\":{\"8\":4,\"34\":4}}],[\"conf核心\",{\"1\":{\"8\":1,\"34\":1}}],[\"cn等\",{\"1\":{\"78\":1}}],[\"cn\",{\"1\":{\"3\":1,\"29\":1,\"69\":1}}],[\"owner\",{\"1\":{\"835\":5}}],[\"overriding\",{\"1\":{\"780\":1}}],[\"override\",{\"1\":{\"325\":5,\"326\":2,\"327\":4,\"343\":2,\"344\":3,\"346\":12,\"350\":6,\"353\":2,\"354\":2,\"359\":2,\"360\":6,\"366\":2,\"372\":15,\"383\":2,\"390\":3,\"436\":2,\"443\":14,\"454\":3,\"455\":3,\"465\":2,\"473\":2,\"495\":9,\"497\":3,\"498\":1,\"502\":4,\"510\":3,\"511\":2,\"525\":2,\"822\":1,\"863\":1,\"870\":2}}],[\"overloading\",{\"1\":{\"780\":1}}],[\"oom\",{\"1\":{\"768\":1}}],[\"oopmap\",{\"0\":{\"747\":1},\"1\":{\"747\":2}}],[\"oldtab中所有的entry数据都已经放入到newtab中了\",{\"1\":{\"821\":1}}],[\"old使用\",{\"1\":{\"751\":1}}],[\"old标记整理\",{\"1\":{\"745\":2}}],[\"old\",{\"1\":{\"738\":2,\"741\":1}}],[\"ocp\",{\"1\":{\"464\":1}}],[\"octet\",{\"1\":{\"8\":1,\"34\":1}}],[\"obj2\",{\"1\":{\"674\":1}}],[\"obj1\",{\"1\":{\"674\":1}}],[\"obj\",{\"1\":{\"674\":1,\"735\":10,\"785\":1}}],[\"objectmonitor\",{\"1\":{\"835\":1}}],[\"objectmonitor有两个队列\",{\"1\":{\"835\":1}}],[\"objectmonitor的工作原理\",{\"1\":{\"835\":1}}],[\"object作为value的结构\",{\"1\":{\"819\":1}}],[\"objects\",{\"1\":{\"498\":3}}],[\"objectinputstream\",{\"1\":{\"455\":4}}],[\"objectoutputstream\",{\"1\":{\"455\":4}}],[\"object\",{\"0\":{\"785\":1},\"1\":{\"346\":6,\"365\":4,\"366\":2,\"371\":1,\"372\":1,\"455\":3,\"490\":1,\"497\":6,\"498\":4,\"674\":3,\"683\":3,\"693\":1,\"735\":8,\"758\":4,\"785\":5,\"787\":1,\"788\":1,\"812\":1,\"844\":2,\"847\":1,\"863\":1}}],[\"object>>\",{\"1\":{\"436\":2,\"443\":2}}],[\"object>\",{\"1\":{\"326\":5,\"436\":1,\"443\":1}}],[\"observable\",{\"1\":{\"327\":2}}],[\"observer3\",{\"1\":{\"327\":2}}],[\"observer2\",{\"1\":{\"327\":2}}],[\"observer1\",{\"1\":{\"327\":2}}],[\"observers\",{\"1\":{\"327\":6}}],[\"observer\",{\"1\":{\"322\":1,\"324\":1,\"327\":18,\"490\":1}}],[\"of\",{\"1\":{\"247\":1,\"348\":1,\"488\":2,\"490\":3}}],[\"office\",{\"1\":{\"94\":1}}],[\"offer\",{\"1\":{\"64\":1,\"870\":1}}],[\"off\",{\"1\":{\"8\":2,\"34\":2,\"360\":8,\"383\":1}}],[\"operation\",{\"1\":{\"495\":6,\"497\":3,\"498\":2,\"502\":19,\"524\":5}}],[\"open\",{\"1\":{\"212\":1,\"335\":3,\"346\":1}}],[\"optimization\",{\"1\":{\"720\":1}}],[\"optimize\",{\"1\":{\"539\":1}}],[\"optical\",{\"1\":{\"240\":1}}],[\"option\",{\"1\":{\"11\":2,\"37\":2}}],[\"os通过android\",{\"1\":{\"538\":1}}],[\"os\",{\"1\":{\"279\":1,\"769\":1}}],[\"osi模型中的第三层\",{\"1\":{\"574\":1}}],[\"osi模型中的第二层\",{\"1\":{\"574\":1}}],[\"osi模型层次\",{\"1\":{\"162\":1}}],[\"osi\",{\"1\":{\"268\":1,\"278\":1}}],[\"ospf的链路状态通告lsa\",{\"1\":{\"210\":1}}],[\"ospf相邻路由器之间通过交互问候\",{\"1\":{\"210\":1}}],[\"ospf工作原理和工作流程\",{\"1\":{\"210\":1}}],[\"ospf分组分类\",{\"1\":{\"210\":1}}],[\"ospf协议\",{\"0\":{\"210\":1},\"1\":{\"210\":1}}],[\"ospf\",{\"1\":{\"206\":1,\"211\":1}}],[\"our\",{\"1\":{\"481\":1}}],[\"outofmemoryerror\",{\"1\":{\"731\":1,\"769\":1,\"793\":2}}],[\"output\",{\"1\":{\"469\":2}}],[\"outputstream\",{\"1\":{\"455\":3,\"500\":1}}],[\"out\",{\"1\":{\"314\":1,\"315\":1,\"316\":6,\"325\":2,\"326\":2,\"327\":1,\"343\":6,\"344\":3,\"346\":7,\"350\":4,\"353\":2,\"354\":2,\"359\":2,\"360\":12,\"366\":1,\"372\":11,\"377\":2,\"378\":5,\"383\":2,\"384\":3,\"390\":1,\"394\":2,\"403\":3,\"408\":3,\"436\":1,\"443\":4,\"448\":4,\"450\":2,\"454\":10,\"455\":2,\"485\":5,\"495\":15,\"497\":12,\"498\":12,\"502\":9,\"506\":2,\"510\":2,\"518\":3,\"525\":4,\"538\":1,\"795\":1,\"822\":1,\"870\":2}}],[\"ou\",{\"1\":{\"166\":1}}],[\"oriented\",{\"1\":{\"490\":1}}],[\"originalevent\",{\"1\":{\"455\":2}}],[\"originator可以在后续的操作中根据备忘录对象来恢复自身状态\",{\"1\":{\"377\":1}}],[\"originator通过创建备忘录对象将自身状态存储在备忘录中\",{\"1\":{\"377\":1}}],[\"originator\",{\"1\":{\"377\":13}}],[\"ordering\",{\"1\":{\"814\":1}}],[\"orderid\",{\"1\":{\"461\":9,\"518\":3}}],[\"orderprocessingfacade\",{\"1\":{\"518\":7}}],[\"orderservice\",{\"1\":{\"489\":13}}],[\"order\",{\"1\":{\"455\":1,\"461\":13,\"465\":6,\"489\":9,\"510\":7}}],[\"orexpression\",{\"1\":{\"394\":3,\"395\":1}}],[\"or\",{\"1\":{\"394\":2}}],[\"organization\",{\"1\":{\"525\":6}}],[\"org\",{\"1\":{\"69\":2,\"538\":2}}],[\"oracle官网下载jdk\",{\"1\":{\"17\":1,\"43\":1}}],[\"oracle\",{\"1\":{\"17\":1,\"43\":1}}],[\"online\",{\"1\":{\"506\":1}}],[\"onlinestorechannel\",{\"1\":{\"506\":5}}],[\"onevent\",{\"1\":{\"326\":6}}],[\"on\",{\"1\":{\"8\":7,\"11\":3,\"34\":7,\"37\":3,\"360\":5,\"383\":1,\"506\":2,\"765\":1}}],[\"o\",{\"1\":{\"3\":1,\"29\":1,\"316\":5,\"498\":1,\"677\":6,\"678\":6,\"690\":1,\"698\":1,\"705\":2}}],[\"yield\",{\"1\":{\"807\":2}}],[\"ygc\",{\"1\":{\"769\":2}}],[\"younggc\",{\"1\":{\"740\":1}}],[\"young\",{\"1\":{\"738\":2,\"739\":8,\"740\":1,\"741\":3}}],[\"yourself\",{\"1\":{\"484\":1,\"486\":1}}],[\"your\",{\"1\":{\"461\":1,\"481\":1}}],[\"y=f\",{\"1\":{\"671\":1}}],[\"y\",{\"1\":{\"3\":1,\"24\":2,\"29\":1,\"50\":2,\"343\":4,\"346\":4,\"671\":1}}],[\"yum\",{\"1\":{\"3\":1,\"24\":4,\"29\":1,\"50\":4}}],[\"密码\",{\"1\":{\"3\":1,\"14\":1,\"29\":1,\"40\":1}}],[\"命令分析\",{\"1\":{\"769\":1}}],[\"命令并结合\",{\"1\":{\"768\":1}}],[\"命令模式\",{\"1\":{\"490\":1}}],[\"命令模式适用于需要将请求封装为对象\",{\"1\":{\"386\":1}}],[\"命令模式的核心角色是命令\",{\"1\":{\"386\":1}}],[\"命令对象调用接收者的具体操作来完成命令的执行\",{\"1\":{\"383\":1}}],[\"命令\",{\"1\":{\"382\":1,\"383\":1,\"386\":1}}],[\"命令设计模式关注的是将请求封装成对象\",{\"1\":{\"386\":1}}],[\"命令设计模式是一种非常有用的设计模式\",{\"1\":{\"385\":1}}],[\"命令设计模式是一种行为型设计模式\",{\"1\":{\"381\":1}}],[\"命令设计模式可以用于实现购物车系统中的\",{\"1\":{\"384\":1}}],[\"命令设计模式适用于以下场景\",{\"1\":{\"384\":1}}],[\"命令设计模式的核心思想是通过将请求封装成一个对象\",{\"1\":{\"382\":1}}],[\"命令设计模式\",{\"0\":{\"380\":1},\"1\":{\"386\":1}}],[\"命令传输等\",{\"1\":{\"85\":1}}],[\"命令不需要换行\",{\"1\":{\"3\":1,\"29\":1}}],[\"命令行安装\",{\"0\":{\"3\":1,\"29\":1}}],[\"1+n\",{\"1\":{\"764\":1}}],[\"1+s\",{\"1\":{\"240\":1}}],[\"1=15\",{\"1\":{\"694\":1}}],[\"1二进制分别为\",{\"1\":{\"688\":1}}],[\"1就可以得到二进制位上1变成0\",{\"1\":{\"688\":1}}],[\"1q\",{\"1\":{\"575\":1}}],[\"1字节\",{\"1\":{\"575\":4}}],[\"1a\",{\"1\":{\"574\":1}}],[\"18\",{\"0\":{\"564\":1,\"610\":1,\"652\":1,\"702\":1,\"749\":1,\"789\":1,\"848\":1},\"1\":{\"450\":2,\"789\":1}}],[\"180\",{\"1\":{\"218\":7}}],[\"1状态\",{\"1\":{\"286\":1}}],[\"1tb\",{\"1\":{\"260\":2}}],[\"1gb\",{\"1\":{\"260\":2}}],[\"1mb\",{\"1\":{\"260\":2}}],[\"1og2​x\",{\"1\":{\"240\":1}}],[\"14\",{\"0\":{\"560\":1,\"606\":1,\"648\":1,\"698\":1,\"745\":1,\"786\":1,\"844\":1,\"870\":1},\"1\":{\"220\":7,\"390\":1,\"786\":1}}],[\"17\",{\"0\":{\"563\":1,\"609\":1,\"651\":1,\"701\":1,\"748\":1,\"847\":1},\"1\":{\"788\":2}}],[\"172\",{\"1\":{\"217\":2,\"221\":11,\"223\":1}}],[\"171\",{\"1\":{\"19\":1,\"45\":1}}],[\"19\",{\"0\":{\"565\":1,\"611\":1,\"653\":1,\"703\":1,\"750\":1,\"790\":1,\"849\":1},\"1\":{\"790\":1}}],[\"192\",{\"1\":{\"217\":3,\"574\":1}}],[\"191\",{\"1\":{\"217\":1}}],[\"1500\",{\"1\":{\"870\":1}}],[\"1500字节\",{\"1\":{\"575\":1}}],[\"15\",{\"0\":{\"561\":1,\"607\":1,\"649\":1,\"699\":1,\"746\":1,\"787\":1,\"845\":1,\"871\":1},\"1\":{\"350\":1,\"394\":1,\"395\":1,\"448\":1,\"740\":1}}],[\"151\",{\"1\":{\"217\":1}}],[\"1522\",{\"1\":{\"152\":1}}],[\"1的数目等于网络id的长度\",{\"1\":{\"216\":1}}],[\"1的持续连接还可以使用流水线方式工作\",{\"1\":{\"112\":1}}],[\"1024~49151\",{\"1\":{\"279\":1}}],[\"1024byte\",{\"1\":{\"260\":1}}],[\"100个\",{\"1\":{\"750\":1}}],[\"1000\",{\"1\":{\"327\":1,\"766\":1,\"768\":1}}],[\"1000000\",{\"1\":{\"316\":2}}],[\"100\",{\"1\":{\"260\":2,\"344\":1,\"510\":2,\"518\":1,\"752\":1,\"769\":1}}],[\"100mb\",{\"1\":{\"260\":1}}],[\"10^12\",{\"1\":{\"260\":1}}],[\"10^14\",{\"1\":{\"166\":1}}],[\"10^9\",{\"1\":{\"260\":1}}],[\"10^6\",{\"1\":{\"260\":3}}],[\"10^3\",{\"1\":{\"260\":1}}],[\"10101000\",{\"1\":{\"215\":1}}],[\"10\",{\"0\":{\"556\":1,\"582\":1,\"602\":1,\"644\":1,\"694\":1,\"728\":1,\"742\":1,\"782\":1,\"813\":1,\"840\":1,\"866\":1},\"1\":{\"198\":1,\"217\":2,\"315\":2,\"350\":2,\"360\":4,\"390\":2,\"394\":2,\"707\":2,\"769\":3,\"782\":1,\"795\":1,\"870\":2}}],[\"10m\",{\"1\":{\"8\":2,\"34\":2}}],[\"11个常用方法\",{\"1\":{\"785\":1}}],[\"111这样形式的\",{\"1\":{\"688\":1}}],[\"1111\",{\"1\":{\"694\":1}}],[\"11110000\",{\"1\":{\"220\":1}}],[\"11111100\",{\"1\":{\"218\":1}}],[\"11111111\",{\"1\":{\"218\":2,\"220\":2}}],[\"11\",{\"0\":{\"557\":1,\"583\":1,\"603\":1,\"645\":1,\"695\":1,\"729\":1,\"743\":1,\"783\":1,\"814\":1,\"841\":1,\"867\":1},\"1\":{\"455\":1,\"706\":1,\"707\":2,\"769\":1,\"783\":1}}],[\"11000000\",{\"1\":{\"215\":1}}],[\"11标准\",{\"1\":{\"158\":1}}],[\"11标准规定\",{\"1\":{\"152\":1}}],[\"11标准还使用了数据链路层确认机制\",{\"1\":{\"152\":1}}],[\"11定义的可选方式\",{\"1\":{\"152\":1}}],[\"11定义的默认方式\",{\"1\":{\"152\":1}}],[\"11的mac层标准定义了两种不同的媒体接入控制方式\",{\"1\":{\"152\":1}}],[\"11无线局域网使用csma\",{\"1\":{\"152\":1}}],[\"1个0\",{\"1\":{\"135\":1,\"576\":1}}],[\"1采用持续连接方式\",{\"1\":{\"112\":1}}],[\"16x0\",{\"1\":{\"696\":1}}],[\"16位\",{\"1\":{\"302\":4,\"304\":1}}],[\"161\",{\"1\":{\"279\":1}}],[\"16\",{\"0\":{\"562\":1,\"608\":1,\"650\":1,\"700\":1,\"747\":1,\"788\":1,\"846\":1},\"1\":{\"217\":5,\"218\":1,\"223\":2,\"239\":1,\"619\":1,\"688\":1,\"689\":2,\"693\":1,\"694\":4,\"695\":1,\"706\":1,\"711\":1,\"765\":2,\"769\":2,\"785\":1,\"788\":1,\"789\":2,\"795\":1}}],[\"168\",{\"1\":{\"215\":1,\"217\":2,\"223\":1,\"574\":1}}],[\"16表示不可达\",{\"1\":{\"209\":1}}],[\"163\",{\"1\":{\"91\":1}}],[\"16k\",{\"1\":{\"8\":1,\"34\":1}}],[\"13\",{\"0\":{\"559\":1,\"584\":1,\"605\":1,\"647\":1,\"697\":1,\"731\":1,\"744\":1,\"785\":1,\"843\":1,\"869\":1},\"1\":{\"78\":1,\"539\":1,\"785\":1}}],[\"127\",{\"1\":{\"774\":2}}],[\"12345\",{\"1\":{\"518\":1}}],[\"123\",{\"1\":{\"450\":1,\"754\":1}}],[\"12和192\",{\"1\":{\"223\":1}}],[\"128\",{\"1\":{\"217\":1,\"220\":6,\"221\":3,\"596\":1,\"774\":1}}],[\"128k\",{\"1\":{\"8\":1,\"34\":1}}],[\"126\",{\"1\":{\"217\":2}}],[\"12\",{\"0\":{\"558\":1,\"604\":1,\"646\":1,\"696\":1,\"730\":1,\"784\":1,\"842\":1,\"868\":1},\"1\":{\"78\":1,\"217\":1,\"455\":1,\"784\":1}}],[\"122\",{\"1\":{\"21\":3,\"22\":4,\"47\":3,\"48\":4}}],[\"1kb\",{\"1\":{\"260\":2}}],[\"1k\",{\"1\":{\"8\":1,\"34\":1}}],[\"1\",{\"0\":{\"3\":1,\"5\":1,\"7\":1,\"10\":1,\"13\":1,\"16\":1,\"17\":1,\"22\":1,\"29\":1,\"31\":1,\"33\":1,\"36\":1,\"39\":1,\"42\":1,\"43\":1,\"48\":1,\"56\":1,\"58\":1,\"61\":1,\"62\":1,\"66\":1,\"67\":1,\"71\":1,\"74\":1,\"83\":1,\"85\":1,\"89\":1,\"90\":1,\"102\":1,\"103\":1,\"106\":1,\"112\":1,\"119\":1,\"123\":1,\"144\":1,\"146\":1,\"155\":1,\"156\":1,\"161\":1,\"164\":1,\"165\":1,\"170\":1,\"173\":1,\"180\":1,\"189\":1,\"190\":1,\"196\":1,\"200\":1,\"204\":1,\"205\":1,\"208\":1,\"214\":1,\"215\":1,\"220\":1,\"229\":1,\"232\":1,\"235\":1,\"245\":1,\"246\":1,\"253\":1,\"257\":1,\"260\":1,\"273\":1,\"277\":1,\"282\":1,\"285\":1,\"288\":1,\"293\":1,\"296\":1,\"301\":1,\"304\":1,\"310\":1,\"311\":2,\"312\":1,\"314\":1,\"315\":2,\"316\":1,\"322\":1,\"330\":1,\"334\":1,\"341\":1,\"348\":1,\"357\":1,\"363\":1,\"369\":1,\"375\":1,\"381\":1,\"388\":1,\"392\":1,\"398\":1,\"401\":1,\"406\":1,\"416\":1,\"423\":1,\"424\":2,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"432\":1,\"439\":1,\"446\":1,\"454\":1,\"460\":1,\"464\":1,\"468\":1,\"472\":1,\"476\":1,\"480\":1,\"484\":1,\"488\":1,\"495\":1,\"500\":1,\"504\":1,\"508\":1,\"514\":1,\"522\":1,\"528\":1,\"537\":1,\"547\":1,\"562\":3,\"573\":1,\"587\":1,\"617\":1,\"627\":1,\"631\":1,\"635\":1,\"670\":1,\"677\":1,\"685\":1,\"719\":1,\"723\":2,\"733\":1,\"754\":1,\"762\":1,\"773\":1,\"804\":1,\"816\":1,\"824\":1,\"831\":1,\"851\":1,\"857\":1},\"1\":{\"8\":3,\"18\":1,\"23\":1,\"24\":2,\"34\":3,\"44\":1,\"49\":1,\"50\":2,\"78\":1,\"111\":1,\"112\":2,\"113\":2,\"121\":1,\"134\":2,\"156\":1,\"166\":2,\"205\":1,\"215\":1,\"217\":6,\"221\":14,\"238\":2,\"260\":1,\"268\":1,\"314\":1,\"315\":5,\"316\":9,\"327\":1,\"346\":3,\"366\":2,\"377\":3,\"378\":4,\"429\":1,\"455\":2,\"485\":1,\"495\":1,\"497\":5,\"498\":5,\"518\":2,\"539\":12,\"540\":1,\"574\":1,\"576\":1,\"677\":3,\"678\":6,\"685\":1,\"686\":1,\"688\":3,\"689\":5,\"690\":4,\"694\":3,\"695\":1,\"701\":8,\"705\":1,\"707\":11,\"711\":7,\"723\":2,\"724\":3,\"725\":1,\"735\":3,\"737\":2,\"743\":1,\"747\":1,\"749\":1,\"752\":2,\"764\":4,\"768\":1,\"769\":1,\"773\":1,\"789\":5,\"791\":2,\"796\":1,\"807\":1,\"819\":1,\"835\":3,\"836\":2,\"844\":2,\"847\":1,\"848\":1,\"866\":1,\"867\":2}}],[\"一次性申请所有的资源\",{\"1\":{\"848\":1}}],[\"一次只能被一个线程拥有\",{\"1\":{\"836\":1}}],[\"一句话概括\",{\"1\":{\"847\":1}}],[\"一把锁只能被一个线程获得\",{\"1\":{\"842\":1}}],[\"一把锁可以被多个线程同时获得\",{\"1\":{\"842\":1}}],[\"一把是\",{\"1\":{\"842\":2}}],[\"一切不可变的对象\",{\"1\":{\"831\":1}}],[\"一样\",{\"1\":{\"785\":1,\"842\":1,\"864\":1}}],[\"一样的效果\",{\"1\":{\"688\":1}}],[\"一种情况例外\",{\"1\":{\"775\":1}}],[\"一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构\",{\"1\":{\"742\":1}}],[\"一种是引用类型\",{\"1\":{\"724\":1}}],[\"一种是8个基本类型\",{\"1\":{\"724\":1}}],[\"一致\",{\"1\":{\"731\":1}}],[\"一定是线程安全的\",{\"1\":{\"831\":1}}],[\"一定被回收\",{\"1\":{\"735\":2}}],[\"一定要记得使用\",{\"1\":{\"731\":1}}],[\"一定不要搞混了\",{\"1\":{\"713\":1}}],[\"一定包含有中央处理机cpu\",{\"1\":{\"257\":1}}],[\"一边长一边短\",{\"1\":{\"698\":1}}],[\"一边通行时另一边必须等待\",{\"1\":{\"582\":1}}],[\"一些模拟调制技术\",{\"1\":{\"619\":1}}],[\"一些更新用户信息的逻辑\",{\"1\":{\"481\":1}}],[\"一些显示用户信息的逻辑\",{\"1\":{\"481\":1}}],[\"一些登录逻辑\",{\"1\":{\"481\":1}}],[\"一些注册逻辑\",{\"1\":{\"481\":1}}],[\"一些互相连接的\",{\"1\":{\"257\":1}}],[\"一层一层的代理包装\",{\"1\":{\"352\":1}}],[\"一条通信线路的\",{\"1\":{\"261\":1}}],[\"一根光缆少则一根光纤\",{\"1\":{\"230\":1}}],[\"一位接一位地传输\",{\"1\":{\"227\":1}}],[\"一直不成功\",{\"1\":{\"845\":1}}],[\"一直找到\",{\"1\":{\"820\":1}}],[\"一直while循环添加静态内部类对象\",{\"1\":{\"731\":1}}],[\"一直占用通信资源\",{\"1\":{\"253\":1}}],[\"一直经历帧的封装的解封\",{\"1\":{\"181\":1,\"574\":1,\"587\":1}}],[\"一直这么循环下去\",{\"1\":{\"141\":1,\"576\":1}}],[\"一对多\",{\"1\":{\"301\":1,\"504\":1}}],[\"一对所有通信方式\",{\"1\":{\"166\":1}}],[\"一对一通信方式\",{\"1\":{\"166\":1}}],[\"一个信号量可以是整数类型\",{\"1\":{\"853\":1}}],[\"一个实现了\",{\"1\":{\"838\":1}}],[\"一个变量被声明为volatile\",{\"1\":{\"827\":1}}],[\"一个抽象概念\",{\"1\":{\"824\":1}}],[\"一个table数组\",{\"1\":{\"819\":1}}],[\"一个共享变量上可能会有多个线程在等待\",{\"1\":{\"807\":1}}],[\"一个线程使用共享方式获取了资源\",{\"1\":{\"846\":1}}],[\"一个线程使用独占方式获取了资源\",{\"1\":{\"846\":1}}],[\"一个线程对共享变量的修改可能对其他线程是不可见的\",{\"1\":{\"814\":1}}],[\"一个线程a调用共享对象的\",{\"1\":{\"807\":1}}],[\"一个线程正在给\",{\"1\":{\"728\":1}}],[\"一个异常对象抛出\",{\"1\":{\"793\":1}}],[\"一个个方法\",{\"1\":{\"781\":1}}],[\"一个是引用数据类型\",{\"1\":{\"773\":1}}],[\"一个是基础数据类型\",{\"1\":{\"773\":1}}],[\"一个小块叫做一个region区域\",{\"1\":{\"749\":1}}],[\"一个指针指向链表的前一个元素\",{\"1\":{\"714\":1}}],[\"一个受限带宽的通道能够以一定的信噪比下最大限度地传输信息\",{\"1\":{\"622\":1}}],[\"一个ip地址可以对应多个域名\",{\"1\":{\"594\":1}}],[\"一个\",{\"0\":{\"594\":1},\"1\":{\"594\":1,\"764\":1}}],[\"一个java代码也可能适配多个界面布局\",{\"1\":{\"540\":1}}],[\"一个界面布局可以被多处代码复用\",{\"1\":{\"540\":1}}],[\"一个具体的业务场景\",{\"1\":{\"518\":1}}],[\"一个对象是否有虚引用的存在\",{\"1\":{\"735\":1}}],[\"一个对象应该尽可能少地了解其他对象的细节和内部结构\",{\"1\":{\"490\":1}}],[\"一个对象的构建过程是复杂且多步骤的\",{\"1\":{\"447\":1}}],[\"一个类从被加载到虚拟机内存中开始\",{\"1\":{\"754\":1}}],[\"一个类包含了两个或者两个以上业务不相干的功能\",{\"1\":{\"462\":1}}],[\"一个类只负责完成一个职责或者功能\",{\"1\":{\"462\":1}}],[\"一个工厂生产一组产品线\",{\"1\":{\"444\":1}}],[\"一个工厂生产一个产品\",{\"1\":{\"437\":1}}],[\"一个工厂负责生产多个产品\",{\"1\":{\"430\":1}}],[\"一个典型的例子是聊天应用程序\",{\"1\":{\"405\":1}}],[\"一个常见的例子是实现一个简单的规则引擎\",{\"1\":{\"391\":1}}],[\"一个常见的业务场景是网络聊天的群聊功能\",{\"1\":{\"325\":1}}],[\"一个基本案例\",{\"1\":{\"377\":1}}],[\"一个请求可能需要经过多个处理步骤\",{\"1\":{\"355\":1}}],[\"一个跨进程的观察者模式呢\",{\"1\":{\"327\":1}}],[\"一个报文或分组\",{\"1\":{\"263\":1}}],[\"一个报文可以同时发送给多个目的地址\",{\"1\":{\"255\":1}}],[\"一个比特就是二进制数字中的一个1或0\",{\"1\":{\"260\":1}}],[\"一个码元对应多个比特\",{\"1\":{\"239\":1}}],[\"一个码元对应一个比特\",{\"1\":{\"239\":1}}],[\"一个方向一条\",{\"1\":{\"237\":1}}],[\"一个企业或者一个公司个体\",{\"1\":{\"211\":1}}],[\"一个自治系统有时也被称为是一个路由选择域\",{\"1\":{\"211\":1}}],[\"一个自治系统\",{\"1\":{\"211\":1}}],[\"一个结点交换机往往与多个结点交换机相连\",{\"1\":{\"162\":1}}],[\"一个单位的不同部门共享一个局域网\",{\"1\":{\"159\":1,\"579\":1}}],[\"一个节点故障则循环不能继续\",{\"1\":{\"153\":1}}],[\"一个特殊的控制锁\",{\"1\":{\"153\":1}}],[\"一个主节点以循环方式轮询每个站点\",{\"1\":{\"153\":1}}],[\"一个中心节点负责协调和控制所有用户的访问\",{\"1\":{\"153\":1}}],[\"一个站点应当能够在这段时间内从发送方式切换到接收方式\",{\"1\":{\"152\":1}}],[\"一旦线程申请了锁\",{\"1\":{\"841\":1}}],[\"一旦类加载动作完成的时候\",{\"1\":{\"747\":1}}],[\"一旦对象创建完成\",{\"1\":{\"450\":1}}],[\"一旦发送帧\",{\"1\":{\"152\":1}}],[\"一旦发现问题\",{\"1\":{\"81\":1}}],[\"一旦数据连接建立\",{\"1\":{\"86\":1}}],[\"一旦连接建立并且用户通过了身份验证\",{\"1\":{\"86\":1}}],[\"一般的经验\",{\"1\":{\"866\":1}}],[\"一般会立即停止\",{\"1\":{\"864\":1}}],[\"一般会选择线程终止\",{\"1\":{\"793\":1}}],[\"一般会选择第一个接收到的dhcp提供消息\",{\"1\":{\"64\":1}}],[\"一般跟finally配合释放锁\",{\"1\":{\"843\":1}}],[\"一般是cpu数\",{\"1\":{\"866\":1}}],[\"一般是lock\",{\"1\":{\"843\":1}}],[\"一般是因为创建了大量对象所导致\",{\"1\":{\"766\":1}}],[\"一般锁进行并发控制的规则\",{\"1\":{\"842\":1}}],[\"一般作为参数和代码块内的局部变量\",{\"1\":{\"773\":1}}],[\"一般分别称为from和to\",{\"1\":{\"737\":1}}],[\"一般应用是很难出现碰撞的\",{\"1\":{\"694\":1}}],[\"一般情况都不会树化\",{\"1\":{\"690\":1}}],[\"一般情况下\",{\"1\":{\"165\":1,\"317\":1}}],[\"一般无须改动\",{\"1\":{\"539\":1}}],[\"一般不能实例化一个runtime对象\",{\"1\":{\"419\":1}}],[\"一般来说\",{\"1\":{\"296\":1,\"756\":1,\"853\":1}}],[\"一般使用在计算机内部\",{\"1\":{\"233\":1}}],[\"一般只有50km左右\",{\"1\":{\"230\":1}}],[\"一般只在小规模网络中采用\",{\"1\":{\"205\":1}}],[\"一般都工作在全双工方式\",{\"1\":{\"173\":1}}],[\"一般在接入点ap实现集中控制\",{\"1\":{\"152\":1}}],[\"一般可将重传时间选为略大于\",{\"1\":{\"137\":1}}],[\"一般为租约时长的一半\",{\"1\":{\"64\":1}}],[\"一\",{\"0\":{\"2\":1,\"28\":1,\"55\":1,\"118\":1,\"179\":1,\"227\":1,\"244\":1,\"272\":1,\"309\":1,\"321\":1,\"415\":1,\"459\":1,\"494\":1,\"626\":1,\"669\":1,\"718\":1,\"803\":1}}],[\"宝塔开放端口3306\",{\"1\":{\"11\":1,\"37\":1}}],[\"宝塔界面查看安装mysql的root密码\",{\"1\":{\"11\":1,\"37\":1}}],[\"宝塔界面\",{\"1\":{\"11\":1,\"14\":1,\"37\":1,\"40\":1}}],[\"宝塔里面软件商店搜索redis\",{\"1\":{\"13\":1,\"39\":1}}],[\"宝塔里面软件商店搜索mysql\",{\"1\":{\"10\":1,\"36\":1}}],[\"宝塔里面软件商店搜索nginx\",{\"1\":{\"7\":1,\"33\":1}}],[\"宝塔安全设置\",{\"1\":{\"5\":2,\"31\":2}}],[\"宝塔安装和配置\",{\"0\":{\"2\":1,\"28\":1}}],[\"宝塔面板设置\",{\"1\":{\"5\":1,\"31\":1}}],[\"宝塔\",{\"1\":{\"1\":1,\"5\":1,\"11\":1,\"27\":1,\"31\":1,\"37\":1},\"2\":{\"26\":1,\"52\":1}}],[\"教学\",{\"1\":{\"1\":1,\"27\":1}}],[\"云服务器开放端口3306\",{\"1\":{\"11\":1,\"37\":1}}],[\"云服务器实例\",{\"1\":{\"3\":1,\"29\":1}}],[\"云服务器\",{\"0\":{\"1\":1,\"27\":1}}],[\"|=\",{\"1\":{\"689\":5}}],[\"||\",{\"1\":{\"394\":1,\"422\":2,\"429\":2,\"436\":2,\"443\":2,\"695\":1,\"870\":1}}],[\"|\",{\"1\":{\"0\":1,\"436\":4,\"443\":4,\"543\":1,\"544\":1,\"545\":1,\"766\":1,\"768\":1}}],[\"少年游\",{\"1\":{\"0\":1}}],[\"欲买桂花同载酒\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
